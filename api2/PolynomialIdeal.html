<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>PolynomialIdeal</title>
</head>
<body>
<h1>PolynomialIdeal(F, Expon, VarSet, DPoly)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/ideal.spad#L1">ideal.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/ideal.spad#L1">[edit on github]</a></p>
<ul>
<li>F : <a href="Field.html">Field</a><li>Expon : <a href="OrderedAbelianMonoidSup.html">OrderedAbelianMonoidSup</a><li>VarSet : <a href="OrderedSet.html">OrderedSet</a><li>DPoly : <a href="PolynomialCategory.html">PolynomialCategory</a>(F, Expon, VarSet)</ul>
<p>
This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations, including intersection, sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is <code>true</code> if the generators are a Groebner basis. The algorithms used are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings.</p>
<a name="f__42"></a><dl><dt>* : (%, %) -&gt %</dt><dd><p>
<code>I*J</code> computes the product of the ideal <code>I</code> and <code>J</code>.</p>
</dd></dl>
<a name="f__43"></a><dl><dt>+ : (%, %) -&gt %</dt><dd><p>
<code>I+J</code> computes the ideal generated by the union of <code>I</code> and <code>J</code>.</p>
</dd></dl>
<a name="f__61"></a><dl><dt><a href="BasicType.html#f__61">=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<a name="f__94"></a><dl><dt>^ : (%, <a href="NonNegativeInteger.html">NonNegativeInteger</a>) -&gt %</dt><dd><p>
<code>I^n</code> computes the <code>n</code>th power of the ideal <code>I</code>.</p>
</dd></dl>
<a name="f_backOldPos"></a><dl><dt>backOldPos : Record(mval : <a href="Matrix.html">Matrix</a>(F), invmval : <a href="Matrix.html">Matrix</a>(F), genIdeal : %) -&gt %</dt><dd><p>
<code>backOldPos(genPos)</code> takes the result produced by <span class="std std-ref">generalPosition</span> and performs the inverse transformation, returning the original ideal <code>backOldPos(generalPosition(I, listvar))</code> = <code>I</code>.</p>
</dd></dl>
<a name="f_coerce"></a><dl><dt>coerce : <a href="List.html">List</a>(DPoly) -&gt %</dt><dd><p>
<code>coerce(polyList)</code> converts the list of polynomials <code>polyList</code> to an ideal.</p>
</dd></dl>
<dl><dt><a href="CoercibleTo.html#f_coerce">coerce</a> : % -&gt <a href="OutputForm.html">OutputForm</a></dt><dd> from <a href="CoercibleTo.html">CoercibleTo</a>(<a href="OutputForm.html">OutputForm</a>)</dd></dl>
<a name="f_dimension"></a><dl><dt>dimension : % -&gt <a href="Integer.html">Integer</a></dt><dd><p>
<code>dimension(I)</code> gives the dimension of the ideal <code>I</code>. in the ring <code>F[lvar]</code>, where lvar are the variables appearing in <code>I</code></p>
</dd></dl>
<dl><dt>dimension : (%, <a href="List.html">List</a>(VarSet)) -&gt <a href="Integer.html">Integer</a></dt><dd><p>
<code>dimension(I, lvar)</code> gives the dimension of the ideal <code>I</code>, in the ring <code>F[lvar]</code></p>
</dd></dl>
<a name="f_element_63"></a><dl><dt>element? : (DPoly, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>element?(f, I)</code> tests whether the polynomial <code>f</code> belongs to the ideal <code>I</code>.</p>
</dd></dl>
<a name="f_generalPosition"></a><dl><dt>generalPosition : (%, <a href="List.html">List</a>(VarSet)) -&gt Record(mval : <a href="Matrix.html">Matrix</a>(F), invmval : <a href="Matrix.html">Matrix</a>(F), genIdeal : %)</dt><dd><p>
<code>generalPosition(I, listvar)</code> perform a random linear transformation on the variables in listvar and returns the transformed ideal along with the change of basis matrix.</p>
</dd></dl>
<a name="f_generators"></a><dl><dt>generators : % -&gt <a href="List.html">List</a>(DPoly)</dt><dd><p>
<code>generators(I)</code> returns a list of generators for the ideal <code>I</code>.</p>
</dd></dl>
<a name="f_groebner"></a><dl><dt>groebner : % -&gt %</dt><dd><p>
<code>groebner(I)</code> returns a set of generators of <code>I</code> that are a Groebner basis for <code>I</code>.</p>
</dd></dl>
<a name="f_groebner_63"></a><dl><dt>groebner? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>groebner?(I)</code> tests if the generators of the ideal <code>I</code> are a Groebner basis.</p>
</dd></dl>
<a name="f_groebnerIdeal"></a><dl><dt>groebnerIdeal : <a href="List.html">List</a>(DPoly) -&gt %</dt><dd><p>
<code>groebnerIdeal(polyList)</code> constructs the ideal generated by the list of polynomials <code>polyList</code> which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation.</p>
</dd></dl>
<a name="f_ideal"></a><dl><dt>ideal : <a href="List.html">List</a>(DPoly) -&gt %</dt><dd><p>
<code>ideal(polyList)</code> constructs the ideal generated by the list of polynomials <code>polyList</code>.</p>
</dd></dl>
<a name="f_in_63"></a><dl><dt>in? : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>in?(I, J)</code> tests if the ideal <code>I</code> is contained in the ideal <code>J</code>.</p>
</dd></dl>
<a name="f_inRadical_63"></a><dl><dt>inRadical? : (DPoly, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>inRadical?(f, I)</code> tests if some power of the polynomial <code>f</code> belongs to the ideal <code>I</code>.</p>
</dd></dl>
<a name="f_intersect"></a><dl><dt>intersect : (%, %) -&gt %</dt><dd><p>
<code>intersect(I, J)</code> computes the intersection of the ideals <code>I</code> and <code>J</code>.</p>
</dd></dl>
<dl><dt>intersect : <a href="List.html">List</a>(%) -&gt %</dt><dd><p>
<code>intersect(LI)</code> computes the intersection of the list of ideals <code>LI</code>.</p>
</dd></dl>
<a name="f_latex"></a><dl><dt><a href="SetCategory.html#f_latex">latex</a> : % -&gt <a href="String.html">String</a></dt><dd> from <a href="SetCategory.html">SetCategory</a></dd></dl>
<a name="f_leadingIdeal"></a><dl><dt>leadingIdeal : % -&gt %</dt><dd><p>
<code>leadingIdeal(I)</code> is the ideal generated by the leading terms of the elements of the ideal <code>I</code>.</p>
</dd></dl>
<a name="f_one_63"></a><dl><dt>one? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>one?(I)</code> tests whether the ideal <code>I</code> is the unit ideal, i.e. contains 1.</p>
</dd></dl>
<a name="f_quotient"></a><dl><dt>quotient : (%, %) -&gt %</dt><dd><p>
<code>quotient(I, J)</code> computes the quotient of the ideals <code>I</code> and <code>J</code>, <code>(I: J)</code>.</p>
</dd></dl>
<dl><dt>quotient : (%, DPoly) -&gt %</dt><dd><p>
<code>quotient(I, f)</code> computes the quotient of the ideal <code>I</code> by the principal ideal generated by the polynomial <code>f</code>, <code>(I: (f))</code>.</p>
</dd></dl>
<a name="f_relationsIdeal"></a><dl><dt>relationsIdeal : <a href="List.html">List</a>(DPoly) -&gt <a href="SuchThat.html">SuchThat</a>(<a href="List.html">List</a>(<a href="Polynomial.html">Polynomial</a>(F)), <a href="List.html">List</a>(<a href="Equation.html">Equation</a>(<a href="Polynomial.html">Polynomial</a>(F)))) if VarSet has <a href="ConvertibleTo.html">ConvertibleTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>relationsIdeal(polyList)</code> returns the ideal of relations among the polynomials in <code>polyList</code>.</p>
</dd></dl>
<a name="f_saturate"></a><dl><dt>saturate : (%, DPoly) -&gt %</dt><dd><p>
<code>saturate(I, f)</code> is the saturation of the ideal <code>I</code> with respect to the multiplicative set generated by the polynomial <code>f</code>.</p>
</dd></dl>
<dl><dt>saturate : (%, DPoly, <a href="List.html">List</a>(VarSet)) -&gt %</dt><dd><p>
<code>saturate(I, f, lvar)</code> is the saturation with respect to the prime principal ideal which is generated by <code>f</code> in the polynomial ring <code>F[lvar]</code>.</p>
</dd></dl>
<a name="f_zero_63"></a><dl><dt>zero? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>zero?(I)</code> tests whether the ideal <code>I</code> is the zero ideal</p>
</dd></dl>
<a name="f_zeroDim_63"></a><dl><dt>zeroDim? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>zeroDim?(I)</code> tests if the ideal <code>I</code> is zero dimensional, i.e. all its associated primes are maximal, in the ring <code>F[lvar]</code>, where lvar are the variables appearing in <code>I</code></p>
</dd></dl>
<dl><dt>zeroDim? : (%, <a href="List.html">List</a>(VarSet)) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>zeroDim?(I, lvar)</code> tests if the ideal <code>I</code> is zero dimensional, i.e. all its associated primes are maximal, in the ring <code>F[lvar]</code></p>
</dd></dl>
<a name="f__126_61"></a><dl><dt><a href="BasicType.html#f__126_61">~=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<p><a href="BasicType.html">BasicType</a>
<p><a href="CoercibleTo.html">CoercibleTo</a>(<a href="OutputForm.html">OutputForm</a>)
<p><a href="SetCategory.html">SetCategory</a>
</body>
</html>
