<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>ThreeSpaceCategory</title>
</head>
<body>
<h1>ThreeSpaceCategory(R)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/space.spad#L1">space.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/space.spad#L1">[edit on github]</a></p>
<ul>
<li>R : <a href="Ring.html">Ring</a></ul>
<p>
The category ThreeSpaceCategory is used for creating three dimensional objects using functions for defining points, curves, polygons, constructs and the subspaces containing them.</p>
<a name="f__61"></a><dl><dt><a href="BasicType.html#f__61">=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<a name="f_check"></a><dl><dt>check : % -&gt %</dt><dd><p>
<code>check(s)</code> returns lllpt, list of lists of lists of point information about the ThreeSpace <code>s</code>.</p>
</dd></dl>
<a name="f_closedCurve"></a><dl><dt>closedCurve : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(R))) -&gt %</dt><dd><p>
<code>closedCurve(s, [[lr0], [lr1], ..., [lrn], [lr0]])</code> adds a closed curve component defined by a list of points <code>lr0</code> through <code>lrn</code>, which are lists of elements from the domain <code>PointDomain(m, R)</code>, where <code>R</code> is the Ring over which the point elements are defined and <code>m</code> is the dimension of the points, in which the last element of the list of points contains a copy of the first element list, <code>lr0</code>. The closed curve is added to the ThreeSpace, <code>s</code>.</p>
</dd></dl>
<dl><dt>closedCurve : (%, <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))) -&gt %</dt><dd><p>
<code>closedCurve(s, [p0, p1, ..., pn, p0])</code> adds a closed curve component which is a list of points defined by the first element <code>p0</code> through the last element <code>pn</code> and back to the first element <code>p0</code> again, to the ThreeSpace <code>s</code>.</p>
</dd></dl>
<dl><dt>closedCurve : <a href="List.html">List</a>(<a href="Point.html">Point</a>(R)) -&gt %</dt><dd><p>
<code>closedCurve(lp)</code> sets a list of points defined by the first element of <code>lp</code> through the last element of <code>lp</code> and back to the first element again and returns a ThreeSpace whose component is the closed curve defined by <code>lp</code>.</p>
</dd></dl>
<dl><dt>closedCurve : % -&gt <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))</dt><dd><p>
<code>closedCurve(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a single closed curve component defined by a list of points in which the first point is also the last point, all of which are from the domain <code>PointDomain(m, R)</code> and if so, returns the list of points. An error is signaled otherwise.</p>
</dd></dl>
<a name="f_closedCurve_63"></a><dl><dt>closedCurve? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>closedCurve?(s)</code> returns <code>true</code> if the ThreeSpace <code>s</code> contains a single closed curve component, i.e. the first element of the curve is also the last element, or <code>false</code> otherwise.</p>
</dd></dl>
<a name="f_coerce"></a><dl><dt>coerce : % -&gt <a href="OutputForm.html">OutputForm</a></dt><dd><p>
<code>coerce(s)</code> returns the ThreeSpace <code>s</code> to Output format.</p>
</dd></dl>
<a name="f_components"></a><dl><dt>components : % -&gt <a href="List.html">List</a>(%)</dt><dd><p>
<code>components(s)</code> takes the ThreeSpace <code>s</code>, and creates a list containing a unique ThreeSpace for each single component of <code>s</code>. If <code>s</code> has no components defined, the list returned is empty.</p>
</dd></dl>
<a name="f_composite"></a><dl><dt>composite : <a href="List.html">List</a>(%) -&gt %</dt><dd><p>
<code>composite([s1, s2, ..., sn])</code> will create a new ThreeSpace that is a union of all the components from each ThreeSpace in the parameter list, grouped as a composite.</p>
</dd></dl>
<a name="f_composites"></a><dl><dt>composites : % -&gt <a href="List.html">List</a>(%)</dt><dd><p>
<code>composites(s)</code> takes the ThreeSpace <code>s</code>, and creates a list containing a unique ThreeSpace for each single composite of <code>s</code>. If <code>s</code> has no composites defined (composites need to be explicitly created), the list returned is empty. Note that not all the components need to be part of a composite.</p>
</dd></dl>
<a name="f_copy"></a><dl><dt>copy : % -&gt %</dt><dd><p>
<code>copy(s)</code> returns a new ThreeSpace that is an exact copy of <code>s</code>.</p>
</dd></dl>
<a name="f_create3Space"></a><dl><dt>create3Space : () -&gt %</dt><dd><p>
<code>create3Space()</code> creates a ThreeSpace object capable of holding point, curve, mesh components and any combination.</p>
</dd></dl>
<dl><dt>create3Space : <a href="SubSpace.html">SubSpace</a>(3, R) -&gt %</dt><dd><p>
<code>create3Space(s)</code> creates a ThreeSpace object containing objects pre-defined within some SubSpace <code>s</code>.</p>
</dd></dl>
<a name="f_curve"></a><dl><dt>curve : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(R))) -&gt %</dt><dd><p>
<code>curve(s, [[p0], [p1], ..., [pn]])</code> adds a space curve which is a list of points <code>p0</code> through <code>pn</code> defined by lists of elements from the domain <code>PointDomain(m, R)</code>, where <code>R</code> is the Ring over which the point elements are defined and <code>m</code> is the dimension of the points, to the ThreeSpace <code>s</code>.</p>
</dd></dl>
<dl><dt>curve : (%, <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))) -&gt %</dt><dd><p>
<code>curve(s, [p0, p1, ..., pn])</code> adds a space curve component defined by a list of points <code>p0</code> through <code>pn</code>, to the ThreeSpace <code>s</code>.</p>
</dd></dl>
<dl><dt>curve : <a href="List.html">List</a>(<a href="Point.html">Point</a>(R)) -&gt %</dt><dd><p>
<code>curve([p0, p1, p2, ..., pn])</code> creates a space curve defined by the list of points <code>p0</code> through <code>pn</code>, and returns the ThreeSpace whose component is the curve.</p>
</dd></dl>
<dl><dt>curve : % -&gt <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))</dt><dd><p>
<code>curve(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a single curve defined by a list of points and if so, returns the curve, i.e. list of points. An error is signaled otherwise.</p>
</dd></dl>
<a name="f_curve_63"></a><dl><dt>curve? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>curve?(s)</code> queries whether the ThreeSpace, <code>s</code>, is a curve, i.e. has one component, a list of list of points, and returns <code>true</code> if it is, or <code>false</code> otherwise.</p>
</dd></dl>
<a name="f_enterPointData"></a><dl><dt>enterPointData : (%, <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))) -&gt <a href="NonNegativeInteger.html">NonNegativeInteger</a></dt><dd><p>
<code>enterPointData(s, [p0, p1, ..., pn])</code> adds a list of points from <code>p0</code> through <code>pn</code> to the ThreeSpace, <code>s</code>, and returns the index, to the starting point of the list.</p>
</dd></dl>
<a name="f_latex"></a><dl><dt><a href="SetCategory.html#f_latex">latex</a> : % -&gt <a href="String.html">String</a></dt><dd> from <a href="SetCategory.html">SetCategory</a></dd></dl>
<a name="f_lllip"></a><dl><dt>lllip : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="List.html">List</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>)))</dt><dd><p>
<code>lllip(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a list of components, which are lists of curves, which are lists of indices to points, and if so, returns the list of lists of lists; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_lllp"></a><dl><dt>lllp : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R))))</dt><dd><p>
<code>lllp(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a list of components, which are lists of curves, which are lists of points, and if so, returns the list of lists of lists; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_llprop"></a><dl><dt>llprop : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>))</dt><dd><p>
<code>llprop(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a list of curves which are lists of the subspace component properties of the curves, and if so, returns the list of lists; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_lp"></a><dl><dt>lp : % -&gt <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))</dt><dd><p>
<code>lp(s)</code> returns the list of points component which the ThreeSpace, <code>s</code>, contains; these points are used by reference, i.e. the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points.</p>
</dd></dl>
<a name="f_lprop"></a><dl><dt>lprop : % -&gt <a href="List.html">List</a>(<a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>)</dt><dd><p>
<code>lprop(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a list of subspace component properties, and if so, returns the list; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_merge"></a><dl><dt>merge : (%, %) -&gt %</dt><dd><p>
<code>merge(s1, s2)</code> will create a new ThreeSpace that has the components of <code>s1</code> and <code>s2</code>; Groupings of components into composites are maintained.</p>
</dd></dl>
<dl><dt>merge : <a href="List.html">List</a>(%) -&gt %</dt><dd><p>
<code>merge([s1, s2, ..., sn])</code> will create a new ThreeSpace that has the components of all the ones in the list; Groupings of components into composites are maintained.</p>
</dd></dl>
<a name="f_mesh"></a><dl><dt>mesh : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="List.html">List</a>(R))), <a href="Boolean.html">Boolean</a>, <a href="Boolean.html">Boolean</a>) -&gt %</dt><dd><p>
<code>mesh(s, [ [[r10]..., [r1m]], [[r20]..., [r2m]], ..., [[rn0]..., [rnm]] ], close1, close2)</code> adds a surface component to the ThreeSpace <code>s</code>, which is defined over a rectangular domain of size <code>WxH</code> where <code>W</code> is the number of lists of points from the domain <code>PointDomain(R)</code> and <code>H</code> is the number of elements in each of those lists; the booleans <code>close1</code> and <code>close2</code> indicate how the surface is to be closed: if <code>close1</code> is <code>true</code> this means that each individual list (a curve) is to be closed (i.e. the last point of the list is to be connected to the first point); if <code>close2</code> is <code>true</code>, this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).</p>
</dd></dl>
<dl><dt>mesh : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="List.html">List</a>(R))), <a href="List.html">List</a>(<a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>), <a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>) -&gt %</dt><dd><p>
<code>mesh(s, [ [[r10]..., [r1m]], [[r20]..., [r2m]], ..., [[rn0]..., [rnm]] ], [props], prop)</code> adds a surface component to the ThreeSpace <code>s</code>, which is defined over a rectangular domain of size <code>WxH</code> where <code>W</code> is the number of lists of points from the domain <code>PointDomain(R)</code> and <code>H</code> is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list, and prop is the subspace component property by which the points are defined.</p>
</dd></dl>
<dl><dt>mesh : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R))), <a href="Boolean.html">Boolean</a>, <a href="Boolean.html">Boolean</a>) -&gt %</dt><dd><p>
<code>mesh(s, [[p0], [p1], ..., [pn]], close1, close2)</code> adds a surface component to the ThreeSpace, which is defined over a list of curves, in which each of these curves is a list of points. The boolean arguments <code>close1</code> and <code>close2</code> indicate how the surface is to be closed. Argument <code>close1</code> equal <code>true</code> means that each individual list (a curve) is to be closed, i.e. the last point of the list is to be connected to the first point. Argument <code>close2</code> equal <code>true</code> means that the boundary at one end of the surface is to be connected to the boundary at the other end, i.e. the boundaries are defined as the first list of points (curve) and the last list of points (curve).</p>
</dd></dl>
<dl><dt>mesh : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R))), <a href="List.html">List</a>(<a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>), <a href="SubSpaceComponentProperty.html">SubSpaceComponentProperty</a>) -&gt %</dt><dd><p>
<code>mesh(s, [[p0], [p1], ..., [pn]], [props], prop)</code> adds a surface component, defined over a list curves which contains lists of points, to the ThreeSpace <code>s</code>; props is a list which contains the subspace component properties for each surface parameter, and prop is the subspace component property by which the points are defined.</p>
</dd></dl>
<dl><dt>mesh : <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R))) -&gt %</dt><dd><p>
<code>mesh([[p0], [p1], ..., [pn]])</code> creates a surface defined by a list of curves which are lists, <code>p0</code> through <code>pn</code>, of points, and returns a ThreeSpace whose component is the surface.</p>
</dd></dl>
<dl><dt>mesh : (<a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R))), <a href="Boolean.html">Boolean</a>, <a href="Boolean.html">Boolean</a>) -&gt %</dt><dd><p>
<code>mesh([[p0], [p1], ..., [pn]], close1, close2)</code> creates a surface defined over a list of curves, <code>p0</code> through <code>pn</code>, which are lists of points; the booleans <code>close1</code> and <code>close2</code> indicate how the surface is to be closed: <code>close1</code> set to <code>true</code> means that each individual list (a curve) is to be closed (that is, the last point of the list is to be connected to the first point); <code>close2</code> set to <code>true</code> means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the ThreeSpace containing this surface is returned.</p>
</dd></dl>
<dl><dt>mesh : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Point.html">Point</a>(R)))</dt><dd><p>
<code>mesh(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a single surface component defined by a list curves which contain lists of points, and if so, returns the list of lists of points; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_mesh_63"></a><dl><dt>mesh? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>mesh?(s)</code> returns <code>true</code> if the ThreeSpace <code>s</code> is composed of one component, a mesh comprising a list of curves which are lists of points, or returns <code>false</code> if otherwise</p>
</dd></dl>
<a name="f_modifyPointData"></a><dl><dt>modifyPointData : (%, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Point.html">Point</a>(R)) -&gt %</dt><dd><p>
<code>modifyPointData(s, i, p)</code> changes the point at the indexed location <code>i</code> in the ThreeSpace, <code>s</code>, to that of point <code>p</code>. This is useful for making changes to a point which has been transformed.</p>
</dd></dl>
<a name="f_numberOfComponents"></a><dl><dt>numberOfComponents : % -&gt <a href="NonNegativeInteger.html">NonNegativeInteger</a></dt><dd><p>
<code>numberOfComponents(s)</code> returns the number of distinct object components in the indicated ThreeSpace, <code>s</code>, such as points, curves, polygons, and constructs.</p>
</dd></dl>
<a name="f_numberOfComposites"></a><dl><dt>numberOfComposites : % -&gt <a href="NonNegativeInteger.html">NonNegativeInteger</a></dt><dd><p>
<code>numberOfComposites(s)</code> returns the number of supercomponents, or composites, in the ThreeSpace, <code>s</code>; Composites are arbitrary groupings of otherwise distinct and unrelated components; A ThreeSpace need not have any composites defined at all and, outside of the requirement that no component can belong to more than one composite at a time, the definition and interpretation of composites are unrestricted.</p>
</dd></dl>
<a name="f_objects"></a><dl><dt>objects : % -&gt Record(points : <a href="NonNegativeInteger.html">NonNegativeInteger</a>, curves : <a href="NonNegativeInteger.html">NonNegativeInteger</a>, polygons : <a href="NonNegativeInteger.html">NonNegativeInteger</a>, constructs : <a href="NonNegativeInteger.html">NonNegativeInteger</a>)</dt><dd><p>
<code>objects(s)</code> returns the ThreeSpace, <code>s</code>, in the form of a 3D object record containing information on the number of points, curves, polygons and constructs comprising the ThreeSpace..</p>
</dd></dl>
<a name="f_point"></a><dl><dt>point : (%, <a href="List.html">List</a>(R)) -&gt %</dt><dd><p>
<code>point(s, [x, y, z])</code> adds a point component defined by a list of elements which are from the <code>PointDomain(R)</code> to the ThreeSpace, <code>s</code>, where <code>R</code> is the Ring over which the point elements are defined.</p>
</dd></dl>
<dl><dt>point : (%, <a href="NonNegativeInteger.html">NonNegativeInteger</a>) -&gt %</dt><dd><p>
<code>point(s, i)</code> adds a point component which is placed into a component list of the ThreeSpace, <code>s</code>, at the index given by <code>i</code>.</p>
</dd></dl>
<dl><dt>point : (%, <a href="Point.html">Point</a>(R)) -&gt %</dt><dd><p>
<code>point(s, p)</code> adds a point component defined by the point, <code>p</code>, specified as a list from <code>List(R)</code>, to the ThreeSpace, <code>s</code>, where <code>R</code> is the Ring over which the point is defined.</p>
</dd></dl>
<dl><dt>point : <a href="Point.html">Point</a>(R) -&gt %</dt><dd><p>
<code>point(p)</code> returns a ThreeSpace object which is composed of one component, the point <code>p</code>.</p>
</dd></dl>
<dl><dt>point : % -&gt <a href="Point.html">Point</a>(R)</dt><dd><p>
<code>point(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of only a single point and if so, returns the point. An error is signaled otherwise.</p>
</dd></dl>
<a name="f_point_63"></a><dl><dt>point? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>point?(s)</code> queries whether the ThreeSpace, <code>s</code>, is composed of a single component which is a point and returns the boolean result.</p>
</dd></dl>
<a name="f_polygon"></a><dl><dt>polygon : (%, <a href="List.html">List</a>(<a href="List.html">List</a>(R))) -&gt %</dt><dd><p>
<code>polygon(s, [[r0], [r1], ..., [rn]])</code> adds a polygon component defined by a list of points <code>r0</code> through <code>rn</code>, which are lists of elements from the domain <code>PointDomain(m, R)</code> to the ThreeSpace <code>s</code>, where <code>m</code> is the dimension of the points and <code>R</code> is the Ring over which the points are defined.</p>
</dd></dl>
<dl><dt>polygon : (%, <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))) -&gt %</dt><dd><p>
<code>polygon(s, [p0, p1, ..., pn])</code> adds a polygon component defined by a list of points, <code>p0</code> through <code>pn</code>, to the ThreeSpace <code>s</code>.</p>
</dd></dl>
<dl><dt>polygon : <a href="List.html">List</a>(<a href="Point.html">Point</a>(R)) -&gt %</dt><dd><p>
<code>polygon([p0, p1, ..., pn])</code> creates a polygon defined by a list of points, <code>p0</code> through <code>pn</code>, and returns a ThreeSpace whose component is the polygon.</p>
</dd></dl>
<dl><dt>polygon : % -&gt <a href="List.html">List</a>(<a href="Point.html">Point</a>(R))</dt><dd><p>
<code>polygon(s)</code> checks to see if the ThreeSpace, <code>s</code>, is composed of a single polygon component defined by a list of points, and if so, returns the list of points; An error is signaled otherwise.</p>
</dd></dl>
<a name="f_polygon_63"></a><dl><dt>polygon? : % -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>polygon?(s)</code> returns <code>true</code> if the ThreeSpace <code>s</code> contains a single polygon component, or <code>false</code> otherwise.</p>
</dd></dl>
<a name="f_subspace"></a><dl><dt>subspace : % -&gt <a href="SubSpace.html">SubSpace</a>(3, R)</dt><dd><p>
<code>subspace(s)</code> returns the SubSpace which holds all the point information in the ThreeSpace, <code>s</code>.</p>
</dd></dl>
<a name="f__126_61"></a><dl><dt><a href="BasicType.html#f__126_61">~=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<p><a href="BasicType.html">BasicType</a>
<p><a href="CoercibleTo.html">CoercibleTo</a>(<a href="OutputForm.html">OutputForm</a>)
<p><a href="SetCategory.html">SetCategory</a>
</body>
</html>
