<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<link rel="stylesheet" type="text/css" href="styles.css">
<head>
<title>PermutationGroup</title>
</head>
<body>
<h1>PermutationGroup(S)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/permgrps.spad#L1">permgrps.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/permgrps.spad#L1">[edit on github]</a></p>
<ul>
<li>S : <a href="SetCategory.html">SetCategory</a></ul>
<p>
PermutationGroup implements permutation groups acting on a set <code>S</code>, i.e. all subgroups of the symmetric group of <code>S</code>, represented as a list of permutations (generators). Note that therefore the objects are not members of the FriCAS category Group. Using the idea of base and strong generators by Sims, basic routines and algorithms are implemented so that the word problem for permutation groups can be solved.</p>
<a name="f__60"></a><dl><dt>&lt; : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>gp1 &lt; gp2</code> returns <code>true</code> if and only if  gp1 is a proper subgroup of  gp2.</p>
</dd></dl>
<a name="f__60_61"></a><dl><dt>&lt;= : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>gp1 &lt;= gp2</code> returns <code>true</code> if and only if  gp1 is a subgroup of  gp2. Note: because of a bug in the parser you have to call this function explicitly by  gp1 &lt;=$(PERMGRP S) gp2.</p>
</dd></dl>
<a name="f__61"></a><dl><dt><a href="BasicType.html#f__61">=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<a name="f_base"></a><dl><dt>base : % -&gt <a href="List.html">List</a>(S)</dt><dd><p>
<code>base(gp)</code> returns a base for the group  gp.</p>
</dd></dl>
<a name="f_coerce"></a><dl><dt>coerce : <a href="List.html">List</a>(<a href="Permutation.html">Permutation</a>(S)) -&gt %</dt><dd><p>
<code>coerce(ls)</code> coerces a list of permutations  ls to the group generated by this list.</p>
</dd></dl>
<dl><dt>coerce : % -&gt <a href="List.html">List</a>(<a href="Permutation.html">Permutation</a>(S))</dt><dd><p>
<code>coerce(gp)</code> returns the generators of the group  gp.</p>
</dd></dl>
<dl><dt><a href="CoercibleTo.html#f_coerce">coerce</a> : % -&gt <a href="OutputForm.html">OutputForm</a></dt><dd> from <a href="CoercibleTo.html">CoercibleTo</a>(<a href="OutputForm.html">OutputForm</a>)</dd></dl>
<a name="f_degree"></a><dl><dt>degree : % -&gt <a href="NonNegativeInteger.html">NonNegativeInteger</a></dt><dd><p>
<code>degree(gp)</code> returns the number of points moved by all permutations of the group  gp.</p>
</dd></dl>
<a name="f_elt"></a><dl><dt>elt : (%, <a href="NonNegativeInteger.html">NonNegativeInteger</a>) -&gt <a href="Permutation.html">Permutation</a>(S)</dt><dd><p>
<code>elt(gp, i)</code> returns the <code>i</code>-th generator of the group  gp.</p>
</dd></dl>
<a name="f_generators"></a><dl><dt>generators : % -&gt <a href="List.html">List</a>(<a href="Permutation.html">Permutation</a>(S))</dt><dd><p>
<code>generators(gp)</code> returns the generators of the group  gp.</p>
</dd></dl>
<a name="f_initializeGroupForWordProblem"></a><dl><dt>initializeGroupForWordProblem : % -&gt <a href="Void.html">Void</a></dt><dd><p>
<code>initializeGroupForWordProblem(gp)</code> initializes the group  gp for the word problem. Notes: it calls the other function of this name with parameters 0 and 1:  initializeGroupForWordProblem(gp, 0, 1). Notes: (1) be careful: invoking this routine will destroy the possibly information about your group (but will recompute it again) (2) users need not call this function normally for the solution of the word problem.</p>
</dd></dl>
<dl><dt>initializeGroupForWordProblem : (%, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt <a href="Void.html">Void</a></dt><dd><p>
<code>initializeGroupForWordProblem(gp, m, n)</code> initializes the group  gp for the word problem. Notes: (1) with a small integer you get shorter words, but the routine takes longer than the standard routine for longer words. (2) be careful: invoking this routine will destroy the possibly stored information about your group (but will recompute it again). (3) users need not call this function normally for the solution of the word problem.</p>
</dd></dl>
<a name="f_latex"></a><dl><dt><a href="SetCategory.html#f_latex">latex</a> : % -&gt <a href="String.html">String</a></dt><dd> from <a href="SetCategory.html">SetCategory</a></dd></dl>
<a name="f_member_63"></a><dl><dt>member? : (<a href="Permutation.html">Permutation</a>(S), %) -&gt <a href="Boolean.html">Boolean</a></dt><dd><p>
<code>member?(pp, gp)</code> answers the question, whether the permutation  pp is in the group  gp or not.</p>
</dd></dl>
<a name="f_movedPoints"></a><dl><dt>movedPoints : % -&gt <a href="Set.html">Set</a>(S)</dt><dd><p>
<code>movedPoints(gp)</code> returns the points moved by the group  gp.</p>
</dd></dl>
<a name="f_orbit"></a><dl><dt>orbit : (%, S) -&gt <a href="Set.html">Set</a>(S)</dt><dd><p>
<code>orbit(gp, el)</code> returns the orbit of the element  el under the group  gp, i.e. the set of all points gained by applying each group element to  el.</p>
</dd></dl>
<dl><dt>orbit : (%, <a href="List.html">List</a>(S)) -&gt <a href="Set.html">Set</a>(<a href="List.html">List</a>(S))</dt><dd><p>
<code>orbit(gp, ls)</code> returns the orbit of the ordered list  ls under the group  gp. Note: return type is <code>L</code> <code>L</code> <code>S</code> temporarily because FSET <code>L</code> <code>S</code> has an error.</p>
</dd></dl>
<dl><dt>orbit : (%, <a href="Set.html">Set</a>(S)) -&gt <a href="Set.html">Set</a>(<a href="Set.html">Set</a>(S))</dt><dd><p>
<code>orbit(gp, els)</code> returns the orbit of the unordered set  els under the group  gp.</p>
</dd></dl>
<a name="f_orbits"></a><dl><dt>orbits : % -&gt <a href="Set.html">Set</a>(<a href="Set.html">Set</a>(S))</dt><dd><p>
<code>orbits(gp)</code> returns the orbits of the group  gp, i.e. it partitions the (finite) of all moved points.</p>
</dd></dl>
<a name="f_order"></a><dl><dt>order : % -&gt <a href="NonNegativeInteger.html">NonNegativeInteger</a></dt><dd><p>
<code>order(gp)</code> returns the order of the group  gp.</p>
</dd></dl>
<a name="f_perm_95to_95vec"></a><dl><dt>perm_to_vec : (<a href="List.html">List</a>(S), <a href="Permutation.html">Permutation</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>) -&gt <a href="Vector.html">Vector</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>)</dt><dd><p>
<code>perm_to_vec(supp, p, degree)</code> should be local but conditional</p>
</dd></dl>
<a name="f_permutationGroup"></a><dl><dt>permutationGroup : <a href="List.html">List</a>(<a href="Permutation.html">Permutation</a>(S)) -&gt %</dt><dd><p>
<code>permutationGroup(ls)</code> coerces a list of permutations  ls to the group generated by this list.</p>
</dd></dl>
<a name="f_pointList"></a><dl><dt>pointList : % -&gt <a href="List.html">List</a>(S)</dt><dd><p>
<code>pointList(gp)</code> should be local but conditional</p>
</dd></dl>
<a name="f_random"></a><dl><dt>random : % -&gt <a href="Permutation.html">Permutation</a>(S)</dt><dd><p>
<code>random(gp)</code> returns a random product of maximal 20 generators of the group  gp. Note:  random(gp)=random(gp, 20).</p>
</dd></dl>
<dl><dt>random : (%, <a href="Integer.html">Integer</a>) -&gt <a href="Permutation.html">Permutation</a>(S)</dt><dd><p>
<code>random(gp, i)</code> returns a random product of maximal <code>i</code> generators of the group  gp.</p>
</dd></dl>
<a name="f_relationsInGenerators"></a><dl><dt>relationsInGenerators : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Integer.html">Integer</a>))</dt><dd><p>
<code>relationsInGenerators(gp)</code> computes relations between generators.</p>
</dd></dl>
<a name="f_relationsInStrongGenerators"></a><dl><dt>relationsInStrongGenerators : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="Integer.html">Integer</a>))</dt><dd><p>
<code>relationsInStrongGenerators(gp)</code> computes relations between strong generators.</p>
</dd></dl>
<a name="f_strongGenerators"></a><dl><dt>strongGenerators : % -&gt <a href="List.html">List</a>(<a href="Permutation.html">Permutation</a>(S))</dt><dd><p>
<code>strongGenerators(gp)</code> returns strong generators for the group  gp.</p>
</dd></dl>
<a name="f_wordInGenerators"></a><dl><dt>wordInGenerators : (<a href="Permutation.html">Permutation</a>(S), %) -&gt <a href="List.html">List</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>)</dt><dd><p>
<code>wordInGenerators(p, gp)</code> returns the word for the permutation <code>p</code> in the original generators of the group  gp, represented by the indices of the list, given by  generators.</p>
</dd></dl>
<a name="f_wordInStrongGenerators"></a><dl><dt>wordInStrongGenerators : (<a href="Permutation.html">Permutation</a>(S), %) -&gt <a href="List.html">List</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>)</dt><dd><p>
<code>wordInStrongGenerators(p, gp)</code> returns the word for the permutation <code>p</code> in the strong generators of the group  gp, represented by the indices of the list, given by  strongGenerators.</p>
</dd></dl>
<a name="f_wordsForStrongGenerators"></a><dl><dt>wordsForStrongGenerators : % -&gt <a href="List.html">List</a>(<a href="List.html">List</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>))</dt><dd><p>
<code>wordsForStrongGenerators(gp)</code> returns the words for the strong generators of the group  gp in the original generators of  gp, represented by their indices in the list, given by  generators.</p>
</dd></dl>
<a name="f__126_61"></a><dl><dt><a href="BasicType.html#f__126_61">~=</a> : (%, %) -&gt <a href="Boolean.html">Boolean</a></dt><dd> from <a href="BasicType.html">BasicType</a></dd></dl>
<p><a href="CoercibleTo.html">CoercibleTo</a>(<a href="OutputForm.html">OutputForm</a>)
<p><a href="BasicType.html">BasicType</a>
<p><a href="SetCategory.html">SetCategory</a>
</body>
</html>
