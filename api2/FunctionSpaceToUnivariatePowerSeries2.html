<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>FunctionSpaceToUnivariatePowerSeries2</title>
</head>
<body>
<h1>FunctionSpaceToUnivariatePowerSeries2(R, FE, Expon, UPS, TRAN, UTS, TEXP, coerce_Ex, x)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/fs2ups.spad#L1">fs2ups.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/fs2ups.spad#L1">[edit on github]</a></p>
<ul>
<li>R : Join(<a href="GcdDomain.html">GcdDomain</a>, <a href="Comparable.html">Comparable</a>, <a href="RetractableTo.html">RetractableTo</a>(<a href="Integer.html">Integer</a>), <a href="LinearlyExplicitOver.html">LinearlyExplicitOver</a>(<a href="Integer.html">Integer</a>))<li>FE : Join(<a href="AlgebraicallyClosedField.html">AlgebraicallyClosedField</a>, <a href="TranscendentalFunctionCategory.html">TranscendentalFunctionCategory</a>, <a href="Algebra.html">Algebra</a>(<a href="Fraction.html">Fraction</a>(<a href="Integer.html">Integer</a>)), <a href="FunctionSpace.html">FunctionSpace</a>(R))<li>Expon : Join(<a href="OrderedAbelianMonoid.html">OrderedAbelianMonoid</a>, <a href="OrderedRing.html">OrderedRing</a>)<li>UPS : Join(<a href="UnivariatePowerSeriesCategory.html">UnivariatePowerSeriesCategory</a>(FE, Expon), <a href="Field.html">Field</a>, <a href="PowerSeriesCategory.html">PowerSeriesCategory</a>(FE, Expon, <a href="SingletonAsOrderedSet.html">SingletonAsOrderedSet</a>), <a href="TranscendentalFunctionCategory.html">TranscendentalFunctionCategory</a>)<li>TRAN : <a href="PartialTranscendentalFunctions.html">PartialTranscendentalFunctions</a>(UPS)<li>UTS : <a href="UnivariateTaylorSeriesCategory.html">UnivariateTaylorSeriesCategory</a>(FE)<li>TEXP : <a href="TaylorSeriesExpansion.html">TaylorSeriesExpansion</a>(FE, Expon, <a href="SingletonAsOrderedSet.html">SingletonAsOrderedSet</a>, UPS, UTS)<li>coerce_Ex : Mapping(FE, Expon)<li>x : <a href="Symbol.html">Symbol</a></ul>
<p>
This package converts expressions in some function space to power series in a variable <code>x</code> with coefficients in that function space. The function <span class="spadfun">exprToUPS</span> converts expressions to power series whose coefficients do not contain the variable <code>x</code>. The function <span class="spadfun">exprToGenUPS</span> converts functional expressions to power series whose coefficients may involve functions of <code>log(x)</code>.</p>
<a name="f_atan1"></a><dl><dt>atan1 : UPS -&gt UPS</dt><dd><p>
<code>atan1 should</code> be local but conditional</p>
</dd></dl>
<a name="f_exprToGenUPS"></a><dl><dt>exprToGenUPS : (FE, <a href="Boolean.html">Boolean</a>, Union("complex", "real: two sides", "real: left side", "real: right side", "just do it")) -&gt Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>)))</dt><dd><p>
<code>exprToGenUPS(fcn, posCheck?, atanFlag)</code> converts the expression <code>fcn</code> to a generalized power series. If <code>posCheck?</code> is <code>true</code>, log<code>'s</code> of negative numbers are not allowed nor are <code>n</code>th roots of negative numbers with <code>n</code> even. If <code>posCheck?</code> is <code>false</code>, these are allowed. <code>atanFlag</code> determines how the case <code>atan(f(x))</code>, where <code>f(x)</code> has a pole, will be treated. The possible values of <code>atanFlag</code> are <code>"complex"</code>, <code>"real: two sides"</code>, <code>"real: left side"</code>, <code>"real: right side"</code>, and <code>"just do it"</code>. If <code>atanFlag</code> is <code>"complex"</code>, then no series expansion will be computed because, viewed as a function of a complex variable, <code>atan(f(x))</code> has an essential singularity. Otherwise, the sign of the leading coefficient of the series expansion of <code>f(x)</code> determines the constant coefficient in the series expansion of <code>atan(f(x))</code>. If this sign cannot be determined, a series expansion is computed only when <code>atanFlag</code> is <code>"just do it"</code>. When the leading term in the series expansion of <code>f(x)</code> is of odd degree (or is a rational degree with odd numerator), then the constant coefficient in the series expansion of <code>atan(f(x))</code> for values to the left differs from that for values to the right. If <code>atanFlag</code> is <code>"real: two sides"</code>, no series expansion will be computed. If <code>atanFlag</code> is <code>"real: left side"</code> the constant coefficient for values to the left will be used and if <code>atanFlag</code> <code>"real: right side"</code> the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series, we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a, the user should perform the substitution <code>x -&gt; x + a</code> before calling this function.</p>
</dd></dl>
<a name="f_exprToPS"></a><dl><dt>exprToPS : (FE, <a href="Boolean.html">Boolean</a>, Union("complex", "real: two sides", "real: left side", "real: right side", "just do it"), <a href="Boolean.html">Boolean</a>, FE) -&gt Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>)))</dt><dd><p>
<code>exprToPS(fcn, posCheck?, atanFlag, log_flag, log_val)</code> is like exprToUPS, but if <code>log_flag</code> is <code>true</code> it replaces logarithms of expansion variable by <code>log_val</code></p>
</dd></dl>
<dl><dt>exprToPS : (FE, <a href="Boolean.html">Boolean</a>, Union("complex", "real: two sides", "real: left side", "real: right side", "just do it"), <a href="Boolean.html">Boolean</a>, FE, Mapping(<a href="Boolean.html">Boolean</a>, FE), Mapping(<a href="Boolean.html">Boolean</a>, FE), Mapping(<a href="Boolean.html">Boolean</a>, FE)) -&gt Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>)))</dt><dd><p>
exprToPS(<code>fcn</code>, posCheck?, atanFlag, log_flag, log_val, coef_chk, inv_chk, zero_chk) is like exprToPS(<code>fcn</code>, posCheck?, atanFlag, log_flag, log_val), but fails if <code>coef_chk</code> is <code>false</code> for some coefficient of <code>fcn</code> or if expansion process needs to invert element of <code>FE</code> for which <code>inv_chk</code> is <code>false</code></p>
</dd></dl>
<a name="f_exprToUPS"></a><dl><dt>exprToUPS : (FE, <a href="Boolean.html">Boolean</a>, Union("complex", "real: two sides", "real: left side", "real: right side", "just do it")) -&gt Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>)))</dt><dd><p>
<code>exprToUPS(fcn, posCheck?, atanFlag)</code> converts the expression <code>fcn</code> to a power series. If <code>posCheck?</code> is <code>true</code>, log<code>'s</code> of negative numbers are not allowed nor are <code>n</code>th roots of negative numbers with <code>n</code> even. If <code>posCheck?</code> is <code>false</code>, these are allowed. <code>atanFlag</code> determines how the case <code>atan(f(x))</code>, where <code>f(x)</code> has a pole, will be treated. The possible values of <code>atanFlag</code> are <code>"complex"</code>, <code>"real: two sides"</code>, <code>"real: left side"</code>, <code>"real: right side"</code>, and <code>"just do it"</code>. If <code>atanFlag</code> is <code>"complex"</code>, then no series expansion will be computed because, viewed as a function of a complex variable, <code>atan(f(x))</code> has an essential singularity. Otherwise, the sign of the leading coefficient of the series expansion of <code>f(x)</code> determines the constant coefficient in the series expansion of <code>atan(f(x))</code>. If this sign cannot be determined, a series expansion is computed only when <code>atanFlag</code> is <code>"just do it"</code>. When the leading term in the series expansion of <code>f(x)</code> is of odd degree (or is a rational degree with odd numerator), then the constant coefficient in the series expansion of <code>atan(f(x))</code> for values to the left differs from that for values to the right. If <code>atanFlag</code> is <code>"real: two sides"</code>, no series expansion will be computed. If <code>atanFlag</code> is <code>"real: left side"</code> the constant coefficient for values to the left will be used and if <code>atanFlag</code> <code>"real: right side"</code> the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series, a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a, the user should perform the substitution <code>x -&gt; x + a</code> before calling this function.</p>
</dd></dl>
<a name="f_integ"></a><dl><dt>integ : UPS -&gt UPS</dt><dd><p>
<code>integ should</code> be local but conditional</p>
</dd></dl>
<a name="f_integ_95df"></a><dl><dt>integ_df : (UPS, UPS) -&gt UPS</dt><dd><p>
<code>integ_df should</code> be local but conditional</p>
</dd></dl>
<a name="f_integt"></a><dl><dt>integt : UTS -&gt UTS</dt><dd><p>
<code>integt should</code> be local but conditional</p>
</dd></dl>
<a name="f_localAbs"></a><dl><dt>localAbs : FE -&gt FE</dt><dd><p>
<code>localAbs(fcn)</code> = <code>abs(fcn)</code> or <code>sqrt(fcn^2)</code> depending on whether or not FE has a function <code>abs</code>. This should be a local function, but the compiler won<code>'t</code> allow it.</p>
</dd></dl>
<a name="f_my_95digamma"></a><dl><dt>my_digamma : FE -&gt FE</dt><dd><p>
<code>my_digamma should</code> be local but conditional</p>
</dd></dl>
<a name="f_powToUPS"></a><dl><dt>powToUPS : (<a href="List.html">List</a>(FE), Record(pos_Check? : <a href="Boolean.html">Boolean</a>, atan_Flag : Union("complex", "real: two sides", "real: left side", "real: right side", "just do it"), coeff_check? : Union(Mapping(<a href="Boolean.html">Boolean</a>, FE), "none"), inv_check? : Union(Mapping(<a href="Boolean.html">Boolean</a>, FE), "none"), zero_check? : Union(Mapping(<a href="Boolean.html">Boolean</a>, FE), "none"), log_x_replace : <a href="Boolean.html">Boolean</a>, log_x_val : FE, cache : <a href="List.html">List</a>(Record(ker : <a href="Kernel.html">Kernel</a>(FE), ser : Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>))))))) -&gt Union(:(%series, UPS), :(%problem, Record(func : <a href="String.html">String</a>, prob : <a href="String.html">String</a>)))</dt><dd><p>
<code>powToUPS should</code> be local but conditional</p>
</dd></dl>
</body>
</html>
