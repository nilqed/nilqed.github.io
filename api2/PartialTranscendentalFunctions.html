<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>PartialTranscendentalFunctions</title>
</head>
<body>
<h1>PartialTranscendentalFunctions(K)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/ptranfn.spad#L1">ptranfn.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/ptranfn.spad#L1">[edit on github]</a></p>
<ul>
<li>K : <a href="Type.html">Type</a></ul>
<p>
This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory.</p>
<a name="f_acosIfCan"></a><dl><dt>acosIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acosIfCan(z)</code> returns acos(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_acoshIfCan"></a><dl><dt>acoshIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acoshIfCan(z)</code> returns acosh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_acotIfCan"></a><dl><dt>acotIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acotIfCan(z)</code> returns acot(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_acothIfCan"></a><dl><dt>acothIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acothIfCan(z)</code> returns acoth(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_acscIfCan"></a><dl><dt>acscIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acscIfCan(z)</code> returns acsc(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_acschIfCan"></a><dl><dt>acschIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>acschIfCan(z)</code> returns acsch(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_asecIfCan"></a><dl><dt>asecIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>asecIfCan(z)</code> returns asec(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_asechIfCan"></a><dl><dt>asechIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>asechIfCan(z)</code> returns asech(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_asinIfCan"></a><dl><dt>asinIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>asinIfCan(z)</code> returns asin(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_asinhIfCan"></a><dl><dt>asinhIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>asinhIfCan(z)</code> returns asinh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_atanIfCan"></a><dl><dt>atanIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>atanIfCan(z)</code> returns atan(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_atanhIfCan"></a><dl><dt>atanhIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>atanhIfCan(z)</code> returns atanh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_cosIfCan"></a><dl><dt>cosIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>cosIfCan(z)</code> returns cos(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_coshIfCan"></a><dl><dt>coshIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>coshIfCan(z)</code> returns cosh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_cotIfCan"></a><dl><dt>cotIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>cotIfCan(z)</code> returns cot(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_cothIfCan"></a><dl><dt>cothIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>cothIfCan(z)</code> returns coth(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_cscIfCan"></a><dl><dt>cscIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>cscIfCan(z)</code> returns <code>csc</code>(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_cschIfCan"></a><dl><dt>cschIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>cschIfCan(z)</code> returns csch(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_expIfCan"></a><dl><dt>expIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>expIfCan(z)</code> returns exp(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_logIfCan"></a><dl><dt>logIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>logIfCan(z)</code> returns log(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_nthRootIfCan"></a><dl><dt>nthRootIfCan : (K, <a href="NonNegativeInteger.html">NonNegativeInteger</a>) -&gt Union(K, "failed")</dt><dd><p>
<code>nthRootIfCan(z, n)</code> returns the <code>n</code>th root of <code>z</code> if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_secIfCan"></a><dl><dt>secIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>secIfCan(z)</code> returns sec(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_sechIfCan"></a><dl><dt>sechIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>sechIfCan(z)</code> returns sech(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_sinIfCan"></a><dl><dt>sinIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>sinIfCan(z)</code> returns sin(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_sinhIfCan"></a><dl><dt>sinhIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>sinhIfCan(z)</code> returns sinh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_tanIfCan"></a><dl><dt>tanIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>tanIfCan(z)</code> returns tan(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
<a name="f_tanhIfCan"></a><dl><dt>tanhIfCan : K -&gt Union(K, "failed")</dt><dd><p>
<code>tanhIfCan(z)</code> returns tanh(<code>z</code>) if possible, and "failed" otherwise.</p>
</dd></dl>
</body>
</html>
