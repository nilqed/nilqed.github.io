<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>NaiveBeckermannLabahnModular</title>
</head>
<body>
<h1>NaiveBeckermannLabahnModular</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/modhpsol.spad#L1">modhpsol.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/modhpsol.spad#L1">[edit on github]</a></p>
<p>
This package solves (multipoint) Hermite-Pade interpolation problem over $<code>Z_p</code>$, where $<code>p</code>$ is machine sized prime.We use quadratic algorithm from 94 Beckermann and Labahn paper (with modification to handle multipoint case).</p>
<a name="f_naiveBeckermannLabahn"></a><dl><dt>naiveBeckermannLabahn : (<a href="Vector.html">Vector</a>(<a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(<a href="Integer.html">Integer</a>)), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Integer.html">Integer</a>) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
<code>naiveBeckermannLabahn(f, degs, sigma, p)</code> solves modulo $<code>p</code>$ Hermite-Pade interpolation problem of order $<code>sigma</code>$. $<code>degs</code>$ specifies degree bounds for solution. The first element of result contains <code>sigma</code>-basis. The second gives defects of elements of <code>sigma</code>-basis. The third one contains residuals <code>--</code> we stop updating solution if this would violate degree bounds, so residual is zero for elements of <code>sigma</code>-basis which are within bounds, but non-zero otherwise.</p>
</dd></dl>
<dl><dt>naiveBeckermannLabahn : (<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Integer.html">Integer</a>) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
<code>naiveBeckermannLabahn(f, degs, sigma, p)</code> solves modulo $<code>p</code>$ Hermite-Pade interpolation problem of order $<code>sigma</code>$. $<code>degs</code>$ specifies degree bounds for solution. The first element of result contains <code>sigma</code>-basis. The second gives defects of elements of <code>sigma</code>-basis. The third one contains residuals <code>--</code> we stop updating solution if this would violate degree bounds, so residual is zero for elements of <code>sigma</code>-basis which are within bounds, but non-zero otherwise.</p>
</dd></dl>
<a name="f_naiveBeckermannLabahn0"></a><dl><dt>naiveBeckermannLabahn0 : (<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Integer.html">Integer</a>, Mapping(<a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>)) -&gt <a href="Void.html">Void</a></dt><dd><p>
main solver routine</p>
</dd></dl>
<a name="f_naiveBeckermannLabahn1"></a><dl><dt>naiveBeckermannLabahn1 : (<a href="Vector.html">Vector</a>(<a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(<a href="Integer.html">Integer</a>)), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Integer.html">Integer</a>, Mapping(<a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>)) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
</p>
</dd></dl>
<dl><dt>naiveBeckermannLabahn1 : (<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Integer.html">Integer</a>, Mapping(<a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), Mapping(<a href="Void.html">Void</a>, <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>)) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
</p>
</dd></dl>
<a name="f_naiveBeckermannLabahnMultipoint"></a><dl><dt>naiveBeckermannLabahnMultipoint : (<a href="Vector.html">Vector</a>(<a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(<a href="Integer.html">Integer</a>)), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
<code>naiveBeckermannLabahnMultipoint(f, degs, sigma, p)</code> solves modulo $<code>p</code>$ multipoint Hermite-Pade interpolation problem of order $<code>sigma</code>$. $<code>degs</code>$ specifies degree bounds for solution. The first element of result contains <code>sigma</code>-basis. The second gives defects of elements of <code>sigma</code>-basis. The third one contains residuals <code>--</code> we stop updating solution if this would violate degree bounds, so residual is zero for elements of <code>sigma</code>-basis which are within bounds, but non-zero otherwise.</p>
</dd></dl>
<dl><dt>naiveBeckermannLabahnMultipoint : (<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="U32Vector.html">U32Vector</a>, <a href="Integer.html">Integer</a>) -&gt <a href="List.html">List</a>(<a href="Any.html">Any</a>)</dt><dd><p>
<code>naiveBeckermannLabahnMultipoint(f, degs, sigma, p)</code> solves modulo $<code>p</code>$ multipoint Hermite-Pade interpolation problem of order $<code>sigma</code>$. $<code>degs</code>$ specifies degree bounds for solution. The first element of result contains <code>sigma</code>-basis. The second gives defects of elements of <code>sigma</code>-basis. The third one contains residuals <code>--</code> we stop updating solution if this would violate degree bounds, so residual is zero for elements of <code>sigma</code>-basis which are within bounds, but non-zero otherwise.</p>
</dd></dl>
<a name="f_reduceBasis"></a><dl><dt>reduceBasis : (<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="Integer.html">Integer</a>) -&gt Record(basis : <a href="TwoDimensionalArray.html">TwoDimensionalArray</a>(<a href="U32Vector.html">U32Vector</a>), defects : <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), cinds : <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>))</dt><dd><p>
<code>reduceBasis skips</code> elements of sigma basis which does not satisfy degree bounds and puts sigma-basis into canonical form.</p>
</dd></dl>
<a name="f_reduceBasis0"></a><dl><dt>reduceBasis0 : (<a href="TwoDimensionalArray.html">TwoDimensionalArray</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), <a href="Integer.html">Integer</a>) -&gt Record(basis : <a href="TwoDimensionalArray.html">TwoDimensionalArray</a>(<a href="U32Vector.html">U32Vector</a>), defects : <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>), cinds : <a href="Vector.html">Vector</a>(<a href="Integer.html">Integer</a>))</dt><dd><p>
</p>
</dd></dl>
</body>
</html>
