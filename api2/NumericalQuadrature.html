<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<link rel="stylesheet" type="text/css" href="styles.css">
<head>
<title>NumericalQuadrature</title>
</head>
<body>
<h1>NumericalQuadrature(F)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/numquad.spad#L1">numquad.spad line 1</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/numquad.spad#L1">[edit on github]</a></p>
<ul>
<li>F : <a href="FloatingPointSystem.html">FloatingPointSystem</a></ul>
<p>
This suite of routines performs numerical quadrature using algorithms derived from the basic trapezoidal rule. Because the error term of this rule contains only even powers of the step size (for open and closed versions), fast convergence can be obtained if the integrand is sufficiently smooth.  Each routine returns a Record of type TrapAns, which contains  value (Float):  estimate of the integral  error (Float):  estimate of the error in the computation  totalpts (Integer):  total number of function evaluations  success (Boolean):  if the integral was computed within the user specified error criterion  To produce this estimate, each routine generates an internal sequence of sub-estimates, denoted by  S(i), depending on the routine, to which the various convergence criteria are applied. The user must supply a relative accuracy, <code>eps_r</code>, and an absolute accuracy, <code>eps_a</code>. Convergence is obtained when either <code>ABS(S(i) - S(i-1)) &lt; eps_r * ABS(S(i-1))</code> or <code>ABS(S(i) - S(i-1)) &lt; eps_a</code> are <code>true</code> statements.  The routines come in three families and three flavors:  closed: romberg, simpson, trapezoidal  open: rombergo, simpsono, trapezoidalo  adaptive closed: aromberg, asimpson, atrapezoidal  The  S(i) for the trapezoidal family is the value of the integral using an equally spaced absicca trapezoidal rule for that level of refinement.  The  S(i) for the simpson family is the value of the integral using an equally spaced absicca simpson rule for that level of refinement.  The  S(i) for the romberg family is the estimate of the integral using an equally spaced absicca romberg method. For the <code>i</code><code>-</code>th level, this is an appropriate combination of all the previous trapezodial estimates so that the error term starts with the <code>2*(i+1)</code> power only.  The three families come in a closed version, where the formulas include the endpoints, an open version where the formulas do not include the endpoints and an adaptive version, where the user is required to input the number of subintervals over which the appropriate closed family integrator will apply with the usual convergence parameters for each subinterval. This is useful where a large number of points are needed only in a small fraction of the entire domain.  Each routine takes as arguments:  <code>f</code> integrand  a starting point  <code>b</code> ending point  <code>eps_r</code> relative error  <code>eps_a</code> absolute error  <code>nmin</code>  refinement level when to start checking for convergence (&gt; 1)  <code>nmax</code>  maximum level of refinement  The adaptive routines take as an additional parameter  <code>nint</code> the number of independent intervals to apply a closed family integrator of the same name.  Notes:  Closed family level <code>i</code> uses <code>1 + 2^i</code> points.  Open family level <code>i</code> uses <code>1 + 3^i</code> points.</p>
<a name="f_aromberg"></a><dl><dt>aromberg : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>aromberg(fn, a, b, epsrel, epsabs, nmin, nmax, nint)</code> uses the adaptive romberg method to numerically integrate function <code>fn</code> over the closed interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>, and where <code>nint</code> is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_asimpson"></a><dl><dt>asimpson : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>asimpson(fn, a, b, epsrel, epsabs, nmin, nmax, nint)</code> uses the adaptive simpson method to numerically integrate function <code>fn</code> over the closed interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>, and where <code>nint</code> is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_atrapezoidal"></a><dl><dt>atrapezoidal : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>atrapezoidal(fn, a, b, epsrel, epsabs, nmin, nmax, nint)</code> uses the adaptive trapezoidal method to numerically integrate function <code>fn</code> over the closed interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>, and where <code>nint</code> is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_romberg"></a><dl><dt>romberg : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>romberg(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the romberg method to numerically integrate function <code>fn</code> over the closed interval <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_rombergo"></a><dl><dt>rombergo : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>rombergo(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the romberg method to numerically integrate function <code>fn</code> over the open interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_simpson"></a><dl><dt>simpson : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>simpson(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the simpson method to numerically integrate function <code>fn</code> over the closed interval <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_simpsono"></a><dl><dt>simpsono : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>simpsono(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the simpson method to numerically integrate function <code>fn</code> over the open interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_trapezoidal"></a><dl><dt>trapezoidal : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>trapezoidal(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the trapezoidal method to numerically integrate function <code>fn</code> over the closed interval <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
<a name="f_trapezoidalo"></a><dl><dt>trapezoidalo : (Mapping(F, F), F, F, F, F, <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>) -&gt Record(value : F, error : F, totalpts : <a href="Integer.html">Integer</a>, success : <a href="Boolean.html">Boolean</a>)</dt><dd><p>
<code>trapezoidalo(fn, a, b, epsrel, epsabs, nmin, nmax)</code> uses the trapezoidal method to numerically integrate function <code>fn</code> over the open interval from <code>a</code> to <code>b</code>, with relative accuracy <code>epsrel</code> and absolute accuracy <code>epsabs</code>, with the refinement levels for convergence checking vary from <code>nmin</code> to <code>nmax</code>. The value returned is a record containing the value of the integral, the estimate of the error in the computation, the total number of function evaluations, and either a boolean value which is <code>true</code> if the integral was computed within the user specified error criterion. See NumericalQuadrature for details.</p>
</dd></dl>
</body>
</html>
