<!doctype html>
<html>
<META http-equiv="Content-Type" content="text/html;" charset="UTF-8">
<head>
<title>Guess</title>
</head>
<body>
<h1>Guess(F, S, EXPRR, retract, coerce)</h1>
<p><a href="https://github.com/fricas/fricas/blob/master/src/algebra/mantepse.spad#L1292">mantepse.spad line 1292</a>
<a href="https://github.com/fricas/fricas/edit/master/src/algebra/mantepse.spad#L1292">[edit on github]</a></p>
<ul>
<li>F : Join(<a href="Field.html">Field</a>, <a href="PolynomialFactorizationExplicit.html">PolynomialFactorizationExplicit</a>)<li>S : <a href="GcdDomain.html">GcdDomain</a><li>EXPRR : Join<a href="FunctionSpace.html">FunctionSpace</a>(<a href="Integer.html">Integer</a>), <a href="IntegralDomain.html">IntegralDomain</a>, <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>), <a href="RetractableTo.html">RetractableTo</a>(<a href="Integer.html">Integer</a>), <a href="CombinatorialOpsCategory.html">CombinatorialOpsCategory</a>, <a href="PartialDifferentialRing.html">PartialDifferentialRing</a>(<a href="Symbol.html">Symbol</a>)) with
<p>* : (%, %) -&gt %<p>/ : (%, %) -&gt %<p>^ : (%, %) -&gt %<p>numerator : % -&gt %<p>denominator : % -&gt %<p>ground? : % -&gt <a href="Boolean.html">Boolean</a><li>retract : Mapping(F, EXPRR)<li>coerce : Mapping(EXPRR, F)</ul>
<p>
This package implements guessing of sequences. Packages for the most common cases are provided as GuessInteger, GuessPolynomial, etc.</p>
<a name="f_algDepHP"></a><dl><dt>algDepHP : (<a href="List.html">List</a>(<a href="List.html">List</a>(F)), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>))</dt><dd><p>
<code>algDepHP(list, options)</code> returns a specification for Hermite-Pade approximation looking for algebraic dependencies</p>
</dd></dl>
<a name="f_diffHP"></a><dl><dt>diffHP : <a href="Symbol.html">Symbol</a> -&gt Mapping(Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>)), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>diffHP options</code> returns a specification for Hermite-Pade approximation with the $<code>q</code>$-dilation operator</p>
</dd></dl>
<dl><dt>diffHP : <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>) -&gt Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>))</dt><dd><p>
<code>diffHP options</code> returns a specification for Hermite-Pade approximation with the differential operator</p>
</dd></dl>
<a name="f_guess"></a><dl><dt>guess : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guess l</code> applies recursively <span class="spadfun">guessRat</span> to the successive differences and quotients of the list. Default options as described in GuessOptionFunctions0 are used.</p>
</dd></dl>
<dl><dt>guess : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guess(l, options)</code> applies recursively <span class="spadfun">guessRat</span> to the successive differences and quotients of the list. The given options are used.</p>
</dd></dl>
<dl><dt>guess : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>))), <a href="List.html">List</a>(<a href="Symbol.html">Symbol</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guess(l, guessers, ops)</code> applies recursively the given <code>guessers</code> to the successive differences if ops contains the symbol guessSum and quotients if ops contains the symbol guessProduct to the list. Default options as described in GuessOptionFunctions0 are used.</p>
</dd></dl>
<dl><dt>guess : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>))), <a href="List.html">List</a>(<a href="Symbol.html">Symbol</a>), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guess(l, guessers, ops)</code> applies recursively the given <code>guessers</code> to the successive differences if ops contains the symbol <code>guessSum</code> and quotients if ops contains the symbol <code>guessProduct</code> to the list. The given options are used.</p>
</dd></dl>
<a name="f_guessADE"></a><dl><dt>guessADE : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessADE l</code> tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the default options described in GuessOptionFunctions0.</p>
</dd></dl>
<dl><dt>guessADE : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessADE(l, options)</code> tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options.</p>
</dd></dl>
<dl><dt>guessADE : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessADE q</code> returns a guesser that tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options.</p>
</dd></dl>
<a name="f_guessAlg"></a><dl><dt>guessAlg : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessAlg l</code> tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the default options described in GuessOptionFunctions0. It is equivalent to <span class="spadfun">guessADE</span>(<code>l</code>, maxDerivative <code>==</code> 0).</p>
</dd></dl>
<dl><dt>guessAlg : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessAlg(l, options)</code> tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessADE</span>(<code>l</code>, options) with <code>maxDerivative == 0</code>.</p>
</dd></dl>
<a name="f_guessAlgDep"></a><dl><dt>guessAlgDep : <a href="List.html">List</a>(<a href="List.html">List</a>(F)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessAlgDep ll</code> tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of <code>ll</code>, using the default options described in GuessOptionFunctions0.</p>
</dd></dl>
<dl><dt>guessAlgDep : (<a href="List.html">List</a>(<a href="List.html">List</a>(F)), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessAlgDep ll</code> tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of <code>ll</code>, using the given options.</p>
</dd></dl>
<a name="f_guessBinRat"></a><dl><dt>guessBinRat : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessBinRat(l, options)</code> tries to find a function of the form <code>n+</code>-&gt;binomial(a+b <code>n</code>, <code>n</code>) <code>r</code>(<code>n</code>), where <code>r</code>(<code>n</code>) is a rational function, that fits <code>l</code>.</p>
</dd></dl>
<dl><dt>guessBinRat : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessBinRat(l, options)</code> tries to find a function of the form <code>n+</code>-&gt;binomial(a+b <code>n</code>, <code>n</code>) <code>r</code>(<code>n</code>), where <code>r</code>(<code>n</code>) is a rational function, that fits <code>l</code>.</p>
</dd></dl>
<dl><dt>guessBinRat : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessBinRat q</code> returns a guesser that tries to find a function of the form <code>n+</code>-&gt;qbinomial(a+b <code>n</code>, <code>n</code>) <code>r</code>(<code>n</code>), where <code>r</code>(<code>q^n</code>) is a <code>q</code>-rational function, that fits <code>l</code>.</p>
</dd></dl>
<a name="f_guessExpRat"></a><dl><dt>guessExpRat : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessExpRat l</code> tries to find a function of the form <code>n+</code>-&gt;(a+b <code>n</code>)<code>^n</code> <code>r</code>(<code>n</code>), where <code>r</code>(<code>n</code>) is a rational function, that fits <code>l</code>.</p>
</dd></dl>
<dl><dt>guessExpRat : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessExpRat(l, options)</code> tries to find a function of the form <code>n+</code>-&gt;(a+b <code>n</code>)<code>^n</code> <code>r</code>(<code>n</code>), where <code>r</code>(<code>n</code>) is a rational function, that fits <code>l</code>.</p>
</dd></dl>
<dl><dt>guessExpRat : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessExpRat q</code> returns a guesser that tries to find a function of the form <code>n+</code>-&gt;(a+b <code>q^n</code>)<code>^n</code> <code>r</code>(<code>q^n</code>), where <code>r</code>(<code>q^n</code>) is a <code>q</code>-rational function, that fits <code>l</code>.</p>
</dd></dl>
<a name="f_guessFE"></a><dl><dt>guessFE : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessFE l</code> tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the default options described in GuessOptionFunctions0.</p>
</dd></dl>
<dl><dt>guessFE : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessFE(l, options)</code> tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options.</p>
</dd></dl>
<a name="f_guessHolo"></a><dl><dt>guessHolo : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessHolo l</code> tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the default options described in GuessOptionFunctions0. It is equivalent to <span class="spadfun">guessADE</span><code>(l, maxPower == 1)</code>.</p>
</dd></dl>
<dl><dt>guessHolo : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessHolo(l, options)</code> tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessADE</span><code>(l, options)</code> with <code>maxPower == 1</code>.</p>
</dd></dl>
<dl><dt>guessHolo : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessHolo q</code> returns a guesser that tries to find a linear differential equation for a generating function whose first Taylor coefficients are given by <code>l</code>, using the given options.</p>
</dd></dl>
<a name="f_guessPRec"></a><dl><dt>guessPRec : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessPRec l</code> tries to find a linear recurrence with polynomial coefficients whose first values are given by <code>l</code>, using the default options described in GuessOptionFunctions0. It is equivalent to <span class="spadfun">guessRec</span><code>(l, maxPower == 1)</code>.</p>
</dd></dl>
<dl><dt>guessPRec : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessPRec(l, options)</code> tries to find a linear recurrence with polynomial coefficients whose first values are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessRec</span><code>(l, options)</code> with <code>maxPower == 1</code>.</p>
</dd></dl>
<dl><dt>guessPRec : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessPRec q</code> returns a guesser that tries to find a linear <code>q</code>-recurrence with polynomial coefficients whose first values are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessRec</span><code>(q)</code> with <code>maxPower == 1</code>.</p>
</dd></dl>
<a name="f_guessPade"></a><dl><dt>guessPade : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessPade(l, options)</code> tries to find a rational function whose first Taylor coefficients are given by <code>l</code>, using the default options described in GuessOptionFunctions0. It is equivalent to <span class="spadfun">guessADE</span><code>(l, options)</code> with <code>maxDerivative == 0, maxPower == 1, allDegrees == true</code>.</p>
</dd></dl>
<dl><dt>guessPade : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessPade(l, options)</code> tries to find a rational function whose first Taylor coefficients are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessADE</span><code>(l, maxDerivative == 0, maxPower == 1, allDegrees == true)</code>.</p>
</dd></dl>
<a name="f_guessRat"></a><dl><dt>guessRat : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessRat l</code> tries to find a rational function whose first values are given by <code>l</code>, using the default options described in GuessOptionFunctions0. It is equivalent to <span class="spadfun">guessRec</span><code>(l, maxShift == 0, maxPower == 1, allDegrees == true)</code>.</p>
</dd></dl>
<dl><dt>guessRat : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessRat(l, options)</code> tries to find a rational function whose first values are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessRec</span><code>(l, maxShift == 0, maxPower == 1, allDegrees == true)</code>.</p>
</dd></dl>
<dl><dt>guessRat : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessRat q</code> returns a guesser that tries to find a <code>q</code>-rational function whose first values are given by <code>l</code>, using the given options. It is equivalent to <span class="spadfun">guessRec</span> with <code>(l, maxShift == 0, maxPower == 1, allDegrees == true)</code>.</p>
</dd></dl>
<a name="f_guessRec"></a><dl><dt>guessRec : <a href="List.html">List</a>(F) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessRec l</code> tries to find an ordinary difference equation whose first values are given by <code>l</code>, using the default options described in GuessOptionFunctions0.</p>
</dd></dl>
<dl><dt>guessRec : (<a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) -&gt <a href="List.html">List</a>(EXPRR)</dt><dd><p>
<code>guessRec(l, options)</code> tries to find an ordinary difference equation whose first values are given by <code>l</code>, using the given options.</p>
</dd></dl>
<dl><dt>guessRec : <a href="Symbol.html">Symbol</a> -&gt Mapping(<a href="List.html">List</a>(EXPRR), <a href="List.html">List</a>(F), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>guessRec q</code> returns a guesser that finds an ordinary <code>q</code>-difference equation whose first values are given by <code>l</code>, using the given options.</p>
</dd></dl>
<a name="f_shiftHP"></a><dl><dt>shiftHP : <a href="Symbol.html">Symbol</a> -&gt Mapping(Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>)), <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>)) if F has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>) and S has <a href="RetractableTo.html">RetractableTo</a>(<a href="Symbol.html">Symbol</a>)</dt><dd><p>
<code>shiftHP options</code> returns a specification for Hermite-Pade approximation with the $<code>q</code>$-shift operator, or, if <code>maxMixedDegree &gt; 0</code> for mixed shifts</p>
</dd></dl>
<dl><dt>shiftHP : <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>) -&gt Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>))</dt><dd><p>
<code>shiftHP options</code> returns a specification for Hermite-Pade approximation with the shift operator</p>
</dd></dl>
<a name="f_substHP"></a><dl><dt>substHP : <a href="List.html">List</a>(<a href="GuessOption.html">GuessOption</a>) -&gt Record(degreeStream : <a href="Stream.html">Stream</a>(<a href="NonNegativeInteger.html">NonNegativeInteger</a>), guessStream : Mapping(<a href="Stream.html">Stream</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(F)), guessModGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="U32Vector.html">U32Vector</a>), <a href="List.html">List</a>(<a href="U32Vector.html">U32Vector</a>), <a href="Integer.html">Integer</a>, <a href="Integer.html">Integer</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>), testGen : Mapping(Mapping(<a href="Vector.html">Vector</a>(<a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), <a href="List.html">List</a>(<a href="PositiveInteger.html">PositiveInteger</a>)), exprStream : Mapping(<a href="Stream.html">Stream</a>(EXPRR), EXPRR, <a href="Symbol.html">Symbol</a>), kind : <a href="Symbol.html">Symbol</a>, qvar : <a href="Symbol.html">Symbol</a>, A : Mapping(S, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="SparseUnivariatePolynomial.html">SparseUnivariatePolynomial</a>(S)), AF : Mapping(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>), <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="UnivariateFormalPowerSeries.html">UnivariateFormalPowerSeries</a>(<a href="SparseMultivariatePolynomial.html">SparseMultivariatePolynomial</a>(F, <a href="NonNegativeInteger.html">NonNegativeInteger</a>))), AX : Mapping(EXPRR, <a href="NonNegativeInteger.html">NonNegativeInteger</a>, <a href="Symbol.html">Symbol</a>, EXPRR), C : Mapping(<a href="List.html">List</a>(S), <a href="NonNegativeInteger.html">NonNegativeInteger</a>))</dt><dd><p>
<code>substHP options</code> returns a specification for Hermite-Pade approximation with the substitution operator</p>
</dd></dl>
</body>
</html>
