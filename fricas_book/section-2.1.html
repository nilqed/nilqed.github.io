<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Section2.1</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Section2.1</h1>
</header>
]&gt;
<a href="book-contents.xhtml">Book Contents</a><a href="section-2.0.xhtml">Previous Section 2.0 Using Types and Modes</a><a href="section-2.2.xhtml">Next Section 2.2 Writing Types and Modes</a> <a href="book-index.xhtml">Book Index</a>
<section id="sec-2.1">
<h2 class="sectiontitle" id="the-basic-idea">2.1 The Basic Idea</h2>
<span id="ugTypesBasic" class="label"></span>
<p>The FriCAS world deals with many kinds of objects. There are mathematical objects such as numbers and polynomials, data structure objects such as lists and arrays, and graphics objects such as points and graphic images. Functions are objects too.</p>
<p>FriCAS organizes objects using the notion of domain of computation, or simply <span class="italic">domain</span>. Each domain denotes a class of objects. The class of objects it denotes is usually given by the name of the domain: <span class="teletype">Integer</span> for the integers, <span class="teletype">Float</span> for floating-point numbers, and so on. The convention is that the first letter of a domain name is capitalized. Similarly, the domain <span class="teletype">Polynomial(Integer)</span> denotes <span class="italic">polynomials with integer coefficients.</span> Also, <span class="teletype">Matrix(Float)</span> denotes <span class="italic">matrices with floating-point entries.</span></p>
Every basic FriCAS object belongs to a unique domain. The integer
3 belongs to the domain <span class="teletype">Integer</span> and the polynomial
x+3 belongs to the domain <span class="teletype">Polynomial(Integer)</span>. The domain of an object is also called its <span class="italic">type</span>. Thus we speak of <span class="italic">the type <span class="teletype">Integer</span></span> and <span class="italic">the type <span class="teletype">Polynomial(Integer)</span>.</span>
<p>After an FriCAS computation, the type is displayed toward the right-hand side of the page (or screen).</p>
<div id="spadComm2-1" class="spadComm">
<span id="commSav2-1" class="commSav">-3</span>
<div id="mathAns2-1">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>-3</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Integer
</div>
<p>Here we create a rational number but it looks like the last result. The type however tells you it is different. You cannot identify the type of an object by how FriCAS displays the object.</p>
<div id="spadComm2-2" class="spadComm">
<span id="commSav2-2" class="commSav">-3/1</span>
<div id="mathAns2-2">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>-3</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Fraction Integer
</div>
<p>When a computation produces a result of a simpler type, FriCAS leaves the type unsimplified. Thus no information is lost.</p>
<div id="spadComm2-3" class="spadComm">
<span id="commSav2-3" class="commSav">x + 3 - x</span>
<div id="mathAns2-3">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>3</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Polynomial Integer
</div>
<p>This seldom matters since FriCAS retracts the answer to the simpler type if it is necessary.</p>
<div id="spadComm2-4" class="spadComm">
<span id="commSav2-4" class="commSav">factorial(%)</span>
<div id="mathAns2-4">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>6</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Expression Integer
</div>
When you issue a positive number, the type <span class="teletype">PositiveInteger</span> is printed. Surely,
3 also has type <span class="teletype">Integer</span>! The curious reader may now have two questions. First, is the type of an object not unique? Second, how is <span class="teletype">PositiveInteger</span> related to <span class="teletype">Integer</span>?
<div id="spadComm2-5" class="spadComm">
<span id="commSav2-5" class="commSav">3</span>
<div id="mathAns2-5">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>3</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: PositiveInteger
</div>
Any domain can be refined to a <span class="italic">subdomain</span> by a membership <span class="teletype">predicate</span>. A <span class="teletype">predicate</span> is a function that, when applied to an object of the domain, returns either <span class="teletype">true</span> or <span class="teletype">false</span>. For example, the domain <span class="teletype">Integer</span> can be refined to the subdomain <span class="teletype">PositiveInteger</span>, the set of integers
x such that
x&gt;0, by giving the FriCAS predicate
x+-&gt;x&gt;0. Similarly, FriCAS can define subdomains such as <span class="italic">the subdomain of diagonal matrices,</span> <span class="italic">the subdomain of lists of length two,</span>
the subdomain of monic irreducible polynomials in
x, and so on. Trivially, any domain is a subdomain of itself.
While an object belongs to a unique domain, it can belong to any number of subdomains. Any subdomain of the domain of an object can be used as the <span class="italic">type</span> of that object. The type of
3 is indeed both <span class="teletype">Integer</span> and <span class="teletype">PositiveInteger</span> as well as any other subdomain of integer whose predicate is satisfied, such as <span class="italic">the prime integers,</span> <span class="italic">the odd positive integers between 3 and 17,</span> and so on.
<span id="subsec-2.1.1"></span>
<div id="subsec-2.1.1" class="subsection">
<h3 class="subsectitle" id="domain-constructors">2.1.1 Domain Constructors</h3>
<span id="ugTypesBasicDomainCons" class="label"></span>
<p>In FriCAS, domains are objects. You can create them, pass them to functions, and, as we'll see later, test them for certain properties.</p>
<p>In FriCAS, you ask for a value of a function by applying its name to a set of arguments.</p>
To ask for
the factorial of
7 you enter this expression to FriCAS. This applies the function <span class="teletype">factorial</span> to the value
7 to compute the result.
<div id="spadComm2-6" class="spadComm">
<span id="commSav2-6" class="commSav">factorial(7)</span>
<div id="mathAns2-6">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>5040</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: PositiveInteger
</div>
<p>Enter the type <span class="teletype">Polynomial (Integer)</span> as an expression to FriCAS. This looks much like a function call as well. It is! The result is appropriately stated to be of type <span class="teletype">Domain</span>, which according to our usual convention, denotes the class of all domains.</p>
<div id="spadComm2-7" class="spadComm">
<span id="commSav2-7" class="commSav">Polynomial(Integer)</span>
<div id="mathAns2-7">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>PolynomialInteger</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Domain
</div>
<p>The most basic operation involving domains is that of building a new domain from a given one. To create the domain of <span class="italic">polynomials over the integers,</span> FriCAS applies the function <span class="teletype">Polynomial</span> to the domain <span class="teletype">Integer</span>. A function like <span class="teletype">Polynomial</span> is called a <span class="italic">domain constructor</span> or, <span class="index">constructor:domain</span><span id="chapter-2-0"></span> more simply, a <span class="italic">constructor</span>. A domain constructor is a function that creates a domain. An argument to a domain constructor can be another domain or, in general, an arbitrary kind of object. <span class="teletype">Polynomial</span> takes a single domain argument while <span class="teletype">SquareMatrix</span> takes a positive integer as an argument to give its dimension and a domain argument to give the type of its components.</p>
<p>What kinds of domains can you use as the argument to <span class="teletype">Polynomial</span> or <span class="teletype">SquareMatrix</span> or <span class="teletype">List</span>? Well, the first two are mathematical in nature. You want to be able to perform algebraic operations like ``<span class="teletype">+</span>'' and <span class="italic"><span class="teletype">*</span></span> on polynomials and square matrices, and operations such as <span style="font-weight: bold;"> determinant</span> on square matrices. So you want to allow polynomials of integers <span class="italic">and</span> polynomials of square matrices with complex number coefficients and, in general, anything that <span class="italic">makes sense.</span> At the same time, you don't want FriCAS to be able to build nonsense domains such as ``polynomials of strings!''</p>
<p>In contrast to algebraic structures, data structures can hold any kind of object. Operations on lists such as <span class="spadfunFrom" style="font-weight: bold;">insert</span><span class="index">insert</span><span id="chapter-2-1"></span><span class="index">List</span><span id="chapter-2-2"></span>, <span class="spadfunFrom" style="font-weight: bold;">delete</span><span class="index">delete</span><span id="chapter-2-3"></span><span class="index">List</span><span id="chapter-2-4"></span>, and <span class="spadfunFrom" style="font-weight: bold;">concat</span><span class="index">concat</span><span id="chapter-2-5"></span><span class="index">List</span><span id="chapter-2-6"></span> just manipulate the list itself without changing or operating on its elements. Thus you can build <span class="teletype">List</span> over almost any datatype, including itself.</p>
<p>Create a complicated algebraic domain.</p>
<div id="spadComm2-8" class="spadComm">
<span id="commSav2-8" class="commSav">List (List (Matrix (Polynomial (Complex (Fraction (Integer))))))</span>
<div id="mathAns2-8">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>ListListMatrixPolynomialComplexFractionInteger</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Domain
</div>
<p>Try to create a meaningless domain.</p>
<div id="spadComm2-9" class="spadComm">
<span id="commSav2-9" class="commSav">Polynomial(String)</span>
<div id="mathAns2-9">

</div>
</div>
<div class="verbatim">
<br />
   Polynomial String is not a valid type.<br />

</div>
<p>Evidently from our last example, FriCAS has some mechanism that tells what a constructor can use as an argument. This brings us to the notion of <span class="italic">category</span>. As domains are objects, they too have a domain. The domain of a domain is a category. A category is simply a type whose members are domains.</p>
A common algebraic category is <span class="teletype">Ring</span>, the class of all domains that are <span class="italic">rings.</span> A ring is an algebraic structure with constants
0 and
1 and operations <span class="spadopFrom" title="Ring">+</span>, <span class="spadopFrom" title="Ring">-</span>, and <span class="spadopFrom" title="Ring">*</span>. These operations are assumed <span class="italic">closed</span> with respect to the domain, meaning that they take two objects of the domain and produce a result object also in the domain. The operations are understood to satisfy certain <span class="italic">axioms,</span> certain mathematical principles providing the algebraic foundation for rings. For example, the <span class="italic">additive inverse axiom</span> for rings states:
<div class="center" style="text-align: center;">
Every element
x has an additive inverse
y such that
x+y=0.
</div>
<p>The prototypical example of a domain that is a ring is the integers. Keep them in mind whenever we mention <span class="teletype">Ring</span>.</p>
Many algebraic domain constructors such as <span class="teletype">Complex</span>, <span class="teletype">Polynomial</span>, <span class="teletype">Fraction</span>, take rings as arguments and return rings as values. You can use the infix operator
has to ask a domain if it belongs to a particular category.
<p>All numerical types are rings. Domain constructor <span class="teletype">Polynomial</span> builds <span class="italic">the ring of polynomials over any other ring.</span></p>
<div id="spadComm2-10" class="spadComm">
<span id="commSav2-10" class="commSav">Polynomial(Integer) has Ring</span>
<div id="mathAns2-10">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>true</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
<p>Constructor <span class="teletype">List</span> never produces a ring.</p>
<div id="spadComm2-11" class="spadComm">
<span id="commSav2-11" class="commSav">List(Integer) has Ring</span>
<div id="mathAns2-11">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>false</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
The constructor <span class="teletype">Matrix(R)</span> builds
the domain of all matrices over the ring
R. This domain is never a ring since the operations ``<span class="teletype">+</span>'', <span class="italic"><span class="teletype">-</span></span>, and <span class="italic"><span class="teletype">*</span></span> on matrices of arbitrary shapes are undefined.
<div id="spadComm2-12" class="spadComm">
<span id="commSav2-12" class="commSav">Matrix(Integer) has Ring</span>
<div id="mathAns2-12">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>false</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
<p>Thus you can never build polynomials over matrices.</p>
<div id="spadComm2-13" class="spadComm">
<span id="commSav2-13" class="commSav">Polynomial(Matrix(Integer))</span>
<div id="mathAns2-13">

</div>
</div>
<div class="verbatim">
<br />
   Polynomial Matrix Integer is not a valid type.<br />

</div>
Use <span class="teletype">SquareMatrix(n,R)</span> instead. For any positive integer
n, it builds
the ring of
n by
n matrices over
R.
<div id="spadComm2-14" class="spadComm">
<span id="commSav2-14" class="commSav">Polynomial(SquareMatrix(7,Complex(Integer)))</span>
<div id="mathAns2-14">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>PolynomialSquareMatrix(7,ComplexInteger)</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Domain
</div>
Another common category is <span class="teletype">Field</span>, the class of all fields. <span class="index">field</span><span id="chapter-2-7"></span> A field is a ring with additional operations. For example, a field has commutative multiplication and a closed operation <span class="spadopFrom" title="Field">/</span> for the division of two elements. <span class="teletype">Integer</span> is not a field since, for example,
3/2 does not have an integer result. The prototypical example of a field is the rational numbers, that is, the domain <span class="teletype">Fraction(Integer)</span>. In general, the constructor <span class="teletype">Fraction</span> takes an IntegralDomain, which is a ring with additional properties, as an argument and returns a field. <span class="footnote">Actually, the argument domain must have some additional so as to belong to the category <span class="teletype">IntegralDomain</span></span> Other domain constructors, such as <span class="teletype">Complex</span>, build fields only if their argument domain is a field.
<p>The complex integers (often called the <span class="italic">Gaussian integers</span>) do not form a field.</p>
<div id="spadComm2-15" class="spadComm">
<span id="commSav2-15" class="commSav">Complex(Integer) has Field</span>
<div id="mathAns2-15">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>false</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
<p>But fractions of complex integers do.</p>
<div id="spadComm2-16" class="spadComm">
<span id="commSav2-16" class="commSav">Fraction(Complex(Integer)) has Field</span>
<div id="mathAns2-16">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>true</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
<p>The algebraically equivalent domain of complex rational numbers is a field since domain constructor <span class="teletype">Complex</span> produces a field whenever its argument is a field.</p>
<div id="spadComm2-17" class="spadComm">
<span id="commSav2-17" class="commSav">Complex(Fraction(Integer)) has Field</span>
<div id="mathAns2-17">

</div>
</div>
<div class="math">
<table>
<tbody>
<tr class="odd">
<td>true</td>
</tr>
</tbody>
</table>
</div>
<div class="returnType">
Type: Boolean
</div>
The most basic category is <span class="teletype">Type</span>. <span class="index">Type</span><span id="chapter-2-8"></span> It denotes the class of all domains and subdomains. Note carefully that <span class="teletype">Type</span> does not denote the class of all types. The type of all categories is <span class="teletype">Category</span>. The type of <span class="teletype">Type</span> itself is undefined. Domain constructor <span class="teletype">List</span> is able to build
lists of elements from domain
D for arbitrary
D simply by requiring that
D belong to category <span class="teletype">Type</span>.
<p>Now, you may ask, what exactly is a category? <span class="index">category</span><span id="chapter-2-9"></span> Like domains, categories can be defined in the FriCAS language. A category is defined by three components:</p>
<ol>
<li>a name (for example, <span class="teletype">Ring</span>), used to refer to the class of domains that the category represents;</li>
<li>a set of operations, used to refer to the operations that the domains of this class support (for example, ``<span class="teletype">+</span>'', <span class="italic"><span class="teletype">-</span></span>, and <span class="italic"><span class="teletype">*</span></span> for rings); and</li>
<li>an optional list of other categories that this category extends.</li>
</ol>
<p>This last component is a new idea. And it is key to the design of FriCAS! Because categories can extend one another, they form hierarchies. Detailed charts showing the category hierarchies in FriCAS are displayed in Appendix (TPDHERE). There you see that all categories are extensions of <span class="teletype">Type</span> and that <span class="teletype">Field</span> is an extension of <span class="teletype">Ring</span>.</p>
<p>The operations supported by the domains of a category are called the <span style="font-style: italic;"> exports</span> of that category because these are the operations made available for system-wide use. The exports of a domain of a given category are not only the ones explicitly mentioned by the category. Since a category extends other categories, the operations of these other categories---and all categories these other categories extend---are also exported by the domains.</p>
<p>For example, polynomial domains belong to <span class="teletype">PolynomialCategory</span>. This category explicitly mentions some twenty-nine operations on polynomials, but it extends eleven other categories (including <span class="teletype">Ring</span>). As a result, the current system has over one hundred operations on polynomials.</p>
<p>If a domain belongs to a category that extends, say, <span class="teletype">Ring</span>, it is convenient to say that the domain exports <span class="teletype">Ring</span>. The name of the category thus provides a convenient shorthand for the list of operations exported by the category. Rather than listing operations such as <span class="spadopFrom" title="Ring">+</span> and <span class="spadopFrom" title="Ring">*</span> of <span class="teletype">Ring</span> each time they are needed, the definition of a type simply asserts that it exports category <span class="teletype">Ring</span>.</p>
<p>The category name, however, is more than a shorthand. The name <span class="teletype">Ring</span>, in fact, implies that the operations exported by rings are required to satisfy a set of <span class="italic">axioms</span> associated with the name <span class="teletype">Ring</span>. This subtle but important feature distinguishes FriCAS from other abstract datatype designs.</p>
Why is it not correct to assume that some type is a ring if it exports all of the operations of <span class="teletype">Ring</span>? Here is why. Some languages such as <span style="font-weight: bold;"> APL</span> <span class="index">APL</span><span id="chapter-2-10"></span> denote the <span class="teletype">Boolean</span> constants <span class="teletype">true</span> and <span class="teletype">false</span> by the integers
1 and
0 respectively, then use ``<span class="teletype">+</span>'' and <span class="italic"><span class="teletype">*</span></span> to denote the logical operators <span style="font-weight: bold;"> or</span> and <span style="font-weight: bold;"> and</span>. But with these definitions <span class="teletype">Boolean</span> is not a ring since the additive inverse axiom is violated. That is, there is no inverse element
a such that
1+a=0, or, in the usual terms: <span class="teletype">true or a = false</span>. This alternative definition of <span class="teletype">Boolean</span> can be easily and correctly implemented in FriCAS, since <span class="teletype">Boolean</span> simply does not assert that it is of category <span class="teletype">Ring</span>. This prevents the system from building meaningless domains such as <span class="teletype">Polynomial(Boolean)</span> and then wrongfully applying algorithms that presume that the ring axioms hold.
<p>Enough on categories. To learn more about them, see Chapter <a href="section-12.0.xhtml#ugCategories" class="ref">ugCategories</a> . We now return to our discussion of domains.</p>
<p>Domains <span class="italic">export</span> a set of operations to make them available for system-wide use. <span class="teletype">Integer</span>, for example, exports the operations <span class="spadopFrom" title="Integer">+</span> and <span class="spadopFrom" title="Integer">=</span> given by the signatures <span class="spadopFrom" title="Integer">+</span>: (Integer,Integer)-&gt;Integer and <span class="spadopFrom" title="Integer">=</span>: (Integer,Integer)-&gt;Boolean, respectively. Each of these operations takes two <span class="teletype">Integer</span> arguments. The <span class="spadopFrom" title="Integer">+</span> operation also returns an <span class="teletype">Integer</span> but <span class="spadopFrom" title="Integer">=</span> returns a <span class="teletype">Boolean</span>: <span class="teletype">true</span> or <span class="teletype">false</span>. The operations exported by a domain usually manipulate objects of the domain---but not always.</p>
<p>The operations of a domain may actually take as arguments, and return as values, objects from any domain. For example, <span class="teletype">Fraction (Integer)</span> exports the operations <span class="spadopFrom" title="Fraction">/</span>: (Integer,Integer)-&gt;Fraction(Integer) and <span class="spadfunFrom" style="font-weight: bold;">characteristic</span><span class="index">characteristic</span><span id="chapter-2-11"></span><span class="index">Fraction</span><span id="chapter-2-12"></span>: -&gt;NonNegativeInteger.</p>
<p>Suppose all operations of a domain take as arguments and return as values, only objects from <span class="italic">other</span> domains. <span class="index">package</span><span id="chapter-2-13"></span> This kind of domain <span class="index">constructor:package</span><span id="chapter-2-14"></span> is what FriCAS calls a <span class="italic">package</span>.</p>
A package does not designate a class of objects at all. Rather, a package is just a collection of operations. Actually the bulk of the FriCAS library of algorithms consists of packages. The facilities for factorization; integration; solution of linear, polynomial, and differential equations; computation of limits; and so on, are all defined in packages. Domains needed by algorithms can be passed to a package as arguments or used by name if they are not <span class="italic">variable.</span> Packages are useful for defining operations that convert objects of one type to another, particularly when these types have different parameterizations. As an example, the package <span class="teletype">PolynomialFunction2(R,S)</span> defines operations that convert polynomials over a domain
R to polynomials over
S. To convert an object from <span class="teletype">Polynomial(Integer)</span> to <span class="teletype">Polynomial(Float)</span>, FriCAS builds the package <span class="teletype">PolynomialFunctions2(Integer,Float)</span> in order to create the required conversion function. (This happens <span class="italic">behind the scenes</span> for you: see <a href="section-2.7.xhtml#ugTypesConvert" class="ref">ugTypesConvert</a> for details on how to convert objects.)
<p>FriCAS categories, domains and packages and all their contained functions are written in the FriCAS programming language and have been compiled into machine code. This is what comprises the FriCAS <span class="italic">library</span>. We will show you how to use these domains and their functions and how to write your own functions.</p>
</div>
</section>
<a href="book-contents.xhtml">Book Contents</a> <a href="section-2.0.xhtml">Previous Section 2.0 Using Types and Modes</a><a href="section-2.2.xhtml">Next Section 2.2 Writing Types and Modes</a> <a href="book-index.xhtml">Book Index</a>
</body>
</html>
