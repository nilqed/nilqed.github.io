PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS "olibdb" (
	"kind"	TEXT,
	"name"	TEXT,
	"nargs"	INTEGER,
	"exposed"	TEXT,
	"type"	TEXT,
	"params"	TEXT,
	"abbrev"	TEXT,
	"comment"	TEXT
);
INSERT INTO olibdb VALUES('c','AbelianGroup',0,'x','()->Category',NULL,'ABELGRP','The class of abelian groups,{} \spadignore{i.e.} additive monoids where each element has an additive inverse. \blankline');
INSERT INTO olibdb VALUES('c','AbelianMonoid',0,'x','()->Category',NULL,'ABELMON','The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with an additive identity element. \blankline');
INSERT INTO olibdb VALUES('c','AbelianMonoidRing',2,'x','(Join(SemiRng,etc),OrderedAbelianMonoid)->Category','(R,E)','AMR','Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficients and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} but in general do not commute with the coefficients (which themselves may or may not be commutative). See \spadtype{FiniteAbelianMonoidRing} for the case of finite support. A useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on.');
INSERT INTO olibdb VALUES('c','AbelianProductCategory',1,'n','(Type)->Category','(A)','APRODC','This category represents products with coordinatewise additive operations.');
INSERT INTO olibdb VALUES('c','AbelianSemiGroup',0,'x','()->Category',NULL,'ABELSG','the class of all additive (commutative) semigroups,{} \spadignore{i.e.} a set with a commutative and associative operation \spadop{+}. \blankline');
INSERT INTO olibdb VALUES('c','additiveValuation',0,'n','()->Category',NULL,'ATADDVA','The class of all euclidean domains such that \spad{euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}.');
INSERT INTO olibdb VALUES('c','Aggregate',0,'x','()->Category',NULL,'AGG','The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogeneous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as the set of \spad{x} satisfying relation {\em r(x)}. An attribute \spadtype{finiteAggregate} is used to assert that a domain has a finite number of elements.');
INSERT INTO olibdb VALUES('c','Algebra',1,'x','(CommutativeRing)->Category','(R)','ALGEBRA','The category of associative algebras (modules which are themselves rings). \blankline');
INSERT INTO olibdb VALUES('c','AlgebraicallyClosedField',0,'x','()->Category',NULL,'ACF','Model for algebraically closed fields.');
INSERT INTO olibdb VALUES('c','AlgebraicallyClosedFunctionSpace',1,'x','(Join(Comparable,etc))->Category','(R)','ACFS','Model for algebraically closed function spaces.');
INSERT INTO olibdb VALUES('c','Approximate',0,'n','()->Category',NULL,'ATAPPRO','An approximation to the real numbers.');
INSERT INTO olibdb VALUES('c','arbitraryExponent',0,'n','()->Category',NULL,'ATARBEX','Approximate numbers with arbitrarily large exponents');
INSERT INTO olibdb VALUES('c','arbitraryPrecision',0,'n','()->Category',NULL,'ATARBPR','Approximate numbers for which the user can set the precision for subsequent calculations.');
INSERT INTO olibdb VALUES('c','ArcHyperbolicFunctionCategory',0,'x','()->Category',NULL,'AHYP','Category for the inverse hyperbolic trigonometric functions.');
INSERT INTO olibdb VALUES('c','ArcTrigonometricFunctionCategory',0,'x','()->Category',NULL,'ATRIG','Category for the inverse trigonometric functions.');
INSERT INTO olibdb VALUES('c','AssociationListAggregate',2,'x','(SetCategory,Type)->Category','(Key,Entry)','ALAGG','An association list is a list of key entry pairs which may be viewed as a table. It is a poor mans version of a table: searching for a key is a linear operation.');
INSERT INTO olibdb VALUES('c','BagAggregate',1,'x','(Type)->Category','(S)','BGAGG','A bag aggregate is an aggregate for which one can insert and extract objects,{} and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks,{} queues,{} and dequeues.');
INSERT INTO olibdb VALUES('c','BasicType',0,'x','()->Category',NULL,'BASTYPE','\spadtype{BasicType} is the basic category for describing a collection of elements with \spadop{=} (equality).');
INSERT INTO olibdb VALUES('c','Bialgebra',2,'x','(R:CommutativeRing,Module(R))->Category','(R,MxM)','BIALG','A bialgebra is a coalgebra which at the same time is an algebra such that the comultiplication is also an algebra homomorphism. MxM: Module(\spad{R}) should be replaced by a more restricted category,{} but it is not clear at this point which one.');
INSERT INTO olibdb VALUES('c','BiCPO',1,'n','(SetCategory)->Category','(S)','BICPO','Complete partial Order,{} partial order that is guaranteed to have both a join and a meet of any two elements. For more documentation see: \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','BiModule',2,'x','(SemiRng,SemiRng)->Category','(R,S)','BMODULE','A \spadtype{BiModule} is both a left and right module with respect to potentially different rings. \blankline');
INSERT INTO olibdb VALUES('c','BinaryRecursiveAggregate',1,'x','(Type)->Category','(S)','BRAGG','A binary-recursive aggregate has 0,{} 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure');
INSERT INTO olibdb VALUES('c','BinaryTreeCategory',1,'x','(SetCategory)->Category','(S)','BTCAT','\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or has a \spadfun{node} consisting of a value and a \spadfun{left} and \spadfun{right} which are both binary trees.');
INSERT INTO olibdb VALUES('c','BitAggregate',0,'x','()->Category',NULL,'BTAGG','The bit aggregate category models aggregates representing large quantities of Boolean data.');
INSERT INTO olibdb VALUES('c','BoundedDistributiveLattice',0,'n','()->Category',NULL,'BDISTL','not every lattice is distributive so treat this \indented{13}{as a separate case} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','BoundedJoinSemilattice',0,'n','()->Category',NULL,'BJOIN','join semilattice with bottom \indented{2}{Different from exterior Grassmann product operator as} \indented{2}{that anticommutes.} \indented{2}{need to check precedence when used as an infix operator} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','BoundedLattice',0,'n','()->Category',NULL,'BLAT','lattice with top and bottom \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','BoundedMeetSemilattice',0,'n','()->Category',NULL,'BMEET','meet semilattice with top \indented{2}{Implementations in set,{} logic and orders} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','CachableSet',0,'x','()->Category',NULL,'CACHSET','A cachable set is a set whose elements keep an integer as part of their structure.');
INSERT INTO olibdb VALUES('c','CancellationAbelianMonoid',0,'x','()->Category',NULL,'CABMON','This is an \spadtype{AbelianMonoid} with the cancellation property,{} \spadignore{i.e.} \spad{ a+b = a+c => b=c }. This is formalised by the partial subtraction operator,{} which satisfies the axioms listed below: \blankline');
INSERT INTO olibdb VALUES('c','Canonical',0,'n','()->Category',NULL,'ATCANON','The class of all domains which have canonical representation,{} that is if mathematically equal elements have the same data structures.');
INSERT INTO olibdb VALUES('c','canonicalsClosed',0,'n','()->Category',NULL,'ATCANCL','The class of all integral domains such that \spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.');
INSERT INTO olibdb VALUES('c','canonicalUnitNormal',0,'n','()->Category',NULL,'ATCUNOR','The class of all integral domains such that we can choose a canonical representative for each class of associate elements,{} that is \spad{associates?(a,{} b)} returns \spad{true} if and only if \spad{unitCanonical(a) = unitCanonical(b)}.');
INSERT INTO olibdb VALUES('c','CharacteristicNonZero',0,'x','()->Category',NULL,'CHARNZ','Rings of Characteristic Non Zero');
INSERT INTO olibdb VALUES('c','CharacteristicZero',0,'x','()->Category',NULL,'CHARZ','Rings of Characteristic Zero.');
INSERT INTO olibdb VALUES('c','Coalgebra',2,'x','(R:CommutativeRing,Module(R))->Category','(R,MxM)','COALG','A coalgebra A over a ring is an \spad{R}-module with a coassociative comultiplication from A to the tensor product of A with itself and which possesses a counit.');
INSERT INTO olibdb VALUES('c','CoDcpo',1,'n','(SetCategory)->Category','(S)','CODCPO','Directed-complete Order,{} partial order that is guaranteed to have a meet of any two elements. For more documentation see: \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','CoercibleFrom',1,'n','(Type)->Category','(S)','KOERCEF','A is coercible to \spad{B} means any element of A can automatically be converted into an element of \spad{B} by the interpreter.');
INSERT INTO olibdb VALUES('c','CoercibleTo',1,'x','(Type)->Category','(S)','KOERCE','A is coercible to \spad{B} means any element of A can automatically be converted into an element of \spad{B} by the interpreter.');
INSERT INTO olibdb VALUES('c','Collection',1,'x','(Type)->Category','(S)','CLAGG','A collection is a homogeneous aggregate which can be built from a list of members. The operation used to build the aggregate is generically named \spadfun{construct}. However,{} each collection provides its own special function with the same name as the data type,{} except with an initial lower case letter,{} \spadignore{e.g.} \spadfun{list} for \spadtype{List},{} \spadfun{flexibleArray} for \spadtype{FlexibleArray},{} and so on.');
INSERT INTO olibdb VALUES('c','CombinatorialFunctionCategory',0,'x','()->Category',NULL,'CFCAT','Category for the usual combinatorial functions.');
INSERT INTO olibdb VALUES('c','CombinatorialOpsCategory',0,'x','()->Category',NULL,'COMBOPC','CombinatorialOpsCategory is the category obtaining by adjoining summations and products to the usual combinatorial operations.');
INSERT INTO olibdb VALUES('c','CommutativeRing',0,'x','()->Category',NULL,'COMRING','The category of commutative rings with unity,{} \spadignore{i.e.} rings where \spadop{*} is commutative,{} and which have a multiplicative identity. element.');
INSERT INTO olibdb VALUES('c','CommutativeStar',0,'n','()->Category',NULL,'ATCS','The class of all commutative semigroups in multiplicative notation. In other words domains \spad{D} with \spad{*: (D,{} D) -> D} which is commutative. Typically applied to rings.');
INSERT INTO olibdb VALUES('c','Comparable',0,'n','()->Category',NULL,'COMPAR','The class of sets equipped with possibly unnatural linear order (needed for technical reasons).');
INSERT INTO olibdb VALUES('c','ComplexCategory',1,'x','(CommutativeRing)->Category','(R)','COMPCAT','This category represents the extension of a ring by a square root of \spad{-1}.');
INSERT INTO olibdb VALUES('c','ConvertibleFrom',1,'n','(Type)->Category','(S)','KONVERF','A is convertible to \spad{B} means any element of A can be converted into an element of \spad{B},{} but not automatically by the interpreter.');
INSERT INTO olibdb VALUES('c','ConvertibleTo',1,'x','(Type)->Category','(S)','KONVERT','A is convertible to \spad{B} means any element of A can be converted into an element of \spad{B},{} but not automatically by the interpreter.');
INSERT INTO olibdb VALUES('c','Dcpo',1,'n','(SetCategory)->Category','(S)','DCPO','Directed-complete partial order,{} partial order that is guaranteed to have a join of any two elements. For more documentation see: \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','DequeueAggregate',1,'x','(Type)->Category','(S)','DQAGG','A dequeue is a doubly ended stack,{} that is,{} a bag where first items inserted are the first items extracted,{} at either the front or the back end of the data structure.');
INSERT INTO olibdb VALUES('c','Dictionary',1,'x','(Type)->Category','(S)','DIAGG','A dictionary is an aggregate in which entries can be inserted,{} searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones.');
INSERT INTO olibdb VALUES('c','DictionaryOperations',1,'x','(Type)->Category','(S)','DIOPS','This category is a collection of operations common to both categories \spadtype{Dictionary} and \spadtype{MultiDictionary}');
INSERT INTO olibdb VALUES('c','DifferentialExtension',1,'x','(Ring)->Category','(R)','DIFEXT','Differential extensions of a ring \spad{R}. Given a differentiation on \spad{R},{} extend it to a differentiation on \%.');
INSERT INTO olibdb VALUES('c','DifferentialPolynomialCategory',4,'x','(Ring,S:OrderedSet,DifferentialVariableCategory(S),OrderedAbelianMonoidSup)->Category','(R,S,V,E)','DPOLCAT','\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition,{} it implements defaults for the basic functions. The functions \spadfun{order} and \spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \spadfun{leader},{} \spadfun{initial},{} \spadfun{separant},{} \spadfun{differentialVariables},{} and \spadfun{isobaric?}. Furthermore,{} if the ground ring is a differential ring,{} then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \spadfun{makeVariable}. \blankline To construct a domain using this constructor,{} one needs to provide a ground ring \spad{R},{} an ordered set \spad{S} of differential indeterminates,{} a ranking \spad{V} on the set of derivatives of the differential indeterminates,{} and a set \spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates. \blankline');
INSERT INTO olibdb VALUES('c','DifferentialRing',0,'x','()->Category',NULL,'DIFRING','An ordinary differential ring,{} that is,{} a ring with an operation \spadfun{differentiate}. \blankline');
INSERT INTO olibdb VALUES('c','DifferentialVariableCategory',1,'x','(OrderedSet)->Category','(S)','DVARCAT','\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If \spad{x},{} ...,{} \spad{y} is an ordered set of differential indeterminates,{} and the prime notation is used for differentiation,{} then the set of derivatives (including zero-th order) of the differential indeterminates is \spad{x},{} \spad{x''},{} \spad{x''''},{} ...,{} \spad{y},{} \spad{y''},{} \spad{y''''},{} ... (Note: in the interpreter,{} the \spad{n}-th derivative of \spad{y} is displayed as \spad{y} with a subscript \spad{n}.) This set is viewed as a set of algebraic indeterminates,{} totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives,{} and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates,{} just as one associates a domain in the category \spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \spadfun{<}. For example,{} one may define one derivative to be less than another by lexicographically comparing first the \spadfun{order},{} then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates,{} Very often,{} a grading is the first step in ordering the set of monomials. For differential polynomial domains,{} this constructor provides a function \spadfun{weight},{} which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example,{} one may define the weight of a derivative to be simply its \spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials,{} providing a graded ring structure.');
INSERT INTO olibdb VALUES('c','DirectProductCategory',2,'x','(NonNegativeInteger,Type)->Category','(dim,R)','DIRPCAT','\indented{2}{This category represents a finite cartesian product of a given type.} Many categorical properties are preserved under this construction.');
INSERT INTO olibdb VALUES('c','DistributionCategory',1,'n','(CommutativeRing)->Category','(R)','DISTCAT','Category of distributions formally given by moments.');
INSERT INTO olibdb VALUES('c','DistributiveLattice',0,'n','()->Category',NULL,'DISTLAT','not every lattice is distributive so treat this \indented{13}{as a separate case} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','DivisionRing',0,'x','()->Category',NULL,'DIVRING','A division ring (sometimes called a skew field),{} \spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.');
INSERT INTO olibdb VALUES('c','DoublyLinkedAggregate',1,'x','(Type)->Category','(S)','DLAGG','A doubly-linked aggregate serves as a model for a doubly-linked list,{} that is,{} a list which has links to both next and previous nodes and thus can be efficiently traversed in both directions.');
INSERT INTO olibdb VALUES('c','ElementaryFunctionCategory',0,'x','()->Category',NULL,'ELEMFUN','Category for the elementary functions.');
INSERT INTO olibdb VALUES('c','Eltable',2,'x','(Type,Type)->Category','(D,I)','ELTAB','An eltable over domains \spad{D} and \spad{I} is a structure which can be viewed as a function from \spad{D} to \spad{I}. Examples of eltable structures range from data structures,{} \spadignore{e.g.} those of type \spadtype{List},{} to algebraic structures,{} \spadignore{e.g.} \spadtype{Polynomial}.');
INSERT INTO olibdb VALUES('c','EltableAggregate',2,'x','(Type,Type)->Category','(Dom,Im)','ELTAGG','An eltable aggregate is one which can be viewed as a function. For example,{} the list \spad{[1,{} 7,{} 4]} can be applied to 1,{} 2,{} and 3 respectively and will return the integers 1,{} 7,{} and 4; thus this list may be viewed as mapping 1 to 1,{} 2 to 7 and 3 to 4. In general,{} an aggregate can map members of a domain {\em Dom} to an image domain {\em Im}.');
INSERT INTO olibdb VALUES('c','EntireRing',0,'x','()->Category',NULL,'ENTIRER','Entire Rings (non-commutative Integral Domains),{} \spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \blankline');
INSERT INTO olibdb VALUES('c','EuclideanDomain',0,'x','()->Category',NULL,'EUCDOM','A constructive euclidean domain,{} \spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\spadfun{euclideanSize}) than the divisor. \blankline Conditional attributes: \indented{2}{multiplicativeValuation\tab{25}\spad{Size(a*b)=Size(a)*Size(b)}} \indented{2}{additiveValuation\tab{25}\spad{Size(a*b)=Size(a)+Size(b)}}');
INSERT INTO olibdb VALUES('c','Evalable',1,'x','(SetCategory)->Category','(R)','EVALAB','This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make');
INSERT INTO olibdb VALUES('c','ExpressionSpace',0,'x','()->Category',NULL,'ES',NULL);
INSERT INTO olibdb VALUES('c','ExpressionSpace2',1,'x','(KernelCategory(%))->Category','(K)','ESC2','An expression space is a set which is closed under certain operators.');
INSERT INTO olibdb VALUES('c','ExtensibleLinearAggregate',1,'x','(Type)->Category','(S)','ELAGG','An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists which are represented by linked structures so as to make insertion,{} deletion,{} and concatenation efficient. However,{} access to elements of these extensible aggregates is generally slow since access is made from the end. See \spadtype{FlexibleArray} for an exception.');
INSERT INTO olibdb VALUES('c','ExtensionField',1,'x','(Field)->Category','(F)','XF','ExtensionField {\em F} is the category of fields which extend the field \spad{F}');
INSERT INTO olibdb VALUES('c','FacetCategory',0,'n','()->Category',NULL,'FACTCAT','This is a category to represent different types of facet,{} such as,{} (1) A single simplex (2) A single cubical simplex (3) The product of two facets \blankline');
INSERT INTO olibdb VALUES('c','Field',0,'x','()->Category',NULL,'FIELD','The category of commutative fields,{} \spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \spadfun{factor} operation while trivial is useful to have defined. \blankline');
INSERT INTO olibdb VALUES('c','FieldOfPrimeCharacteristic',0,'x','()->Category',NULL,'FPC','FieldOfPrimeCharacteristic is the category of fields of prime characteristic,{} \spadignore{e.g.} finite fields,{} algebraic closures of fields of prime characteristic,{} transcendental extensions of of fields of prime characteristic.');
INSERT INTO olibdb VALUES('c','FileCategory',2,'x','(SetCategory,SetCategory)->Category','(Name,S)','FILECAT','This category provides an interface to operate on files in the computer\spad{''s} file system. The precise method of naming files is determined by the Name parameter. The type of the contents of the file is determined by \spad{S}.');
INSERT INTO olibdb VALUES('c','FileNameCategory',0,'x','()->Category',NULL,'FNCAT','This category provides an interface to names in the file system.');
INSERT INTO olibdb VALUES('c','Finite',0,'x','()->Category',NULL,'FINITE','The category of domains composed of a finite set of elements. We include the functions \spadfun{lookup} and \spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \blankline');
INSERT INTO olibdb VALUES('c','FiniteAbelianMonoidRing',2,'x','(Join(SemiRng,etc),OrderedAbelianMonoid)->Category','(R,E)','FAMR','This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general.');
INSERT INTO olibdb VALUES('c','finiteAggregate',0,'n','()->Category',NULL,'ATFINAG','The class of all aggregates with a finite number of elements.');
INSERT INTO olibdb VALUES('c','FiniteAlgebraicExtensionField',1,'x','(Field)->Category','(F)','FAXF','FiniteAlgebraicExtensionField {\em F} is the category of fields which are finite algebraic extensions of the field {\em F}. If {\em F} is finite then any finite algebraic extension of {\em F} is finite,{} too. Let {\em K} be a finite algebraic extension of the finite field {\em F}. The exponentiation of elements of {\em K} defines a \spad{Z}-module structure on the multiplicative group of {\em K}. The additive group of {\em K} becomes a module over the ring of polynomials over {\em F} via the operation \spadfun{linearAssociatedExp}(a: \spad{K},{} \spad{f:} SparseUnivariatePolynomial \spad{F}) which is linear over {\em F},{} \spadignore{i.e.} for elements {\em a} from {\em K},{} {\em c,{} d} from {\em F} and {\em f,{} g} univariate polynomials over {\em F} we have \spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\em c} times \spadfun{linearAssociatedExp}(a,{} \spad{f}) plus {\em d} times \spadfun{linearAssociatedExp}(a,{} \spad{g}). Therefore \spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\em F[X]}: \spadfun{linearAssociatedExp}(a,{} monomial(1,{} \spad{k})\spad{\$}SUP(\spad{F})) is defined to be \spadfun{Frobenius}(a,{} \spad{k}) which is {\em a^(q^k)} where {\em q=size()\$F}. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \spadfun{linearAssociatedExp}. These are the functions \spadfun{linearAssociatedOrder} and \spadfun{linearAssociatedLog},{} respectively.');
INSERT INTO olibdb VALUES('c','FiniteDivisorCategory',4,'x','(F:Field,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),FunctionFieldCategory(F,UP,UPUP))->Category','(F,UP,UPUP,R)','FDIVCAT','This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{''s} are integers and the \spad{P}\spad{''s} are finite rational points on the curve.');
INSERT INTO olibdb VALUES('c','FiniteFieldCategory',0,'x','()->Category',NULL,'FFIELDC','FiniteFieldCategory is the category of finite fields');
INSERT INTO olibdb VALUES('c','FiniteGraph',1,'n','(SetCategory)->Category','(S)','FGRPH','Category of finite graphs,{} allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('c','FiniteGroup',0,'n','()->Category',NULL,'FINGRP','The category of finite groups.');
INSERT INTO olibdb VALUES('c','FiniteLinearAggregate',1,'x','(Type)->Category','(S)','FLAGG','A finite linear aggregate is a linear aggregate of finite length.');
INSERT INTO olibdb VALUES('c','FinitelyGenerated',0,'n','()->Category',NULL,'FINGEN','A category for finitely generated structures. Exports a list of generators.');
INSERT INTO olibdb VALUES('c','FiniteRankAlgebra',2,'x','(R:CommutativeRing,UnivariatePolynomialCategory(R))->Category','(R,UP)','FINRALG','A FiniteRankAlgebra is an algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.');
INSERT INTO olibdb VALUES('c','FiniteRankNonAssociativeAlgebra',1,'x','(CommutativeRing)->Category','(R)','FINAALG','A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.');
INSERT INTO olibdb VALUES('c','FiniteSetAggregate',1,'x','(SetCategory)->Category','(S)','FSAGG','A finite-set aggregate models the notion of a finite set,{} that is,{} a collection of elements characterized by membership,{} but not by order or multiplicity. See \spadtype{Set} for an example.');
INSERT INTO olibdb VALUES('c','FloatingPointSystem',0,'x','()->Category',NULL,'FPS','This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact,{} it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \blankline \indented{2}{1: \spadfunFrom{base}{FloatingPointSystem} of the \spadfunFrom{exponent}{FloatingPointSystem}.} \indented{9}{(actual implementations are usually binary or decimal)} \indented{2}{2: \spadfunFrom{precision}{FloatingPointSystem} of the \spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)} \indented{2}{3: rounding error for operations} \blankline Because a Float is an approximation to the real numbers,{} even though it is defined to be a join of a Field and OrderedRing,{} some of the attributes do not hold. In particular associative(\spad{+}) does not hold. Algorithms defined over a field need special considerations when the field is a floating point system.');
INSERT INTO olibdb VALUES('c','FormatterCategory',0,'n','()->Category',NULL,'FMTCAT',NULL);
INSERT INTO olibdb VALUES('c','FortranFunctionCategory',0,'n','()->Category',NULL,'FORTFN','\spadtype{FortranFunctionCategory} is the category of arguments to NAG Library routines which return (sets of) function values.');
INSERT INTO olibdb VALUES('c','FortranMachineTypeCategory',0,'n','()->Category',NULL,'FMTC','A category of domains which model machine arithmetic used by machines in the AXIOM-NAG link.');
INSERT INTO olibdb VALUES('c','FortranMatrixCategory',0,'n','()->Category',NULL,'FMC','\spadtype{FortranMatrixCategory} provides support for producing Functions and Subroutines when the input to these is a FriCAS object of type \spadtype{Matrix} or in domains involving \spadtype{FortranCode}.');
INSERT INTO olibdb VALUES('c','FortranMatrixFunctionCategory',0,'n','()->Category',NULL,'FMFUN','\spadtype{FortranMatrixFunctionCategory} provides support for producing Functions and Subroutines representing matrices of expressions.');
INSERT INTO olibdb VALUES('c','FortranProgramCategory',0,'n','()->Category',NULL,'FORTCAT','\spadtype{FortranProgramCategory} provides various models of FORTRAN subprograms. These can be transformed into actual FORTRAN code.');
INSERT INTO olibdb VALUES('c','FortranVectorCategory',0,'n','()->Category',NULL,'FVC','\spadtype{FortranVectorCategory} provides support for producing Functions and Subroutines when the input to these is a FriCAS object of type \spadtype{Vector} or in domains involving \spadtype{FortranCode}.');
INSERT INTO olibdb VALUES('c','FortranVectorFunctionCategory',0,'n','()->Category',NULL,'FVFUN','\spadtype{FortranVectorFunctionCategory} is the category of arguments to NAG Library routines which return the values of vectors of functions.');
INSERT INTO olibdb VALUES('c','FramedAlgebra',2,'x','(R:CommutativeRing,UnivariatePolynomialCategory(R))->Category','(R,UP)','FRAMALG','A \spadtype{FramedAlgebra} is a \spadtype{FiniteRankAlgebra} together with a fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('c','FramedModule',1,'n','(Join(SemiRng,etc))->Category','(R)','FRMOD','A \spadtype{FramedModule} is a finite rank free module with fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('c','FramedNonAssociativeAlgebra',1,'x','(CommutativeRing)->Category','(R)','FRNAALG','FramedNonAssociativeAlgebra(\spad{R}) is a \spadtype{FiniteRankNonAssociativeAlgebra} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank) over a commutative ring \spad{R} together with a fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('c','FreeLieAlgebra',2,'x','(OrderedSet,CommutativeRing)->Category','(VarSet,R)','FLALG','The category of free Lie algebras. It is used by domains of non-commutative algebra: \spadtype{LiePolynomial} and \spadtype{XPBWPolynomial}. \newline Author: Michel Petitot (petitot@lifl.\spad{fr})');
INSERT INTO olibdb VALUES('c','FreeModuleCategory',2,'x','(Join(SemiRng,etc),SetCategory)->Category','(R,S)','FMCAT','A domain of this category implements formal linear combinations of elements from a domain \spad{Basis} with coefficients in a domain \spad{R}. The domain \spad{Basis} needs only to belong to the category \spadtype{SetCategory} and \spad{R} to the category \spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \spadtype{XDistributedPolynomial} constructor for examples of domains built with the \spadtype{FreeModuleCategory} category constructor. Author: Michel Petitot (petitot@lifl.\spad{fr}) \blankline Note (Franz Lehner,{} June 2009): \spad{FreeModule} originally was not of FreeModuleCategory. Some functions (like \spad{support},{} \spad{coefficients},{} \spad{monomials},{} ...) from here could be moved to \spad{IndexedDirectProductCategory} but at the moment there is no need for this.');
INSERT INTO olibdb VALUES('c','FullyEvalableOver',1,'x','(SetCategory)->Category','(R)','FEVALAB','This category provides a selection of evaluation operations depending on what the argument type \spad{R} provides.');
INSERT INTO olibdb VALUES('c','FullyLinearlyExplicitOver',1,'x','(Ring)->Category','(R)','FLINEXP','\spad{S} is \spadtype{FullyLinearlyExplicitOver R} means that \spad{S} is a \spadtype{LinearlyExplicitOver R} and,{} in addition,{} if \spad{R} is a \spadtype{LinearlyExplicitOver Integer},{} then so is \spad{S}');
INSERT INTO olibdb VALUES('c','FullyPatternMatchable',1,'x','(Type)->Category','(R)','FPATMAB','A set \spad{S} is PatternMatchable over \spad{R} if \spad{S} can lift the pattern-matching functions of \spad{S} over the integers and float to itself (necessary for matching in towers).');
INSERT INTO olibdb VALUES('c','FullyRetractableTo',1,'x','(Type)->Category','(S)','FRETRCT','\indented{2}{A is fully retractable to \spad{B} means that A is retractable to \spad{B},{} and,{}} \indented{2}{in addition,{} if \spad{B} is retractable to the integers or rational} \indented{2}{numbers then so is A.} \indented{2}{In particular,{} what we are asserting is that there are no integers} \indented{2}{(rationals) in A which don\spad{''t} retract into \spad{B}.} Date Created: March 1990');
INSERT INTO olibdb VALUES('c','FunctionFieldCategory',3,'x','(F:UniqueFactorizationDomain,UP:UnivariatePolynomialCategory(F),UnivariatePolynomialCategory(Fraction(UP)))->Category','(F,UP,UPUP)','FFCAT','This category is a model for the function field of a plane algebraic curve.');
INSERT INTO olibdb VALUES('c','FunctionSpace',1,'x','(Comparable)->Category','(R)','FS',NULL);
INSERT INTO olibdb VALUES('c','FunctionSpace2',2,'x','(Comparable,KernelCategory(%))->Category','(R,K)','FSC2','A space of formal functions with arguments in an arbitrary ordered set.');
INSERT INTO olibdb VALUES('c','GcdDomain',0,'x','()->Category',NULL,'GCDDOM','This category describes domains where \spadfun{\spad{gcd}} can be computed but where there is no guarantee of the existence of \spadfun{factor} operation for factorization into irreducibles. However,{} if such a \spadfun{factor} operation exist,{} factorization will be unique up to order and units.');
INSERT INTO olibdb VALUES('c','GradedAlgebra',2,'x','(CommutativeRing,AbelianMonoid)->Category','(R,E)','GRALG','GradedAlgebra(\spad{R},{} \spad{E}) denotes');
INSERT INTO olibdb VALUES('c','GradedModule',2,'x','(CommutativeRing,AbelianMonoid)->Category','(R,E)','GRMOD','GradedModule(\spad{R},{} \spad{E}) denotes');
INSERT INTO olibdb VALUES('c','Group',0,'x','()->Category',NULL,'GROUP','The class of multiplicative groups,{} \spadignore{i.e.} monoids with multiplicative inverses. \blankline');
INSERT INTO olibdb VALUES('c','Hashable',0,'n','()->Category',NULL,'HASHABL','All domains for which we can compute hash function \indented{1}{compatible with equality.}');
INSERT INTO olibdb VALUES('c','HomogeneousAggregate',1,'x','(Type)->Category','(S)','HOAGG','A homogeneous aggregate is an aggregate of elements all of the same type. In the current system,{} all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \spadtype{finiteAggregate} have a finite number of members. Of course,{} such a domain may have an infinite number of elements,{} like,{} for example \spadtype{List}. Those domains with attribute \spadtype{shallowlyMutable} allow an element to be modified or updated without changing its overall value.');
INSERT INTO olibdb VALUES('c','HopfAlgebra',2,'x','(R:CommutativeRing,Module(R))->Category','(R,MxM)','HOPFALG','A Hopf algebra is a bialgebra with antipode.');
INSERT INTO olibdb VALUES('c','HyperbolicFunctionCategory',0,'x','()->Category',NULL,'HYPCAT','Category for the hyperbolic trigonometric functions.');
INSERT INTO olibdb VALUES('c','IndexedAggregate',2,'x','(Type,Type)->Category','(Index,Entry)','IXAGG','An indexed aggregate is a many-to-one mapping of indices to entries. For example,{} a one-dimensional-array is an indexed aggregate where the index is an integer. Also,{} a table is an indexed aggregate where the indices and entries may have any type.');
INSERT INTO olibdb VALUES('c','IndexedDirectProductCategory',2,'x','(SetCategory,SetCategory)->Category','(A,S)','IDPC','This category represents the direct product of some set with respect to an ordered indexing set. The ordered set \spad{S} is considered as the');
INSERT INTO olibdb VALUES('c','IndexedProductCategory',2,'n','(SetCategory,SetCategory)->Category','(A,S)','IPC','This category represents the product of some set with respect to an indexing set. The set \spad{S} is considered as the');
INSERT INTO olibdb VALUES('c','InnerEvalable',2,'x','(SetCategory,Type)->Category','(A,B)','IEVALAB','This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make');
INSERT INTO olibdb VALUES('c','IntegerNumberSystem',0,'x','()->Category',NULL,'INS','An \spad{IntegerNumberSystem} is a model for the integers.');
INSERT INTO olibdb VALUES('c','IntegralDomain',0,'x','()->Category',NULL,'INTDOM','The category of commutative integral domains,{} \spadignore{i.e.} commutative rings with no zero divisors. \blankline');
INSERT INTO olibdb VALUES('c','IntervalCategory',1,'x','(Join(FloatingPointSystem,etc))->Category','(R)','INTCAT','\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: This category implements of interval arithmetic and + transcendental functions over intervals.');
INSERT INTO olibdb VALUES('c','JetBundleBaseFunctionCategory',1,'n','(JetBundleCategory)->Category','(JB)','JBBFC','\spadtype{JetBundleBaseFunctionCategory} defines the category of functions (local sections) of the base space of a jet bundle,{} \spadignore{i.e.} functions depending only on the independent variables. Such a category is needed \spadignore{e.g.} for the representation of solutions.');
INSERT INTO olibdb VALUES('c','JetBundleCategory',0,'n','()->Category',NULL,'JBC','\spadtype{JetBundleCategory} provides basic data structures and procedures for jet bundles. Nearly all necessary functions are implemented already here. Only the representation and functions which directly access it must be implemented in a domain. Two notations of derivatives are supported. Default is multi-index notation,{} where the \spad{i}-th entry of the index denotes the number of differentiations taken with respect to \spad{x^i}. In repeated index notation each entry \spad{i} in the index denotes a differentiation with respect to \spad{x^i}. The choice affects,{} however,{} only in- and output. Internally,{} multi-index notation is used throughout.');
INSERT INTO olibdb VALUES('c','JetBundleFunctionCategory',1,'n','(JetBundleCategory)->Category','(JB)','JBFC','\spadtype{JetBundleFunctionCategory} defines the category of functions (local sections) over a jet bundle. The formal derivative is defined already here. It uses the Jacobi matrix of the functions. The columns of the matrices are enumerated by jet variables. Thus they are represented as a \spadtype{Record} of the matrix and a list of the jet variables. Several simplification routines are implemented already here.');
INSERT INTO olibdb VALUES('c','JoinSemilattice',0,'n','()->Category',NULL,'JOINLAT','join semilattice \indented{2}{Different from exterior Grassmann product operator as} \indented{2}{that anticommutes.} \indented{2}{need to check precedence when used as an infix operator} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','KernelCategory',1,'n','(Comparable)->Category','(S)','KERCAT','A kernel over a set \spad{S} is an operator applied to a given list of arguments from \spad{S}.');
INSERT INTO olibdb VALUES('c','KeyedDictionary',2,'x','(Type,Type)->Category','(Key,Entry)','KDAGG','A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key.');
INSERT INTO olibdb VALUES('c','Lattice',0,'n','()->Category',NULL,'LAT','lattice \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','lazyRepresentation',0,'n','()->Category',NULL,'ATLR','The class of all domains which have have lazy representation.');
INSERT INTO olibdb VALUES('c','LazyStreamAggregate',1,'x','(Type)->Category','(S)','LZSTAGG','LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function ''empty?'' will cause lazy evaluation if necessary to determine if there are entries. Functions which call ''empty?'',{} \spadignore{e.g.} ''first'' and ''rest'',{} will also cause lazy evaluation if necessary. Elements of LazyStreamAggregate are computed only when strictly needed. Lazy computation means that potential errors are delayed,{} so errors are detected later than in case of normal (eager) evaluation used by other aggregates. In some cases computation that would signal error when using eager evaluation can succeed when using lazy evaluation.');
INSERT INTO olibdb VALUES('c','LeftAlgebra',1,'x','(Ring)->Category','(R)','LALG','The category of all left algebras over an arbitrary ring.');
INSERT INTO olibdb VALUES('c','LeftModule',1,'x','(SemiRng)->Category','(R)','LMODULE','The category of left modules over an \spad{rng} (ring not necessarily with unit). This is an abelian group which supports left multiplication by elements of the \spad{rng}. \blankline');
INSERT INTO olibdb VALUES('c','LeftOreRing',0,'n','()->Category',NULL,'LORER','This is category of left ore rings,{} that is noncommutaive rings without zero divisors where we can compute least left common multiple');
INSERT INTO olibdb VALUES('c','LieAlgebra',1,'x','(CommutativeRing)->Category','(R)','LIECAT','The category of Lie Algebras. It is used by the following domains of non-commutative algebra: \spadtype{LiePolynomial} and \spadtype{XPBWPolynomial}. \newline Author : Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('c','LinearAggregate',1,'x','(Type)->Category','(S)','LNAGG','A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings,{} lists,{} and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example,{} \spadfun{concat} of two lists needs only to copy its first argument,{} whereas \spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\spadignore{e.g.} streams) as well to finite ones. If the aggregate is a finite aggregate then it has several additional exports such as \spadfun{reverse},{} \spadfun{sort},{} and so on.');
INSERT INTO olibdb VALUES('c','LinearlyExplicitOver',1,'x','(Ring)->Category','(R)','LINEXP','An extension ring with an explicit linear dependence test.');
INSERT INTO olibdb VALUES('c','LinearOrdinaryDifferentialOperatorCategory',1,'x','(Ring)->Category','(A)','LODOCAT','\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}');
INSERT INTO olibdb VALUES('c','LiouvillianFunctionCategory',0,'x','()->Category',NULL,'LFCAT','Category for the transcendental Liouvillian functions.');
INSERT INTO olibdb VALUES('c','ListAggregate',1,'x','(Type)->Category','(S)','LSAGG','A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation.');
INSERT INTO olibdb VALUES('c','Logic',0,'x','()->Category',NULL,'LOGIC','''Logic'' adds ''not'' operation to lattices,{} Implements De Morgan\spad{''s} laws.');
INSERT INTO olibdb VALUES('c','Magma',0,'x','()->Category',NULL,'MAGMA','Magma is the class of all multiplicative magmas,{} \spadignore{i.e.} sets with a binary operation.');
INSERT INTO olibdb VALUES('c','MagmaWithUnit',0,'x','()->Category',NULL,'MAGMAWU','\indented{1}{MagmaWithUnit is the class of multiplicative monads with unit,{}} \indented{1}{\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \indented{3}{leftIdentity(*:(\%,{}\%)\spad{->}\%,{}1)\space{3}\tab{30} 1*x=x} \indented{3}{rightIdentity(*:(\%,{}\%)\spad{->}\%,{}1)\space{2}\tab{30} x*1=x} Common Additional Axioms \indented{3}{unitsKnown---if recip says failed,{} that PROVES input wasn\spad{''t} a unit}');
INSERT INTO olibdb VALUES('c','MatrixCategory',3,'x','(R:AbelianMonoid,FiniteLinearAggregate(R),FiniteLinearAggregate(R))->Category','(R,Row,Col)','MATCAT','\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the ''first'' row may be obtained by calling the function \spadfun{minRowIndex}. The index of the ''first'' column may be obtained by calling the function \spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.');
INSERT INTO olibdb VALUES('c','MaybeSkewPolynomialCategory',3,'n','(Join(SemiRng,etc),OrderedAbelianMonoidSup,OrderedSet)->Category','(R,E,VarSet)','GPOLCAT','The category for general multi-variate possibly skew polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}.');
INSERT INTO olibdb VALUES('c','MeetSemilattice',0,'n','()->Category',NULL,'MEETLAT','meet semilattice \indented{2}{Implementations in set,{} logic and orders} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','ModularAlgebraicGcdOperations',3,'n','(Type,Type,Type)->Category','(MP,MPT,MD)','MAGCDOC','This category specifies operations needed by \indented{1}{ModularAlgebraicGcd package.\space{2}Since we have multiple} \indented{1}{implementations we specify interface here and put} \indented{1}{implementations in separate packages.\space{2}Most operations} \indented{1}{are done using special purpose abstract representation.} \indented{1}{Appropriate types are passed as parameters: \spad{MPT} is type} \indented{1}{of modular polynomials in one variable with coefficients} \indented{1}{in some algebraic extension.\space{2}\spad{MD} is type of modulus.} \indented{1}{Final results are converted to packed representation,{}} \indented{1}{with coefficients (from prime field) stored in one} \indented{1}{array and exponents (in main variable and in auxiliary} \indented{1}{variables representing generators of algebrac extension)} \indented{1}{stored in parallel array.}');
INSERT INTO olibdb VALUES('c','ModularEvaluationCategory',2,'n','(Type,Type)->Category','(PT,MP)','MEVCAT','ModularEvaluationCategory(\spad{PT},{} \spad{MP}) defines interface \indented{1}{to evaluation functions for \spad{ModularAlgebraicGcd2}.}');
INSERT INTO olibdb VALUES('c','ModularFactorizationOperations',4,'n','(Type,Type,Type,Type)->Category','(PA,MMT,MD,PMD)','MFOPC','This category specifies operations needed by \indented{1}{univariate factorization over finite fields}');
INSERT INTO olibdb VALUES('c','Module',1,'x','(CommutativeRing)->Category','(R)','MODULE','The category of modules over a commutative ring. \blankline');
INSERT INTO olibdb VALUES('c','MonogenicAlgebra',2,'x','(R:CommutativeRing,UnivariatePolynomialCategory(R))->Category','(R,UP)','MONOGEN','A \spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.');
INSERT INTO olibdb VALUES('c','Monoid',0,'x','()->Category',NULL,'MONOID','The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with a multiplicative identity element. \blankline');
INSERT INTO olibdb VALUES('c','MonoidRingCategory',2,'x','(Ring,Monoid)->Category','(R,M)','MRCAT','\spadtype{MonoidRingCategory}(\spad{R},{} \spad{M}) defines the algebra of all maps from the monoid \spad{M} to the commutative ring \spad{R} with finite support.');
INSERT INTO olibdb VALUES('c','MultiDictionary',1,'x','(SetCategory)->Category','(S)','MDAGG','A multi-dictionary is a dictionary which may contain duplicates. As for any dictionary,{} its size is assumed large so that copying (non-destructive) operations are generally to be avoided.');
INSERT INTO olibdb VALUES('c','multiplicativeValuation',0,'n','()->Category',NULL,'ATMULVA','The class of all euclidean domains such that \spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}.');
INSERT INTO olibdb VALUES('c','MultisetAggregate',1,'x','(SetCategory)->Category','(S)','MSETAGG','A multi-set aggregate is a set which keeps track of the multiplicity of its elements.');
INSERT INTO olibdb VALUES('c','MultivariateSkewPolynomialCategory',3,'n','(Ring,OrderedAbelianMonoidSup,OrderedSet)->Category','(R,E,Var)','MORECAT',NULL);
INSERT INTO olibdb VALUES('c','MultivariateTaylorSeriesCategory',2,'x','(Ring,OrderedSet)->Category','(Coef,Var)','MTSCAT','\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category.');
INSERT INTO olibdb VALUES('c','NonAssociativeAlgebra',1,'x','(CommutativeRing)->Category','(R)','NAALG','NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \indented{3}{\spad{r*}(a*b) = (r*a)\spad{*b} = a*(\spad{r*b})}');
INSERT INTO olibdb VALUES('c','NonAssociativeRing',0,'x','()->Category',NULL,'NARING','A NonAssociativeRing is a non associative \spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative.');
INSERT INTO olibdb VALUES('c','NonAssociativeRng',0,'x','()->Category',NULL,'NARNG','NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \indented{2}{\spad{x*}(\spad{y+z}) = x*y + \spad{x*z}} \indented{2}{(x+y)\spad{*z} = \spad{x*z} + \spad{y*z}} Common Additional Axioms \indented{2}{noZeroDivisors\space{2}ab = 0 \spad{=>} \spad{a=0} or \spad{b=0}}');
INSERT INTO olibdb VALUES('c','NonAssociativeSemiRing',0,'n','()->Category',NULL,'NASRING','The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} with 0 and 1.');
INSERT INTO olibdb VALUES('c','NonAssociativeSemiRng',0,'n','()->Category',NULL,'NASRNG','The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} and not necessarily with a 1.');
INSERT INTO olibdb VALUES('c','NormalizedTriangularSetCategory',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,RecursivePolynomialCategory(R,E,V))->Category','(R,E,V,P)','NTSCAT','The category of normalized triangular sets. A triangular set \spad{ts} is said normalized if for every algebraic variable \spad{v} of \spad{ts} the polynomial \spad{select(ts,{} v)} is normalized \spad{w}.\spad{r}.\spad{t}. every polynomial in \spad{collectUnder(ts,{} v)}. A polynomial \spad{p} is said normalized \spad{w}.\spad{r}.\spad{t}. a non-constant polynomial \spad{q} if \spad{p} is constant or \spad{degree(p,{} mdeg(q)) = 0} and \spad{init(p)} is normalized \spad{w}.\spad{r}.\spad{t}. \spad{q}. One of the important features of normalized triangular sets is that they are regular sets.');
INSERT INTO olibdb VALUES('c','noZeroDivisors',0,'n','()->Category',NULL,'ATNZDIV','The class of all semirings such that \spad{x * y \~~= 0} implies both \spad{x} and \spad{y} are non-zero');
INSERT INTO olibdb VALUES('c','OctonionCategory',1,'x','(CommutativeRing)->Category','(R)','OC','OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the Complex numbers to get the quaternions.');
INSERT INTO olibdb VALUES('c','OneDimensionalArrayAggregate',1,'x','(Type)->Category','(S)','A1AGG','One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically,{} these aggregates are finite linear aggregates with the \spadtype{shallowlyMutable} property,{} that is,{} any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and therefore cannot efficiently grow or shrink on demand as can list structures (see however \spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over,{} and access to,{} elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result.');
INSERT INTO olibdb VALUES('c','OpenMath',0,'x','()->Category',NULL,'OM','\spadtype{OpenMath} provides operations for exporting an object in OpenMath format.');
INSERT INTO olibdb VALUES('c','OrderedAbelianGroup',0,'x','()->Category',NULL,'OAGROUP','Ordered sets which are also abelian groups,{} such that the addition preserves the ordering.');
INSERT INTO olibdb VALUES('c','OrderedAbelianMonoid',0,'x','()->Category',NULL,'OAMON','Ordered sets which are also abelian monoids,{} such that the addition preserves the ordering.');
INSERT INTO olibdb VALUES('c','OrderedAbelianMonoidSup',0,'x','()->Category',NULL,'OAMONS','This domain is an OrderedAbelianMonoid with a \spadfun{sup} operation added. The purpose of the \spadfun{sup} operator in this domain is to act as a supremum with respect to the partial order imposed by \spadop{-},{} rather than with respect to the total \spad{>} order (since that is max). \blankline');
INSERT INTO olibdb VALUES('c','OrderedAbelianSemiGroup',0,'x','()->Category',NULL,'OASGP','Ordered sets which are also abelian semigroups,{} such that the addition preserves the ordering. \indented{2}{\spad{ x < y => x+z < y+z}}');
INSERT INTO olibdb VALUES('c','OrderedCancellationAbelianMonoid',0,'x','()->Category',NULL,'OCAMON','Ordered sets which are also abelian cancellation monoids,{} such that the addition preserves the ordering.');
INSERT INTO olibdb VALUES('c','OrderedFinite',0,'x','()->Category',NULL,'ORDFIN','Ordered finite sets.');
INSERT INTO olibdb VALUES('c','OrderedIntegralDomain',0,'x','()->Category',NULL,'OINTDOM','The category of ordered commutative integral domains,{} where ordering and the arithmetic operations are compatible.');
INSERT INTO olibdb VALUES('c','OrderedMonoid',0,'x','()->Category',NULL,'ORDMON','Ordered sets which are also monoids,{} such that multiplication preserves the ordering. \blankline');
INSERT INTO olibdb VALUES('c','OrderedMultisetAggregate',1,'x','(OrderedSet)->Category','(S)','OMSAGG','An ordered-multiset aggregate is a multiset built over an ordered set \spad{S} so that the relative sizes of its entries can be assessed. These aggregates serve as models for priority queues.');
INSERT INTO olibdb VALUES('c','OrderedRing',0,'x','()->Category',NULL,'ORDRING','Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \blankline');
INSERT INTO olibdb VALUES('c','OrderedSemiGroup',0,'n','()->Category',NULL,'OSGROUP','Semigroups with compatible ordering.');
INSERT INTO olibdb VALUES('c','OrderedSet',0,'x','()->Category',NULL,'ORDSET','The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \spad{(a,{} b)} exactly one of the following relations holds \spad{a<b or a=b or b<a} and the relation is transitive,{} \spadignore{i.e.} \spad{a<b and b<c => a<c}. This order should be the natural order on given structure.');
INSERT INTO olibdb VALUES('c','OutputFormatterCategory',0,'n','()->Category',NULL,'FORMCAT','This is category specifying required interface \indented{1}{to output formatters.}');
INSERT INTO olibdb VALUES('c','PAdicIntegerCategory',1,'x','(Integer)->Category','(p)','PADICCT','This is the category of stream-based representations of \indented{2}{the \spad{p}-adic integers.}');
INSERT INTO olibdb VALUES('c','PartialDifferentialRing',1,'x','(SetCategory)->Category','(S)','PDRING','A partial differential ring with differentiations indexed by a parameter type \spad{S}. \blankline');
INSERT INTO olibdb VALUES('c','PartialOrder',0,'x','()->Category',NULL,'PORDER','The class of partially ordered sets,{} that is sets equipped with transitive and reflexive relation \spad{<=}.');
INSERT INTO olibdb VALUES('c','PartialTranscendentalFunctions',1,'x','(Type)->Category','(K)','PTRANFN','This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory.');
INSERT INTO olibdb VALUES('c','Patternable',1,'x','(Type)->Category','(R)','PATAB','An object \spad{S} is Patternable over an object \spad{R} if \spad{S} can lift the conversions from \spad{R} into \spadtype{Pattern(Integer)} and \spadtype{Pattern(Float)} to itself.');
INSERT INTO olibdb VALUES('c','PatternMatchable',1,'x','(SetCategory)->Category','(S)','PATMAB','A set \spad{R} is PatternMatchable over \spad{S} if elements of \spad{R} can be matched to patterns over \spad{S}.');
INSERT INTO olibdb VALUES('c','PermutationCategory',1,'x','(SetCategory)->Category','(S)','PERMCAT','PermutationCategory provides a categorical environment \indented{1}{for subgroups of bijections of a set (\spadignore{i.e.} permutations)}');
INSERT INTO olibdb VALUES('c','PlottablePlaneCurveCategory',0,'x','()->Category',NULL,'PPCURVE','PlottablePlaneCurveCategory is the category of curves in the plane which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \spad{x}-coordinates and \spad{y}-coordinates of the points on the curve.');
INSERT INTO olibdb VALUES('c','PlottableSpaceCurveCategory',0,'x','()->Category',NULL,'PSCURVE','PlottableSpaceCurveCategory is the category of curves in 3-space which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \spad{x-},{} \spad{y-},{} and \spad{z}-coordinates of the points on the curve.');
INSERT INTO olibdb VALUES('c','PointCategory',1,'x','(Ring)->Category','(R)','PTCAT','PointCategory is the category of points in space which may be plotted via the graphics facilities. Functions are provided for defining points and handling elements of points.');
INSERT INTO olibdb VALUES('c','PolynomialCategory',3,'x','(Join(SemiRng,etc),OrderedAbelianMonoidSup,OrderedSet)->Category','(R,E,VarSet)','POLYCAT','The category for general multi-variate polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}. Here variables commute with the coefficients.');
INSERT INTO olibdb VALUES('c','PolynomialFactorizationExplicit',0,'x','()->Category',NULL,'PFECAT','This is the category of domains that know enough about themselves in order to factor univariate polynomials over their fraction field.');
INSERT INTO olibdb VALUES('c','PolynomialSetCategory',4,'x','(R:Ring,E:OrderedAbelianMonoidSup,VarSet:OrderedSet,RecursivePolynomialCategory(R,E,VarSet))->Category','(R,E,VarSet,P)','PSETCAT','A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \spad{R} being an integral domain,{} a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions.');
INSERT INTO olibdb VALUES('c','Poset',1,'n','(SetCategory)->Category','(S)','POSET','holds a complete set together with a structure to codify \indented{2}{the partial order.} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','PowerSeriesCategory',3,'x','(Ring,OrderedAbelianMonoid,OrderedSet)->Category','(Coef,Expon,Var)','PSCAT','\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.');
INSERT INTO olibdb VALUES('c','Preorder',1,'n','(SetCategory)->Category','(S)','PREORD','implies operation with reflexivity and transitivity \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('c','PrimitiveFunctionCategory',0,'x','()->Category',NULL,'PRIMCAT','Category for the functions defined by integrals.');
INSERT INTO olibdb VALUES('c','PrincipalIdealDomain',0,'x','()->Category',NULL,'PID','The category of constructive principal ideal domains,{} \spadignore{i.e.} where a single generator can be constructively found for any ideal given by a finite set of generators. Note that this constructive definition only implies that finitely generated ideals are principal. It is not clear what we would mean by an infinitely generated ideal.');
INSERT INTO olibdb VALUES('c','PriorityQueueAggregate',1,'x','(OrderedSet)->Category','(S)','PRQAGG','A priority queue is a bag of items from an ordered set where the item extracted is always the maximum element.');
INSERT INTO olibdb VALUES('c','QuaternionCategory',1,'x','(CommutativeRing)->Category','(R)','QUATCAT','\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.');
INSERT INTO olibdb VALUES('c','QueueAggregate',1,'x','(Type)->Category','(S)','QUAGG','A queue is a bag where the first item inserted is the first item extracted.');
INSERT INTO olibdb VALUES('c','QuotientFieldCategory',1,'x','(IntegralDomain)->Category','(S)','QFCAT','QuotientField(\spad{S}) is the category of fractions of an Integral Domain \spad{S}.');
INSERT INTO olibdb VALUES('c','RadicalCategory',0,'x','()->Category',NULL,'RADCAT','The \spad{RadicalCategory} is a model for the rational numbers.');
INSERT INTO olibdb VALUES('c','RealClosedField',0,'x','()->Category',NULL,'RCFIELD','\spadtype{RealClosedField} provides common access functions for all real closed fields.');
INSERT INTO olibdb VALUES('c','RealConstant',0,'x','()->Category',NULL,'REAL','The category of real numeric domains,{} \spadignore{i.e.} convertible to floats.');
INSERT INTO olibdb VALUES('c','RealNumberSystem',0,'x','()->Category',NULL,'RNS','The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \spadtype{DifferentialRing} or the elementary functions (see \spadtype{TranscendentalFunctionCategory}) in the definition.');
INSERT INTO olibdb VALUES('c','RealRootCharacterizationCategory',2,'x','(TheField:Join(OrderedRing,etc),UnivariatePolynomialCategory(TheField))->Category','(TheField,ThePols)','RRCC','\spadtype{RealRootCharacterizationCategory} provides common access functions for all real root codings.');
INSERT INTO olibdb VALUES('c','RectangularMatrixCategory',5,'x','(m:NonNegativeInteger,n:NonNegativeInteger,R:Join(SemiRng,etc),DirectProductCategory(n,R),DirectProductCategory(m,R))->Category','(m,n,R,Row,Col)','RMATCAT','\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \spad{R}-modules and will be non-mutable.');
INSERT INTO olibdb VALUES('c','RecursiveAggregate',1,'x','(Type)->Category','(S)','RCAGG','A recursive aggregate over a type \spad{S} is a model for a a directed graph containing values of type \spad{S}. Recursively,{} a recursive aggregate is either empty or a {\em node} consisting of a \spadfun{value} from \spad{S} and 0 or more \spadfun{children} which are also nodes. A node with no children is called a \spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop.');
INSERT INTO olibdb VALUES('c','RecursivePolynomialCategory',3,'x','(Ring,OrderedAbelianMonoidSup,OrderedSet)->Category','(R,E,V)','RPOLCAT','A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \spadfun{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in the ordered set,{} so that some operations usually defined for univariate polynomials make sense here.');
INSERT INTO olibdb VALUES('c','RegularTriangularSetCategory',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,RecursivePolynomialCategory(R,E,V))->Category','(R,E,V,P)','RSETCAT','The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \spad{k[x1,{} ...,{} xn]} where \spad{k} is the fraction field of \spad{R}. The triangular set \spad{[t1,{} ...,{} tm]} is regular iff for every \spad{i} the initial of \spad{ti+1} is invertible in the tower of simple extensions associated with \spad{[t1,{} ...,{} \spad{ti}]}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \spad{I} iff the radical of \spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \spad{[T1,{} ...,{} \spad{Ti}]}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \spad{T} iff it is a split of Kalkbrener of the saturated ideal of \spad{T}. Let \spad{K} be an algebraic closure of \spad{k}. Assume that \spad{V} is finite with cardinality \spad{n} and let \spad{A} be the affine space \spad{K^n}. For a regular triangular set \spad{T} let denote by \spad{W(T)} the set of regular zeros of \spad{T}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given subset \spad{S} of \spad{A} iff the union of the \spad{W(\spad{Ti})} contains \spad{S} and is contained in the closure of \spad{S} (\spad{w}.\spad{r}.\spad{t}. Zariski topology). A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given triangular set \spad{T} if it is a split of Lazard of \spad{W(T)}. Note that if \spad{[T1,{} ...,{} Ts]} is a split of Lazard of \spad{T} then it is also a split of Kalkbrener of \spad{T}. The converse is \spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \newline');
INSERT INTO olibdb VALUES('c','RetractableFrom',1,'n','(Type)->Category','(S)','RETFROM','\spad{B} is retractable from A means that some elements in A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.');
INSERT INTO olibdb VALUES('c','RetractableTo',1,'x','(Type)->Category','(S)','RETRACT','A is retractable to \spad{B} means that some elements of A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.');
INSERT INTO olibdb VALUES('c','RightModule',1,'x','(SemiRng)->Category','(R)','RMODULE','The category of right modules over an \spad{rng} (ring not necessarily with unit). This is an abelian group which supports right multiplation by elements of the \spad{rng}. \blankline');
INSERT INTO olibdb VALUES('c','Ring',0,'x','()->Category',NULL,'RING','The category of rings with unity,{} always associative,{} but not necessarily commutative.');
INSERT INTO olibdb VALUES('c','Rng',0,'x','()->Category',NULL,'RNG','The category of associative rings,{} not necessarily commutative,{} and not necessarily with a 1. This is a combination of an abelian group and a semigroup,{} with multiplication distributing over addition. \blankline');
INSERT INTO olibdb VALUES('c','SegmentCategory',1,'x','(Type)->Category','(S)','SEGCAT','This category provides operations on ranges,{} or {\em segments} as they are called.');
INSERT INTO olibdb VALUES('c','SegmentExpansionCategory',2,'x','(S:OrderedRing,StreamAggregate(S))->Category','(S,L)','SEGXCAT','This category provides an interface for expanding segments to a stream of elements.');
INSERT INTO olibdb VALUES('c','SemiGroup',0,'x','()->Category',NULL,'SGROUP','the class of all multiplicative semigroups,{} \spadignore{i.e.} a set with an associative operation \spadop{*}. \blankline');
INSERT INTO olibdb VALUES('c','SemiRing',0,'n','()->Category',NULL,'SRING','The category of associative semirings,{} not necessarily commutative,{} with 0 and 1.');
INSERT INTO olibdb VALUES('c','SemiRng',0,'n','()->Category',NULL,'SRNG','The category of associative semirings,{} not necessarily commutative,{} and not necessarily with a 1.');
INSERT INTO olibdb VALUES('c','SequenceCategory',1,'n','(CommutativeRing)->Category','(R)','SEQUCAT','A category for infinite sequences over a commutative ring. It is a stream with arithmetics.');
INSERT INTO olibdb VALUES('c','SetAggregate',1,'x','(SetCategory)->Category','(S)','SETAGG','A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both,{} the relationship between the two cannot be described by inclusion or inheritance.');
INSERT INTO olibdb VALUES('c','SetCategory',0,'x','()->Category',NULL,'SETCAT','\spadtype{SetCategory} is the basic category for describing a collection of elements with \spadop{=} (equality) and \spadfun{coerce} to output form. \blankline Conditional Attributes: \indented{3}{canonical\tab{15}data structure equality is the same as \spadop{=}}');
INSERT INTO olibdb VALUES('c','SExpressionCategory',4,'x','(SetCategory,SetCategory,SetCategory,SetCategory)->Category','(Str,Sym,Int,Flt)','SEXCAT','This category allows the manipulation of Lisp values while keeping the grunge fairly localized.');
INSERT INTO olibdb VALUES('c','shallowlyMutable',0,'n','()->Category',NULL,'ATSHMUT','The class of all domains which have have immediate components that are updateable (mutable).');
INSERT INTO olibdb VALUES('c','SolvableSkewPolynomialCategory',2,'n','(Ring,OrderedAbelianMonoidSup)->Category','(R,Expon)','SSKPOLC','This is the category of polynomials in noncommutative variables over noncommutative rings. We do not assume that variables and elements of the base ring commute. We assume that the polynomial ring is of solvable type,{} so noncommutative version of Buchberger algorithm works.');
INSERT INTO olibdb VALUES('c','SpecialFunctionCategory',0,'x','()->Category',NULL,'SPFCAT','Category for the other special functions.');
INSERT INTO olibdb VALUES('c','SPointCategory',0,'n','()->Category',NULL,'SPTCAT','PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.');
INSERT INTO olibdb VALUES('c','SquareFreeNormalizedTriangularSetCategory',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,RecursivePolynomialCategory(R,E,V))->Category','(R,E,V,P)','SNTSCAT','The category of square-free and normalized triangular sets. Thus,{} up to the primitivity axiom of [1],{} these sets are Lazard triangular sets.\newline');
INSERT INTO olibdb VALUES('c','SquareFreeRegularTriangularSetCategory',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,RecursivePolynomialCategory(R,E,V))->Category','(R,E,V,P)','SFRTCAT','The category of square-free regular triangular sets. A regular triangular set \spad{ts} is square-free if the \spad{gcd} of any polynomial \spad{p} in \spad{ts} and \spad{differentiate(p,{} mvar(p))} \spad{w}.\spad{r}.\spad{t}. \spadopFrom{collectUnder}{TriangularSetCategory}(\spad{ts},{} \spadopFrom{mvar}{RecursivePolynomialCategory}(\spad{p})) has degree zero \spad{w}.\spad{r}.\spad{t}. \spad{mvar(p)}. Thus any square-free regular set defines a tower of square-free simple extensions.\newline');
INSERT INTO olibdb VALUES('c','SquareMatrixCategory',4,'x','(ndim:NonNegativeInteger,R:Join(SemiRng,etc),DirectProductCategory(ndim,R),DirectProductCategory(ndim,R))->Category','(ndim,R,Row,Col)','SMATCAT','\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col.');
INSERT INTO olibdb VALUES('c','StackAggregate',1,'x','(Type)->Category','(S)','SKAGG','A stack is a bag where the last item inserted is the first item extracted.');
INSERT INTO olibdb VALUES('c','StepThrough',0,'x','()->Category',NULL,'STEP','A class of objects which can be ''stepped through''. Repeated applications of \spadfun{nextItem} is guaranteed never to return duplicate items and only return failed after exhausting all elements of the domain. This assumes that the sequence starts with \spad{init()}. For infinite domains,{} repeated application of \spadfun{nextItem} is not required to reach all possible domain elements starting from any initial element. \blankline Conditional attributes: \indented{2}{infinite\tab{15}repeated \spad{nextItem}\spad{''s} are never failed.}');
INSERT INTO olibdb VALUES('c','StreamAggregate',1,'x','(Type)->Category','(S)','STAGG','A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \spadtype{Stream}. From streams,{} a number of infinite structures such as power series can be built.');
INSERT INTO olibdb VALUES('c','StringAggregate',0,'x','()->Category',NULL,'SRAGG','A string aggregate is a category for strings,{} that is,{} one dimensional arrays of characters.');
INSERT INTO olibdb VALUES('c','StringCategory',0,'x','()->Category',NULL,'STRICAT','A category for string-like objects');
INSERT INTO olibdb VALUES('c','TableAggregate',2,'x','(Type,Type)->Category','(Key,Entry)','TBAGG','A table aggregate is a model of a table,{} \spadignore{i.e.} a discrete many-to-one mapping from keys to entries.');
INSERT INTO olibdb VALUES('c','TaylorSeriesExpansion',5,'n','(Coef:Algebra(Fraction(Integer)),Expon:OrderedAbelianMonoid,Var:OrderedSet,PowerSeriesCategory(Coef,Expon,Var),UnivariateTaylorSeriesCategory(Coef))->Category','(Coef,Expon,Var,PS,UTS)','TSEREXP','Category for operations needed by Taylor expansions.');
INSERT INTO olibdb VALUES('c','TensorPowerCategory',3,'x','(NonNegativeInteger,R:CommutativeRing,Module(R))->Category','(n,R,M)','TENSPC','Category of tensor powers of modules over commutative rings.');
INSERT INTO olibdb VALUES('c','TensorProductCategory',3,'x','(R:CommutativeRing,Module(R),Module(R))->Category','(R,M,N)','TENSCAT','Category of tensor products of modules over commutative rings.');
INSERT INTO olibdb VALUES('c','TensorProductProperty',5,'x','(R:CommutativeRing,M:Module(R),N:Module(R),TensorProductCategory(R,M,N),Module(R))->Category','(R,M,N,MxN,S)','TENSPRP','Universal property of tensor products.');
INSERT INTO olibdb VALUES('c','ThreeSpaceCategory',1,'x','(Ring)->Category','(R)','SPACEC','The category ThreeSpaceCategory is used for creating three dimensional objects using functions for defining points,{} curves,{} polygons,{} constructs and the subspaces containing them.');
INSERT INTO olibdb VALUES('c','TranscendentalFunctionCategory',0,'x','()->Category',NULL,'TRANFUN','Category for the transcendental elementary functions.');
INSERT INTO olibdb VALUES('c','TriangularSetCategory',4,'x','(R:IntegralDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,RecursivePolynomialCategory(R,E,V))->Category','(R,E,V,P)','TSETCAT','The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \spad{R} be an integral domain and \spad{V} a finite ordered set of variables,{} say \spad{X1 < X2 < ... < Xn}. A set \spad{S} of polynomials in \spad{R[X1,{} X2,{} ...,{} Xn]} is triangular if no elements of \spad{S} lies in \spad{R},{} and if two distinct elements of \spad{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \spad{P} is reduced \spad{w}.\spad{r}.\spad{t} a non-constant polynomial \spad{Q} if the degree of \spad{P} in the main variable of \spad{Q} is less than the main degree of \spad{Q}. A polynomial \spad{P} is reduced \spad{w}.\spad{r}.\spad{t} a triangular set \spad{T} if it is reduced \spad{w}.\spad{r}.\spad{t}. every polynomial of \spad{T}. \newline');
INSERT INTO olibdb VALUES('c','TrigonometricFunctionCategory',0,'x','()->Category',NULL,'TRIGCAT','Category for the trigonometric functions.');
INSERT INTO olibdb VALUES('c','TwoDimensionalArrayCategory',3,'x','(R:Type,IndexedAggregate(Integer,R),IndexedAggregate(Integer,R))->Category','(R,Row,Col)','ARR2CAT','\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the ''first'' row may be obtained by calling the function ''minRowIndex''. The index of the ''first'' column may be obtained by calling the function ''minColIndex''. The index of the first element of a ''Row'' is the same as the index of the first column in an array and vice versa.');
INSERT INTO olibdb VALUES('c','TwoSidedRecip',0,'n','()->Category',NULL,'ATTWSR','The class of all magmas where \spad{leftRecip} and \spad{rightRecip} are the same as \spad{recip}.');
INSERT INTO olibdb VALUES('c','Type',0,'x','()->Category',NULL,'TYPE','The fundamental Type.');
INSERT INTO olibdb VALUES('c','UnaryRecursiveAggregate',1,'x','(Type)->Category','(S)','URAGG','A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \spadfun{value} of the list designating the head,{} or \spadfun{first},{} of the list,{} and the child designating the tail,{} or \spadfun{rest},{} of the list. Since these aggregates are recursive aggregates,{} they may be cyclic.');
INSERT INTO olibdb VALUES('c','UniqueFactorizationDomain',0,'x','()->Category',NULL,'UFD','A constructive unique factorization domain,{} \spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.');
INSERT INTO olibdb VALUES('c','unitsKnown',0,'n','()->Category',NULL,'ATUNIKN','The class of all monoids (multiplicative semigroups with a 1) such that the operation \spadfun{recip} can only return failed if its argument is not a unit.');
INSERT INTO olibdb VALUES('c','UnivariateLaurentSeriesCategory',1,'x','(Ring)->Category','(Coef)','ULSCAT','\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable.');
INSERT INTO olibdb VALUES('c','UnivariateLaurentSeriesConstructorCategory',2,'x','(Coef:Ring,UnivariateTaylorSeriesCategory(Coef))->Category','(Coef,UTS)','ULSCCAT','This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \spad{[n,{} f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x^n * f(x)}.');
INSERT INTO olibdb VALUES('c','UnivariatePolynomialCategory',1,'x','(Join(SemiRng,etc))->Category','(R)','UPOLYC','The category of univariate polynomials over a ring \spad{R}. No particular model is assumed - implementations can be either sparse or dense.');
INSERT INTO olibdb VALUES('c','UnivariatePowerSeriesCategory',2,'x','(Ring,OrderedAbelianMonoid)->Category','(Coef,Expon)','UPSCAT','\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents.');
INSERT INTO olibdb VALUES('c','UnivariatePuiseuxSeriesCategory',1,'x','(Ring)->Category','(Coef)','UPXSCAT','\spadtype{UnivariatePuiseuxSeriesCategory} is the category of Puiseux series in one variable.');
INSERT INTO olibdb VALUES('c','UnivariatePuiseuxSeriesConstructorCategory',2,'x','(Coef:Ring,UnivariateLaurentSeriesCategory(Coef))->Category','(Coef,ULS)','UPXSCCA','This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{} f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.');
INSERT INTO olibdb VALUES('c','UnivariateSeriesWithRationalExponents',2,'n','(Ring,OrderedAbelianMonoid)->Category','(Coef,Expon)','RATPSCT',NULL);
INSERT INTO olibdb VALUES('c','UnivariateSkewPolynomialCategory',1,'x','(Ring)->Category','(R)','OREPCAT','This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}. This category is an evolution of the types \indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \indented{2}{NonCommutativeOperatorDivision} developed by Jean Della Dora and Stephen \spad{M}. Watt.');
INSERT INTO olibdb VALUES('c','UnivariateTaylorSeriesCategory',1,'x','(Ring)->Category','(Coef)','UTSCAT','\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.');
INSERT INTO olibdb VALUES('c','VarCat',0,'n','()->Category',NULL,'VARCAT','VarCat represents a variable in Lambda and Ski domains. Since we are working in terms of functions then a variable will be a function (possibly a constant function) a variable has a name represented by a String. If the Lambda or Ski calculus is typed then the variable will also have a type.');
INSERT INTO olibdb VALUES('c','VariablesCommuteWithCoefficients',0,'n','()->Category',NULL,'ATVCWC','The class of all polynomial domains such that variables commute with coefficients.');
INSERT INTO olibdb VALUES('c','VectorCategory',1,'x','(Type)->Category','(R)','VECTCAT','\spadtype{VectorCategory} represents the type of vector like objects,{} \spadignore{i.e.} finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time.');
INSERT INTO olibdb VALUES('c','XAlgebra',1,'x','(Ring)->Category','(R)','XALG','This is the category of algebras over non-commutative rings. It is used by constructors of non-commutative algebras such as: \indented{4}{\spadtype{XPolynomialRing}.} \indented{4}{\spadtype{XFreeAlgebra}} Author: Michel Petitot (petitot@lifl.\spad{fr})');
INSERT INTO olibdb VALUES('c','XFreeAlgebra',2,'x','(OrderedSet,Ring)->Category','(vl,R)','XFALG','This category specifies operations for polynomials and formal series with non-commutative variables.');
INSERT INTO olibdb VALUES('c','XPolynomialsCat',2,'x','(OrderedSet,Ring)->Category','(vl,R)','XPOLYC','The Category of polynomial rings with non-commutative variables. The coefficient ring may be non-commutative too. However coefficients commute with variables.');
INSERT INTO olibdb VALUES('d','AlgebraGivenByStructuralConstants',4,'x','(R:CommutativeRing,n:PositiveInteger,ls:List(Symbol),Vector(Matrix(R)))->Join(FramedNonAssociativeAlgebra(R),etc)','(R,n,ls,gamma)','ALGSC','AlgebraGivenByStructuralConstants implements finite rank algebras over a commutative ring,{} given by the structural constants \spad{gamma} with respect to a fixed basis \spad{[a1,{} ..,{} an]},{} where \spad{gamma} is an \spad{n}-vector of \spad{n} by \spad{n} matrices \spad{[(gammaijk) for k in 1..rank()]} defined by \spad{\spad{ai} * aj = gammaij1 * a1 + ... + gammaijn * an}. The symbols for the fixed basis have to be given as a list of symbols.');
INSERT INTO olibdb VALUES('d','AlgebraicFunctionField',4,'n','(F:Field,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),UPUP)->Join(FunctionFieldCategory(F,UP,UPUP),etc)','(F,UP,UPUP,modulus)','ALGFF','Function field defined by \spad{f}(\spad{x},{} \spad{y}) = 0.');
INSERT INTO olibdb VALUES('d','AlgebraicNumber',0,'x','()->Join(ExpressionSpace,etc)',NULL,'AN','Algebraic closure of the rational numbers.');
INSERT INTO olibdb VALUES('d','AnonymousFunction',0,'n','()->SetCategory',NULL,'ANON','This domain implements anonymous functions');
INSERT INTO olibdb VALUES('d','AntiSymm',2,'n','(Ring,List(Symbol))->Join(LeftAlgebra(R),etc)','(R,lVar)','ANTISYM','The domain of antisymmetric polynomials.');
INSERT INTO olibdb VALUES('d','Any',0,'x','()->Join(SetCategory,etc)',NULL,'ANY','\spadtype{Any} implements a type that packages up objects and their types in objects of \spadtype{Any}. Roughly speaking that means that if \spad{s : S} then when converted to \spadtype{Any},{} the new object will include both the original object and its type. This is a way of converting arbitrary objects into a single type without losing any of the original information. Any object can be converted to one of \spadtype{Any}.');
INSERT INTO olibdb VALUES('d','ArrayStack',1,'x','(SetCategory)->Join(StackAggregate(S),etc)','(S)','ASTACK','A stack represented as a flexible array.');
INSERT INTO olibdb VALUES('d','AssociatedJordanAlgebra',2,'x','(R:CommutativeRing,A:NonAssociativeAlgebra(R))->Join(NonAssociativeAlgebra(R),etc)','(R,A)','JORDAN','\indented{1}{AssociatedJordanAlgebra takes an algebra \spad{A} and uses \spadfun{*\$A}} \indented{1}{to define the new multiplications \spad{a*b := (a *\$A b + b *\$A a)/2}} \indented{1}{(anticommutator).} \indented{1}{The usual notation \spad{{a,{} b}_+} cannot be used due to} \indented{1}{restrictions in the current language.} \indented{1}{This domain only gives a Jordan algebra if the} \indented{1}{Jordan-identity \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds} \indented{1}{for all \spad{a},{} \spad{b},{} \spad{c} in \spad{A}.} \indented{1}{This relation can be checked by} \indented{1}{\spadfun{jordanAdmissible?()\$A}.} \blankline If the underlying algebra is of type \spadtype{FramedNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank,{} together with a fixed \spad{R}-module basis),{} then the same is \spad{true} for the associated Jordan algebra. Moreover,{} if the underlying algebra is of type \spadtype{FiniteRankNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank),{} then the same \spad{true} for the associated Jordan algebra.');
INSERT INTO olibdb VALUES('d','AssociatedLieAlgebra',2,'x','(R:CommutativeRing,A:NonAssociativeAlgebra(R))->Join(NonAssociativeAlgebra(R),etc)','(R,A)','LIE','AssociatedLieAlgebra takes an algebra \spad{A} and uses \spadfun{*\$A} to define the Lie bracket \spad{a*b := (a *\$A b - b *\$A a)} (commutator). Note that the notation \spad{[a,{} b]} cannot be used due to restrictions of the current compiler. This domain only gives a Lie algebra if the Jacobi-identity \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \spad{a},{} \spad{b},{} \spad{c} in \spad{A}. This relation can be checked by \spad{lieAdmissible?()\$A}. \blankline If the underlying algebra is of type \spadtype{FramedNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank,{} together with a fixed \spad{R}-module basis),{} then the same is \spad{true} for the associated Lie algebra. Also,{} if the underlying algebra is of type \spadtype{FiniteRankNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank),{} then the same is \spad{true} for the associated Lie algebra.');
INSERT INTO olibdb VALUES('d','AssociationList',2,'n','(SetCategory,Entry:Type)->AssociationListAggregate(Key,Entry)','(Key,Entry)','ALIST','\spadtype{AssociationList} implements association lists. These may be viewed as lists of pairs where the first part is a key and the second is the stored value. For example,{} the key might be a string with a persons employee identification number and the value might be a record with personnel data.');
INSERT INTO olibdb VALUES('d','Automorphism',1,'n','(Ring)->Join(Group,etc)','(R)','AUTOMOR','Automorphism \spad{R} is the multiplicative group of automorphisms of \spad{R}.');
INSERT INTO olibdb VALUES('d','BalancedBinaryTree',1,'x','(SetCategory)->Join(BinaryTreeCategory(S),etc)','(S)','BBTREE','\spadtype{BalancedBinaryTree(S)} is the domain of balanced binary trees (bbtree). A balanced binary tree of \spad{2^k} leaves,{} for some \spad{k > 0},{} is symmetric,{} that is,{} the left and right subtree of each interior node have identical shape. In general,{} the left and right subtree of a given node can differ by at most one leaf node.');
INSERT INTO olibdb VALUES('d','BalancedPAdicInteger',1,'n','(Integer)->PAdicIntegerCategory(p)','(p)','BPADIC','Stream-based implementation of \spad{Zp:} \spad{p}-adic numbers are represented as sum(\spad{i} = 0..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in -(\spad{p} - 1)\spad{/2},{} ...,{} (\spad{p} - 1)\spad{/2}.');
INSERT INTO olibdb VALUES('d','BalancedPAdicRational',1,'n','(Integer)->Join(QuotientFieldCategory(BalancedPAdicInteger(p)),etc)','(p)','BPADICRT','Stream-based implementation of \spad{Qp:} numbers are represented as sum(\spad{i} = \spad{k}..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in -(\spad{p} - 1)\spad{/2},{} ...,{} (\spad{p} - 1)\spad{/2}.');
INSERT INTO olibdb VALUES('d','BasicFile',0,'n','()->etc',NULL,'BASFILE','This is domain for storing and reading Spad values in files.');
INSERT INTO olibdb VALUES('d','BasicKeyedAccessFile',0,'n','()->etc',NULL,'BKAFILE',NULL);
INSERT INTO olibdb VALUES('d','BasicOperator',0,'x','()->Join(OrderedSet,etc)',NULL,'BOP','A basic operator is an object that can be applied to a list of arguments from a set,{} the result being a kernel over that set.');
INSERT INTO olibdb VALUES('d','BinaryExpansion',0,'x','()->Join(QuotientFieldCategory(Integer),etc)',NULL,'BINARY','This domain allows rational numbers to be presented as repeating binary expansions.');
INSERT INTO olibdb VALUES('d','BinarySearchTree',1,'x','(OrderedSet)->Join(BinaryTreeCategory(S),etc)','(S)','BSTREE','BinarySearchTree(\spad{S}) is the domain of binary trees where elements are ordered across the tree. A binary search tree is either empty or has a value which is an \spad{S},{} and a left and a right which are both BinarySearchTree(\spad{S}).');
INSERT INTO olibdb VALUES('d','BinaryTournament',1,'x','(OrderedSet)->Join(BinaryTreeCategory(S),etc)','(S)','BTOURN','\spadtype{BinaryTournament(S)} is the domain of binary trees where elements are ordered down the tree. A binary tournament is either empty or is a node containing a \spadfun{value} of type \spad{S},{} and a \spadfun{left} and a \spadfun{right} which are both \spadtype{BinaryTree(S)}');
INSERT INTO olibdb VALUES('d','BinaryTree',1,'x','(SetCategory)->Join(BinaryTreeCategory(S),etc)','(S)','BTREE','\spadtype{BinaryTree(S)} is the domain of all binary trees. A binary tree over \spad{S} is either empty or has a \spadfun{value} which is an \spad{S} and a \spadfun{right} and \spadfun{left} which are both BinaryTree(\spad{S}).');
INSERT INTO olibdb VALUES('d','Bits',0,'x','()->Join(BitAggregate,etc)',NULL,'BITS','\spadtype{Bits} provides logical functions for Indexed Bits.');
INSERT INTO olibdb VALUES('d','BitStreamFrame',0,'n','()->Join(Lattice,etc)',NULL,'BITST','An example of a frame taken from Vickers section 3.7 Date Created: Aug 2015');
INSERT INTO olibdb VALUES('d','Boolean',0,'x','()->Join(OrderedSet,etc)',NULL,'BOOLEAN','\indented{1}{\spadtype{Boolean} is the elementary logic with 2 values:} \spad{true} and \spad{false}');
INSERT INTO olibdb VALUES('d','CardinalNumber',0,'x','()->Join(OrderedSet,etc)',NULL,'CARD','Members of the domain CardinalNumber are values indicating the cardinality of sets,{} both finite and infinite. Arithmetic operations are defined on cardinal numbers as follows. \blankline If \spad{x = \#X} and \spad{y = \#Y} then \indented{2}{\spad{x+y\space{2}= \#(X+Y)}\space{3}\tab{30}disjoint union} \indented{2}{\spad{x-y\space{2}= \#(X-Y)}\space{3}\tab{30}relative complement} \indented{2}{\spad{x*y\space{2}= \#(X*Y)}\space{3}\tab{30}cartesian product} \indented{2}{\spad{x^y = \#(X^Y)}\space{2}\tab{30}\spad{X^Y = \{g| g: Y->X\}}} \blankline The non-negative integers have a natural construction as cardinals \indented{2}{\spad{0 = \#\{\}},{} \spad{1 = \{0\}},{} \spad{2 = \{0,{} 1\}},{} ...,{} \spad{n = \{i| 0 <= i < n\}}.} \blankline That \spad{0} acts as a zero for the multiplication of cardinals is equivalent to the axiom of choice. \blankline The generalized continuum hypothesis asserts \centerline{\spad{2^Aleph i = Aleph(i+1)}} and is independent of the axioms of set theory [Goedel 1940]. \blankline Three commonly encountered cardinal numbers are \indented{3}{\spad{a = \#Z}\space{7}\tab{30}countable infinity} \indented{3}{\spad{c = \#R}\space{7}\tab{30}the continuum} \indented{3}{\spad{f = \#\{g| g: [0,{} 1]->R\}}} \blankline In this domain,{} these values are obtained using \indented{3}{\spad{a := Aleph 0},{} \spad{c := 2^a},{} \spad{f := 2^c}.} \blankline');
INSERT INTO olibdb VALUES('d','CartesianTensor',3,'x','(Integer,dim:NonNegativeInteger,R:CommutativeRing)->Join(GradedAlgebra(R,NonNegativeInteger),etc)','(minix,dim,R)','CARTEN','CartesianTensor(minix,{} dim,{} \spad{R}) provides Cartesian tensors with components belonging to a commutative ring \spad{R}. These tensors can have any number of indices. Each index takes values from \spad{minix} to \spad{minix + dim - 1}.');
INSERT INTO olibdb VALUES('d','Cell',1,'n','(RealClosedField)->Join(CoercibleTo(OutputForm),etc)','(TheField)','CELL',NULL);
INSERT INTO olibdb VALUES('d','ChainComplex',0,'n','()->Join(SetCategory,etc)',NULL,'CHAINC','\indented{2}{Delta Complexes are defined by a sequence of ''face maps'',{} These} \indented{2}{can be represented by a list of matrices.} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/} Date Created: March 2016 Basic Operations: Related packages: Related categories: Related Domains: CoChainComplex Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','Character',0,'x','()->Join(OrderedFinite,etc)',NULL,'CHAR','This domain provides the basic character data type.');
INSERT INTO olibdb VALUES('d','CharacterClass',0,'x','()->Join(SetCategory,etc)',NULL,'CCLASS','This domain allows classes of characters to be defined and manipulated efficiently.');
INSERT INTO olibdb VALUES('d','CliffordAlgebra',3,'x','(n:PositiveInteger,K:Field,SquareMatrix(n,K))->Join(Ring,etc)','(n,K,bLin)','CLIF','CliffordAlgebra(\spad{n},{} \spad{K},{} bLin) defines a module of dimension \spad{2^n} over \spad{K},{} given a bilinear form bLin on \spad{K^n}. \blankline Examples of Clifford Algebras are: gaussians,{} quaternions,{} exterior algebras and spin algebras.');
INSERT INTO olibdb VALUES('d','CoChainComplex',1,'n','(AbelianGroup)->Join(SetCategory,etc)','(VS)','COCHNC','\indented{2}{Delta Complexes are defined by a sequence of ''face maps'',{} These can} \indented{2}{be represented by a list of matrices.} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/cochain/} Date Created: Jan 2016 Basic Operations: Related packages: Related categories: Related Domains: ChainComplex Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','Color',0,'x','()->Join(AbelianSemiGroup,etc)',NULL,'COLOR','Color() specifies a domain of 27 colors provided in the \Language{} system (the colors mix additively).');
INSERT INTO olibdb VALUES('d','Commutator',0,'x','()->Join(SetCategory,etc)',NULL,'COMM','A type for basic commutators.');
INSERT INTO olibdb VALUES('d','Complex',1,'x','(CommutativeRing)->Join(ComplexCategory(R),etc)','(R)','COMPLEX','\spadtype {Complex(R)} creates the domain of elements of the form \spad{a + b * i} where \spad{a} and \spad{b} come from the ring \spad{R},{} and \spad{i} is a new element such that \spad{i^2 = -1}.');
INSERT INTO olibdb VALUES('d','ComplexDoubleFloatMatrix',0,'n','()->MatrixCategory(Complex(DoubleFloat),ComplexDoubleFloatVector,ComplexDoubleFloatVector)',NULL,'CDFMAT','This is a low-level domain which implements matrices (two dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','ComplexDoubleFloatVector',0,'n','()->Join(VectorCategory(Complex(DoubleFloat)),etc)',NULL,'CDFVEC','This is a low-level domain which implements vectors (one dimensional arrays) of complex double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','ContinuedFraction',1,'x','(EuclideanDomain)->Join(Algebra(R),etc)','(R)','CONTFRAC','\spadtype{ContinuedFraction} implements general \indented{1}{continued fractions.\space{2}This version is not restricted to simple,{}} \indented{1}{finite fractions and uses the \spadtype{Stream} as a} \indented{1}{representation.\space{2}The arithmetic functions assume that the} \indented{1}{approximants alternate below/above the convergence point.} \indented{1}{This is enforced by ensuring the partial numerators and partial} \indented{1}{denominators are greater than 0 in the Euclidean domain view of \spad{R}} \indented{1}{(\spadignore{i.e.} \spad{sizeLess?(0,{} x)}).}');
INSERT INTO olibdb VALUES('d','CubicalFacet',0,'n','()->Join(FacetCategory,etc)',NULL,'CFACET','\indented{2}{A single vertex,{} edge,{} square,{} cube...} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/} Date Created: April 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','CyclicGroup',2,'n','(PositiveInteger,Symbol)->Join(FiniteGroup,etc)','(n,g)','CYCGRP','A domain for finite cyclic groups.');
INSERT INTO olibdb VALUES('d','Database',1,'x','(Join(OrderedSet,etc))->Join(SetCategory,etc)','(S)','DBASE','\indented{1}{This domain implements a simple view of a database whose fields are} indexed by symbols');
INSERT INTO olibdb VALUES('d','DataList',1,'x','(OrderedSet)->Join(ListAggregate(S),etc)','(S)','DLIST','This domain provides some nice functions on lists');
INSERT INTO olibdb VALUES('d','DecimalExpansion',0,'x','()->Join(QuotientFieldCategory(Integer),etc)',NULL,'DECIMAL','This domain allows rational numbers to be presented as repeating decimal expansions.');
INSERT INTO olibdb VALUES('d','DeltaComplex',1,'n','(AbelianGroup)->Join(SetCategory,etc)','(VS)','DELTAC','\indented{2}{Similar to Simplicial Complex but faces (edges,{} triangles,{} etc.)} \indented{2}{are indexed by ''face maps'' into the next lower face map until} \indented{2}{we get down to the vertices.} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/delta/} Date Created: Feb 2016 Basic Operations: Related packages: Related categories: Related Domains: FiniteSimplicialComplex is a simpler and more \indented{3}{compact representation which can be used if edges,{} triangles,{}} \indented{3}{etc. don\spad{''t} need to be indexed.} Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','DenavitHartenbergMatrix',1,'x','(Join(Field,etc))->Join(MatrixCategory(R,Vector(R),Vector(R)),etc)','(R)','DHMATRIX','\indented{1}{A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:} \indented{1}{\spad{nx ox ax px}} \indented{1}{\spad{ny oy ay py}} \indented{1}{\spad{nz oz az pz}} \indented{2}{\spad{0\space{2}0\space{2}0\space{2}1}} (\spad{n},{} \spad{o},{} and a are the direction cosines)');
INSERT INTO olibdb VALUES('d','Dequeue',1,'x','(SetCategory)->Join(DequeueAggregate(S),etc)','(S)','DEQUEUE','Linked list implementation of a Dequeue');
INSERT INTO olibdb VALUES('d','DeRhamComplex',2,'n','(Join(Ring,etc),List(Symbol))->Join(LeftAlgebra(Expression(CoefRing)),etc)','(CoefRing,listIndVar)','DERHAM','The deRham complex of Euclidean space,{} that is,{} the class of differential forms of arbitrary degree over a coefficient ring. See Flanders,{} Harley,{} Differential Forms,{} With Applications to the Physical Sciences,{} New York,{} Academic Press,{} 1963.');
INSERT INTO olibdb VALUES('d','DifferentialSparseMultivariatePolynomial',3,'n','(Ring,S:OrderedSet,V:DifferentialVariableCategory(S))->Join(DifferentialPolynomialCategory(R,S,V,IndexedExponents(V)),etc)','(R,S,V)','DSMP','\spadtype{DifferentialSparseMultivariatePolynomial} implements an ordinary differential polynomial ring by combining a domain belonging to the category \spadtype{DifferentialVariableCategory} with the domain \spadtype{SparseMultivariatePolynomial}. \blankline');
INSERT INTO olibdb VALUES('d','DihedralGroup',3,'n','(PositiveInteger,Symbol,Symbol)->Join(FiniteGroup,etc)','(n,a,b)','DIHGRP','\spad{DihedralGroup(n,{} a,{} b)} is the dihedral group generated by a rotation a of order \spad{n} and a reflection \spad{b}.');
INSERT INTO olibdb VALUES('d','DirectedGraph',1,'n','(SetCategory)->Join(FiniteGraph(S),etc)','(S)','DGRPH','Category of directed graphs,{} allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('d','DirectProduct',2,'n','(NonNegativeInteger,R:Type)->Join(DirectProductCategory(dim,R),etc)','(dim,R)','DIRPROD','\indented{2}{This type represents the finite direct or cartesian product of an} underlying component type. This contrasts with simple vectors in that the members can be viewed as having constant length. Thus many categorical properties can by lifted from the underlying component type. Component extraction operations are provided but no updating operations. Thus new direct product elements can either be created by converting vector elements using the \spadfun{directProduct} function or by taking appropriate linear combinations of basis vectors provided by the \spad{unitVector} operation.');
INSERT INTO olibdb VALUES('d','DirectProductMatrixModule',4,'n','(n:PositiveInteger,R:Ring,M:SquareMatrixCategory(n,R,DirectProduct(n,R),DirectProduct(n,R)),S:LeftModule(R))->Join(DirectProductCategory(n,S),etc)','(n,R,M,S)','DPMM','This constructor provides a direct product type with a left matrix-module view.');
INSERT INTO olibdb VALUES('d','DirectProductModule',3,'n','(NonNegativeInteger,R:Ring,S:LeftModule(R))->Join(DirectProductCategory(n,S),etc)','(n,R,S)','DPMO','This constructor provides a direct product of \spad{R}-modules with an \spad{R}-module view.');
INSERT INTO olibdb VALUES('d','DirichletRing',1,'n','(Ring)->Join(Ring,etc)','(Coef)','DIRRING','DirichletRing is the ring of arithmetical functions with Dirichlet convolution as multiplication');
INSERT INTO olibdb VALUES('d','DistributedJetBundlePolynomial',4,'n','(Ring,JB:JetBundleCategory,LJV:List(JB),E:DirectProductCategory(#(LJV),NonNegativeInteger))->Join(PolynomialCategory(R,E,JB),etc)','(R,JB,LJV,E)','DJBP','\spadtype{DistributedJetBundlePolynomial} implements polynomials in a distributed representation. The unknowns come from a finite list of jet variables. The implementation is basically a copy of the one of \spadtype{GeneralDistributedMultivariatePolynomial}.');
INSERT INTO olibdb VALUES('d','DistributedMultivariatePolynomial',2,'n','(List(Symbol),R:Ring)->Join(PolynomialCategory(R,DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl)),etc)','(vl,R)','DMP','\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is lexicographic specified by the variable list parameter with the most significant variable first in the list.');
INSERT INTO olibdb VALUES('d','Distribution',1,'x','(CommutativeRing)->Join(DistributionCategory(R),etc)','(R)','DISTRO','Domain for distributions formally given by moments. moments and different kinds of cumulants are stored in streams and computed on demand.');
INSERT INTO olibdb VALUES('d','DoubleFloat',0,'x','()->Join(FloatingPointSystem,etc)',NULL,'DFLOAT','\indented{1}{\spadtype{DoubleFloat} is intended to make accessible} hardware floating point arithmetic in \Language{},{} either native double precision,{} or IEEE. On most machines,{} there will be hardware support for the arithmetic operations: \spadfunFrom{+}{DoubleFloat},{} \spadfunFrom{*}{DoubleFloat},{} \spadfunFrom{/}{DoubleFloat} and possibly also the \spadfunFrom{sqrt}{DoubleFloat} operation. The operations \spadfunFrom{exp}{DoubleFloat},{} \spadfunFrom{log}{DoubleFloat},{} \spadfunFrom{sin}{DoubleFloat},{} \spadfunFrom{cos}{DoubleFloat},{} \spadfunFrom{atan}{DoubleFloat} are normally coded in software based on minimax polynomial/rational approximations. Some general comments about the accuracy of the operations: the operations \spadfunFrom{+}{DoubleFloat},{} \spadfunFrom{*}{DoubleFloat},{} \spadfunFrom{/}{DoubleFloat} and \spadfunFrom{sqrt}{DoubleFloat} are expected to be fully accurate. The operations \spadfunFrom{exp}{DoubleFloat},{} \spadfunFrom{log}{DoubleFloat},{} \spadfunFrom{sin}{DoubleFloat},{} \spadfunFrom{cos}{DoubleFloat} and \spadfunFrom{atan}{DoubleFloat} are not expected to be fully accurate. In particular,{} \spadfunFrom{sin}{DoubleFloat} and \spadfunFrom{cos}{DoubleFloat} will lose all precision for large arguments. \blankline The \spadtype{Float} domain provides an alternative to the \spad{DoubleFloat} domain. It provides an arbitrary precision model of floating point arithmetic. This means that accuracy problems like those above are eliminated by increasing the working precision where necessary. \spadtype{Float} provides some special functions such as \spadfunFrom{erf}{\spad{DoubleFloatSpecialFunctions2}},{} the error function in addition to the elementary functions. The disadvantage of \spadtype{Float} is that it is much more expensive than small floats when the latter can be used.');
INSERT INTO olibdb VALUES('d','DoubleFloatMatrix',0,'n','()->MatrixCategory(DoubleFloat,DoubleFloatVector,DoubleFloatVector)',NULL,'DFMAT','This is a low-level domain which implements matrices (two dimensional arrays) of double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','DoubleFloatVector',0,'n','()->Join(VectorCategory(DoubleFloat),etc)',NULL,'DFVEC','This is a low-level domain which implements vectors (one dimensional arrays) of double precision floating point numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','DrawOption',0,'x','()->Join(SetCategory,etc)',NULL,'DROPT','DrawOption allows the user to specify defaults for the creation and rendering of plots.');
INSERT INTO olibdb VALUES('d','ElementaryFunctionsGeneralizedUnivariatePowerSeries',3,'n','(Coef:Algebra(Fraction(Integer)),Expon:OrderedAbelianMonoid,PS:Join(UnivariatePowerSeriesCategory(Coef,Expon),etc))->Join(PartialTranscendentalFunctions(PS),etc)','(Coef,Expon,PS)','EFGUSER','This package implements elementary functions on general \indented{1}{univariate power series.}');
INSERT INTO olibdb VALUES('d','ElementaryFunctionsUnivariateLaurentSeries',3,'n','(Coef:Algebra(Fraction(Integer)),UTS:UnivariateTaylorSeriesCategory(Coef),ULS:UnivariateLaurentSeriesConstructorCategory(Coef,UTS))->Join(PartialTranscendentalFunctions(ULS),etc)','(Coef,UTS,ULS)','EFULS','\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide ''partial functions'' which compute transcendental functions of Laurent series when possible and return failed when this is not possible.');
INSERT INTO olibdb VALUES('d','ElementaryFunctionsUnivariatePuiseuxSeries',4,'n','(Coef:Algebra(Fraction(Integer)),ULS:UnivariateLaurentSeriesCategory(Coef),UPXS:UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS),PartialTranscendentalFunctions(ULS))->Join(PartialTranscendentalFunctions(UPXS),etc)','(Coef,ULS,UPXS,EFULS)','EFUPXS','\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We also provide ''partial functions'' which compute transcendental functions of Laurent series when possible and return failed when this is not possible.');
INSERT INTO olibdb VALUES('d','Enumeration',1,'x','special','(a,b,...,c)','ENUM','\spad{Enumeration(a,b,...,c)} is a primitive type in FriCAS used to represent the object composed of the symbols \spad{a},\spad{b},..., and \spad{c}.');
INSERT INTO olibdb VALUES('d','EqTable',2,'n','(SetCategory,Entry:Type)->Join(TableAggregate(Key,Entry),etc)','(Key,Entry)','EQTBL','This domain provides tables where the keys are compared using \spadfun{eq?}. Thus keys are considered equal only if they are the same instance of a structure.');
INSERT INTO olibdb VALUES('d','Equation',1,'x','(Type)->Join(Type,etc)','(S)','EQ','Equations as mathematical objects. All properties of the basis domain,{} \spadignore{e.g.} being an abelian group are carried over the equation domain,{} by performing the structural operations on the left and on the right hand side.');
INSERT INTO olibdb VALUES('d','EuclideanModularRing',6,'n','(S:CommutativeRing,R:UnivariatePolynomialCategory(S),Mod:AbelianMonoid,(R,Mod)->R,(Mod,Mod)->Union(Mod,failed),(R,R,Mod)->Union(R,failed))->Join(EuclideanDomain,etc)','(S,R,Mod,reduction,merge,exactQuo)','EMR','These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{ModularRing},{} \spadtype{ModularField}');
INSERT INTO olibdb VALUES('d','Exit',0,'x','()->SetCategory',NULL,'EXIT','A function which does not return directly to its caller should have Exit as its return type. \blankline Note: It is convenient to have a formal \spad{coerce} into each type from type Exit. This allows,{} for example,{} errors to be raised in one half of a type-balanced \spad{if}.');
INSERT INTO olibdb VALUES('d','ExponentialExpansion',4,'n','(R:Join(Comparable,etc),FE:Join(AlgebraicallyClosedField,etc),var:Symbol,cen:FE)->Join(QuotientFieldCategory(UnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,var,cen)),etc)','(R,FE,var,cen)','EXPEXPAN','UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent essential singularities of functions. Objects in this domain are quotients of sums,{} where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series.');
INSERT INTO olibdb VALUES('d','ExponentialOfUnivariatePuiseuxSeries',3,'n','(FE:Join(Field,etc),var:Symbol,cen:FE)->Join(UnivariatePuiseuxSeriesCategory(FE),etc)','(FE,var,cen)','EXPUPXS','ExponentialOfUnivariatePuiseuxSeries is a domain used to represent essential singularities of functions. An object in this domain is a function of the form \spad{exp(f(x))},{} where \spad{f(x)} is a Puiseux series with no terms of non-negative degree. Objects are ordered according to order of singularity,{} with functions which tend more rapidly to zero or infinity considered to be larger. Thus,{} if \spad{order(f(x)) < order(g(x))},{} \spadignore{i.e.} the first non-zero term of \spad{f(x)} has lower degree than the first non-zero term of \spad{g(x)},{} then \spad{exp(f(x)) > exp(g(x))}. If \spad{order(f(x)) = order(g(x))},{} then the ordering is essentially random. This domain is used in computing limits involving functions with essential singularities.');
INSERT INTO olibdb VALUES('d','Expression',1,'x','(Comparable)->Join(FunctionSpace(R),etc)','(R)','EXPR','Expressions involving symbolic functions.');
INSERT INTO olibdb VALUES('d','ExtAlgBasis',0,'n','()->Join(OrderedSet,etc)',NULL,'EAB','A domain used in the construction of the exterior algebra on a set \spad{X} over a ring \spad{R}. This domain represents the set of all ordered subsets of the set \spad{X},{} assumed to be in correspondence with {1,{} 2,{} 3,{} ...}. The ordered subsets are themselves ordered lexicographically and are in bijective correspondence with an ordered basis of the exterior algebra. In this domain we are dealing strictly with the exponents of basis elements which can only be 0 or 1. \blankline The multiplicative identity element of the exterior algebra corresponds to the empty subset of \spad{X}. A coerce from List Integer to an ordered basis element is provided to allow the convenient input of expressions. Another exported function forgets the ordered structure and simply returns the list corresponding to an ordered subset.');
INSERT INTO olibdb VALUES('d','Factored',1,'x','(IntegralDomain)->Join(IntegralDomain,etc)','(R)','FR','\spadtype{Factored} creates a domain whose objects are kept in factored form as long as possible. Thus certain operations like multiplication and \spad{gcd} are relatively easy to do. Others,{} like addition require somewhat more work,{} and unless the argument domain provides a factor function,{} the result may not be completely factored. Each object consists of a unit and a list of factors,{} where a factor has a member of \spad{R} (the base),{} and exponent and a flag indicating what is known about the base. A flag may be one of nil,{} sqfr,{} irred or prime,{} which respectively mean that nothing is known about the base,{} it is square-free,{} it is irreducible,{} or it is prime. The current restriction to integral domains allows simplification to be performed without worrying about multiplication order.');
INSERT INTO olibdb VALUES('d','FakePolynomial',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'FAKEPOL','FakePolynomial is a domain of univariate polynomials \indented{1}{with coefficients being fractions of multivariate integer} \indented{1}{polynomials.\space{2}Coefficients are kept in unsimplified form.} \indented{1}{This domain exists to avoid cost of recursive \spad{GCD} calls} \indented{1}{during polynomial evaluation.}');
INSERT INTO olibdb VALUES('d','File',1,'x','(SetCategory)->Join(FileCategory(FileName,S),etc)','(S)','FILE','This domain provides a basic model of files to save arbitrary values. The operations provide sequential access to the contents.');
INSERT INTO olibdb VALUES('d','FileName',0,'x','()->FileNameCategory',NULL,'FNAME','This domain provides an interface to names in the file system.');
INSERT INTO olibdb VALUES('d','FiniteBiCPO',1,'n','(SetCategory)->BiCPO(S)','(S)','FBICPO','Holds a complete set together with a structure to codify the partial order. For more documentation see: \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('d','FiniteCoDcpo',1,'n','(SetCategory)->CoDcpo(S)','(S)','FCDCPO','holds a complete set together with a structure to codify \indented{2}{the partial order.} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('d','FiniteCubicalComplex',1,'n','(AbelianGroup)->Join(SetCategory,etc)','(VS)','CUBEC','\indented{2}{A Finite Cubical Complex} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/cubical/} Date Created: April 2016 Basic Operations: Related packages: Related categories: Related Domains: Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','FiniteDcpo',1,'n','(SetCategory)->Dcpo(S)','(S)','FDCPO','holds a complete set together with a structure to codify \indented{2}{the partial order.} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('d','FiniteDivisor',4,'n','(F:Field,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F,UP,UPUP))->Join(FiniteDivisorCategory(F,UP,UPUP,R),etc)','(F,UP,UPUP,R)','FDIV','This domains implements finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{''s} are integers and the \spad{P}\spad{''s} are finite rational points on the curve.');
INSERT INTO olibdb VALUES('d','FiniteField',2,'x','(PositiveInteger,PositiveInteger)->FiniteAlgebraicExtensionField(PrimeField(p))','(p,n)','FF','FiniteField(\spad{p},{} \spad{n}) implements finite fields with \spad{p^n} elements. This packages checks that \spad{p} is prime. For a non-checking version,{} see \spadtype{InnerFiniteField}.');
INSERT INTO olibdb VALUES('d','FiniteFieldCyclicGroup',2,'x','(PositiveInteger,PositiveInteger)->Join(FiniteAlgebraicExtensionField(PrimeField(p)),etc)','(p,extdeg)','FFCG','FiniteFieldCyclicGroup(\spad{p},{} \spad{n}) implements a finite field extension of degee \spad{n} over the prime field with \spad{p} elements. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by {\em createPrimitivePoly} from \spadtype{FiniteFieldPolynomialPackage}. The Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.');
INSERT INTO olibdb VALUES('d','FiniteFieldCyclicGroupExtension',2,'n','(FiniteFieldCategory,PositiveInteger)->Join(FiniteAlgebraicExtensionField(GF),etc)','(GF,extdeg)','FFCGX','FiniteFieldCyclicGroupExtension(\spad{GF},{} \spad{n}) implements a extension of degree \spad{n} over the ground field {\em GF}. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by {\em createPrimitivePoly} from \spadtype{FiniteFieldPolynomialPackage}. Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.');
INSERT INTO olibdb VALUES('d','FiniteFieldCyclicGroupExtensionByPolynomial',2,'n','(GF:FiniteFieldCategory,SparseUnivariatePolynomial(GF))->Join(FiniteAlgebraicExtensionField(GF),etc)','(GF,defpol)','FFCGP','FiniteFieldCyclicGroupExtensionByPolynomial(\spad{GF},{} defpol) implements a finite extension field of the ground field {\em GF}. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial {\em defpol},{} which MUST be primitive (user responsibility). Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.');
INSERT INTO olibdb VALUES('d','FiniteFieldExtension',2,'n','(FiniteFieldCategory,PositiveInteger)->FiniteAlgebraicExtensionField(GF)','(GF,n)','FFX','FiniteFieldExtensionByPolynomial(\spad{GF},{} \spad{n}) implements an extension of the finite field {\em GF} of degree \spad{n} generated by the extension polynomial constructed by \spadfunFrom{createIrreduciblePoly}{FiniteFieldPolynomialPackage} from \spadtype{FiniteFieldPolynomialPackage}.');
INSERT INTO olibdb VALUES('d','FiniteFieldExtensionByPolynomial',2,'n','(GF:FiniteFieldCategory,SparseUnivariatePolynomial(GF))->FiniteAlgebraicExtensionField(GF)','(GF,defpol)','FFP','FiniteFieldExtensionByPolynomial(\spad{GF},{} defpol) implements the extension of the finite field {\em GF} generated by the extension polynomial {\em defpol} which MUST be irreducible. Note: the user has the responsibility to ensure that {\em defpol} is irreducible.');
INSERT INTO olibdb VALUES('d','FiniteFieldNormalBasis',2,'x','(PositiveInteger,PositiveInteger)->Join(FiniteAlgebraicExtensionField(PrimeField(p)),etc)','(p,extdeg)','FFNB','FiniteFieldNormalBasis(\spad{p},{} \spad{n}) implements a finite extension field of degree \spad{n} over the prime field with \spad{p} elements. The elements are represented by coordinate vectors with respect to a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-powers) of an element,{} in this case called normal element. This is chosen as a root of the extension polynomial created by \spadfunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}.');
INSERT INTO olibdb VALUES('d','FiniteFieldNormalBasisExtension',2,'n','(FiniteFieldCategory,PositiveInteger)->Join(FiniteAlgebraicExtensionField(GF),etc)','(GF,extdeg)','FFNBX','FiniteFieldNormalBasisExtensionByPolynomial(\spad{GF},{} \spad{n}) implements a finite extension field of degree \spad{n} over the ground field {\em GF}. The elements are represented by coordinate vectors with respect to a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-powers) of an element,{} in this case called normal element. This is chosen as a root of the extension polynomial,{} created by {\em createNormalPoly} from \spadtype{FiniteFieldPolynomialPackage}');
INSERT INTO olibdb VALUES('d','FiniteFieldNormalBasisExtensionByPolynomial',2,'n','(GF:FiniteFieldCategory,Union(SparseUnivariatePolynomial(GF),Vector(List(Record(value:GF,index:SingleInteger)))))->Join(FiniteAlgebraicExtensionField(GF),etc)','(GF,uni)','FFNBP','FiniteFieldNormalBasisExtensionByPolynomial(\spad{GF},{} uni) implements a finite extension of the ground field {\em GF}. The elements are represented by coordinate vectors with respect to. a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-powers) of an element,{} in this case called normal element,{} where \spad{q} is the size of {\em GF}. The normal element is chosen as a root of the extension polynomial,{} which MUST be normal over {\em GF} (user responsibility)');
INSERT INTO olibdb VALUES('d','FiniteLattice',2,'n','(S:SetCategory,FiniteBiCPO(S))->Join(Lattice,etc)','(S,p)','FINLAT','This is the algebration of poset. A big difference between \indented{3}{this lattice domain and the poset domain is that,{} in this domain,{} the} \indented{3}{REP holds a single node whereas in poset REP holds the whole poset.} Date Created: Aug 2015');
INSERT INTO olibdb VALUES('d','FiniteMoebiusFunction',1,'n','(Join(PartialOrder,etc))->Join(SetCategory,etc)','(P)','FMOEBF','A domain for Moebius functions of explicit subposets of infinite posets.');
INSERT INTO olibdb VALUES('d','FinitePoset',1,'n','(SetCategory)->Poset(S)','(S)','FPOSET','holds a complete set together with a structure to codify \indented{2}{the partial order.} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('d','FiniteSimplicialComplex',1,'n','(AbelianGroup)->Join(SetCategory,etc)','(VS)','SIMPC','\indented{2}{A Finite Simplicial Complex} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/} Date Created: Dec 2015 Basic Operations: star,{} link,{} cone,{} product Related packages: Related categories: Related Domains: DeltaComplex is an alternative representation \indented{3}{which is less compact but allows edges,{} triangles,{} etc to be indexed.} Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','FlexibleArray',1,'x','(Type)->Join(OneDimensionalArrayAggregate(S),etc)','(S)','FARRAY','A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations \indented{2}{\spad{concat!(a,{} x)} meaning append item \spad{x} at the end of the array \spad{a}} \indented{2}{\spad{delete!(a,{} n)} meaning delete the last item from the array \spad{a}} Flexible arrays support the other operations inherited from \spadtype{ExtensibleLinearAggregate}. However,{} these are not efficient. Flexible arrays combine the \spad{O(1)} access time property of arrays with growing and shrinking at the end in \spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50\% larger) array. Conversely,{} when the array becomes less than 1/2 full,{} it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps,{} stacks and sets.');
INSERT INTO olibdb VALUES('d','Float',0,'x','()->Join(FloatingPointSystem,etc)',NULL,'FLOAT','\spadtype{Float} implements arbitrary precision floating point arithmetic. The number of significant digits of each operation can be set to an arbitrary value (the default is 20 decimal digits). The operation \spadfunFrom{float}{FloatingPointSystem}(mantissa,{} exponent,{} \spadfunFrom{base}{FloatingPointSystem}) for integer \spad{mantissa},{} \spad{exponent} specifies the number \spad{mantissa} * \spadfunFrom{base}{FloatingPointSystem} ^ \spad{exponent} The underlying representation for floats is binary not decimal. The implications of this are described below. \blankline The model adopted is that arithmetic operations are rounded to to nearest unit in the last place,{} that is,{} accurate to within 2^(-\spadfunFrom{bits}{FloatingPointSystem}). Also,{} the elementary functions and constants are accurate to one unit in the last place. A float is represented as a record of two integers,{} the mantissa and the exponent. The \spadfunFrom{base}{FloatingPointSystem} of the representation is binary,{} hence a \spad{Record(m: mantissa,{} e: exponent)} represents the number \spad{m * 2 ^ e}. Though it is not assumed that the underlying integers are represented with a binary \spadfunFrom{base}{FloatingPointSystem},{} the code will be most efficient when this is the the case (this is \spad{true} in most implementations of Lisp). The decision to choose the \spadfunFrom{base}{FloatingPointSystem} to be binary has some unfortunate consequences. First,{} decimal numbers like 0.3 cannot be represented exactly. Second,{} there is a further loss of accuracy during conversion to decimal for output. To compensate for this,{} if \spad{d} digits of precision are specified,{} \spad{1 + ceiling(log2(10^d))} bits are used. Two numbers that are displayed identically may therefore be not equal. On the other hand,{} a significant efficiency loss would be incurred if we chose to use a decimal \spadfunFrom{base}{FloatingPointSystem} when the underlying integer base is binary. \blankline Algorithms used: For the elementary functions,{} the general approach is to apply identities so that the taylor series can be used,{} and,{} so that it will converge within \spad{O( sqrt n )} steps. For example,{} using the identity \spad{exp(x) = exp(x/2)^2},{} we can compute \spad{exp(1/3)} to \spad{n} digits of precision as follows. We have \spad{exp(1/3) = exp(2 ^ (-sqrt s) / 3) ^ (2 ^ sqrt s)}. The taylor series will converge in less than sqrt \spad{n} steps and the exponentiation requires sqrt \spad{n} multiplications for a total of \spad{2 sqrt n} multiplications. Assuming integer multiplication costs \spad{O( n^2 )} the overall running time is \spad{O( sqrt(n) n^2 )}. This approach is the best known approach for precisions up to about 10,{} 000 digits at which point the methods of Brent which are \spad{O( log(n) n^2 )} become competitive. Note also that summing the terms of the taylor series for the elementary functions is done using integer operations. This avoids the overhead of floating point operations and results in efficient code at low precisions. This implementation makes no attempt to reuse storage,{} relying on the underlying system to do \spadgloss{garbage collection}. \spad{I} estimate that the efficiency of this package at low precisions could be improved by a factor of 2 if in-place operations were available. \blankline Running times: in the following,{} \spad{n} is the number of bits of precision \indented{5}{\spad{*},{} \spad{/},{} \spad{sqrt},{} \spad{\spad{pi}},{} \spad{exp1},{} \spad{log2},{} \spad{log10}: \spad{ O( n^2 )}} \indented{5}{\spad{exp},{} \spad{log},{} \spad{sin},{} \spad{atan}:\space{2}\spad{ O( sqrt(n) n^2 )}} The other elementary functions are coded in terms of the ones above.');
INSERT INTO olibdb VALUES('d','Format1D',0,'n','()->FormatterCategory',NULL,'FMT1D','\indented{1}{\spadtype{Format1D} provides a coercion from \spadtype{OutputForm}} to a one-dimensional format such that the output can be pasted back as input,{}');
INSERT INTO olibdb VALUES('d','Format2D',0,'n','()->FormatterCategory',NULL,'FMT2D','\indented{1}{\spadtype{Format2D} provides a coercion from} \spadtype{OutputForm} to two-dimensional format.');
INSERT INTO olibdb VALUES('d','FormatLaTeX',0,'n','()->Join(FormatterCategory,etc)',NULL,'FMTLATEX','\indented{1}{\spadtype{FormatLaTeX} provides a coercion from} \spadtype{OutputForm} to \LaTeX{} format. The particular dialect of \TeX{} used is \LaTeX{},{} but for flexibility reasons \spadtype{FormatLaTeX} outputs everything into a fricasmath environment in which certain additional commands are available. These commands are defined in a .sty file that is distributed with the source code of FriCAS.');
INSERT INTO olibdb VALUES('d','FormatMathJax',0,'n','()->Join(FormatterCategory,etc)',NULL,'FMTMJAX','\indented{1}{\spadtype{FormatMathJax} provides a coercion from} \spadtype{OutputForm} to a \LaTeX{} format in a variant that can be understood by MahtJax (https://www.mathjax.org).');
INSERT INTO olibdb VALUES('d','FormattedOutput',0,'n','()->Join(OutputFormatterCategory,etc)',NULL,'FMTOUT','\indented{1}{The domain \spad{FormattedOutput} is used when} )set output formatted on is issued on the command line. Then for each formatter that is stored in the internal data structure of \spad{FormattedOutput}');
INSERT INTO olibdb VALUES('d','Formatter',1,'n','(FormatterCategory)->Join(OutputFormatterCategory,etc)','(F)','FORMAT',NULL);
INSERT INTO olibdb VALUES('d','FortranCode',0,'n','()->Join(SetCategory,etc)',NULL,'FC','This domain builds representations of program code segments for use with the FortranProgram domain.');
INSERT INTO olibdb VALUES('d','FortranExpression',3,'n','(List(Symbol),List(Symbol),R:FortranMachineTypeCategory)->Join(ExpressionSpace,etc)','(basicSymbols,subscriptedSymbols,R)','FEXPR','A domain of expressions involving functions which can be translated into standard Fortran-77,{} with some extra extensions from the NAG Fortran Library.');
INSERT INTO olibdb VALUES('d','FortranFormat',0,'n','()->OutputFormatterCategory',NULL,'FORTFORM',NULL);
INSERT INTO olibdb VALUES('d','FortranProgram',4,'n','(Symbol,Union(fst:FortranScalarType,void:void),List(Symbol),SymbolTable)->Join(FortranProgramCategory,etc)','(name,returnType,arguments,symbols)','FORTRAN','\spadtype{FortranProgram} allows the user to build and manipulate simple models of FORTRAN subprograms. These can then be transformed into actual FORTRAN notation.');
INSERT INTO olibdb VALUES('d','FortranScalarType',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'FST','Creates and manipulates objects which correspond to the basic FORTRAN data types: REAL,{} INTEGER,{} COMPLEX,{} LOGICAL and CHARACTER');
INSERT INTO olibdb VALUES('d','FortranTemplate',0,'n','()->Join(FileCategory(FileName,String),etc)',NULL,'FTEM','Code to manipulate Fortran templates');
INSERT INTO olibdb VALUES('d','FortranType',0,'n','()->Join(SetCategory,etc)',NULL,'FT','Creates and manipulates objects which correspond to FORTRAN data types,{} including array dimensions.');
INSERT INTO olibdb VALUES('d','FourierComponent',1,'n','(OrderedSet)->Join(OrderedSet,etc)','(E)','FCOMP','Domain representing components of Fourier series.');
INSERT INTO olibdb VALUES('d','FourierSeries',2,'x','(Join(CommutativeRing,etc),E:Join(OrderedSet,etc))->Join(Algebra(R),etc)','(R,E)','FSERIES','Domain of Fourier series.');
INSERT INTO olibdb VALUES('d','Fraction',1,'x','(IntegralDomain)->Join(QuotientFieldCategory(S),etc)','(S)','FRAC','Fraction takes an IntegralDomain \spad{S} and produces the domain of Fractions with numerators and denominators from \spad{S}. If \spad{S} is also a GcdDomain,{} then \spad{gcd}\spad{''s} between numerator and denominator will be cancelled during all operations.');
INSERT INTO olibdb VALUES('d','FractionalIdeal',4,'n','(R:EuclideanDomain,F:QuotientFieldCategory(R),UP:UnivariatePolynomialCategory(F),A:Join(FramedAlgebra(F,UP),etc))->Join(Group,etc)','(R,F,UP,A)','FRIDEAL','Fractional ideals in a framed algebra.');
INSERT INTO olibdb VALUES('d','FractionalIdealAsModule',5,'n','(R:EuclideanDomain,F:QuotientFieldCategory(R),UP:UnivariatePolynomialCategory(F),A:FramedAlgebra(F,UP),Vector(A))->Join(Monoid,etc)','(R,F,UP,A,ibasis)','FRIMOD','Module representation of fractional ideals.');
INSERT INTO olibdb VALUES('d','FreeDivisionAlgebra',2,'n','(OrderedSet,F:Field)->Join(DivisionRing,etc)','(VAR,F)','FDALG','The elements of the Free Field are represented by Admissible Linear Systems (ALS) in standard form ...');
INSERT INTO olibdb VALUES('d','FreeGroup',1,'n','(SetCategory)->Join(Group,etc)','(S)','FGROUP','The free group on a set \spad{S} is the group of finite products of the form \spad{reduce(*,{} [\spad{si} ^ \spad{ni}])} where the \spad{si}\spad{''s} are in \spad{S},{} and the \spad{ni}\spad{''s} are integers. The multiplication is not commutative.');
INSERT INTO olibdb VALUES('d','FreeMagma',1,'n','(OrderedSet)->Join(OrderedSet,etc)','(VarSet)','FMAGMA','This type is the basic representation of parenthesized words (binary trees over arbitrary symbols) useful in \spadtype{LiePolynomial}. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','FreeModule',2,'n','(Join(SemiRng,etc),S:SetCategory)->Join(BiModule(R,R),etc)','(R,S)','FM','A \spad{bi}-module is a free module over a ring with generators indexed by an ordered set. Each element can be expressed as a finite linear combination of generators. Only non-zero terms are stored. old domain \spad{FreeModule1} was merged to it in May 2009 The description of the latter: \indented{2}{This domain implements linear combinations} \indented{2}{of elements from the domain \spad{S} with coefficients} \indented{2}{in the domain \spad{R} where \spad{S} is an ordered set} \indented{2}{and \spad{R} is a ring (which may be non-commutative).} \indented{2}{This domain is used by domains of non-commutative algebra such as:} \indented{6}{\spadtype{XDistributedPolynomial},{}} \indented{6}{\spadtype{XRecursivePolynomial}.} \indented{2}{Author: Michel Petitot (petitot@lifl.\spad{fr})}');
INSERT INTO olibdb VALUES('d','FreeMonoid',1,'n','(SetCategory)->Join(Monoid,etc)','(S)','FMONOID','The free monoid on a set \spad{S} is the monoid of finite products of the form \spad{reduce(*,{} [\spad{si} ^ \spad{ni}])} where the \spad{si}\spad{''s} are in \spad{S},{} and the \spad{ni}\spad{''s} are nonnegative integers. The multiplication is not commutative. When \spad{S} is an OrderedSet,{} then FreeMonoid(\spad{S}) has order: for two elements \spad{x} and \spad{y} the relation \spad{x < y} holds if either \spad{length(x) < length(y)} holds or if these lengths are equal and if \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \spad{S}.');
INSERT INTO olibdb VALUES('d','FreeNilpotentLie',3,'x','(NonNegativeInteger,NonNegativeInteger,R:CommutativeRing)->Join(NonAssociativeAlgebra(R),etc)','(n,class,R)','FNLA','Generate the Free Lie Algebra over a ring \spad{R} with identity; A \spad{P}. Hall basis is generated by a package call to HallBasis.');
INSERT INTO olibdb VALUES('d','FullPartialFractionExpansion',2,'x','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F))->Join(SetCategory,etc)','(F,UP)','FPARFRAC','Full partial fraction expansion of rational functions.');
INSERT INTO olibdb VALUES('d','FunctionCalled',1,'n','(Symbol)->Join(SetCategory,etc)','(f)','FUNCTION','This domain implements named functions');
INSERT INTO olibdb VALUES('d','FunctionGraph',1,'n','(SetCategory)->Join(FiniteGraph(S),etc)','(S)','FNGRPH','allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('d','GeneralDistributedMultivariatePolynomial',3,'n','(vl:List(Symbol),R:Ring,E:DirectProductCategory(#(vl),NonNegativeInteger))->Join(PolynomialCategory(R,E,OrderedVariableList(vl)),etc)','(vl,R,E)','GDMP','\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is specified by its third parameter. Suggested types which define term orderings include: \spadtype{DirectProduct},{} \spadtype{HomogeneousDirectProduct},{} \spadtype{SplitHomogeneousDirectProduct} and finally \spadtype{OrderedDirectProduct} which accepts an arbitrary user function to define a term ordering.');
INSERT INTO olibdb VALUES('d','GeneralizedFiniteMoebiusFunction',2,'n','(Join(PartialOrder,etc),R:Field)->etc','(P,R)','GENMOEBF','A domain for generalized Moebius functions of explicit subposets.');
INSERT INTO olibdb VALUES('d','GeneralizedUnivariatePowerSeries',4,'n','(Coef:Ring,Expon:Join(OrderedAbelianMonoid,etc),Symbol,Coef)->Join(UnivariatePowerSeriesCategory(Coef,Expon),etc)','(Coef,Expon,var,cen)','GENUSER','Domain for univariate power series with variable \indented{1}{coefficients.}');
INSERT INTO olibdb VALUES('d','GeneralModulePolynomial',6,'n','(vl:List(Symbol),R:CommutativeRing,IS:OrderedSet,E:DirectProductCategory(#(vl),NonNegativeInteger),ff:(Record(index:IS,exponent:E),Record(index:IS,exponent:E))->Boolean,P:PolynomialCategory(R,E,OrderedVariableList(vl)))->Join(Module(P),etc)','(vl,R,IS,E,ff,P)','GMODPOL','This package \undocumented');
INSERT INTO olibdb VALUES('d','GeneralPolynomialSet',4,'n','(R:Ring,E:OrderedAbelianMonoidSup,VarSet:OrderedSet,P:RecursivePolynomialCategory(R,E,VarSet))->Join(PolynomialSetCategory(R,E,VarSet,P),etc)','(R,E,VarSet,P)','GPOLSET','A domain for polynomial sets.');
INSERT INTO olibdb VALUES('d','GeneralQuaternion',3,'n','(R:CommutativeRing,R,R)->QuaternionCategory(R)','(R,p,q)','QUAT2','\spadtype{GeneralQuaternion} implements general quaternions \indented{2}{over a commutative ring. The main constructor function is} \indented{2}{\spadfun{quatern} which takes 4 arguments: the real part,{}} \indented{2}{the \spad{i} imaginary part,{} the \spad{j} imaginary part and the \spad{k} imaginary part.}');
INSERT INTO olibdb VALUES('d','GeneralSparseTable',4,'n','(Key:SetCategory,Entry:BasicType,TableAggregate(Key,Entry),Entry)->TableAggregate(Key,Entry)','(Key,Entry,Tbl,dent)','GSTBL','A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key.');
INSERT INTO olibdb VALUES('d','GeneralTriangularSet',4,'n','(R:IntegralDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->TriangularSetCategory(R,E,V,P)','(R,E,V,P)','GTSET','A domain constructor of the category \spadtype{TriangularSetCategory}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. Triangular sets are stored as sorted lists \spad{w}.\spad{r}.\spad{t}. the main variables of their members but they are displayed in reverse order.\newline');
INSERT INTO olibdb VALUES('d','GeneralUnivariatePowerSeries',3,'x','(Coef:Ring,var:Symbol,cen:Coef)->Join(UnivariatePuiseuxSeriesCategory(Coef),etc)','(Coef,var,cen)','GSERIES','This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{} f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x\^r)}.');
INSERT INTO olibdb VALUES('d','GenericNonAssociativeAlgebra',4,'n','(R:CommutativeRing,n:PositiveInteger,List(Symbol),Vector(Matrix(R)))->Join(FramedNonAssociativeAlgebra(Fraction(Polynomial(R))),etc)','(R,n,ls,gamma)','GCNAALG','AlgebraGenericElementPackage allows you to create generic elements of an algebra,{} \spadignore{i.e.} the scalars are extended to include symbolic coefficients');
INSERT INTO olibdb VALUES('d','GraphImage',0,'n','()->Join(SetCategory,etc)',NULL,'GRIMAGE','TwoDimensionalGraph creates virtual two dimensional graphs (to be displayed on TwoDimensionalViewports).');
INSERT INTO olibdb VALUES('d','GroupPresentation',0,'n','()->Join(SetCategory,etc)',NULL,'GROUPP','\indented{2}{Group represented by its generators and relations.} \indented{2}{Here we use it to hold homotopy group such as fundamental group.} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/finiteGroup/presentation/} Date Created: Jan 2016 Basic Operations: Related packages: Related categories: Related Domains: PermutationGroup Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','GuessOption',0,'x','()->Join(SetCategory,etc)',NULL,'GOPT','GuessOption is a domain whose elements are various options used by \spadtype{Guess}.');
INSERT INTO olibdb VALUES('d','GuessOptionFunctions0',0,'n','()->Join(SetCategory,etc)',NULL,'GOPT0','\spad{GuessOptionFunctions0} provides operations that extract the values of options for \spadtype{Guess}.');
INSERT INTO olibdb VALUES('d','HashState',0,'n','()->etc',NULL,'HASHSTAT','This domain supports incremental computation of hash values.');
INSERT INTO olibdb VALUES('d','HashTable',3,'n','(SetCategory,Entry:Type,String)->Join(TableAggregate(Key,Entry),etc)','(Key,Entry,hashfn)','HASHTBL','This domain provides access to the underlying Lisp hash tables. By varying the hashfn parameter,{} tables suited for different purposes can be obtained.');
INSERT INTO olibdb VALUES('d','Heap',1,'x','(OrderedSet)->Join(PriorityQueueAggregate(S),etc)','(S)','HEAP','Heap implemented in a flexible array to allow for insertions');
INSERT INTO olibdb VALUES('d','HexadecimalExpansion',0,'x','()->Join(QuotientFieldCategory(Integer),etc)',NULL,'HEXADEC','This domain allows rational numbers to be presented as repeating hexadecimal expansions.');
INSERT INTO olibdb VALUES('d','HomogeneousDirectProduct',2,'n','(NonNegativeInteger,S:OrderedAbelianMonoid)->DirectProductCategory(dim,S)','(dim,S)','HDP','\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered first by the sum of their components,{} and then refined using a reverse lexicographic ordering. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.');
INSERT INTO olibdb VALUES('d','HomogeneousDistributedMultivariatePolynomial',2,'n','(List(Symbol),R:Ring)->Join(PolynomialCategory(R,HomogeneousDirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl)),etc)','(vl,R)','HDMP','\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is total degree ordering refined by reverse lexicographic ordering with respect to the position that the variables appear in the list of variables parameter.');
INSERT INTO olibdb VALUES('d','Homology',0,'n','()->Join(SetCategory,etc)',NULL,'HOMOL','\indented{2}{Intended to hold homology which is calculated using SmithNormalForm:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/} Date Created: June 2016 Basic Operations: Related packages: Related categories: Related Domains: FreeModule,{} FiniteSimplicialComplex Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','HTMLFormat',0,'n','()->Join(SetCategory,etc)',NULL,'HTMLFORM','\spadtype{HtmlFormat} provides a coercion from \spadtype{OutputForm} to html.');
INSERT INTO olibdb VALUES('d','HyperellipticFiniteDivisor',4,'n','(F:Field,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F,UP,UPUP))->FiniteDivisorCategory(F,UP,UPUP,R)','(F,UP,UPUP,R)','HELLFDIV','This domains implements finite rational divisors on an hyperelliptic curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{''s} are integers and the \spad{P}\spad{''s} are finite rational points on the curve. The equation of the curve must be \spad{y^2} = \spad{f}(\spad{x}) and \spad{f} must have odd degree.');
INSERT INTO olibdb VALUES('d','I16Matrix',0,'n','()->MatrixCategory(Integer,I16Vector,I16Vector)',NULL,'I16MAT','This is a low-level domain which implements matrices (two dimensional arrays) of 16-bit signed integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','I16Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'I16VEC','This is a low-level domain which implements vectors (one dimensional arrays) of signed 16-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','I32Matrix',0,'n','()->MatrixCategory(Integer,I32Vector,I32Vector)',NULL,'I32MAT','This is a low-level domain which implements matrices (two dimensional arrays) of signed 32-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','I32Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'I32VEC','This is a low-level domain which implements vectors (one dimensional arrays) of signed 32-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','I8Matrix',0,'n','()->MatrixCategory(Integer,I8Vector,I8Vector)',NULL,'I8MAT','This is a low-level domain which implements matrices (two dimensional arrays) of 8-bit signed integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','I8Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'I8VEC','This is a low-level domain which implements vectors (one dimensional arrays) of signed 8-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','ILogic',0,'n','()->Join(BoundedLattice,etc)',NULL,'ILOGIC','ILogic is an algebra with \spad{true},{} \spad{false} and other ''unproven'' values');
INSERT INTO olibdb VALUES('d','IncidenceAlgebra',2,'n','(Ring,S:SetCategory)->Join(SetCategory,etc)','(R,S)','INCALG','A domain for incidence matrices of finite posets.');
INSERT INTO olibdb VALUES('d','IndexCard',0,'x','()->Join(OrderedSet,etc)',NULL,'ICARD','\indented{1}{This domain implements a container of information} about the FriCAS library');
INSERT INTO olibdb VALUES('d','IndexedBits',1,'n','(Integer)->Join(BitAggregate,etc)','(mn)','IBITS','\spadtype{IndexedBits} is a domain to compactly represent large quantities of Boolean data.');
INSERT INTO olibdb VALUES('d','IndexedDirectProductObject',2,'n','(SetCategory,S:SetCategory)->Join(IndexedDirectProductCategory(A,S),etc)','(A,S)','IDPO','Indexed direct products of objects over a set \spad{A} of generators indexed by an ordered set \spad{S}. It currently provides the ground for,{} \spadignore{e.g.} \spadtype{FreeModule} which lies at the basis of polynomials of all sorts. All items have finite support. If A is a monoid,{} then only non-zero terms are stored. If A has additive structure,{} it is propagated coordinatewise to the product. Similarly,{} comparisons are propagated using lexicographic ordering.');
INSERT INTO olibdb VALUES('d','IndexedExponents',1,'n','(OrderedSet)->Join(OrderedAbelianMonoidSup,etc)','(Varset)','INDE','\indented{2}{IndexedExponents of an ordered set of variables gives a representation} for the degree of polynomials in commuting variables. It gives an ordered pairing of non negative integer exponents with variables');
INSERT INTO olibdb VALUES('d','IndexedFlexibleArray',2,'n','(Type,Integer)->Join(OneDimensionalArrayAggregate(S),etc)','(S,mn)','IFARRAY','A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations \indented{2}{\spad{concat!(a,{} x)} meaning append item \spad{x} at the end of the array \spad{a}} \indented{2}{\spad{delete!(a,{} n)} meaning delete the last item from the array \spad{a}} Flexible arrays support the other operations inherited from \spadtype{ExtensibleLinearAggregate}. However,{} these are not efficient. Flexible arrays combine the \spad{O(1)} access time property of arrays with growing and shrinking at the end in \spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50\% larger) array. Conversely,{} when the array becomes less than 1/2 full,{} it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps,{} stacks and sets.');
INSERT INTO olibdb VALUES('d','IndexedJetBundle',5,'n','(Symbol,Symbol,Symbol,PositiveInteger,PositiveInteger)->JetBundleCategory','(x,u,p,n,m)','IJB','\spadtype{JetBundle} provides the standard implementation for a jet bundle with a given number of dependent and independent variables.');
INSERT INTO olibdb VALUES('d','IndexedList',2,'n','(Type,Integer)->ListAggregate(S)','(S,mn)','ILIST','\spadtype{IndexedList} is an implementation of \spadtype{ListAggregate},{} the beginning index of the list is the second parameter to the constructor (\spad{mn}). That is,{} if \spad{l} is a list,{} then \spad{elt(l,{} mn)} is the first value.');
INSERT INTO olibdb VALUES('d','IndexedMatrix',3,'n','(AbelianMonoid,mnRow:Integer,mnCol:Integer)->MatrixCategory(R,IndexedVector(R,mnCol),IndexedVector(R,mnRow))','(R,mnRow,mnCol)','IMATRIX','An \spad{IndexedMatrix} is a matrix where the minimal row and column indices are parameters of the type. The domains Row and Col are both IndexedVectors. The index of the ''first'' row may be obtained by calling the function \spadfun{minRowIndex}. The index of the ''first'' column may be obtained by calling the function \spadfun{minColIndex}. The index of the first element of a ''Row'' is the same as the index of the first column in a matrix and vice versa.');
INSERT INTO olibdb VALUES('d','IndexedOneDimensionalArray',2,'n','(Type,Integer)->OneDimensionalArrayAggregate(S)','(S,mn)','IARRAY1','This is the basic one dimensional array data type.');
INSERT INTO olibdb VALUES('d','IndexedString',1,'n','(Integer)->StringAggregate','(mn)','ISTRING','This domain implements low-level strings');
INSERT INTO olibdb VALUES('d','IndexedTwoDimensionalArray',3,'n','(Type,mnRow:Integer,mnCol:Integer)->TwoDimensionalArrayCategory(R,IndexedOneDimensionalArray(R,mnCol),IndexedOneDimensionalArray(R,mnRow))','(R,mnRow,mnCol)','IARRAY2','\indented{1}{An IndexedTwoDimensionalArray is a 2-dimensional array where} the minimal row and column indices are parameters of the type. Rows and columns are returned as IndexedOneDimensionalArray\spad{''s} with minimal indices matching those of the IndexedTwoDimensionalArray. The index of the ''first'' row may be obtained by calling the function ''minRowIndex''. The index of the ''first'' column may be obtained by calling the function ''minColIndex''. The index of the first element of a ''Row'' is the same as the index of the first column in an array and vice versa.');
INSERT INTO olibdb VALUES('d','IndexedVector',2,'n','(Type,Integer)->VectorCategory(R)','(R,mn)','IVECTOR','\indented{2}{This type represents vector like objects with varying lengths} and a user-specified initial index.');
INSERT INTO olibdb VALUES('d','InfiniteCyclicGroup',1,'n','(Symbol)->Join(Group,etc)','(g)','INFCG','Infinite cyclic groups.');
INSERT INTO olibdb VALUES('d','InfiniteTuple',1,'x','(Type)->Join(CoercibleTo(OutputForm),etc)','(S)','ITUPLE','\indented{1}{This package implements ''infinite tuples'' for the interpreter.} The representation is a stream.');
INSERT INTO olibdb VALUES('d','InnerFiniteField',2,'n','(PositiveInteger,PositiveInteger)->FiniteAlgebraicExtensionField(InnerPrimeField(p))','(p,n)','IFF','InnerFiniteField(\spad{p},{} \spad{n}) implements finite fields with \spad{p^n} elements where \spad{p} is assumed prime but does not check. For a version which checks that \spad{p} is prime,{} see \spadtype{FiniteField}.');
INSERT INTO olibdb VALUES('d','InnerIndexedTwoDimensionalArray',5,'n','(R:Type,Integer,Integer,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R))->TwoDimensionalArrayCategory(R,Row,Col)','(R,mnRow,mnCol,Row,Col)','IIARRAY2','\indented{1}{This is an internal type which provides an implementation of} 2-dimensional arrays as PrimitiveArray\spad{''s} of PrimitiveArray\spad{''s}.');
INSERT INTO olibdb VALUES('d','InnerPAdicInteger',2,'n','(Integer,Boolean)->PAdicIntegerCategory(p)','(p,unBalanced?)','IPADIC','This domain implements \spad{Zp},{} the \spad{p}-adic completion of the integers. This is an internal domain.');
INSERT INTO olibdb VALUES('d','InnerPrimeField',1,'n','(PositiveInteger)->Join(FiniteFieldCategory,etc)','(p)','IPF','InnerPrimeField(\spad{p}) implements the field with \spad{p} elements by using IntegerMod \spad{p}. Note: argument \spad{p} MUST be a prime (this domain does not check). See \spadtype{PrimeField} for a domain that does check. In addition to the inherited operations of IntegerMod \spad{p},{} the domain provides exploits the structure of the cyclic group of its invertible elements. It stores a primitive element \spad{w},{} \spad{i}.a. generator of this group and it stores a logarithm table for \spad{w} as soon as this is required. sqrt was added in 2018.');
INSERT INTO olibdb VALUES('d','InnerSparseUnivariatePowerSeries',1,'n','(Ring)->Join(UnivariatePowerSeriesCategory(Coef,Integer),etc)','(Coef)','ISUPS','InnerSparseUnivariatePowerSeries is an internal domain \indented{2}{used for creating sparse Taylor and Laurent series.}');
INSERT INTO olibdb VALUES('d','InnerTable',3,'n','(Key:SetCategory,Entry:Type,Join(TableAggregate(Key,Entry),etc))->Join(TableAggregate(Key,Entry),etc)','(Key,Entry,addDom)','INTABL','This domain is used to provide a conditional add domain for the implementation of \spadtype{Table}.');
INSERT INTO olibdb VALUES('d','InnerTaylorSeries',1,'n','(Ring)->Join(Ring,etc)','(Coef)','ITAYLOR','Internal package for dense Taylor series. This is an internal Taylor series type in which Taylor series are represented by a \spadtype{Stream} of \spadtype{Ring} elements. For univariate series,{} the \spad{Stream} elements are the Taylor coefficients. For multivariate series,{} the \spad{n}th Stream element is a form of degree \spad{n} in the power series variables.');
INSERT INTO olibdb VALUES('d','InputForm',0,'n','()->Join(SExpressionCategory(String,Symbol,Integer,DoubleFloat),etc)',NULL,'INFORM','Domain of parsed forms which can be passed to the interpreter. This is also the interface between algebra code and facilities in the interpreter.');
INSERT INTO olibdb VALUES('d','Integer',0,'x','()->Join(IntegerNumberSystem,etc)',NULL,'INT','\spadtype{Integer} provides the domain of arbitrary precision integers.');
INSERT INTO olibdb VALUES('d','IntegerLocalizedAtPrime',1,'n','(PositiveInteger)->Join(EuclideanDomain,etc)','(p)','INTLOCP','IntegerLocalizedAtPrime(\spad{p}) represents the Euclidean domain of integers localized at a prime \spad{p},{} \spadignore{i.e.} the set of rational numbers whose denominator is not divisible by \spad{p}.');
INSERT INTO olibdb VALUES('d','IntegerMod',1,'n','(PositiveInteger)->Join(CommutativeRing,etc)','(p)','ZMOD','IntegerMod(\spad{n}) creates the ring of integers reduced modulo the integer \spad{n}.');
INSERT INTO olibdb VALUES('d','IntegrationResult',1,'n','(Field)->Join(Module(Fraction(Integer)),etc)','(F)','IR','If a function \spad{f} has an elementary integral \spad{g},{} then \spad{g} can be written in the form \spad{g = h + c1 log(u1) + c2 log(u2) + ... + cn log(un)} where \spad{h},{} which is in the same field as \spad{f},{} is called the rational part of the integral,{} and \spad{c1 log(u1) + ... cn log(un)} is called the logarithmic part of the integral. This domain manipulates integrals represented in that form,{} by keeping both parts separately. The logs are not explicitly computed.');
INSERT INTO olibdb VALUES('d','Interval',1,'x','(Join(FloatingPointSystem,etc))->IntervalCategory(R)','(R)','INTRVL','\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: + This domain is an implementation of interval arithmetic and transcendental + functions over intervals.');
INSERT INTO olibdb VALUES('d','JetBundle',2,'n','(List(Symbol),List(Symbol))->Join(JetBundleCategory,etc)','(IVar,DVar)','JBUNDLE','\spad{JetBundle} implements a jet bundle of arbitrary order with given names for the independent and dependent variables. It supports only repeated index notation.');
INSERT INTO olibdb VALUES('d','JetBundleExpression',1,'n','(JetBundleCategory)->Join(JetBundleFunctionCategory(JB),etc)','(JB)','JBE','\spadtype{JetBundleExpression} defines expressions over a jet bundle based on \spadtype{Expression Integer}. It allows all kind of algebraic operations. \spad{simplify} is implemented using Groebner bases in polynomials over kernels. Thus it might not work correctly for general expressions. This also affects \spad{dimension}.');
INSERT INTO olibdb VALUES('d','JetBundleLinearFunction',2,'n','(JB:JetBundleCategory,D:JetBundleBaseFunctionCategory(JB))->Join(JetBundleFunctionCategory(JB),etc)','(JB,D)','JBLF','\spadtype{JetBundleLinearFunction} implements linear functions over a jet bundle. The coefficients are functions of the independent variables only.');
INSERT INTO olibdb VALUES('d','JetBundlePolynomial',2,'n','(Ring,JB:JetBundleCategory)->Join(JetBundleFunctionCategory(JB),etc)','(R,JB)','JBP','\spadtype{JetBundlePolynomial} implements polynomial sections over a jet bundle. The order is not fixed,{} thus jet variables of any order can appear.');
INSERT INTO olibdb VALUES('d','JetBundleSymAna',3,'n','(JetBundleCategory,Union(Symbol,List(Symbol)),Union(Symbol,List(Symbol)))->Join(JetBundleCategory,etc)','(JB1,xi,eta)','JBSA','\spad{JetBundleSymAna} is only necessary to have a valid return type for some procedures in \spad{SymmetryAnalysis}. It is essentially identical with \spad{JetBundle} but computes its parameters in a more complicated way.');
INSERT INTO olibdb VALUES('d','JetBundleXExpression',1,'n','(JetBundleCategory)->Join(JetBundleFunctionCategory(JB),etc)','(JB)','JBX','\spadtype{JetBundleXExpression} implements arbitrary functions in a jet bundle which depend only on the independent variables \spad{x}. Otherwise it is identical with \spadtype{JetBundleExpression}. Such a domain is needed for \spadtype{JetLinearFunction}.');
INSERT INTO olibdb VALUES('d','JetDifferential',2,'n','(JB:JetBundleCategory,D:JetBundleFunctionCategory(JB))->Join(Module(D),etc)','(JB,D)','JDIFF','\spad{JetDifferential(JB,{} D)} implements differentials (one-forms) \indented{1}{over the jet bundle \spad{JB} with coefficients from \spad{D}.} \indented{1}{The differentials operate on \spad{JetVectorField(JB,{} D)}.}');
INSERT INTO olibdb VALUES('d','JetDifferentialEquation',2,'n','(JB:JetBundleCategory,D:JetBundleFunctionCategory(JB))->etc','(JB,D)','JDE','\spadtype{JetDifferentialEquation} provides the basic data structures and procedures for differential equations as needed in the geometric theory. Differential equation means here always a submanifold in the jet bundle. The concrete equations which define this submanifold are called system. In an object of the type \spadtype{JetDifferentialEquation} much more than only the system is stored. \spad{D} denotes the class of functions allowed as equations. It is assumed that the \spad{simplify} procedure of \spad{D} returns only independent equations and a system with symbol in row echelon form.');
INSERT INTO olibdb VALUES('d','JetLazyFunction',2,'n','(JB:JetBundleCategory,D:JetBundleFunctionCategory(JB))->Join(JetBundleFunctionCategory(JB),etc)','(JB,D)','JLF','\spadtype{JetLazyFunction} takes as argument a domain in \spadtype{JetBundleFunctionCategory} and returns another domain in the same category. This domain has basically the same properties as the argument domain,{} but there is a lazy evaluation mechanism for derivatives. This means that differentiations are not immediately performed. Instead a pointer is established to the function to be differentiated. Only when the exact value of the derivative is needed,{} the differentiation is executed. Special care is taken for leading derivatives and jet variables to avoid as much as possible the need to evaluate expressions. This entails that the result of \spad{jetVariables} may contain spurious variables. Furthermore many functions in \spadtype{JetLazyFunction} destructively change their arguments. This affects,{} however,{} only their internal representation,{} not the value obtained after full evaluation.');
INSERT INTO olibdb VALUES('d','JetVectorField',2,'n','(JB:JetBundleCategory,D:JetBundleFunctionCategory(JB))->Join(Module(D),etc)','(JB,D)','JVF','\spad{JetVectorField(JB,{} D)} implements vector fields over the jet bundle \spad{JB} with coefficients from \spad{D}. The fields operate on functions from \spad{D}.');
INSERT INTO olibdb VALUES('d','Kernel',1,'n','(Comparable)->Join(CachableSet,etc)','(S)','KERNEL','A kernel over a set \spad{S} is an operator applied to a given list of arguments from \spad{S}.');
INSERT INTO olibdb VALUES('d','KeyedAccessFile',1,'x','(SetCategory)->Join(FileCategory(FileName,Record(key:String,entry:Entry)),etc)','(Entry)','KAFILE','This domain allows a random access file to be viewed both as a table and as a file object.');
INSERT INTO olibdb VALUES('d','Lambda',1,'n','(VarCat)->Join(CoercibleTo(OutputForm),etc)','(UT)','LAMBDA','An implementation of untyped lambda-calculus');
INSERT INTO olibdb VALUES('d','LatticeJoinOfMeets',0,'n','()->Join(BoundedDistributiveLattice,etc)',NULL,'LATJOFM','Infinite Lattice which is distributive. \indented{2}{Representation held as join of meets.}');
INSERT INTO olibdb VALUES('d','LatticeMeetOfJoins',0,'n','()->Join(BoundedDistributiveLattice,etc)',NULL,'LATMOFJ','Infinite Lattice which is distributive. \indented{2}{Representation held as meet of joins.}');
INSERT INTO olibdb VALUES('d','LaurentPolynomial',2,'n','(R:IntegralDomain,UP:UnivariatePolynomialCategory(R))->Join(DifferentialExtension(UP),etc)','(R,UP)','LAUPOL','Univariate polynomials with negative and positive exponents.');
INSERT INTO olibdb VALUES('d','Library',0,'x','()->Join(TableAggregate(String,Any),etc)',NULL,'LIB','This domain provides a simple way to save values in files.');
INSERT INTO olibdb VALUES('d','LieExponentials',3,'n','(OrderedSet,R:Join(CommutativeRing,etc),PositiveInteger)->Join(Group,etc)','(VarSet,R,Order)','LEXP','Management of the Lie Group associated with a free nilpotent Lie algebra. Every Lie bracket with length greater than \spad{Order} are assumed to be null. The implementation inherits from the \spadtype{XPBWPolynomial} domain constructor: Lyndon coordinates are exponential coordinates of the second kind. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','LiePolynomial',2,'n','(OrderedSet,R:CommutativeRing)->Join(FreeLieAlgebra(VarSet,R),etc)','(VarSet,R)','LPOLY','This type supports Lie polynomials in Lyndon basis see Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','LieSquareMatrix',2,'x','(PositiveInteger,R:CommutativeRing)->Join(CoercibleTo(SquareMatrix(n,R)),etc)','(n,R)','LSQM','LieSquareMatrix(\spad{n},{} \spad{R}) implements the Lie algebra of the \spad{n} by \spad{n} matrices over the commutative ring \spad{R}. The Lie bracket (commutator) of the algebra is given by \spad{a*b := (a *\$SQMATRIX(n,{} R) b - b *\$SQMATRIX(n,{} R) a)},{} where \spadfun{*\$SQMATRIX(\spad{n},{} \spad{R})} is the usual matrix multiplication.');
INSERT INTO olibdb VALUES('d','LinearMultivariateMatrixPencil',1,'n','(Ring)->etc','(R)','LINPEN','Linear matrix pencil with multivariate coefficients.');
INSERT INTO olibdb VALUES('d','LinearOrdinaryDifferentialOperator1',1,'n','(DifferentialRing)->LinearOrdinaryDifferentialOperatorCategory(A)','(A)','LODO1','\spad{LinearOrdinaryDifferentialOperator1} defines a ring of differential operators with coefficients in a differential ring A. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}');
INSERT INTO olibdb VALUES('d','LinearOrdinaryDifferentialOperator2',2,'n','(A:DifferentialRing,M:Join(LeftModule(A),etc))->Join(LinearOrdinaryDifferentialOperatorCategory(A),etc)','(A,M)','LODO2','\spad{LinearOrdinaryDifferentialOperator2} defines a ring of differential operators with coefficients in a differential ring A and acting on an A-module \spad{M}. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}');
INSERT INTO olibdb VALUES('d','LinearOrdinaryDifferentialOperator',2,'x','(A:Ring,(A)->A)->LinearOrdinaryDifferentialOperatorCategory(A)','(A,diff)','LODO','\spad{LinearOrdinaryDifferentialOperator} defines a ring of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}');
INSERT INTO olibdb VALUES('d','LinearOrdinaryDifferentialOperator3',3,'n','(Coeff:Ring,A:AbelianMonoidRing(Coeff,NonNegativeInteger),R:Join(DifferentialRing,etc))->LinearOrdinaryDifferentialOperatorCategory(R)','(Coeff,A,R)','LODO3','\spad{LinearOrdinaryDifferentialOperator3} is a ring \indented{1}{differential operators with coefficients in a differential ring \spad{R}.} \indented{1}{Basic derivative is derivative in \spad{R} times variable (monomial} \indented{1}{of degree 1).}');
INSERT INTO olibdb VALUES('d','List',1,'x','(Type)->Join(ListAggregate(S),etc)','(S)','LIST','\spadtype{List} implements singly-linked lists that are addressable by indices; the index of the first element is 1. In addition to the operations provided by \spadtype{ListAggregate},{} this constructor provides some LISP-like functions such as \spadfun{cons} and \spadfun{append}.');
INSERT INTO olibdb VALUES('d','ListMonoidOps',3,'n','(SetCategory,E:AbelianMonoid,E)->Join(SetCategory,etc)','(S,E,un)','LMOPS','This internal package represents monoid (abelian or not,{} with or without inverses) as lists and provides some common operations to the various flavors of monoids.');
INSERT INTO olibdb VALUES('d','ListMultiDictionary',1,'n','(SetCategory)->Join(MultiDictionary(S),etc)','(S)','LMDICT','The \spadtype{ListMultiDictionary} domain implements a dictionary with duplicates allowed. The representation is a list with duplicates represented explicitly. Hence most operations will be relatively inefficient when the number of entries in the dictionary becomes large. If the objects in the dictionary belong to an ordered set,{} the entries are maintained in ascending order.');
INSERT INTO olibdb VALUES('d','LocalAlgebra',2,'n','(Algebra(R),R:CommutativeRing)->Join(Algebra(R),etc)','(A,R)','LA','LocalAlgebra produces the localization of an algebra,{} \spadignore{i.e.} fractions whose numerators come from some \spad{R} algebra.');
INSERT INTO olibdb VALUES('d','Localize',2,'n','(Module(R),R:CommutativeRing)->Join(Module(R),etc)','(M,R)','LO','Localize(\spad{M},{} \spad{R}) produces fractions with numerators from an \spad{R} module \spad{M} and denominators being the nonzero elements of \spad{R}.');
INSERT INTO olibdb VALUES('d','Loop',0,'n','()->Join(SetCategory,etc)',NULL,'LOOP','This is used with graph theory code (FiniteGraph,{} DirectedGraph. FunctionGraph,{} and so on) to represent a loop as either a sequence of vertex or arrow indexes depending on context. The main benefit is that the loop is stored in a canonical way so that loops can be quickly compared using \spad{''=''}.');
INSERT INTO olibdb VALUES('d','LyndonWord',1,'n','(OrderedSet)->Join(OrderedSet,etc)','(VarSet)','LWORD','Lyndon words over arbitrary (ordered) symbols: see Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). A Lyndon word is a word which is smaller than any of its right factors \spad{w}.\spad{r}.\spad{t}. the pure lexicographical ordering. If \spad{a} and \spad{b} are two Lyndon words such that \spad{a < b} holds \spad{w}.\spad{r}.\spad{t} lexicographical ordering then \spad{a*b} is a Lyndon word. Parenthesized Lyndon words can be generated from symbols by using the following rule: \spad{[[a,{} b],{} c]} is a Lyndon word iff \spad{a*b < c <= b} holds. Lyndon words are internally represented by binary trees using the \spadtype{FreeMagma} domain constructor. Two ordering are provided: lexicographic and length-lexicographic. \newline Author : Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','MachineComplex',0,'n','()->Join(FortranMachineTypeCategory,etc)',NULL,'MCMPLX','A domain which models the complex number representation used by machines in the AXIOM-NAG link.');
INSERT INTO olibdb VALUES('d','MachineFloat',0,'n','()->Join(FloatingPointSystem,etc)',NULL,'MFLOAT','A domain which models the floating point representation used by machines in the AXIOM-NAG link.');
INSERT INTO olibdb VALUES('d','MachineInteger',0,'n','()->Join(FortranMachineTypeCategory,etc)',NULL,'MINT','A domain which models the integer representation used by machines in the AXIOM-NAG link.');
INSERT INTO olibdb VALUES('d','MakeCachableSet',1,'n','(SetCategory)->Join(CachableSet,etc)','(S)','MKCHSET','MakeCachableSet(\spad{S}) returns a cachable set which is equal to \spad{S} as a set.');
INSERT INTO olibdb VALUES('d','Mapping',1,'x','special','(T,S)','MAPPING','\spad{Mapping(T,S)} is a primitive type in FriCAS used to represent mappings from source type \spad{S} to target type \spad{T}. Similarly, \spad{Mapping(T,A,B)} denotes a mapping from source type \spad{(A,B)} to target type \spad{T}.');
INSERT INTO olibdb VALUES('d','MathMLFormat',0,'n','()->Join(SetCategory,etc)',NULL,'MMLFORM','\spadtype{MathMLFormat} provides a coercion from \spadtype{OutputForm} to MathML format.');
INSERT INTO olibdb VALUES('d','Matrix',1,'x','(AbelianMonoid)->Join(MatrixCategory(R,Vector(R),Vector(R)),etc)','(R)','MATRIX','\spadtype{Matrix} is a matrix domain where 1-based indexing is used for both rows and columns.');
INSERT INTO olibdb VALUES('d','ModMonic',2,'n','(R:Ring,Rep:UnivariatePolynomialCategory(R))->Join(Ring,etc)','(R,Rep)','MODMON','This domain implements quotient of ring of univariate polynomials by ideal generated by modulus polynomial. Modulus must be monic. Before performing any operations you need to set modulus,{} subsequent operations use this modulus.');
INSERT INTO olibdb VALUES('d','ModularAlgebraicGcdTools2',0,'n','()->ModularAlgebraicGcdOperations(Polynomial(Integer),PrimitiveArray(U32Vector),Record(svz:Symbol,sm:U32Vector,sp:Integer))',NULL,'MAGCDT2',NULL);
INSERT INTO olibdb VALUES('d','ModularAlgebraicGcdTools3',0,'n','()->Join(ModularAlgebraicGcdOperations(Polynomial(Integer),SparseUnivariatePolynomial(Polynomial(Integer)),Record(svz:List(Symbol),sm:List(Polynomial(Integer)),msizes:List(Integer),sp:Integer)),etc)',NULL,'MAGCDT3',NULL);
INSERT INTO olibdb VALUES('d','ModularAlgebraicGcdTools4',0,'n','()->ModularAlgebraicGcdOperations(FakePolynomial,SparseUnivariatePolynomial(Polynomial(Integer)),Record(svz:List(Symbol),sm:List(Polynomial(Integer)),msizes:List(Integer),sp:Integer))',NULL,'MAGCDT4',NULL);
INSERT INTO olibdb VALUES('d','ModularEvaluation1',0,'n','()->ModularEvaluationCategory(Polynomial(Integer),Polynomial(Integer))',NULL,'MEVAL1',NULL);
INSERT INTO olibdb VALUES('d','ModularEvaluation2',0,'n','()->ModularEvaluationCategory(Record(var:Symbol,coef:SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))),FakePolynomial)',NULL,'MEVAL2',NULL);
INSERT INTO olibdb VALUES('d','ModularFactorizationTools1',0,'n','()->ModularFactorizationOperations(U32Vector,U32Matrix,Integer,List(Record(ind:NonNegativeInteger,poly:U32Vector)))',NULL,'MODFT1',NULL);
INSERT INTO olibdb VALUES('d','ModularFactorizationTools3',1,'n','(FiniteFieldCategory)->Join(ModularFactorizationOperations(PrimitiveArray(K),PrimitiveTwoDimensionalArray(K),Record(i_mod:Integer,deg:Integer),Record(mod_data:Record(i_mod:Integer,deg:Integer),p_mod:PrimitiveArray(K))),etc)','(K)','MODFT3',NULL);
INSERT INTO olibdb VALUES('d','ModularField',5,'n','(R:CommutativeRing,Mod:AbelianMonoid,(R,Mod)->R,(Mod,Mod)->Union(Mod,failed),(R,R,Mod)->Union(R,failed))->Join(Field,etc)','(R,Mod,reduction,merge,exactQuo)','MODFIELD','\indented{1}{These domains are used for the factorization and gcds} of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{ModularRing},{} \spadtype{EuclideanModularRing}');
INSERT INTO olibdb VALUES('d','ModularRing',5,'n','(R:CommutativeRing,Mod:AbelianMonoid,(R,Mod)->R,(Mod,Mod)->Union(Mod,failed),(R,R,Mod)->Union(R,failed))->Join(Ring,etc)','(R,Mod,reduction,merge,exactQuo)','MODRING','These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{EuclideanModularRing} ,{} \spadtype{ModularField}');
INSERT INTO olibdb VALUES('d','ModuleMonomial',3,'n','(IS:OrderedSet,E:SetCategory,(Record(index:IS,exponent:E),Record(index:IS,exponent:E))->Boolean)->Join(OrderedSet,etc)','(IS,E,ff)','MODMONOM','This package \undocumented');
INSERT INTO olibdb VALUES('d','ModuleOperator',2,'x','(R:Ring,M:LeftModule(R))->Join(Ring,etc)','(R,M)','MODOP','Algebra of ADDITIVE operators on a module.');
INSERT INTO olibdb VALUES('d','MoebiusTransform',1,'n','(Field)->Join(Group,etc)','(F)','MOEBIUS','\indented{1}{MoebiusTransform(\spad{F}) is the domain of fractional linear (Moebius)} transformations over \spad{F}.');
INSERT INTO olibdb VALUES('d','MonoidRing',2,'n','(Ring,M:Monoid)->MonoidRingCategory(R,M)','(R,M)','MRING','\spadtype{MonoidRing}(\spad{R},{} \spad{M}),{} implements the algebra of all maps from the monoid \spad{M} to the commutative ring \spad{R} with finite support. Multiplication of two maps \spad{f} and \spad{g} is defined to map an element \spad{c} of \spad{M} to the (convolution) sum over {\em f(a)g(b)} such that {\em ab = c}. Thus \spad{M} can be identified with a canonical basis and the maps can also be considered as formal linear combinations of the elements in \spad{M}. Scalar multiples of a basis element are called monomials. A prominent example is the class of polynomials where the monoid is a direct product of the natural numbers with pointwise addition. When \spad{M} is \spadtype{FreeMonoid Symbol},{} one gets polynomials in infinitely many non-commuting variables. Another application area is representation theory of finite groups \spad{G},{} where modules over \spadtype{MonoidRing}(\spad{R},{} \spad{G}) are studied.');
INSERT INTO olibdb VALUES('d','MultifunctionGraph',1,'n','(SetCategory)->Join(FiniteGraph(S),etc)','(S)','MFGRPH','allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('d','Multiset',1,'x','(SetCategory)->Join(MultisetAggregate(S),etc)','(S)','MSET','A multiset is a set with multiplicities.');
INSERT INTO olibdb VALUES('d','MultivariatePolynomial',2,'x','(List(Symbol),R:Ring)->PolynomialCategory(R,IndexedExponents(OrderedVariableList(vl)),OrderedVariableList(vl))','(vl,R)','MPOLY','\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are from a user specified list of symbols. The ordering is specified by the position of the variable in the list. The coefficient ring may be non commutative,{} but the variables are assumed to commute.');
INSERT INTO olibdb VALUES('d','NewSparseMultivariatePolynomial',2,'n','(Ring,VarSet:OrderedSet)->Join(RecursivePolynomialCategory(R,IndexedExponents(VarSet),VarSet),etc)','(R,VarSet)','NSMP','A post-facto extension for \spadtype{SMP} in order to speed up operations related to pseudo-division and \spad{gcd}. This domain is based on the \spadtype{NSUP} constructor which is itself a post-facto extension of the \spadtype{SUP} constructor.');
INSERT INTO olibdb VALUES('d','NewSparseUnivariatePolynomial',1,'n','(Ring)->Join(UnivariatePolynomialCategory(R),etc)','(R)','NSUP','A post-facto extension for \spadtype{SUP} in order to speed up operations related to pseudo-division and \spad{gcd} for both \spadtype{SUP} and,{} consequently,{} \spadtype{NSMP}.');
INSERT INTO olibdb VALUES('d','None',0,'n','()->SetCategory',NULL,'NONE','\spadtype{None} implements an universal type,{} that is type which can represent values of any normal type. It is mainly used in technical situations where such a thing is needed (\spadignore{e.g.} the interpreter and some of the internal \spadtype{Expression} code).');
INSERT INTO olibdb VALUES('d','NonNegativeInteger',0,'x','()->Join(OrderedAbelianMonoidSup,etc)',NULL,'NNI','\spadtype{NonNegativeInteger} provides functions for non \indented{2}{negative integers.}');
INSERT INTO olibdb VALUES('d','NonNegativeRational',0,'n','()->Join(OrderedAbelianMonoidSup,etc)',NULL,'NNRAT','\spadtype{NonNegativeRational} is domain of \indented{1}{nonnegative rational numbers.}');
INSERT INTO olibdb VALUES('d','Octonion',1,'x','(CommutativeRing)->Join(OctonionCategory(R),etc)','(R)','OCT','Octonion implements octonions (Cayley-Dixon algebra) over a commutative ring,{} an eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the complex numbers to get the quaternions the main constructor function is {\em octon} which takes 8 arguments: the real part,{} the \spad{i} imaginary part,{} the \spad{j} imaginary part,{} the \spad{k} imaginary part,{} (as with quaternions) and in addition the imaginary parts \spad{E},{} \spad{I},{} \spad{J},{} \spad{K}.');
INSERT INTO olibdb VALUES('d','OneDimensionalArray',1,'x','(Type)->Join(OneDimensionalArrayAggregate(S),etc)','(S)','ARRAY1','This is the domain of 1-based one dimensional arrays.');
INSERT INTO olibdb VALUES('d','OnePointCompletion',1,'x','(SetCategory)->Join(SetCategory,etc)','(R)','ONECOMP','Adjunction of a complex infinity to a set. Date Created: 4 Oct 1989');
INSERT INTO olibdb VALUES('d','OpenMathConnection',0,'x','()->etc',NULL,'OMCONN','\spadtype{OpenMathConnection} provides low-level functions for handling connections to and from \spadtype{OpenMathDevice}\spad{s}.');
INSERT INTO olibdb VALUES('d','OpenMathDevice',0,'x','()->etc',NULL,'OMDEV','\spadtype{OpenMathDevice} provides support for reading and writing openMath objects to files,{} strings etc. It also provides access to low-level operations from within the interpreter.');
INSERT INTO olibdb VALUES('d','OpenMathEncoding',0,'x','()->Join(SetCategory,etc)',NULL,'OMENC','\spadtype{OpenMathEncoding} is the set of valid OpenMath encodings.');
INSERT INTO olibdb VALUES('d','OpenMathError',0,'x','()->Join(SetCategory,etc)',NULL,'OMERR','\spadtype{OpenMathError} is the domain of OpenMath errors.');
INSERT INTO olibdb VALUES('d','OpenMathErrorKind',0,'x','()->Join(SetCategory,etc)',NULL,'OMERRK','\spadtype{OpenMathErrorKind} represents different kinds of OpenMath errors: specifically parse errors,{} unknown \spad{CD} or symbol errors,{} and read errors.');
INSERT INTO olibdb VALUES('d','Operator',1,'n','(Ring)->Join(Ring,etc)','(R)','OP','Algebra of ADDITIVE operators over a ring.');
INSERT INTO olibdb VALUES('d','OperatorHandlers',1,'n','(Type)->etc','(HANDLER)','OPHANDL','\indented{1}{OperatorHandlers is an auxiliary domain. It is used holds functions} for each operator of \spad{OutputForm},{} classified by the arity and the name of that operator.');
INSERT INTO olibdb VALUES('d','OrderedCompletion',1,'x','(SetCategory)->Join(SetCategory,etc)','(R)','ORDCOMP','Adjunction of two real infinites quantities to a set. Date Created: 4 Oct 1989');
INSERT INTO olibdb VALUES('d','OrderedDirectProduct',3,'n','(NonNegativeInteger,S:OrderedAbelianMonoid,(Vector(S),Vector(S))->Boolean)->DirectProductCategory(dim,S)','(dim,S,f)','ODP','\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The ordering on the type is determined by its third argument which represents the less than function on vectors. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.');
INSERT INTO olibdb VALUES('d','OrderedExpression',0,'n','()->Join(OrderedRing,etc)',NULL,'OEXPR',NULL);
INSERT INTO olibdb VALUES('d','OrderedVariableList',1,'n','(List(Symbol))->Join(OrderedFinite,etc)','(VariableList)','OVAR','This domain implements ordered variables');
INSERT INTO olibdb VALUES('d','OrderlyDifferentialPolynomial',1,'n','(Ring)->Join(DifferentialPolynomialCategory(R,Symbol,OrderlyDifferentialVariable(Symbol),IndexedExponents(OrderlyDifferentialVariable(Symbol))),etc)','(R)','ODPOL','\spadtype{OrderlyDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates,{} with coefficients in a ring. The ranking on the differential indeterminate is orderly. This is analogous to the domain \spadtype{Polynomial}. \blankline');
INSERT INTO olibdb VALUES('d','OrderlyDifferentialVariable',1,'n','(OrderedSet)->DifferentialVariableCategory(S)','(S)','ODVAR','\spadtype{OrderlyDifferentialVariable} adds a commonly used orderly ranking to the set of derivatives of an ordered list of differential indeterminates. An orderly ranking is a ranking \spadfun{<} of the derivatives with the property that for two derivatives \spad{u} and \spad{v},{} \spad{u} \spadfun{<} \spad{v} if the \spadfun{order} of \spad{u} is less than that of \spad{v}. This domain belongs to \spadtype{DifferentialVariableCategory}. It defines \spadfun{weight} to be just \spadfun{order},{} and it defines an orderly ranking \spadfun{<} on derivatives \spad{u} via the lexicographic order on the pair (\spadfun{order}(\spad{u}),{} \spadfun{variable}(\spad{u})).');
INSERT INTO olibdb VALUES('d','OrdinaryDifferentialRing',3,'x','(Kernels:SetCategory,R:PartialDifferentialRing(Kernels),Kernels)->Join(BiModule(%,%),etc)','(Kernels,R,var)','ODR','This constructor produces an ordinary differential ring from a partial differential ring by specifying a variable.');
INSERT INTO olibdb VALUES('d','OrdinaryWeightedPolynomials',4,'n','(Ring,List(Symbol),List(NonNegativeInteger),NonNegativeInteger)->Join(Ring,etc)','(R,vl,wl,wtlevel)','OWP','This domain represents truncated weighted polynomials over the Polynomial type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented.');
INSERT INTO olibdb VALUES('d','OrdSetInts',0,'x','()->Join(OrderedSet,etc)',NULL,'OSI','A domain used in order to take the free \spad{R}-module on the \indented{1}{Integers \spad{I}.\space{2}This is actually the forgetful functor from OrderedRings} \indented{1}{to OrderedSets applied to \spad{I}.}');
INSERT INTO olibdb VALUES('d','OrientedFacet',0,'n','()->Join(FacetCategory,etc)',NULL,'OFACET','\indented{2}{A single vertex,{} edge,{} triangle...} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/} Date Created: March 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','OutputBox',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'OUTBOX','\indented{1}{The domain \spad{OutputBox} represents the two-dimensional form of} an expression by a number of strings (lines). Such a box has a baseline (at which such boxes will be horizontally aligned,{} a height (size above and including the baseline),{} a depth (size below the baseline),{} and a width (horizontal size).');
INSERT INTO olibdb VALUES('d','OutputForm',0,'n','()->Join(SetCategory,etc)',NULL,'OUTFORM','This domain is used to create and manipulate mathematical expressions for output. It is intended to provide an insulating layer between the expression rendering software (\spadignore{e.g.} TeX,{} or Script) and the output coercions in the various domains.');
INSERT INTO olibdb VALUES('d','PAdicInteger',1,'n','(Integer)->PAdicIntegerCategory(p)','(p)','PADIC','Stream-based implementation of \spad{Zp:} \spad{p}-adic numbers are represented as sum(\spad{i} = 0..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in 0,{} 1,{} ...,{} (\spad{p} - 1).');
INSERT INTO olibdb VALUES('d','PAdicRational',1,'n','(Integer)->Join(QuotientFieldCategory(PAdicInteger(p)),etc)','(p)','PADICRAT','Stream-based implementation of \spad{Qp:} numbers are represented as sum(\spad{i} = \spad{k}..,{} a[\spad{i}] * p^i) where the a[\spad{i}] lie in 0,{} 1,{} ...,{} (\spad{p} - 1).');
INSERT INTO olibdb VALUES('d','PAdicRationalConstructor',2,'n','(p:Integer,PADIC:PAdicIntegerCategory(p))->Join(QuotientFieldCategory(PADIC),etc)','(p,PADIC)','PADICRC','This is the category of stream-based representations of \spad{Qp}.');
INSERT INTO olibdb VALUES('d','Palette',0,'x','()->Join(SetCategory,etc)',NULL,'PALETTE','This domain describes four groups of color shades (palettes).');
INSERT INTO olibdb VALUES('d','ParametricComplexCurve',1,'x','(Type)->etc','(VT)','PARCCURV','ParametricComplexCurve is used for drawing complex \indented{1}{curves on the plane.\space{2}Its main effect is on function selection,{}} \indented{1}{namely introducing \spad{complex_curve} in the middle} \indented{1}{disambiguates between expression defining real function} \indented{1}{(default) and expression defining complex function.}');
INSERT INTO olibdb VALUES('d','ParametricPlaneCurve',1,'x','(Type)->etc','(ComponentFunction)','PARPCURV','ParametricPlaneCurve is used for plotting parametric plane curves in the affine plane.');
INSERT INTO olibdb VALUES('d','ParametricSpaceCurve',1,'x','(Type)->etc','(ComponentFunction)','PARSCURV','ParametricSpaceCurve is used for plotting parametric space curves in affine 3-space.');
INSERT INTO olibdb VALUES('d','ParametricSurface',1,'x','(Type)->etc','(ComponentFunction)','PARSURF','ParametricSurface is used for plotting parametric surfaces in affine 3-space.');
INSERT INTO olibdb VALUES('d','PartialDifferentialOperator',2,'n','(PartialDifferentialRing(Var),Var:OrderedSet)->Join(MultivariateSkewPolynomialCategory(R,IndexedExponents(Var),Var),etc)','(R,Var)','PDO','PartialDifferentialOperator(\spad{R},{} \spad{V}) defines a ring of partial differential operators in variables from \spad{V} and with coefficients in a partial differential ring \spad{R}. Multiplication of operators corresponds to composition of operators. \blankline');
INSERT INTO olibdb VALUES('d','PartialFraction',1,'x','(EuclideanDomain)->Join(Field,etc)','(R)','PFR','The domain \spadtype{PartialFraction} implements partial fractions over a euclidean domain \spad{R}. This requirement on the argument domain allows us to normalize the fractions. Of particular interest are the 2 forms for these fractions. The');
INSERT INTO olibdb VALUES('d','Partition',0,'n','()->Join(OrderedCancellationAbelianMonoid,etc)',NULL,'PRTITION','\indented{1}{Partition is an OrderedCancellationAbelianMonoid which is used} as the basis for symmetric polynomial representation of the sums of powers in SymmetricPolynomial. Thus,{} \spad{(5 2 2 1)} will represent \spad{s5 * s2^2 * s1}.');
INSERT INTO olibdb VALUES('d','Pattern',1,'n','(SetCategory)->Join(SetCategory,etc)','(R)','PATTERN','Patterns for use by the pattern matcher.');
INSERT INTO olibdb VALUES('d','PatternMatchListResult',3,'n','(SetCategory,S:SetCategory,L:ListAggregate(S))->Join(SetCategory,etc)','(R,S,L)','PATLRES','A PatternMatchListResult is an object internally returned by the pattern matcher when matching on lists. It is either a failed match,{} or a pair of PatternMatchResult,{} one for atoms (elements of the list),{} and one for lists.');
INSERT INTO olibdb VALUES('d','PatternMatchResult',2,'n','(SetCategory,S:SetCategory)->Join(SetCategory,etc)','(R,S)','PATRES','A PatternMatchResult is an object internally returned by the pattern matcher; It is either a failed match,{} or a list of matches of the form (var,{} expr) meaning that the variable var matches the expression expr.');
INSERT INTO olibdb VALUES('d','PendantTree',1,'x','(SetCategory)->Join(BinaryRecursiveAggregate(S),etc)','(S)','PENDTREE','\indented{1}{A PendantTree(\spad{S}) is either a leaf? and is an \spad{S} or has} a left and a right are both PendantTree(\spad{S}).');
INSERT INTO olibdb VALUES('d','Permutation',1,'x','(SetCategory)->Join(PermutationCategory(S),etc)','(S)','PERM','Permutation(\spad{S}) implements the group of all bijections \indented{2}{on a set \spad{S},{} which move only a finite number of points.} \indented{2}{A permutation is considered as a map from \spad{S} into \spad{S}. In particular} \indented{2}{multiplication is defined as composition of maps:} \indented{2}{{\em pi1 * pi2 = pi1 o pi2}.} \indented{2}{The internal representation of permutations are two lists} \indented{2}{of equal length representing preimages and images.}');
INSERT INTO olibdb VALUES('d','PermutationGroup',1,'x','(SetCategory)->Join(SetCategory,etc)','(S)','PERMGRP','PermutationGroup implements permutation groups acting on a set \spad{S},{} \spadignore{i.e.} all subgroups of the symmetric group of \spad{S},{} represented as a list of permutations (generators). Note that therefore the objects are not members of the \Language category \spadtype{Group}. Using the idea of base and strong generators by Sims,{} basic routines and algorithms are implemented so that the word problem for permutation groups can be solved.');
INSERT INTO olibdb VALUES('d','PiDomain',0,'x','()->Join(Field,etc)',NULL,'HACKPI','\indented{1}{Symbolic fractions in \%\spad{pi} with integer coefficients;} \indented{1}{The point for using PiDomain as the default domain for those fractions} \indented{1}{is that PiDomain is coercible to the float types,{} and not Expression.} Date Created: 21 Feb 1990');
INSERT INTO olibdb VALUES('d','PlaneAlgebraicCurvePlot',0,'n','()->Join(PlottablePlaneCurveCategory,etc)',NULL,'ACPLOT','Plot a NON-SINGULAR plane algebraic curve \spad{p(x,{} y) = 0}.');
INSERT INTO olibdb VALUES('d','Plot',0,'n','()->Join(PlottablePlaneCurveCategory,etc)',NULL,'PLOT','The Plot domain supports plotting of functions defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example floating point numbers and infinite continued fractions. The facilities at this point are limited to 2-dimensional plots or either a single function or a parametric function.');
INSERT INTO olibdb VALUES('d','Plot3D',0,'n','()->Join(PlottableSpaceCurveCategory,etc)',NULL,'PLOT3D','Plot3D supports parametric plots defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example,{} floating point numbers and infinite continued fractions are real number systems. The facilities at this point are limited to 3-dimensional parametric plots.');
INSERT INTO olibdb VALUES('d','PoincareBirkhoffWittLyndonBasis',1,'n','(OrderedSet)->Join(OrderedSet,etc)','(VarSet)','PBWLB','This domain provides the internal representation of polynomials in non-commutative variables written over the Poincare-Birkhoff-Witt basis. See the \spadtype{XPBWPolynomial} domain constructor. See Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','Point',1,'n','(Ring)->PointCategory(R)','(R)','POINT','This domain implements points in coordinate space');
INSERT INTO olibdb VALUES('d','Polynomial',1,'x','(Ring)->Join(PolynomialCategory(R,IndexedExponents(Symbol),Symbol),etc)','(R)','POLY','\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are arbitrary symbols. The ordering is alphabetic determined by the Symbol type. The coefficient ring may be non commutative,{} but the variables are assumed to commute.');
INSERT INTO olibdb VALUES('d','PolynomialIdeal',4,'x','(F:Field,Expon:OrderedAbelianMonoidSup,VarSet:OrderedSet,DPoly:PolynomialCategory(F,Expon,VarSet))->Join(SetCategory,etc)','(F,Expon,VarSet,DPoly)','IDEAL','This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations,{} including intersection,{} sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is \spad{true} if the generators are a Groebner basis. The algorithms used are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings.');
INSERT INTO olibdb VALUES('d','PolynomialRing',2,'n','(Join(SemiRng,etc),E:OrderedAbelianMonoid)->Join(FiniteAbelianMonoidRing(R,E),etc)','(R,E)','PR','This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and terms indexed by their exponents (from an arbitrary ordered abelian monoid). This type is used,{} for example,{} by the \spadtype{DistributedMultivariatePolynomial} domain where the exponent domain is a direct product of non negative integers.');
INSERT INTO olibdb VALUES('d','PositiveInteger',0,'x','()->Join(OrderedAbelianSemiGroup,etc)',NULL,'PI','\spadtype{PositiveInteger} provides functions for \indented{2}{positive integers.}');
INSERT INTO olibdb VALUES('d','PrimeField',1,'x','(PositiveInteger)->Join(FiniteFieldCategory,etc)','(p)','PF','PrimeField(\spad{p}) implements the field with \spad{p} elements if \spad{p} is a prime number. Error: if \spad{p} is not prime.');
INSERT INTO olibdb VALUES('d','PrimitiveArray',1,'n','(Type)->OneDimensionalArrayAggregate(S)','(S)','PRIMARR','This provides a fast array type with no bound checking on elt\spad{''s}. Minimum index is 0 in this type,{} cannot be changed.');
INSERT INTO olibdb VALUES('d','PrimitiveTwoDimensionalArray',1,'n','(Type)->Join(TwoDimensionalArrayCategory(S,PrimitiveArray(S),PrimitiveArray(S)),etc)','(S)','PRIMMAT2','This is a low-level domain which implements matrices \indented{1}{(two dimensional arrays) of general values.} \indented{1}{Indexing is 0 based,{} there is no bound checking (unless} \indented{1}{provided by lower level).}');
INSERT INTO olibdb VALUES('d','Product',2,'n','(SetCategory,B:SetCategory)->Join(SetCategory,etc)','(A,B)','PRODUCT','This domain implements cartesian product. If the underlying domains are both Finite then the resulting Product is also Finite and can be enumerated via size(),{} index(),{} location(),{} etc. The index of the second component (\spad{B}) varies most quickly.');
INSERT INTO olibdb VALUES('d','ProductFacet',0,'n','()->Join(FacetCategory,etc)',NULL,'PFACET','\indented{2}{Holds the product of two simplexes} \indented{2}{for more documentation see:} \indented{2}{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Date Created: April 2016 Basic Operations: Related packages: Related categories: FacetCategory Related Domains: Also See: AMS Classifications:');
INSERT INTO olibdb VALUES('d','QuadraticForm',2,'x','(PositiveInteger,K:Field)->Join(AbelianGroup,etc)','(n,K)','QFORM','This domain provides modest support for quadratic forms.');
INSERT INTO olibdb VALUES('d','QuasiAlgebraicSet',4,'n','(R:GcdDomain,Var:OrderedSet,Expon:OrderedAbelianMonoidSup,Dpoly:PolynomialCategory(R,Expon,Var))->Join(SetCategory,etc)','(R,Var,Expon,Dpoly)','QALGSET','\spadtype{QuasiAlgebraicSet} constructs a domain representing quasi-algebraic sets,{} which is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the common zeros of a polynomial \spad{f} (the defining polynomial for the inequation). This domain provides simplification of a user-given representation using groebner basis computations. There are two simplification routines: the first function \spadfun{idealSimplify} uses groebner basis of ideals alone,{} while the second,{} \spadfun{simplify} uses both groebner basis and factorization. The resulting defining equations \spad{L} always form a groebner basis,{} and the resulting defining inequation \spad{f} is always reduced. The function \spadfun{simplify} may be applied several times if desired. A third simplification routine \spadfun{radicalSimplify} is provided in \spadtype{QuasiAlgebraicSet2} for comparison study only,{} as it is inefficient compared to the other two,{} as well as is restricted to only certain coefficient domains. For detail analysis and a comparison of the three methods,{} please consult the reference cited. \blankline A polynomial function \spad{q} defined on the quasi-algebraic set is equivalent to its reduced form with respect to \spad{L}. While this may be obtained using the usual normal form algorithm,{} there is no canonical form for \spad{q}. \blankline The ordering in groebner basis computation is determined by the data type of the input polynomials. If it is possible we suggest to use refinements of total degree orderings.');
INSERT INTO olibdb VALUES('d','Quaternion',1,'x','(CommutativeRing)->QuaternionCategory(R)','(R)','QUAT','\spadtype{Quaternion} implements Hamilton quaternions \indented{2}{over a commutative ring.}');
INSERT INTO olibdb VALUES('d','QueryEquation',0,'x','()->Join(CoercibleTo(OutputForm),etc)',NULL,'QEQUAT','This domain implements simple database queries');
INSERT INTO olibdb VALUES('d','Queue',1,'x','(SetCategory)->Join(QueueAggregate(S),etc)','(S)','QUEUE','Linked List implementation of a Queue');
INSERT INTO olibdb VALUES('d','RadicalFunctionField',5,'n','(F:UniqueFactorizationDomain,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),Fraction(UP),NonNegativeInteger)->FunctionFieldCategory(F,UP,UPUP)','(F,UP,UPUP,radicnd,n)','RADFF','Function field defined by \spad{y^n} = \spad{f}(\spad{x}).');
INSERT INTO olibdb VALUES('d','RadixExpansion',1,'x','(Integer)->Join(QuotientFieldCategory(Integer),etc)','(bb)','RADIX','This domain allows rational numbers to be presented as repeating decimal expansions or more generally as repeating expansions in any base.');
INSERT INTO olibdb VALUES('d','RealClosure',1,'x','(Join(OrderedRing,etc))->Join(RealClosedField,etc)','(TheField)','RECLOS','This domain implements the real closure of an ordered field.');
INSERT INTO olibdb VALUES('d','Record',1,'x','special','(a:A,b:B,...,c:C)','RECORD','\spad{Record(a:A,b:B,...,c:C)} is a primitive type in FriCAS used to represent composite objects made up of objects of type \spad{A}, \spad{B},..., \spad{C} which are indexed by keys (identifiers) \spad{a},\spad{b},...,\spad{c}.');
INSERT INTO olibdb VALUES('d','RectangularMatrix',3,'n','(NonNegativeInteger,n:NonNegativeInteger,R:Join(SemiRng,etc))->Join(RectangularMatrixCategory(m,n,R,DirectProduct(n,R),DirectProduct(m,R)),etc)','(m,n,R)','RMATRIX','\spadtype{RectangularMatrix} is a matrix domain where the number of rows and the number of columns are parameters of the domain.');
INSERT INTO olibdb VALUES('d','Reference',1,'n','(Type)->Join(Type,etc)','(S)','REF','\indented{1}{\spadtype{Reference} is for making a changeable instance} of something.');
INSERT INTO olibdb VALUES('d','RegularChain',2,'x','(GcdDomain,ls:List(Symbol))->Join(RegularTriangularSetCategory(R,IndexedExponents(OrderedVariableList(ls)),OrderedVariableList(ls),NewSparseMultivariatePolynomial(R,OrderedVariableList(ls))),etc)','(R,ls)','RGCHAIN','A domain for regular chains (\spadignore{i.e.} regular triangular sets) over a \spad{Gcd}-Domain and with a fix list of variables. This is just a front-end for the \spadtype{RegularTriangularSet} domain constructor.');
INSERT INTO olibdb VALUES('d','RegularTriangularSet',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->Join(RegularTriangularSetCategory(R,E,V,P),etc)','(R,E,V,P)','REGSET','This domain provides an implementation of regular chains. Moreover,{} the operation \spadopFrom{zeroSetSplit}{RegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\newline');
INSERT INTO olibdb VALUES('d','ResidueRing',5,'n','(F:Field,Expon:OrderedAbelianMonoidSup,VarSet:OrderedSet,FPol:PolynomialCategory(F,Expon,VarSet),List(FPol))->Join(CommutativeRing,etc)','(F,Expon,VarSet,FPol,LFPol)','RESRING','ResidueRing is the quotient of a polynomial ring by an ideal. The ideal is given as a list of generators. The elements of the domain are equivalence classes expressed in terms of reduced elements');
INSERT INTO olibdb VALUES('d','Result',0,'n','()->Join(TableAggregate(Symbol,Any),etc)',NULL,'RESULT','A domain used to return the results from a call to the NAG Library. It prints as a list of names and types,{} though the user may choose to display values automatically if he or she wishes.');
INSERT INTO olibdb VALUES('d','RewriteRule',3,'x','(Base:SetCategory,R:Join(Ring,etc),F:Join(FunctionSpace(R),etc))->Join(SetCategory,etc)','(Base,R,F)','RULE','Rules for the pattern matcher.');
INSERT INTO olibdb VALUES('d','RightOpenIntervalRootCharacterization',2,'x','(TheField:Join(OrderedRing,etc),ThePolDom:UnivariatePolynomialCategory(TheField))->Join(RealRootCharacterizationCategory(TheField,ThePolDom),etc)','(TheField,ThePolDom)','ROIRC','\spadtype{RightOpenIntervalRootCharacterization} provides work with interval root coding.');
INSERT INTO olibdb VALUES('d','RomanNumeral',0,'x','()->Join(IntegerNumberSystem,etc)',NULL,'ROMAN','\spadtype{RomanNumeral} provides functions for converting \indented{1}{integers to roman numerals.}');
INSERT INTO olibdb VALUES('d','RuleCalled',1,'n','(Symbol)->Join(SetCategory,etc)','(f)','RULECOLD','This domain implements named rules');
INSERT INTO olibdb VALUES('d','Ruleset',3,'x','(Base:SetCategory,R:Join(Ring,etc),F:Join(FunctionSpace(R),etc))->Join(SetCategory,etc)','(Base,R,F)','RULESET','A ruleset is a set of pattern matching rules grouped together.');
INSERT INTO olibdb VALUES('d','SArgand',0,'n','()->Join(SPointCategory,etc)',NULL,'SARGND','\indented{1}{Domain for representing points,{} vectors,{} subspaces and properties} of components in a subspace as complex numbers');
INSERT INTO olibdb VALUES('d','SBoundary',1,'n','(SPointCategory)->etc','(PT)','SBOUND','\indented{1}{SBoundary implements boundaries for use in scene graph} This defines the outer extent of the scene,{} or of an element in the scene,{} or of some branch in the scene. The difference between this boundary and an \spad{n}-dimensional surface,{} such as IFS,{} is that boundary must always have a well defined inside and an outside. SBoundary does not necessarily follow the exact outer contours of the shape but just constructs a simple boundary shape where all points of the shape are guaranteed to be inside the boundary. Currently there are the following boundary forms: \indented{1}{Simple types:} \indented{2}{box::Symbol which is a \spad{n}-dimensional axis-aligned rectangle.} \indented{2}{ellipoid::Symbol which is a \spad{n}-dimensional axis-aligned ellipse.} \indented{1}{Compound types:} \indented{2}{This is a combination of simple and other compound types such} \indented{2}{as union or intersection.} \indented{3}{union::Symbol represents union of supplied list} \indented{3}{intersection::Symbol represents intersection of supplied list} \indented{1}{Null types:} \indented{2}{none is used for a node which does not have a boundary in} \indented{6}{space,{} for example,{} when the boundary of a material node} \indented{6}{is requested.} The uses of SBoundary are: 1) So we know how much to scale a given scene to fit in a \indented{3}{given size.} 2) So that we know where to terminate arrows going in out out of \indented{3}{of the shape.} 3) To detect if objects intersect (collision detect),{} or if one \indented{3}{object is contained completely inside another.}');
INSERT INTO olibdb VALUES('d','SCartesian',1,'n','(PositiveInteger)->SPointCategory','(n)','SCRT','an implementation of PointCategory to represent points and vectors in three dimensional coordinate space');
INSERT INTO olibdb VALUES('d','Scene',1,'n','(SPointCategory)->etc','(PT)','SCENE','\indented{1}{these are the parameters that can be set for nodes of} various types');
INSERT INTO olibdb VALUES('d','SceneIFS',1,'n','(SPointCategory)->etc','(PT)','SCIFS','Generates various surfaces (2 dimensional subsets of 3D space). When 1 dimensional subspace (a line) needs to be represented in a 3D editor then we convert the line into a tube. Many of the functions here are from NumericTubePlot and related packages. However \spad{I} needed them to be defined over SPointCategory so \spad{I} adapted them here.');
INSERT INTO olibdb VALUES('d','SceneNamedPoints',1,'n','(SPointCategory)->Join(SetCategory,etc)','(PT)','SCNP','Associates points or nodes in Scene structure with names (or a hierarchy of names). The aim is,{} where a point or node is used in several different constructions,{} it only needs to be specified once.');
INSERT INTO olibdb VALUES('d','SConformal',1,'n','(PositiveInteger)->Join(SPointCategory,etc)','(n)','SCONF','\indented{1}{number of base dimensions (excluding point at infinity and point} at origin)');
INSERT INTO olibdb VALUES('d','Segment',1,'x','(Type)->Join(SegmentCategory(S),etc)','(S)','SEG','This type is used to specify a range of values from type \spad{S}.');
INSERT INTO olibdb VALUES('d','SegmentBinding',1,'x','(Type)->Join(Type,etc)','(S)','SEGBIND','This domain is used to provide the function argument syntax \spad{v=a..b}. This is used,{} for example,{} by the top-level \spadfun{draw} functions.');
INSERT INTO olibdb VALUES('d','Sequence',1,'x','(CommutativeRing)->SequenceCategory(R)','(R)','SEQU','A domain for infinite sequences over a commutative ring. It is implemented as stream with arithmetics.');
INSERT INTO olibdb VALUES('d','SequentialDifferentialPolynomial',1,'n','(Ring)->Join(DifferentialPolynomialCategory(R,Symbol,SequentialDifferentialVariable(Symbol),IndexedExponents(SequentialDifferentialVariable(Symbol))),etc)','(R)','SDPOL','\spadtype{SequentialDifferentialPolynomial} implements an ordinary differential polynomial ring in arbitrary number of differential indeterminates,{} with coefficients in a ring. The ranking on the differential indeterminate is sequential. \blankline');
INSERT INTO olibdb VALUES('d','SequentialDifferentialVariable',1,'n','(OrderedSet)->DifferentialVariableCategory(S)','(S)','SDVAR','\spadtype{OrderlyDifferentialVariable} adds a commonly used sequential ranking to the set of derivatives of an ordered list of differential indeterminates. A sequential ranking is a ranking \spadfun{<} of the derivatives with the property that for any derivative \spad{v},{} there are only a finite number of derivatives \spad{u} with \spad{u} \spadfun{<} \spad{v}. This domain belongs to \spadtype{DifferentialVariableCategory}. It defines \spadfun{weight} to be just \spadfun{order},{} and it defines a sequential ranking \spadfun{<} on derivatives \spad{u} by the lexicographic order on the pair (\spadfun{variable}(\spad{u}),{} \spadfun{order}(\spad{u})).');
INSERT INTO olibdb VALUES('d','Set',1,'x','(SetCategory)->FiniteSetAggregate(S)','(S)','SET','A set over a domain \spad{S} models the usual mathematical notion of a finite set of elements from \spad{S}. Sets are unordered collections of distinct elements (that is,{} order and duplication does not matter). The notation \spad{set [a,{} b,{} c]} can be used to create a set and the usual operations such as union and intersection are available to form new sets. If \spad{S} has OrderdSet,{} \Language{} maintains the entries in sorted order. Specifically,{} the parts function returns the entries as a list in ascending order and the \spadfun{extract!} operation returns the maximum entry. Given two sets \spad{s} and \spad{t} where \spad{\#s = m} and \spad{\#t = n},{} the complexity of \indented{2}{\spad{s = t} is \spad{O(min(n,{} m))}} \indented{2}{\spad{s < t} is \spad{O(max(n,{} m))}} \indented{2}{\spad{union(s,{} t)},{} \spad{intersect(s,{} t)},{} \spad{minus(s,{} t)},{} \spad{symmetricDifference(s,{} t)} is \spad{O(max(n,{} m))}} \indented{2}{\spad{member?(x,{} t)} is \spad{O(n log n)}} \indented{2}{\spad{insert!(x,{} t)} and \spad{remove!(x,{} t)} is \spad{O(n)}}');
INSERT INTO olibdb VALUES('d','SetOfMIntegersInOneToN',2,'n','(PositiveInteger,PositiveInteger)->Join(Finite,etc)','(m,n)','SETMN','\spadtype{SetOfMIntegersInOneToN} implements the subsets of \spad{M} integers in the interval \spad{[1..n]}');
INSERT INTO olibdb VALUES('d','SExpression',0,'n','()->SExpressionCategory(String,Symbol,Integer,DoubleFloat)',NULL,'SEX','This domain allows the manipulation of the usual Lisp values.');
INSERT INTO olibdb VALUES('d','SExpressionOf',4,'n','(SetCategory,Sym:SetCategory,Int:SetCategory,Flt:SetCategory)->SExpressionCategory(Str,Sym,Int,Flt)','(Str,Sym,Int,Flt)','SEXOF','This domain allows the manipulation of Lisp values over arbitrary atomic types.');
INSERT INTO olibdb VALUES('d','SimpleAlgebraicExtension',3,'n','(R:CommutativeRing,UP:UnivariatePolynomialCategory(R),UP)->Join(MonogenicAlgebra(R,UP),etc)','(R,UP,M)','SAE','Domain which represents simple algebraic extensions of arbitrary rings. The first argument to the domain,{} \spad{R},{} is the underlying ring,{} the second argument is a domain of univariate polynomials over \spad{R},{} while the last argument specifies the defining minimal polynomial. The elements of the domain are canonically represented as polynomials of degree less than that of the minimal polynomial with coefficients in \spad{R}. The second argument is both the type of the third argument and the underlying representation used by \spadtype{SAE} itself.');
INSERT INTO olibdb VALUES('d','SimpleCell',2,'n','(TheField:RealClosedField,ThePols:UnivariatePolynomialCategory(TheField))->Join(CoercibleTo(OutputForm),etc)','(TheField,ThePols)','SCELL',NULL);
INSERT INTO olibdb VALUES('d','SimpleFortranProgram',2,'n','(R:OrderedSet,FS:FunctionSpace(R))->Join(FortranProgramCategory,etc)','(R,FS)','SFORT','\spadtype{SimpleFortranProgram} provides a simple model of some FORTRAN subprograms,{} making it possible to coerce objects of various domains into a FORTRAN subprogram called \spad{f}. These can then be translated into legal FORTRAN code.');
INSERT INTO olibdb VALUES('d','SingleInteger',0,'x','()->Join(IntegerNumberSystem,etc)',NULL,'SINT','SingleInteger is intended to support machine integer arithmetic.');
INSERT INTO olibdb VALUES('d','SingletonAsOrderedSet',0,'n','()->Join(OrderedSet,etc)',NULL,'SAOS','\indented{1}{This trivial domain let us build Univariate Polynomials} in an anonymous variable.');
INSERT INTO olibdb VALUES('d','SKICombinators',1,'n','(VarCat)->Join(SetCategory,etc)','(UT)','SKICOMB','This domain implements SKI combinators. Ski combinators were introduced by Moses Schoenfinkel and Haskell Curry with the aim of eliminating the need for variables in mathematical logic. It is equivalent to lambda calculus but it can be used for doing,{} without variables,{} anything that would require variables in other systems.');
INSERT INTO olibdb VALUES('d','SmallOrdinal',0,'n','()->Join(OrderedAbelianMonoid,etc)',NULL,'SORD','SmallOrdinal implements ordinal numbers up to \spad{epsilon_0}. \spad{+} and \spad{*} are natural addition and multiplication of ordinals. Available separately are ordered operataions.');
INSERT INTO olibdb VALUES('d','SortedExponentVector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'SOREXPV','\indented{1}{Domain for storing information about structure of polynomials} as vectors of exponents');
INSERT INTO olibdb VALUES('d','SparseEchelonMatrix',2,'n','(OrderedSet,D:Ring)->Join(CoercibleTo(OutputForm),etc)','(C,D)','SEM','\spad{SparseEchelonMatrix(C,{} D)} implements sparse matrices whose columns are enumerated by the \spadtype{OrderedSet} \spad{C} and whose entries belong to the \spadtype{GcdDomain} \spad{D}. The basic operation of this domain is the computation of an row echelon form. The algorithm used tries to maintain the sparsity and is especially adapted to matrices which are already close to a row echelon form.');
INSERT INTO olibdb VALUES('d','SparseMultivariatePolynomial',2,'n','(Join(SemiRng,etc),VarSet:OrderedSet)->PolynomialCategory(R,IndexedExponents(VarSet),VarSet)','(R,VarSet)','SMP','\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials. It is parameterized by the coefficient ring and the variable set which may be infinite. The variable ordering is determined by the variable set parameter. The coefficient ring may be non-commutative,{} but the variables are assumed to commute.');
INSERT INTO olibdb VALUES('d','SparseMultivariatePolynomialExpressions',1,'n','(Ring)->Join(PolynomialCategory(R,IndexedExponents(NonNegativeInteger),NonNegativeInteger),etc)','(R)','SMPEXPR',NULL);
INSERT INTO olibdb VALUES('d','SparseMultivariateSkewPolynomial',4,'n','(R:Ring,Var:OrderedSet,(Var)->Automorphism(R),(Var)->(R)->R)->Join(MultivariateSkewPolynomialCategory(R,IndexedExponents(Var),Var),etc)','(R,Var,sigma,delta)','SKSMP','SparseMultivariateSkewPolynomial(\spad{R},{} Var,{} sigma,{} delta) defines a mutivariate Ore ring over \spad{R} in variables from \spad{V}. \spad{sigma(v)} gives automorphism of \spad{R} corresponding to variable \spad{v} and \spad{delta(v)} gives corresponding derivative. \blankline');
INSERT INTO olibdb VALUES('d','SparseMultivariateTaylorSeries',3,'n','(Coef:Ring,Var:OrderedSet,SMP:PolynomialCategory(Coef,IndexedExponents(Var),Var))->Join(MultivariateTaylorSeriesCategory(Coef,Var),etc)','(Coef,Var,SMP)','SMTS','This domain provides multivariate Taylor series with variables from an arbitrary ordered set. A Taylor series is represented by a stream of polynomials from the polynomial domain \spad{SMP}. The \spad{n}th element of the stream is a form of degree \spad{n}. SMTS is an internal domain.');
INSERT INTO olibdb VALUES('d','SparseTable',3,'n','(SetCategory,Ent:BasicType,Ent)->TableAggregate(Key,Ent)','(Key,Ent,dent)','STBL','A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key.');
INSERT INTO olibdb VALUES('d','SparseUnivariateLaurentSeries',3,'n','(Coef:Ring,var:Symbol,cen:Coef)->Join(UnivariateLaurentSeriesConstructorCategory(Coef,SparseUnivariateTaylorSeries(Coef,var,cen)),etc)','(Coef,var,cen)','SULS','Sparse Laurent series in one variable \indented{2}{\spadtype{SparseUnivariateLaurentSeries} is a domain representing Laurent} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{SparseUnivariateLaurentSeries(Integer,{} x,{} 3)} represents Laurent} \indented{2}{series in \spad{(x - 3)} with integer coefficients.}');
INSERT INTO olibdb VALUES('d','SparseUnivariatePolynomial',1,'n','(Join(SemiRng,etc))->Join(UnivariatePolynomialCategory(R),etc)','(R)','SUP','This domain represents univariate polynomials over arbitrary (not necessarily commutative) coefficient rings. The variable is unspecified so that the variable displays as \spad{?} in output. If it is necessary to specify the variable name,{} use type \spadtype{UnivariatePolynomial}. The representation is sparse in the sense that only non-zero terms are represented.');
INSERT INTO olibdb VALUES('d','SparseUnivariatePuiseuxSeries',3,'n','(Coef:Ring,var:Symbol,cen:Coef)->Join(UnivariatePuiseuxSeriesConstructorCategory(Coef,SparseUnivariateLaurentSeries(Coef,var,cen)),etc)','(Coef,var,cen)','SUPXS','Sparse Puiseux series in one variable \indented{2}{\spadtype{SparseUnivariatePuiseuxSeries} is a domain representing Puiseux} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{SparseUnivariatePuiseuxSeries(Integer,{} x,{} 3)} represents Puiseux} \indented{2}{series in \spad{(x - 3)} with \spadtype{Integer} coefficients.}');
INSERT INTO olibdb VALUES('d','SparseUnivariateSkewPolynomial',3,'n','(R:Ring,Automorphism(R),(R)->R)->Join(UnivariateSkewPolynomialCategory(R),etc)','(R,sigma,delta)','ORESUP','This is the domain of sparse univariate skew polynomials over an Ore coefficient field. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}.');
INSERT INTO olibdb VALUES('d','SparseUnivariateTaylorSeries',3,'n','(Coef:Ring,var:Symbol,Coef)->Join(UnivariateTaylorSeriesCategory(Coef),etc)','(Coef,var,cen)','SUTS','Sparse Taylor series in one variable \indented{2}{\spadtype{SparseUnivariateTaylorSeries} is a domain representing Taylor} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spadtype{SparseUnivariateTaylorSeries}(Integer,{} \spad{x},{} 3) represents Taylor} \indented{2}{series in \spad{(x - 3)} with \spadtype{Integer} coefficients.}');
INSERT INTO olibdb VALUES('d','SplitHomogeneousDirectProduct',3,'n','(NonNegativeInteger,NonNegativeInteger,S:OrderedAbelianMonoid)->DirectProductCategory(dimtot,S)','(dimtot,dim1,S)','SHDP','\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered as if they were split into two blocks. The \spad{dim1} parameter specifies the length of the first block. The ordering is lexicographic between the blocks but acts like \spadtype{HomogeneousDirectProduct} within each block. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.');
INSERT INTO olibdb VALUES('d','SplittingNode',2,'n','(Join(SetCategory,etc),C:Join(SetCategory,etc))->Join(SetCategory,etc)','(V,C)','SPLNODE','This domain exports a modest implementation for the vertices of splitting trees. These vertices are called here splitting nodes. Every of these nodes store 3 informations. The first one is its value,{} that is the current expression to evaluate. The second one is its condition,{} that is the hypothesis under which the value has to be evaluated. The last one is its status,{} that is a boolean flag which is \spad{true} iff the value is the result of its evaluation under its condition. Two splitting vertices are equal iff they have the sane values and the same conditions (so their status do not matter).');
INSERT INTO olibdb VALUES('d','SplittingTree',2,'n','(Join(SetCategory,etc),C:Join(SetCategory,etc))->Join(RecursiveAggregate(SplittingNode(V,C)),etc)','(V,C)','SPLTREE','This domain exports a modest implementation of splitting trees. Splitting trees are needed when the evaluation of some quantity under some hypothesis requires to split the hypothesis into sub-cases. For instance by adding some new hypothesis on one hand and its negation on another hand. The computations are terminated for a splitting tree \spad{a} when \spad{status(value(a))} is \spad{true}. Thus,{} if for the splitting tree \spad{a} the flag \spad{status(value(a))} is \spad{true},{} then \spad{status(value(d))} is \spad{true} for any subtree \spad{d} of \spad{a}. This property of splitting trees is called the termination condition. If no vertex in a splitting tree \spad{a} is equal to another,{} \spad{a} is said to satisfy the no-duplicates condition. The splitting tree \spad{a} will satisfy this condition if nodes are added to \spad{a} by means of \spad{splitNodeOf!} and if \spad{construct} is only used to create the root of \spad{a} with no children.');
INSERT INTO olibdb VALUES('d','SquareFreeRegularTriangularSet',4,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->Join(SquareFreeRegularTriangularSetCategory(R,E,V,P),etc)','(R,E,V,P)','SREGSET','This domain provides an implementation of square-free regular chains. Moreover,{} the operation \spadopFrom{zeroSetSplit}{SquareFreeRegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\newline');
INSERT INTO olibdb VALUES('d','SquareMatrix',2,'n','(NonNegativeInteger,R:Join(SemiRng,etc))->Join(SquareMatrixCategory(ndim,R,DirectProduct(ndim,R),DirectProduct(ndim,R)),etc)','(ndim,R)','SQMATRIX','\spadtype{SquareMatrix} is a matrix domain of square matrices,{} where the number of rows (= number of columns) is a parameter of the type.');
INSERT INTO olibdb VALUES('d','Stack',1,'x','(SetCategory)->Join(StackAggregate(S),etc)','(S)','STACK','Linked List implementation of a Stack');
INSERT INTO olibdb VALUES('d','STransform',1,'n','(SPointCategory)->etc','(PT)','STR','\indented{1}{Domains for transform from SPoint to SPoint} STransform transform domain can by used to represent linear transforms for instance when working with SCartesian where its Representation is a matrix of DoubleFloat Other transform domains may not necessarily be linear and will have different representations');
INSERT INTO olibdb VALUES('d','Stream',1,'x','(Type)->Join(LazyStreamAggregate(S),etc)','(S)','STREAM','A stream is an implementation of a possibly infinite sequence using a list of terms that have been computed and a function closure to compute additional terms when needed.');
INSERT INTO olibdb VALUES('d','String',0,'x','()->Join(StringCategory,etc)',NULL,'STRING','This is the domain of character strings.');
INSERT INTO olibdb VALUES('d','StringTable',1,'n','(Type)->Join(TableAggregate(String,Entry),etc)','(Entry)','STRTBL','This domain provides tables where the keys are strings. A specialized hash function for strings is used.');
INSERT INTO olibdb VALUES('d','SubsetLattice',2,'n','(S:SetCategory,List(S))->Join(Lattice,etc)','(S,top)','SETLAT','Implementation of subset logic. \indented{3}{implements pseudo complement} \indented{3}{subset of powerset} \indented{3}{related to ''containment order''} \indented{3}{REP holds a single node and complete set (representing ''top'')} Date Created: Oct 2015');
INSERT INTO olibdb VALUES('d','SubSpace',2,'n','(PositiveInteger,R:Ring)->Join(SetCategory,etc)','(n,R)','SUBSPACE','This domain \undocumented');
INSERT INTO olibdb VALUES('d','SubSpaceComponentProperty',0,'n','()->Join(SetCategory,etc)',NULL,'COMPPROP','This domain implements some global properties of subspaces.');
INSERT INTO olibdb VALUES('d','SuchThat',2,'n','(SetCategory,S2:SetCategory)->Join(SetCategory,etc)','(S1,S2)','SUCH','This domain implements such that forms');
INSERT INTO olibdb VALUES('d','Switch',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'SWITCH','This domain builds representations of boolean expressions for use with the \spadtype{FortranCode} domain.');
INSERT INTO olibdb VALUES('d','Symbol',0,'x','()->Join(OrderedSet,etc)',NULL,'SYMBOL','Basic and scripted symbols.');
INSERT INTO olibdb VALUES('d','SymbolTable',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'SYMTAB','Create and manipulate a symbol table for generated FORTRAN code');
INSERT INTO olibdb VALUES('d','SymmetricPolynomial',1,'n','(Ring)->Join(FiniteAbelianMonoidRing(R,Partition),etc)','(R)','SYMPOLY','This domain implements symmetric polynomial');
INSERT INTO olibdb VALUES('d','Table',2,'n','(SetCategory,Entry:Type)->Join(TableAggregate(Key,Entry),etc)','(Key,Entry)','TABLE','This is the general purpose table type. The keys are hashed to look up the entries. This creates a \spadtype{HashTable} if equal for the Key domain is consistent with Lisp EQUAL otherwise an \spadtype{AssociationList}');
INSERT INTO olibdb VALUES('d','Tableau',1,'x','(SetCategory)->Join(CoercibleTo(OutputForm),etc)','(S)','TABLEAU','The tableau domain is for printing Young tableaux,{} and coercions to and from List List \spad{S} where \spad{S} is a set.');
INSERT INTO olibdb VALUES('d','TaylorSeries',1,'x','(Ring)->Join(MultivariateTaylorSeriesCategory(Coef,Symbol),etc)','(Coef)','TS','\spadtype{TaylorSeries} is a general multivariate Taylor series domain over the ring Coef and with variables of type Symbol.');
INSERT INTO olibdb VALUES('d','TaylorSeriesExpansionGeneralized',4,'n','(Coef:Algebra(Fraction(Integer)),Expon:OrderedAbelianMonoid,UPS:Join(UnivariatePowerSeriesCategory(Coef,Expon),etc),UTS:UnivariateTaylorSeriesCategory(Coef))->TaylorSeriesExpansion(Coef,Expon,SingletonAsOrderedSet,UPS,UTS)','(Coef,Expon,UPS,UTS)','TSEREXPG',NULL);
INSERT INTO olibdb VALUES('d','TaylorSeriesExpansionLaurent',3,'n','(Coef:Algebra(Fraction(Integer)),UTS:UnivariateTaylorSeriesCategory(Coef),ULS:UnivariateLaurentSeriesConstructorCategory(Coef,UTS))->TaylorSeriesExpansion(Coef,Integer,SingletonAsOrderedSet,ULS,UTS)','(Coef,UTS,ULS)','TSEREXPL',NULL);
INSERT INTO olibdb VALUES('d','TaylorSeriesExpansionPuiseux',4,'n','(Coef:Algebra(Fraction(Integer)),UTS:UnivariateTaylorSeriesCategory(Coef),ULS:UnivariateLaurentSeriesConstructorCategory(Coef,UTS),UPS:UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS))->TaylorSeriesExpansion(Coef,Fraction(Integer),SingletonAsOrderedSet,UPS,UTS)','(Coef,UTS,ULS,UPS)','TSEREXPP',NULL);
INSERT INTO olibdb VALUES('d','TaylorSeriesExpansionTaylor',2,'n','(Coef:Algebra(Fraction(Integer)),UTS:UnivariateTaylorSeriesCategory(Coef))->TaylorSeriesExpansion(Coef,NonNegativeInteger,SingletonAsOrderedSet,UTS,UTS)','(Coef,UTS)','TSEREXPT',NULL);
INSERT INTO olibdb VALUES('d','TensorPower',4,'n','(NonNegativeInteger,R:CommutativeRing,B:OrderedSet,M:FreeModuleCategory(R,B))->Join(TensorPowerCategory(n,R,M),etc)','(n,R,B,M)','TENSPOW','Tensor powers of a free module over a commutative ring. It is represented as a free module over the cartesian power of the basis.');
INSERT INTO olibdb VALUES('d','TensorProduct',5,'n','(R:CommutativeRing,B1:OrderedSet,B2:OrderedSet,M1:FreeModuleCategory(R,B1),M2:FreeModuleCategory(R,B2))->Join(TensorProductCategory(R,M1,M2),etc)','(R,B1,B2,M1,M2)','TENSOR','Tensor product of free modules over a commutative ring. It is represented as a free module over the direct product of the respective bases. The factor domains must provide operations \spad{listOfTerms},{} whose result is assumed to be stored in reverse order.');
INSERT INTO olibdb VALUES('d','TexFormat',0,'n','()->Join(SetCategory,etc)',NULL,'TEX','\spadtype{TexFormat} provides a coercion from \spadtype{OutputForm} to \TeX{} format. The particular dialect of \TeX{} used is \LaTeX{}. The basic object consists of three parts: a prologue,{} a tex part and an epilogue. The functions \spadfun{prologue},{} \spadfun{tex} and \spadfun{epilogue} extract these parts,{} respectively. The main guts of the expression go into the tex part. The other parts can be set (\spadfun{setPrologue!},{} \spadfun{setEpilogue!}) so that contain the appropriate tags for printing. For example,{} the prologue and epilogue might simply contain \spad{');
INSERT INTO olibdb VALUES('d','TexmacsFormat',0,'n','()->Join(SetCategory,etc)',NULL,'TMFORM','\spadtype{TexmacsFormat} provides a coercion from \spadtype{OutputForm} to TeXmacs format.');
INSERT INTO olibdb VALUES('d','TextFile',0,'x','()->Join(FileCategory(FileName,String),etc)',NULL,'TEXTFILE','This domain provides an implementation of text files. Text is stored in these files using the native character set of the computer.');
INSERT INTO olibdb VALUES('d','TheSymbolTable',0,'n','()->Join(CoercibleTo(OutputForm),etc)',NULL,'SYMS','Creates and manipulates one global symbol table for FORTRAN code generation,{} containing details of types,{} dimensions,{} and argument lists.');
INSERT INTO olibdb VALUES('d','ThreeDimensionalMatrix',1,'n','(SetCategory)->Join(HomogeneousAggregate(R),etc)','(R)','M3D','This domain represents three dimensional matrices over a general object type');
INSERT INTO olibdb VALUES('d','ThreeDimensionalViewport',0,'x','()->Join(SetCategory,etc)',NULL,'VIEW3D','ThreeDimensionalViewport creates viewports to display graphs');
INSERT INTO olibdb VALUES('d','ThreeSpace',1,'x','(Ring)->ThreeSpaceCategory(R)','(R)','SPACE3','The domain ThreeSpace is used for creating three dimensional objects using functions for defining points,{} curves,{} polygons,{} constructs and the subspaces containing them.');
INSERT INTO olibdb VALUES('d','Tree',1,'x','(SetCategory)->Join(RecursiveAggregate(S),etc)','(S)','TREE','\spadtype{Tree(S)} is a basic domain of tree structures. Each tree is either empty or has a {\it node} consisting of a value and a list of (sub)trees.');
INSERT INTO olibdb VALUES('d','TubePlot',1,'n','(PlottableSpaceCurveCategory)->etc','(Curve)','TUBE','\indented{2}{Package for constructing tubes around 3-dimensional parametric curves.} Domain of tubes around 3-dimensional parametric curves.');
INSERT INTO olibdb VALUES('d','Tuple',1,'n','(Type)->Join(CoercibleTo(PrimitiveArray(S)),etc)','(S)','TUPLE','This domain is used to interface with the interpreter\spad{''s} notion of comma-delimited sequences of values.');
INSERT INTO olibdb VALUES('d','TwoDimensionalArray',1,'n','(Type)->TwoDimensionalArrayCategory(R,OneDimensionalArray(R),OneDimensionalArray(R))','(R)','ARRAY2','\indented{1}{A TwoDimensionalArray is a two dimensional array with} 1-based indexing for both rows and columns.');
INSERT INTO olibdb VALUES('d','TwoDimensionalViewport',0,'n','()->Join(SetCategory,etc)',NULL,'VIEW2D','TwoDimensionalViewport creates viewports to display graphs.');
INSERT INTO olibdb VALUES('d','Typed',0,'n','()->VarCat',NULL,'TYPED','Typed represents an typed variable in Lambda and Ski domains,{} a variable has a name represented by a String and a type represented by intutionistic logic.');
INSERT INTO olibdb VALUES('d','U16Matrix',0,'n','()->MatrixCategory(Integer,U16Vector,U16Vector)',NULL,'U16MAT','This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 16-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','U16Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'U16VEC','This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 16-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','U32Matrix',0,'n','()->MatrixCategory(Integer,U32Vector,U32Vector)',NULL,'U32MAT','This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 32-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','U32Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'U32VEC','This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 32-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','U64Int',0,'n','()->Join(Ring,etc)',NULL,'U64INT','Domain of unsigned 64-bit integers. It is used \indented{1}{to declare that values of local variables fit into 64 bits.}');
INSERT INTO olibdb VALUES('d','U8Matrix',0,'n','()->MatrixCategory(Integer,U8Vector,U8Vector)',NULL,'U8MAT','This is a low-level domain which implements matrices (two dimensional arrays) of unsigned 8-bit integers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','U8Vector',0,'n','()->OneDimensionalArrayAggregate(Integer)',NULL,'U8VEC','This is a low-level domain which implements vectors (one dimensional arrays) of unsigned 8-bit numbers. Indexing is 0 based,{} there is no bound checking (unless provided by lower level).');
INSERT INTO olibdb VALUES('d','UndirectedGraph',1,'n','(SetCategory)->Join(FiniteGraph(S),etc)','(S)','UDGRPH','allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('d','Union',1,'x','special','(A,B,...,C)','UNION','\spad{Union(A,B,...,C)} is a primitive type in FriCAS used to represent objects of type \spad{A} or of type \spad{B} or...or of type \spad{C}.');
INSERT INTO olibdb VALUES('d','UnivariateFormalPowerSeries',1,'n','(Ring)->Join(UnivariateTaylorSeriesCategory(Coef),etc)','(Coef)','UFPS',NULL);
INSERT INTO olibdb VALUES('d','UnivariateLaurentSeries',3,'n','(Coef:Ring,var:Symbol,cen:Coef)->Join(UnivariateLaurentSeriesConstructorCategory(Coef,UnivariateTaylorSeries(Coef,var,cen)),etc)','(Coef,var,cen)','ULS','Dense Laurent series in one variable \indented{2}{\spadtype{UnivariateLaurentSeries} is a domain representing Laurent} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{UnivariateLaurentSeries(Integer,{} x,{} 3)} represents Laurent series in} \indented{2}{\spad{(x - 3)} with integer coefficients.}');
INSERT INTO olibdb VALUES('d','UnivariateLaurentSeriesConstructor',2,'n','(Coef:Ring,UTS:UnivariateTaylorSeriesCategory(Coef))->UnivariateLaurentSeriesConstructorCategory(Coef,UTS)','(Coef,UTS)','ULSCONS','This package enables one to construct a univariate Laurent series domain from a univariate Taylor series domain. Univariate Laurent series are represented by a pair \spad{[n,{} f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x^n * f(x)}.');
INSERT INTO olibdb VALUES('d','UnivariatePolynomial',2,'x','(Symbol,R:Ring)->Join(UnivariatePolynomialCategory(R),etc)','(x,R)','UP','This domain represents univariate polynomials in some symbol over arbitrary (not necessarily commutative) coefficient rings. The representation is sparse in the sense that only non-zero terms are represented.');
INSERT INTO olibdb VALUES('d','UnivariatePuiseuxSeries',3,'n','(Coef:Ring,var:Symbol,cen:Coef)->Join(UnivariatePuiseuxSeriesConstructorCategory(Coef,UnivariateLaurentSeries(Coef,var,cen)),etc)','(Coef,var,cen)','UPXS','Dense Puiseux series in one variable \indented{2}{\spadtype{UnivariatePuiseuxSeries} is a domain representing Puiseux} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{UnivariatePuiseuxSeries(Integer,{} x,{} 3)} represents Puiseux series in} \indented{2}{\spad{(x - 3)} with \spadtype{Integer} coefficients.}');
INSERT INTO olibdb VALUES('d','UnivariatePuiseuxSeriesConstructor',2,'n','(Coef:Ring,ULS:UnivariateLaurentSeriesCategory(Coef))->UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)','(Coef,ULS)','UPXSCONS','This package enables one to construct a univariate Puiseux series domain from a univariate Laurent series domain. Univariate Puiseux series are represented by a pair \spad{[r,{} f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.');
INSERT INTO olibdb VALUES('d','UnivariatePuiseuxSeriesWithExponentialSingularity',4,'n','(R:Join(Comparable,etc),FE:Join(AlgebraicallyClosedField,etc),var:Symbol,cen:FE)->Join(FiniteAbelianMonoidRing(UnivariatePuiseuxSeries(FE,var,cen),ExponentialOfUnivariatePuiseuxSeries(FE,var,cen)),etc)','(R,FE,var,cen)','UPXSSING','UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent functions with essential singularities. Objects in this domain are sums,{} where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux series. Thus,{} the elements of this domain are sums of expressions of the form \spad{g(x) * exp(f(x))},{} where \spad{g}(\spad{x}) is a univariate Puiseux series and \spad{f}(\spad{x}) is a univariate Puiseux series with no terms of non-negative degree.');
INSERT INTO olibdb VALUES('d','UnivariateSkewPolynomial',4,'n','(Symbol,R:Ring,Automorphism(R),(R)->R)->Join(UnivariateSkewPolynomialCategory(R),etc)','(x,R,sigma,delta)','OREUP','This is the domain of univariate skew polynomials over an Ore coefficient field in a named variable. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}.');
INSERT INTO olibdb VALUES('d','UnivariateTaylorSeries',3,'n','(Coef:Ring,var:Symbol,Coef)->Join(UnivariateTaylorSeriesCategory(Coef),etc)','(Coef,var,cen)','UTS','Dense Taylor series in one variable \spadtype{UnivariateTaylorSeries} is a domain representing Taylor series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring,{} the power series variable,{} and the center of the power series expansion. For example,{} \spadtype{UnivariateTaylorSeries}(Integer,{} \spad{x},{} 3) represents Taylor series in \spad{(x - 3)} with \spadtype{Integer} coefficients.');
INSERT INTO olibdb VALUES('d','UniversalSegment',1,'x','(Type)->Join(SegmentCategory(S),etc)','(S)','UNISEG','This domain provides segments which may be half open. That is,{} ranges of the form \spad{a..} or \spad{a..b}.');
INSERT INTO olibdb VALUES('d','Untyped',0,'n','()->VarCat',NULL,'UNTYPED','Untyped represents an untyped variable in Lambda and Ski domains,{} a variable has a name represented by a String.');
INSERT INTO olibdb VALUES('d','Variable',1,'n','(Symbol)->Join(SetCategory,etc)','(sym)','VARIABLE','This domain implements variables');
INSERT INTO olibdb VALUES('d','Vector',1,'x','(Type)->Join(VectorCategory(R),etc)','(R)','VECTOR','This type represents vector like objects with varying lengths and indexed by a finite segment of integers starting at 1.');
INSERT INTO olibdb VALUES('d','VectorIntegerReconstructor',0,'n','()->etc',NULL,'VECREC2','This domain supports modular methods based on \indented{1}{evaluation and rational reconstruction.\space{2}Each evaluation} \indented{1}{is done modulo machine sized prime \spad{p}.\space{2}Both Chinese} \indented{1}{remaindering and (linear) Hensel lift are supported.} \indented{1}{Once enough evaluations are known rational reconstruction} \indented{1}{produces vector of rational numbers or integers.}');
INSERT INTO olibdb VALUES('d','VectorModularReconstructor',0,'n','()->etc',NULL,'VECREC1','This domain supports modular methods based on \indented{1}{evaluation and rational reconstruction.\space{2}All computation} \indented{1}{are done on polynomials modulo machine sized prime \spad{p} \spad{--} \spad{p} must} \indented{1}{be chosen small enough to avoid overflow in intermediate} \indented{1}{calculations. Each evaluation is supposed to produce vector of} \indented{1}{values. Once enough evaluations are known rational reconstruction} \indented{1}{produces vector of rational functions or multivariate polynomials.}');
INSERT INTO olibdb VALUES('d','VectorSpaceBasis',1,'n','(Field)->Join(BasicType,etc)','(R)','VSBASIS','The domain \spad{VectorSpaceBasis F} implements subspaces of finite dimensional vector spaces over a field \spad{F}. A subspace is represented by a list of linearly independent coordinate vectors which constitute a basis. The empty list represents the space of dimension 0.');
INSERT INTO olibdb VALUES('d','Void',0,'x','()->etc',NULL,'VOID','This type is used when no value is needed,{} \spadignore{e.g.} in the \spad{then} part of a one armed \spad{if}. All values can be coerced to type Void. Once a value has been coerced to Void,{} it cannot be recovered.');
INSERT INTO olibdb VALUES('d','WeightedGraph',2,'n','(SetCategory,W:OrderedAbelianMonoid)->Join(FiniteGraph(S),etc)','(S,W)','WGRPH','allows us to model weighted graphs This graph assigns a weight to each arrow. This is used when calculating say,{} lowest ''cost'' routes. An arrow with a higher weight is more ''costly'' in some way and therefore we try to choose the minimum weight. For arrows in series the overall weight is the sum of the individual weights. For arrows in parallel the overall weight is the minimum of the individual weights. \spad{I} may change this in future to allow different cost metrics to be plugged in. \blankline');
INSERT INTO olibdb VALUES('d','WeightedPolynomials',7,'n','(R:Ring,VarSet:OrderedSet,E:OrderedAbelianMonoidSup,P:PolynomialCategory(R,E,VarSet),List(VarSet),List(NonNegativeInteger),NonNegativeInteger)->Join(Ring,etc)','(R,VarSet,E,P,vl,wl,wtlevel)','WP','This domain represents truncated weighted polynomials over a general (not necessarily commutative) polynomial type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented.');
INSERT INTO olibdb VALUES('d','WuWenTsunTriangularSet',4,'x','(R:IntegralDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->Join(TriangularSetCategory(R,E,V,P),etc)','(R,E,V,P)','WUTSET','A domain constructor of the category \spadtype{GeneralTriangularSet}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. The \spadopFrom{construct}{WuWenTsunTriangularSet} operation does not check the previous requirement. Triangular sets are stored as sorted lists \spad{w}.\spad{r}.\spad{t}. the main variables of their members. Furthermore,{} this domain exports operations dealing with the characteristic set method of Wu Wen Tsun and some optimizations mainly proposed by Dong Ming Wang.\newline');
INSERT INTO olibdb VALUES('d','XDistributedPolynomial',2,'n','(OrderedSet,R:Ring)->Join(XPolynomialsCat(vl,R),etc)','(vl,R)','XDPOLY','\indented{2}{This type supports distributed multivariate polynomials} whose variables do not commute. The coefficient ring may be non-commutative too. However,{} coefficients and variables commute.');
INSERT INTO olibdb VALUES('d','XHashTable',2,'n','(Hashable,Entry:Type)->Join(TableAggregate(Key,Entry),etc)','(Key,Entry)','XHASHTBL','An implementation of a hash table that uses equality of the key domain to decide upon equality of keys.');
INSERT INTO olibdb VALUES('d','XmlAttribute',0,'n','()->etc',NULL,'XMLAT','This package provides support for \spad{XML} files \spad{XML} attributes are inside the opening tag: <tagname attributes> and usually have the form: name=value');
INSERT INTO olibdb VALUES('d','XmlElement',0,'n','()->etc',NULL,'XMLEL','This package provides support for \spad{XML} files an \spad{XML} element is something which either has the form: <tagname attributes> content </tagname> or <tagname attributes/> where content may be a sequence of sub-elements or unstructured text');
INSERT INTO olibdb VALUES('d','XPBWPolynomial',2,'n','(OrderedSet,R:CommutativeRing)->Join(XPolynomialsCat(VarSet,R),etc)','(VarSet,R)','XPBWPOLY','This domain constructor implements polynomials in non-commutative variables written in the Poincare-Birkhoff-Witt basis from the Lyndon basis. These polynomials can be used to compute Baker-Campbell-Hausdorff relations. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('d','XPolynomial',1,'n','(Ring)->Join(XPolynomialsCat(Symbol,R),etc)','(R)','XPOLY','\indented{2}{This type supports multivariate polynomials} whose set of variables is \spadtype{Symbol}. The representation is recursive. The coefficient ring may be non-commutative and the variables do not commute. However,{} coefficients and variables commute.');
INSERT INTO olibdb VALUES('d','XPolynomialRing',2,'n','(Ring,E:OrderedMonoid)->Join(XAlgebra(R),etc)','(R,E)','XPR','This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and words belonging to an arbitrary \spadtype{OrderedMonoid}. This type is used,{} for instance,{} by the \spadtype{XDistributedPolynomial} domain constructor where the Monoid is free.');
INSERT INTO olibdb VALUES('d','XRecursivePolynomial',2,'n','(OrderedSet,R:Ring)->Join(XPolynomialsCat(VarSet,R),etc)','(VarSet,R)','XRPOLY','\indented{2}{This type supports multivariate polynomials} whose variables do not commute. The representation is recursive. The coefficient ring may be non-commutative. Coefficients and variables commute.');
INSERT INTO olibdb VALUES('o','0',0,'n','()->%','cDistributionCategory(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'n','()->%','dInputForm',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'n','()->%','dPattern(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'n','()->%','dVectorSpaceBasis(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'n','()->S','xGradedAlgebra&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'x','()->%','cAbelianMonoid',NULL,NULL);
INSERT INTO olibdb VALUES('o','0',0,'x','()->%','cGradedModule(R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','_|_',0,'n','()->%','cBoundedJoinSemilattice',NULL,'bottom (\spad{false} in logic).');
INSERT INTO olibdb VALUES('o','_|_',0,'n','()->S','xLogic&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'n','()->%','cJetBundleCategory',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'n','()->%','dInputForm',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'n','()->%','dPattern(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'n','()->%','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'n','()->S','xGradedAlgebra&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'x','()->%','cGradedAlgebra(R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','1',0,'x','()->%','cMagmaWithUnit',NULL,NULL);
INSERT INTO olibdb VALUES('o','#',1,'n','(A)->NonNegativeInteger','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','#',1,'n','(A)->NonNegativeInteger','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','#',1,'n','(A)->NonNegativeInteger','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','#',1,'n','(A)->NonNegativeInteger','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','#',1,'n','(A)->NonNegativeInteger','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','~',1,'n','(%)->%','dDirectedGraph(S)',NULL,'The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http://en.wikipedia.org/wiki/Complement_graph');
INSERT INTO olibdb VALUES('o','~',1,'n','(%)->%','dILogic',NULL,'\spad{~(x)} returns the logical complement of \spad{x}. TODO not sure if complement should be included here? intuitionistic logic can have complement but has different axioms to complement in Boolean algebra. Equivalent capability can be provided by implication.');
INSERT INTO olibdb VALUES('o','~',1,'n','(%)->%','dMultifunctionGraph(S)',NULL,'The complement or inverse of a graph is a graph on the same vertices such that there is an arrow if and only if there is not an arrow in its compliment. That is,{} it is the compliment of the arrows but is not the set complement. for more information see: http://en.wikipedia.org/wiki/Complement_graph');
INSERT INTO olibdb VALUES('o','-',1,'n','(%)->%','dOutputForm',NULL,'\spad{- f} creates the equivalent prefix form.');
INSERT INTO olibdb VALUES('o','#',1,'n','(%)->NonNegativeInteger','dTuple(S)',NULL,'\spad{\#(x)} returns the number of elements in tuple \spad{x}');
INSERT INTO olibdb VALUES('o','#',1,'n','(%)->NonNegativeInteger','dXPolynomialRing(R,E)',NULL,'\spad{\# p} returns the number of terms in \spad{p}.');
INSERT INTO olibdb VALUES('o','#',1,'n','(S)->NonNegativeInteger','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','~',1,'n','(S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xGradedModule&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{- a} returns the power series negative of \spad{a}: \spad{- [a0,{} a1,{} ...] = [- a0,{} - a1,{} ...]}');
INSERT INTO olibdb VALUES('o','-',1,'x','(%)->%','cAbelianGroup',NULL,'\spad{-x} is the additive inverse of \spad{x}.');
INSERT INTO olibdb VALUES('o','-',1,'x','(%)->%','cGradedModule(R,E)',NULL,'\spad{-g} is the additive inverse of \spad{g} in the module of elements of the same grade as \spad{g}.');
INSERT INTO olibdb VALUES('o','~',1,'x','(%)->%','cLogic',NULL,'\spad{~(x)} returns the logical complement of \spad{x}.');
INSERT INTO olibdb VALUES('o','-',1,'x','(%)->%','cMatrixCategory(R,Row,Col)','has(R,AbelianGroup)','\spad{-x} returns the negative of the matrix \spad{x}.');
INSERT INTO olibdb VALUES('o','-',1,'x','(%)->%','cVectorCategory(R)','has(R,AbelianGroup)','\spad{-x} negates all components of the vector \spad{x}.');
INSERT INTO olibdb VALUES('o','~',1,'x','(%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'reverse,{} complement,{} canonical dual basis');
INSERT INTO olibdb VALUES('o','-',1,'x','(%)->%','dOrderedCompletion(R)','has(R,AbelianGroup)',NULL);
INSERT INTO olibdb VALUES('o','~',1,'x','(%)->%','dSingleInteger',NULL,'\spad{~ n} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.');
INSERT INTO olibdb VALUES('o','#',1,'x','(%)->Integer','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{\#((a1,{} ...,{} an))} returns \spad{n}.');
INSERT INTO olibdb VALUES('o','#',1,'x','(%)->NonNegativeInteger','cAggregate','has(%,finiteAggregate)','\spad{\#(u)} returns the number of elements in \spad{u}.');
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xDictionary&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(A,A)->Boolean','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','~=',2,'n','(A,A)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<=',2,'n','(A,A)->Boolean','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(A,A)->Boolean','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(A,A)->Boolean','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(A,A)->Boolean','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','~=',2,'n','(A,A)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(A,A)->Boolean','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(A,A)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(A,R)->%','dLocalAlgebra(A,R)',NULL,'\spad{a / d} divides the element \spad{a} by \spad{d}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(A,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{r * a} returns the power series scalar multiplication of \spad{r} by \spad{a}: \spad{r * [a0,{} a1,{} ...] = [r * a0,{} r * a1,{} ...]}');
INSERT INTO olibdb VALUES('o','>',2,'n','(%,%)->Boolean','cJetBundleCategory',NULL,'\spad{jv1 > jv2} checks whether \spad{jv1} is greater than \spad{jv2} in the internal ordering.');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','cVarCat',NULL,'return \spad{true} if equal,{} that is names are equal and if there is a type then they must also be equal');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dFortranScalarType',NULL,'\spad{x=y} tests for equality');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dILogic',NULL,'returns \spad{true} (boolean \spad{true}) if Intuitionistic Logic values are the same. Translates from Intuitionistic Logic to Boolean Logic');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dLambda(UT)',NULL,'return \spad{true} if equal (deep search) that is: all terms at all levels in tree must be alpha-equivalent to return \spad{true} That is the names,{} but not the deBruijn index,{} of the bound variables can be different. beta-equivalence is not implemented because it is not decidable.');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dLatticeJoinOfMeets',NULL,'returns \spad{true} (boolean \spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dLatticeMeetOfJoins',NULL,'returns \spad{true} (boolean \spad{true}) if intuitionisticLogic values are the same. Translates from Intuitionistic Logic to Boolean Logic');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{p = q} entrywise equality.');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dReference(S)',NULL,'\spad{a=b} tests if \spad{a} and \spad{b} are the same pointer/reference.');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->Boolean','dSKICombinators(UT)',NULL,'return \spad{true} if equal (deep search) that is: all terms at all levels in tree must be equal to return \spad{true} all terms must be exactly equal,{} not just equivalent,{} that is SKK=I will return \spad{false} even though ''SKK'' and ''I'' have the same effect');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','cFiniteGraph(S)',NULL,'\spad{x+y} computes sum of \spad{x} and \spad{y},{} that is disjoint union of nodes with arrows from appropriate input');
INSERT INTO olibdb VALUES('o','\/',2,'n','(%,%)->%','cJoinSemilattice',NULL,'returns the logical ''join'',{} \spadignore{e.g.} ''or''.');
INSERT INTO olibdb VALUES('o','/\',2,'n','(%,%)->%','cMeetSemilattice',NULL,'returns the logical ''meet'',{} \spadignore{e.g.} ''and''.');
INSERT INTO olibdb VALUES('o','*',2,'n','(Coef,%)->%','dInnerTaylorSeries(Coef)',NULL,'\spad{c*x} returns the product of \spad{c} and the series \spad{x}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,Coef)->%','dInnerTaylorSeries(Coef)',NULL,'\spad{x*c} returns the product of \spad{c} and the series \spad{x}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(Coef,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','cSPointCategory',NULL,'+(\spad{x},{} \spad{y}) gives addition add the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector + vector = vector point + vector = point point + point = invalid (but interpret as vector) Although,{} adding two points is not strictly a valid operation,{} we allow it here by interpreting the point as a vector relative to the origin. We do that because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5.');
INSERT INTO olibdb VALUES('o','-',2,'n','(%,%)->%','cSPointCategory',NULL,'\spad{-(x,{} y)} gives subtraction subtract the corresponding elements of the vector or point. The type (vector or point) depends on the following table: vector - vector = vector point - vector = point vector - point = invalid (but interpret as point) point - point = invalid (but interpret as vector) Although,{} subtracting two points is not strictly a valid operation,{} we allow it here by interpreting the result as the vector distance between the two points.');
INSERT INTO olibdb VALUES('o','*',2,'n','(D,%)->%','dJetLazyFunction(JB,D)',NULL,'\spad{d*exp} is provided mainly for internal use,{} as basically all calculations should be performed within \spadtype{JetLazyFunction}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f / g} computes \spad{f} * \spad{g^}-1 for nonzero element \spad{g}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dFreeMagma(VarSet)',NULL,'\spad{x*y} returns the tree \spad{[x,{} y]}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{x * y} is the product of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{x + y} is the sum of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dInputForm',NULL,'\spad{a * b} returns the input form corresponding to \spad{a * b}.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','dInputForm',NULL,'\spad{a + b} returns the input form corresponding to \spad{a + b}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->%','dInputForm',NULL,'\spad{a / b} returns the input form corresponding to \spad{a / b}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->DirectedGraph(Product(S,S))','dDirectedGraph(S)',NULL,'\spad{*}(a,{}\spad{b}) returns a tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) are adjacent in \spad{G} \times \spad{H} if and only if u'' is adjacent with \spad{v''} and \spad{u} is adjacent with \spad{v}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(DoubleFloat,%)->%','cSPointCategory',NULL,'*(\spad{s},{} \spad{x}) gives scalar multiplication Although,{} scalar multiplication is strictly only a valid operation for vectors and not points,{} we allow it here because there are some useful short cuts,{} for instance,{} to find the central point between two points we can add them together and scalar multiply by 0.5.');
INSERT INTO olibdb VALUES('o','*',2,'n','(DoubleFloat,Point(DoubleFloat))->Point(DoubleFloat)','pTubePlotTools',NULL,'\spad{s * p} returns a point whose coordinates are the scalar multiple of the point \spad{p} by the scalar \spad{s},{} preserving the color,{} or fourth coordinate,{} of \spad{p}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f * g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f + g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','-',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f - g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f / g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','<=',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f <= g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','<',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f < g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','=',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f = g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','>=',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f >= g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','>',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f > g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f ^ g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','~=',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f ~= g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dPattern(R)',NULL,'\spad{a * b} returns the pattern \spad{a * b}.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','dPattern(R)',NULL,'\spad{a + b} returns the pattern \spad{a + b}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->%','dPattern(R)',NULL,'\spad{a / b} returns the pattern \spad{a / b}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,%)->%','dPattern(R)',NULL,'\spad{a ^ b} returns the pattern \spad{a ^ b}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,%)->%','dSmallOrdinal',NULL,'\spad{o1^o2} returns \spad{o1} to power \spad{o2},{} where power is inductively defined using successive natural multiplication from the left');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->%','dVectorSpaceBasis(R)',NULL,'\spad{b1*b2} computes a basis of the intersection of two subspaces.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,%)->%','dVectorSpaceBasis(R)',NULL,'\spad{B1+B2} computes a basis of the sum of two subspaces.');
INSERT INTO olibdb VALUES('o','+',2,'n','(F,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{alpha + f} adds the scalar alpha to \spad{f}.');
INSERT INTO olibdb VALUES('o','-',2,'n','(F,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{alpha - f} adds the scalar alpha to \spad{-f}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(F,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{alpha / f} computes alpha / \spad{f} for nonzero \spad{f}.');
INSERT INTO olibdb VALUES('o','+',2,'n','(%,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f + alpha} adds the scalar alpha to \spad{f}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f / alpha} computes \spad{f} / alpha for nonzero alpha.');
INSERT INTO olibdb VALUES('o','-',2,'n','(%,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f - alpha} subtracts the scalar alpha from \spad{f}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(F,F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{a ^ b} returns the formal exponential a^b.');
INSERT INTO olibdb VALUES('o','^',2,'n','(F,Fraction(Integer))->F','pAlgebraicFunction(R,F)','has(R,RetractableTo(Integer))','\spad{x ^ q} is \spad{x} raised to the rational power \spad{q}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Fraction(Integer),S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->FunctionGraph(Product(S,S))','dFunctionGraph(S)',NULL,'tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) are adjacent in \spad{G} \times \spad{H} if and only if u'' is adjacent with \spad{v''} and \spad{u} is adjacent with \spad{v}. Cartesian product does apply to function graph produces two arrows out of every node');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,Integer)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f^n} returns \spad{f^n}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,Integer)->%','dInnerTaylorSeries(Coef)',NULL,'\spad{x*i} returns the product of integer \spad{i} and the series \spad{x}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,Integer)->%','dInputForm',NULL,'\spad{a ^ b} returns the input form corresponding to \spad{a ^ b}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,Integer)->%','dOperator(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xFullyLinearlyExplicitOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Integer,S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Matrix(D),%)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{L*A} implements left multiplication with a usual matrix.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,Matrix(F))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f * U} column transformation');
INSERT INTO olibdb VALUES('o','*',2,'n','(Matrix(F),%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{T * f} row transformation');
INSERT INTO olibdb VALUES('o','*',2,'n','(Matrix(Fraction(D)),%)->%','dSparseEchelonMatrix(C,D)','has(D,IntegralDomain)','\spad{L*A} implements left multiplication with a usual matrix over the quotient field of \spad{D}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,Matrix(R))->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{p * U} column transformation ...');
INSERT INTO olibdb VALUES('o','*',2,'n','(Matrix(R),%)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{T * P} row transformation ...');
INSERT INTO olibdb VALUES('o','^',2,'n','(Matrix(R),NonNegativeInteger)->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{x ^ n} computes the \spad{n}-th power of a square matrix. The power \spad{n} is assumed greater than 1.');
INSERT INTO olibdb VALUES('o','/',2,'n','(M,R)->%','dLocalize(M,R)',NULL,'\spad{m / d} divides the element \spad{m} by \spad{d}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->MultifunctionGraph(Product(S,S))','dMultifunctionGraph(S)',NULL,'tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) are adjacent in \spad{G} \times \spad{H} if and only if u'' is adjacent with \spad{v''} and \spad{u} is adjacent with \spad{v}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,NonNegativeInteger)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{x ^ n} computes a non-negative integral power of the matrix \spad{x}. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,NonNegativeInteger)->%','dInputForm',NULL,'\spad{a ^ b} returns the input form corresponding to \spad{a ^ b}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,NonNegativeInteger)->%','dPattern(R)',NULL,'\spad{a ^ n} returns the pattern \spad{a ^ n}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xAbelianMonoid&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xFullyLinearlyExplicitOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(NonNegativeInteger,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(P,%)->%','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{p*x} \undocumented');
INSERT INTO olibdb VALUES('o','*',2,'n','(Permutation(Integer),%)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{\pi * A} permutes the indices and the matrix according to the permutation \spad{\pi}.');
INSERT INTO olibdb VALUES('o','-',2,'n','(Point(DoubleFloat),Point(DoubleFloat))->Point(DoubleFloat)','pTubePlotTools',NULL,'\spad{p - q} computes and returns a point whose coordinates are the differences of the coordinates of two points \spad{p} and \spad{q},{} using the color,{} or fourth coordinate,{} of the first point \spad{p} as the color also of the point \spad{q}.');
INSERT INTO olibdb VALUES('o','+',2,'n','(Point(DoubleFloat),Point(DoubleFloat))->Point(DoubleFloat)','pTubePlotTools',NULL,'\spad{p + q} computes and returns a point whose coordinates are the sums of the coordinates of the two points \spad{p} and \spad{q},{} using the color,{} or fourth coordinate,{} of the first point \spad{p} as the color also of the point \spad{q}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,PositiveInteger)->%','cDistributionCategory(R)',NULL,'\spad{x^k} constructs the distribution of the \spad{k}th power of the random variable with distribution \spad{X} by picking every \spad{k}-th moment.');
INSERT INTO olibdb VALUES('o','^',2,'n','(%,PositiveInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{f^n} returns \spad{f^n}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xAbelianMonoid&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xAbelianSemiGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xFullyLinearlyExplicitOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(PositiveInteger,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(%,R)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{r*x} is the left scalar multiple of the scalar \spad{r} and the matrix \spad{x}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(R,%)->%','dIncidenceAlgebra(R,S)',NULL,'\spad{r*x} is the left scalar multiple of the scalar \spad{r} and the matrix \spad{x}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,R)->%','dLocalAlgebra(A,R)',NULL,'\spad{x / d} divides the element \spad{x} by \spad{d}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,R)->%','dLocalize(M,R)',NULL,'\spad{x / d} divides the element \spad{x} by \spad{d}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,R)->%','dXPolynomialRing(R,E)','has(R,Field)','\spad{p/r} returns \spad{p*(1/r)}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,R)->%','dXPolynomialRing(R,E)',NULL,'\spad{p*r} returns the product of \spad{p} by \spad{r}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(Row,S)->Row','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->%','dFreeModule(R,S)',NULL,'\spad{r*b} returns the product of \spad{r} by \spad{b}.');
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xGradedAlgebra&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(R,S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Coef)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,Coef)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Coef)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Col)->Col','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,%)->%','dFreeGroup(S)',NULL,'\spad{s * x} returns the product of \spad{x} by \spad{s} on the left.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,S)->%','dFreeGroup(S)',NULL,'\spad{x * s} returns the product of \spad{x} by \spad{s} on the right.');
INSERT INTO olibdb VALUES('o','*',2,'n','(S,%)->%','dFreeMonoid(S)',NULL,'\spad{s * x} returns the product of \spad{x} by \spad{s} on the left.');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,S)->%','dFreeMonoid(S)',NULL,'\spad{x * s} returns the product of \spad{x} by \spad{s} on the right.');
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Fraction(Integer))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Fraction(Integer))->S','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Fraction(Integer))->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Fraction(Integer))->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->%','dFreeGroup(S)',NULL,'\spad{s ^ n} returns the product of \spad{s} by itself \spad{n} times.');
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Integer)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Integer)->S','xFullyLinearlyExplicitOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Integer)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Integer)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,Integer)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,Integer)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(SMP,%)->%','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{smp*ts} multiplies a TaylorSeries \spad{ts} by a monomial \spad{smp}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->%','dFreeMonoid(S)',NULL,'\spad{s ^ n} returns the product of \spad{s} by itself \spad{n} times.');
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,NonNegativeInteger)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xMagma&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,PositiveInteger)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->%','dFreeModule(R,S)',NULL,'\spad{s*r} returns the product \spad{r*s} used by \spadtype{XRecursivePolynomial}');
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,R)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xFullyLinearlyExplicitOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xGradedAlgebra&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,R)->S','xLieAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,R)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,R)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','~=',2,'n','(S,S)->Boolean','xBasicType&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(S,S)->Boolean','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','>',2,'n','(S,S)->Boolean','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(S,S)->Boolean','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<=',2,'n','(S,S)->Boolean','xOrderedSet&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','>=',2,'n','(S,S)->Boolean','xOrderedSet&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','>',2,'n','(S,S)->Boolean','xOrderedSet&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(S,S)->Boolean','xPartialOrder&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','>=',2,'n','(S,S)->Boolean','xPartialOrder&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','>',2,'n','(S,S)->Boolean','xPartialOrder&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','<',2,'n','(S,S)->Boolean','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','=',2,'n','(S,S)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/\',2,'n','(S,S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','\/',2,'n','(S,S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(S,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xDivisionRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,S)->S','xElementaryFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,S)->S','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xGradedModule&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(S,S)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(S,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(S,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xPowerSeriesCategory&(S,Coef,Expon,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(S,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(S,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','^',2,'n','(S,S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','+',2,'n','(S,S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','-',2,'n','(S,S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','*',2,'n','(Stream(A),A)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{a * r} returns the power series scalar multiplication of \spad{a} by \spad{r:} \spad{[a0,{} a1,{} ...] * r = [a0 * r,{} a1 * r,{} ...]}');
INSERT INTO olibdb VALUES('o','*',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{a * b} returns the power series (Cauchy) product of \spad{a} and \spad{b:} \spad{[a0,{} a1,{} ...] * [b0,{} b1,{} ...] = [c0,{} c1,{} ...]} where \spad{ck = sum(i + j = k,{} \spad{ai} * bk)}.');
INSERT INTO olibdb VALUES('o','-',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{a - b} returns the power series difference of \spad{a} and \spad{b}: \spad{[a0,{} a1,{} ..] - [b0,{} b1,{} ..] = [a0 - b0,{} a1 - b1,{} ..]}');
INSERT INTO olibdb VALUES('o','/',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{a / b} returns the power series quotient of \spad{a} by \spad{b}. An error message is returned if \spad{b} is not invertible. This function is used in fixed point computations.');
INSERT INTO olibdb VALUES('o','+',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{a + b} returns the power series sum of \spad{a} and \spad{b}: \spad{[a0,{} a1,{} ..] + [b0,{} b1,{} ..] = [a0 + b0,{} a1 + b1,{} ..]}');
INSERT INTO olibdb VALUES('o','*',2,'n','(Stream(Coef),Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{a * b} returns the power series (Cauchy) product of \spad{a} and \spad{b:} \spad{[a0,{} a1,{} ...] * [b0,{} b1,{} ...] = [c0,{} c1,{} ...]} where \spad{ck = sum(i + j = k,{} binomial(k,{} i) * \spad{ai} * bj)}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(Stream(Coef),Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{st1 ^ st2} computes the power of a power series \spad{st1} by another power series \spad{st2}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(Stream(Coef),Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{st1 ^ st2} computes the power of a power series \spad{st1} by another power series \spad{st2}.');
INSERT INTO olibdb VALUES('o','^',2,'n','(ULS,Fraction(Integer))->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)','has(Coef,Field)','\spad{s ^ r} raises a Laurent series \spad{s} to a rational power \spad{r}');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->UndirectedGraph(Product(S,S))','dUndirectedGraph(S)',NULL,'tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) are adjacent in \spad{G} \times \spad{H} if and only if u'' is adjacent with \spad{v''} and \spad{u} is adjacent with \spad{v}.');
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->Union(%,failed)','dOrdinaryWeightedPolynomials(R,vl,wl,wtlevel)','has(R,Field)',NULL);
INSERT INTO olibdb VALUES('o','/',2,'n','(%,%)->Union(%,failed)','dWeightedPolynomials(R,VarSet,E,P,vl,wl,wtlevel)','has(R,Field)','\spad{x/y} division (only works if minimum weight of divisor is zero,{} and if \spad{R} is a Field)');
INSERT INTO olibdb VALUES('o','^',2,'n','(UPXS,Fraction(Integer))->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)','has(Coef,Field)','\spad{z ^ r} raises a Puiseaux series \spad{z} to a rational power \spad{r}');
INSERT INTO olibdb VALUES('o','^',2,'n','(Vector(GF),Integer)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{x^n} \undocumented{} See \spadfunFrom{^}{DivisionRing}');
INSERT INTO olibdb VALUES('o','/',2,'n','(Vector(GF),Vector(GF))->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{x/y} \undocumented{} See \spadfunFrom{/}{Field}');
INSERT INTO olibdb VALUES('o','*',2,'n','(Vector(GF),Vector(GF))->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{x*y} \undocumented{} See \spadfunFrom{*}{SemiGroup}');
INSERT INTO olibdb VALUES('o','*',2,'n','(%,%)->WeightedGraph(Product(S,S),W)','dWeightedGraph(S,W)',NULL,'tensor product : the tensor product \spad{G*H} of graphs \spad{G} and \spad{H} is a graph such that the vertex set of \spad{G*H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}); and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) are adjacent in \spad{G} \times \spad{H} if and only if u'' is adjacent with \spad{v''} and \spad{u} is adjacent with \spad{v}.');
INSERT INTO olibdb VALUES('o','^',2,'x','((A)->A,NonNegativeInteger)->(A)->A','pMappingPackage1(A)',NULL,'\spad{f^n} is the function which is the \spad{n}-fold application \indented{1}{of \spad{f}.}');
INSERT INTO olibdb VALUES('o','*',2,'x','((B)->C,(A)->B)->(A)->C','pMappingPackage3(A,B,C)',NULL,'\spad{f*g} is the function \spad{h} \indented{1}{such that \spad{h x= f(g x)}.}');
INSERT INTO olibdb VALUES('o','=',2,'x','(%,%)->Boolean','cBasicType',NULL,'\spad{x = y} tests if \spad{x} and \spad{y} are equal.');
INSERT INTO olibdb VALUES('o','~=',2,'x','(%,%)->Boolean','cBasicType',NULL,'\spad{x~=y} tests if \spad{x} and \spad{y} are not equal.');
INSERT INTO olibdb VALUES('o','>=',2,'x','(%,%)->Boolean','cPartialOrder',NULL,'\spad{x >= y} is a greater than or equal test.');
INSERT INTO olibdb VALUES('o','>',2,'x','(%,%)->Boolean','cPartialOrder',NULL,'\spad{x > y} is a greater than test.');
INSERT INTO olibdb VALUES('o','<=',2,'x','(%,%)->Boolean','cPartialOrder',NULL,'\spad{x <= y} is a less than or equal test.');
INSERT INTO olibdb VALUES('o','<',2,'x','(%,%)->Boolean','cPartialOrder',NULL,'\spad{x < y} is a less than test.');
INSERT INTO olibdb VALUES('o','<',2,'x','(%,%)->Boolean','cPermutationCategory(S)',NULL,'\spad{p < q} is an order relation on permutations. Note: this order is only total if and only if \spad{S} is totally ordered or \spad{S} is finite.');
INSERT INTO olibdb VALUES('o','<',2,'x','(%,%)->Boolean','dPermutationGroup(S)',NULL,'\spad{gp1 < gp2} returns \spad{true} if and only if {\em gp1} is a proper subgroup of {\em gp2}.');
INSERT INTO olibdb VALUES('o','<=',2,'x','(%,%)->Boolean','dPermutationGroup(S)',NULL,'\spad{gp1 <= gp2} returns \spad{true} if and only if {\em gp1} is a subgroup of {\em gp2}. Note: because of a bug in the parser you have to call this function explicitly by {\em gp1 <=\$(PERMGRP S) gp2}.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->%','cAbelianGroup',NULL,'\spad{x-y} is the difference of \spad{x} and \spad{y} \spadignore{i.e.} \spad{x + (-y)}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','cAbelianSemiGroup',NULL,'\spad{x+y} computes the sum of \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,%)->%','cElementaryFunctionCategory',NULL,'\spad{x^y} returns \spad{x} to the power \spad{y}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,%)->%','cField',NULL,'\spad{x/y} divides the element \spad{x} by the element \spad{y}. Error: if \spad{y} is 0.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->%','cGradedModule(R,E)',NULL,'\spad{g-h} is the difference of \spad{g} and \spad{h} in the module of elements of the same degree as \spad{g} and \spad{h}. Error: if \spad{g} and \spad{h} have different degrees.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','cGradedModule(R,E)',NULL,'\spad{g+h} is the sum of \spad{g} and \spad{h} in the module of elements of the same degree as \spad{g} and \spad{h}. Error: if \spad{g} and \spad{h} have different degrees.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,%)->%','cGroup',NULL,'\spad{x/y} is the same as \spad{x} times the inverse of \spad{y}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,%)->%','cMagma',NULL,'\spad{a*b} is the product of \spad{a} and \spad{b} in a set with a binary operation.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->%','cMatrixCategory(R,Row,Col)','has(R,AbelianGroup)','\spad{x - y} is the difference of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,%)->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{x * y} is the product of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{x + y} is the sum of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Coef)->%','cUnivariateTaylorSeriesCategory(Coef)','has(Coef,Field)','\spad{f(x) ^ a} computes a power of a power series. When the coefficient ring is a field,{} we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,Col)->Col','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{x * c} is the product of the matrix \spad{x} and the column vector \spad{c}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,Col)->Col','cSquareMatrixCategory(ndim,R,Row,Col)',NULL,'\spad{x * c} is the product of the matrix \spad{x} and the column vector \spad{c}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->%','cVectorCategory(R)','has(R,AbelianGroup)','\spad{x - y} returns the component-wise difference of the vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','cVectorCategory(R)','has(R,AbelianSemiGroup)','\spad{x + y} returns the component-wise sum of the vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,%)->%','dCardinalNumber',NULL,'\spad{x^y} returns \spad{\#(X^Y)} where \spad{X^Y} is defined \indented{1}{as \spad{\{g| g: Y->X\}}.}');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,%)->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{s*t} is the inner product of the tensors \spad{s} and \spad{t} which contracts the last index of \spad{s} with the first index of \spad{t},{} \spadignore{i.e.} \indented{4}{\spad{t*s = contract(t,{} rank t,{} s,{} 1)}} \indented{4}{\spad{t*s = sum(k=1..N,{} t[i1,{} ..,{} iN,{} k]*s[k,{} j1,{} ..,{} jM])}} This is compatible with the use of \spad{M*v} to denote the matrix-vector inner product.');
INSERT INTO olibdb VALUES('o','/\',2,'x','(%,%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'Implement exterior grassmann product operator need to check precedence when used as an infix operator');
INSERT INTO olibdb VALUES('o','\/',2,'x','(%,%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'Implement regressive inner,{} meet product operator need to check precedence when used as an infix operator');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','dColor',NULL,'\spad{c1 + c2} additively mixes the two colors \spad{c1} and \spad{c2}.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->%','dDatabase(S)',NULL,'\spad{db1-db2} returns the difference of databases \spad{db1} and \spad{db2} \spadignore{i.e.} consisting of elements in \spad{db1} but not in \spad{db2}');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','dDatabase(S)',NULL,'\spad{db1+db2} returns the merge of databases \spad{db1} and \spad{db2}');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,%)->%','dEquation(S)','has(S,Field)','\spad{e1/e2} produces a new equation by dividing the left and right hand sides of equations \spad{e1} and \spad{e2}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','dOrderedCompletion(R)','has(R,AbelianMonoid)',NULL);
INSERT INTO olibdb VALUES('o','*',2,'x','(DoubleFloat,%)->%','dColor',NULL,'\spad{s * c},{} returns the color \spad{c},{} whose weighted shade has been scaled by \spad{s}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,%)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{I+J} computes the ideal generated by the union of \spad{I} and \spad{J}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,%)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{I*J} computes the product of the ideal \spad{I} and \spad{J}.');
INSERT INTO olibdb VALUES('o','/\',2,'x','(%,%)->%','dSingleInteger',NULL,'\spad{n} \spad{/\} \spad{m} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','\/',2,'x','(%,%)->%','dSingleInteger',NULL,'\spad{n} \spad{\/} \spad{m} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,F)->%','cExtensionField(F)',NULL,'\spad{x/y} divides \spad{x} by the scalar \spad{y}.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Fraction(Integer))->%','cRadicalCategory',NULL,'\spad{x ^ y} is the rational exponentiation of \spad{x} by the power \spad{y}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(Integer,%)->%','cAbelianGroup',NULL,'\spad{n*x} is the product of \spad{x} by the integer \spad{n}.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Integer)->%','cDivisionRing',NULL,'\spad{x^n} returns \spad{x} raised to the integer power \spad{n}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,Integer)->%','cFloatingPointSystem',NULL,'\spad{x / i} computes the division from \spad{x} by an integer \spad{i}.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Integer)->%','cGroup',NULL,'\spad{x^n} returns \spad{x} raised to the integer power \spad{n}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(Integer,%)->%','cMatrixCategory(R,Row,Col)','has(R,AbelianGroup)','\spad{n * x} is an integer multiple.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Integer)->%','cMatrixCategory(R,Row,Col)','has(R,Field)','\spad{m^n} computes an integral power of the matrix \spad{m}. Error: if matrix is not square or if the matrix is square but not invertible.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Integer)->%','cSquareMatrixCategory(ndim,R,Row,Col)','has(R,Field)','\spad{m^n} computes an integral power of the matrix \spad{m}. Error: if the matrix is not invertible.');
INSERT INTO olibdb VALUES('o','*',2,'x','(Integer,%)->%','cVectorCategory(R)','has(R,AbelianGroup)','\spad{n * y} multiplies each component of the vector \spad{y} by the integer \spad{n}.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,Integer)->%','dModuleOperator(R,M)',NULL,'\spad{op^n} \undocumented');
INSERT INTO olibdb VALUES('o','*',2,'x','(NonNegativeInteger,%)->%','cAbelianMonoid',NULL,'\spad{n * x} is left-multiplication by a non negative integer');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,NonNegativeInteger)->%','cMagmaWithUnit',NULL,'\spad{a^n} returns the \spad{n}\spad{-}th power of \spad{a},{} defined by repeated squaring.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,NonNegativeInteger)->%','cMatrixCategory(R,Row,Col)','AND(has(R,Monoid),has(R,SemiRng))','\spad{x ^ n} computes a non-negative integral power of the matrix \spad{x}. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,NonNegativeInteger)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{I^n} computes the \spad{n}th power of the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,Point(R))->Point(R)','dDenavitHartenbergMatrix(R)',NULL,'\spad{t*p} applies the dhmatrix \spad{t} to point \spad{p}');
INSERT INTO olibdb VALUES('o','*',2,'x','(PositiveInteger,%)->%','cAbelianSemiGroup',NULL,'\spad{n*x} computes the left-multiplication of \spad{x} by the positive integer \spad{n}. This is equivalent to adding \spad{x} to itself \spad{n} times.');
INSERT INTO olibdb VALUES('o','^',2,'x','(%,PositiveInteger)->%','cMagma',NULL,'\spad{a^n} returns the \spad{n}\spad{-}th power of \spad{a},{} defined by repeated squaring.');
INSERT INTO olibdb VALUES('o','*',2,'x','(PositiveInteger,%)->%','dColor',NULL,'\spad{s * c},{} returns the color \spad{c},{} whose weighted shade has been scaled by \spad{s}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,R)->%','cAbelianMonoidRing(R,E)','has(R,Field)','\spad{p/c} divides \spad{p} by the coefficient \spad{c}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(R,%)->%','cDirectProductCategory(dim,R)','has(R,SemiGroup)','\spad{r * y} multiplies the element \spad{r} times each component of the vector \spad{y}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cDirectProductCategory(dim,R)','has(R,SemiGroup)','\spad{y * r} multiplies each component of the vector \spad{y} by the element \spad{r}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cGradedModule(R,E)',NULL,'\spad{g*r} is right module multiplication.');
INSERT INTO olibdb VALUES('o','*',2,'x','(R,%)->%','cGradedModule(R,E)',NULL,'\spad{r*g} is left module multiplication.');
INSERT INTO olibdb VALUES('o','*',2,'x','(R,%)->%','cLeftModule(R)',NULL,'\spad{r*x} returns the left multiplication of the module element \spad{x} by the ring element \spad{r}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,R)->%','cLieAlgebra(R)','has(R,Field)','\spad{x/r} returns the division of \spad{x} by \spad{r}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,R)->%','cMatrixCategory(R,Row,Col)','has(R,Field)','\spad{m/r} divides the elements of \spad{m} by \spad{r}. Error: if \spad{r = 0}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(R,%)->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{r*x} is the left scalar multiple of the scalar \spad{r} and the matrix \spad{x}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{x * r} is the right scalar multiple of the scalar \spad{r} and the matrix \spad{x}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(%,R)->%','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,Field)','\spad{m/r} divides the elements of \spad{m} by \spad{r}. Error: if \spad{r = 0}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cRightModule(R)',NULL,'\spad{x*r} returns the right multiplication of the module element \spad{x} by the ring element \spad{r}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(R,%)->%','cVectorCategory(R)','has(R,SemiGroup)','\spad{r * y} multiplies the element \spad{r} times each component of the vector \spad{y}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cVectorCategory(R)','has(R,SemiGroup)','\spad{y * r} multiplies each component of the vector \spad{y} by the element \spad{r}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,R)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{x * r} returns the product of \spad{x} by \spad{r}. Useful if \spad{R} is a non-commutative Ring.');
INSERT INTO olibdb VALUES('o','*',2,'x','(Row,%)->Row','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{r * x} is the product of the row vector \spad{r} and the matrix \spad{x}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','*',2,'x','(Row,%)->Row','cSquareMatrixCategory(ndim,R,Row,Col)',NULL,'\spad{r * x} is the product of the row vector \spad{r} and the matrix \spad{x}. Error: if the dimensions are incompatible.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,S)->%','cSegmentCategory(S)','has(S,AbelianGroup)','\spad{(l..h)\spad{-i}} returns segment \spad{l-i .. h-i}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(S,%)->%','cSegmentCategory(S)','has(S,AbelianSemiGroup)','\spad{i+(l..h)} returns segment \spad{i+l .. i+h}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,S)->%','cSegmentCategory(S)','has(S,AbelianSemiGroup)','\spad{(l..h)\spad{+i}} returns segment \spad{l+i .. h+i}.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,S)->%','dEquation(S)','has(S,AbelianGroup)','\spad{eqn-x} produces a new equation by subtracting \spad{x} from both sides of equation eqn.');
INSERT INTO olibdb VALUES('o','-',2,'x','(S,%)->%','dEquation(S)','has(S,AbelianGroup)','\spad{x-eqn} produces a new equation by subtracting both sides of equation eqn from \spad{x}.');
INSERT INTO olibdb VALUES('o','+',2,'x','(%,S)->%','dEquation(S)','has(S,AbelianSemiGroup)','\spad{eqn+x} produces a new equation by adding \spad{x} to both sides of equation eqn.');
INSERT INTO olibdb VALUES('o','+',2,'x','(S,%)->%','dEquation(S)','has(S,AbelianSemiGroup)','\spad{x+eqn} produces a new equation by adding \spad{x} to both sides of equation eqn.');
INSERT INTO olibdb VALUES('o','*',2,'x','(%,S)->%','dEquation(S)','has(S,SemiGroup)','\spad{eqn*x} produces a new equation by multiplying both sides of equation eqn by \spad{x}.');
INSERT INTO olibdb VALUES('o','*',2,'x','(S,%)->%','dEquation(S)','has(S,SemiGroup)','\spad{x*eqn} produces a new equation by multiplying both sides of equation eqn by \spad{x}.');
INSERT INTO olibdb VALUES('o','/',2,'x','(SparseMultivariatePolynomial(R,K),SparseMultivariatePolynomial(R,K))->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{p1/p2} returns the quotient of \spad{p1} and \spad{p2} as an element of \%.');
INSERT INTO olibdb VALUES('o','/',2,'x','(S,S)->%','cQuotientFieldCategory(S)',NULL,'\spad{d1 / d2} returns the fraction \spad{d1} divided by \spad{d2}.');
INSERT INTO olibdb VALUES('o','=',2,'x','(S,S)->%','dEquation(S)',NULL,'\spad{a=b} creates an equation.');
INSERT INTO olibdb VALUES('o','-',2,'x','(%,%)->Union(%,failed)','dCardinalNumber',NULL,'\spad{x - y} returns an element \spad{z} such that \spad{z+y=x} or failed if no such element exists.');
INSERT INTO olibdb VALUES('o','+',2,'x','(UP,%)->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{p + x} returns the sum of \spad{p} and \spad{x}');
INSERT INTO olibdb VALUES('o','*',2,'x','(vl,%)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{v * x} returns the product of a variable \spad{x} by \spad{x}.');
INSERT INTO olibdb VALUES('o','abelianGroup',1,'x','(List(PositiveInteger))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{abelianGroup([n1,{} ...,{} nk])} constructs the abelian group that is the direct product of cyclic groups with order {\em \spad{ni}}.');
INSERT INTO olibdb VALUES('o','abs',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{abs(x)} represents the Fortran intrinsic function ABS');
INSERT INTO olibdb VALUES('o','abs',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{abs(f)} returns the absolute value operator applied to \spad{f}.');
INSERT INTO olibdb VALUES('o','abs',1,'n','(S)->R','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','abs',1,'n','(S)->R','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','abs',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','abs',1,'n','(S)->S','xOrderedRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','abs',1,'x','(%)->%','cComplexCategory(R)','has(R,RealNumberSystem)','\spad{abs(x)} returns the absolute value of \spad{x} = sqrt(norm(\spad{x})).');
INSERT INTO olibdb VALUES('o','abs',1,'x','(%)->%','cOrderedRing',NULL,'\spad{abs(x)} returns the absolute value of \spad{x}.');
INSERT INTO olibdb VALUES('o','abs',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{abs(x)} returns the absolute value of \spad{x}.');
INSERT INTO olibdb VALUES('o','abs',1,'x','(%)->R','cOctonionCategory(R)','has(R,RealNumberSystem)','\spad{abs(o)} computes the absolute value of an octonion,{} equal to the square root of the \spadfunFrom{norm}{Octonion}.');
INSERT INTO olibdb VALUES('o','abs',1,'x','(%)->R','cQuaternionCategory(R)','has(R,RealNumberSystem)','\spad{abs(q)} computes the absolute value of quaternion \spad{q} (sqrt of norm).');
INSERT INTO olibdb VALUES('o','absolutelyIrreducible?',0,'n','()->Boolean','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?');
INSERT INTO olibdb VALUES('o','absolutelyIrreducible?',0,'x','()->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?');
INSERT INTO olibdb VALUES('o','acos',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{acos(x)} represents the Fortran intrinsic function ACOS');
INSERT INTO olibdb VALUES('o','acos',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acos(x)} applies the inverse cosine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acos',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acos',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acos',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acos',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acos(st)} computes arccosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acos',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acos(st)} computes arccosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acos',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acos(z)} returns the arc-cosine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acos',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acos(z)} returns the arc-cosine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acos',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{acos(x)} returns the arc-cosine of \spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for acos lies along the negative real axis to the left of \spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane.');
INSERT INTO olibdb VALUES('o','acosh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acosh(x)} applies the inverse hyperbolic cosine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acosh',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acosh',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acosh',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acosh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acosh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acosh',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acosh(z)} returns the inverse hyperbolic cosine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acosh',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acosh(z)} returns the inverse hyperbolic cosine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acosh',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{acosh(x)} returns the hyperbolic arc-cosine of \spad{x}.');
INSERT INTO olibdb VALUES('o','acoshIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acoshIfCan(z)} returns acosh(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','acosIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acosIfCan(z)} returns acos(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','acot',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acot(x)} applies the inverse cotangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acot',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acot',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acot',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acot(st)} computes arccotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acot',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acot(st)} computes arccotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acot',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acot(z)} returns the arc-cotangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acot',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acot(z)} returns the arc-cotangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acot',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{acot(x)} returns the arc-cotangent of \spad{x}.');
INSERT INTO olibdb VALUES('o','acoth',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acoth(x)} applies the inverse hyperbolic cotangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acoth',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acoth',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acoth',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acoth',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acoth',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acoth(z)} returns the inverse hyperbolic cotangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acoth',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acoth(z)} returns the inverse hyperbolic cotangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acoth',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{acoth(x)} returns the hyperbolic arc-cotangent of \spad{x}.');
INSERT INTO olibdb VALUES('o','acothIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acothIfCan(z)} returns acoth(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','acotIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acotIfCan(z)} returns acot(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','acsc',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acsc(x)} applies the inverse cosecant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acsc',1,'n','(S)->S','xArcTrigonometricFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acsc',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acsc',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acsc(st)} computes arccosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acsc',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acsc(st)} computes arccosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acsc',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acsc(z)} returns the arc-cosecant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acsc',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acsc(z)} returns the arc-cosecant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acsc',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{acsc(x)} returns the arc-cosecant of \spad{x}.');
INSERT INTO olibdb VALUES('o','acsch',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{acsch(x)} applies the inverse hyperbolic cosecant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','acsch',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acsch',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','acsch',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acsch',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','acsch',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{acsch(z)} returns the inverse hyperbolic cosecant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','acsch',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{acsch(z)} returns the inverse hyperbolic cosecant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','acsch',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{acsch(x)} returns the hyperbolic arc-cosecant of \spad{x}.');
INSERT INTO olibdb VALUES('o','acschIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acschIfCan(z)} returns acsch(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','acscIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{acscIfCan(z)} returns acsc(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','aCubic',4,'n','(F,F,F,F)->F','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{aCubic(f,{} g,{} h,{} j)} \undocumented');
INSERT INTO olibdb VALUES('o','adaptive?',0,'n','()->Boolean','dPlot',NULL,'\spad{adaptive?()} determines whether plotting be done adaptively');
INSERT INTO olibdb VALUES('o','adaptive',0,'x','()->Boolean','pGraphicsDefaults',NULL,'\spad{adaptive()} determines whether plotting will be done adaptively.');
INSERT INTO olibdb VALUES('o','adaptive',1,'x','(Boolean)->Boolean','pGraphicsDefaults',NULL,'\spad{adaptive(true)} turns adaptive plotting on; \spad{adaptive(false)} turns adaptive plotting off.');
INSERT INTO olibdb VALUES('o','adaptive',1,'x','(Boolean)->%','dDrawOption',NULL,'\spad{adaptive(b)} turns adaptive 2D plotting on if \spad{b} is \spad{true},{} or off if \spad{b} is \spad{false}. This option is expressed in the form \spad{adaptive == b}.');
INSERT INTO olibdb VALUES('o','adaptive',2,'n','(List(DrawOption),Boolean)->Boolean','pDrawOptionFunctions0',NULL,'\spad{adaptive(l,{} b)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{adaptive}. If the option does not exist the value,{} \spad{b} is returned.');
INSERT INTO olibdb VALUES('o','adaptive3D?',0,'n','()->Boolean','dPlot3D',NULL,'\spad{adaptive3D?()} determines whether plotting be done adaptively.');
INSERT INTO olibdb VALUES('o','addALS',2,'n','(%,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addALS(f,{}g)} computes \spad{f+g} in terms of the admissible linear systems for \spad{f} and \spad{g} (without minimization).');
INSERT INTO olibdb VALUES('o','addArrow!',2,'n','(A,Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))->A','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',2,'n','(A,Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',2,'n','(%,Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))->%','cFiniteGraph(S)',NULL,'\spad{addArrow!(s,{} ar)} adds an arrow ar to the graph \spad{s}');
INSERT INTO olibdb VALUES('o','addArrow',3,'n','(A,S,S)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow',3,'n','(%,S,S)->%','cPoset(S)',NULL,'\spad{addArrow(s,{} nm,{} n1,{} n2)} constructs new poset by adding to the poset \spad{s} arrow from \spad{n1} to \spad{n2}.');
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(A,String,NonNegativeInteger,NonNegativeInteger)->A','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(A,String,NonNegativeInteger,NonNegativeInteger)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(A,String,S,S)->A','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(A,String,S,S)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(%,String,NonNegativeInteger,NonNegativeInteger)->%','cFiniteGraph(S)',NULL,'\spad{addArrow!(s,{} nm,{} n1,{} n2)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{n1} is the index of the start object \spad{n2} is the index of the end object');
INSERT INTO olibdb VALUES('o','addArrow!',4,'n','(%,String,S,S)->%','cFiniteGraph(S)',NULL,'\spad{addArrow!(s,{} nm,{} o1,{} o2)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{o1} is the start object \spad{o2} is the end object');
INSERT INTO olibdb VALUES('o','addArrow!',5,'n','(A,String,NonNegativeInteger,NonNegativeInteger,List(NonNegativeInteger))->A','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',5,'n','(A,String,NonNegativeInteger,NonNegativeInteger,List(NonNegativeInteger))->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addArrow!',5,'n','(%,String,NonNegativeInteger,NonNegativeInteger,List(NonNegativeInteger))->%','cFiniteGraph(S)',NULL,'\spad{addArrow!(s,{} nm,{} n1,{} n2,{} mp)} adds an arrow to the graph \spad{s},{} where: \spad{nm} is the name of the arrow \spad{n1} is the index of the start object \spad{n2} is the index of the end object \spad{mp} is a map represented by this arrow');
INSERT INTO olibdb VALUES('o','addArrows2Din2D',5,'n','(%,(PT)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addArrows2Din2D(n,{} ptFun,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createArrows2Din2D with addChild!');
INSERT INTO olibdb VALUES('o','addBadValue',2,'n','(%,Any)->%','dPattern(R)',NULL,'\spad{addBadValue(p,{} v)} adds \spad{v} to the list of bad values for \spad{p}. Note: \spad{p} is not allowed to match any of its bad values.');
INSERT INTO olibdb VALUES('o','addBadValue',2,'n','(Pattern(R),D)->Pattern(R)','pPatternFunctions1(R,D)',NULL,'\spad{addBadValue(p,{} v)} adds \spad{v} to the list of bad values for \spad{p}; \spad{p} is not allowed to match any of its bad values.');
INSERT INTO olibdb VALUES('o','addChild!',2,'n','(%,%)->Void','dScene(PT)',NULL,'\spad{addChild!(n,{} c)} adds the specified child node \spad{''c''} below node \spad{''n''}');
INSERT INTO olibdb VALUES('o','addColumns!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addColumns!(f,{} i,{} j,{} alpha)} adds alpha*column(\spad{i}) to column(\spad{j}) in A and subtracts row(\spad{j}) from row(\spad{i}) in \spad{s} (in the ALS of \spad{f}),{} \spadignore{i.e.} (A*U)(U^-1*s) = \spad{v}.');
INSERT INTO olibdb VALUES('o','addColumns!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{addColumns!(p,{} i,{} j,{} alpha)} adds alpha*column(\spad{i}) to column(\spad{j}) in all matrices of the linear pencil \spad{p}.');
INSERT INTO olibdb VALUES('o','addColumnsRows!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addColumnsRows!(f,{} i,{} j,{} alpha)} adds alpha*column(\spad{i}) to column(\spad{j}) and subtracts alpha*row(\spad{j}) from row(\spad{i}) in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','addCube',2,'n','(%,CubicalFacet)->%','dFiniteCubicalComplex(VS)',NULL,'Add a facet to this simplex If the facet is also in the list then,{} do not append,{} instead change the multiplier.');
INSERT INTO olibdb VALUES('o','addiag',1,'n','(Stream(Stream(A)))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{addiag(x)} performs diagonal addition of a stream of streams. if \spad{x} = \spad{[[a<0,{} 0>,{} a<0,{} 1>,{} ..],{} [a<1,{} 0>,{} a<1,{} 1>,{} ..],{} [a<2,{} 0>,{} a<2,{} 1>,{} ..],{} ..]} and \spad{addiag(x) = [b<0,{} b<1>,{} ...],{} then b<k> = sum(i+j=k,{} a<i,{} j>)}.');
INSERT INTO olibdb VALUES('o','addImpliedFaces',1,'n','(%)->List(List(CubicalFacet))','dFiniteCubicalComplex(VS)',NULL,'a function to take a set of faces and add those that are implied by the cubicalComplex conventions (if they don\spad{''t} already exist). For example,{} if the input is a square [1..2,{} 1..2] then we would add its edges [1..1,{} 1..2],{} [2..2,{} 1..2],{} [1..2,{} 1..1],{} and [1..2,{} 2..2].');
INSERT INTO olibdb VALUES('o','addImpliedFaces',1,'n','(%)->List(List(OrientedFacet))','dFiniteSimplicialComplex(VS)',NULL,'a function to take a set of faces and add those that are implied by the simplecicalComplex conventions (if they don\spad{''t} already exist). For example,{} if the input is a triangle ((1,{} 2,{} 3)) then we would add: its points ((1),{} (2),{} (3)). and its edges ((1,{} 2),{} (1,{} 3),{} (2,{} 3)).');
INSERT INTO olibdb VALUES('o','additive?',2,'n','(%,PositiveInteger)->Boolean','dDirichletRing(Coef)',NULL,'\spad{additive?(a,{} n)} returns \spad{true} if the first \spad{n} coefficients of a are additive');
INSERT INTO olibdb VALUES('o','addMatch',3,'n','(Pattern(R),S,%)->%','dPatternMatchResult(R,S)',NULL,'\spad{addMatch(var,{} expr,{} r)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} provided that \spad{expr} satisfies the predicates attached to \spad{var},{} and that \spad{var} is not matched to another expression already.');
INSERT INTO olibdb VALUES('o','addMatchRestricted',4,'n','(Pattern(R),S,%,S)->%','dPatternMatchResult(R,S)',NULL,'\spad{addMatchRestricted(var,{} expr,{} r,{} val)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} provided that \spad{expr} satisfies the predicates attached to \spad{var},{} that \spad{var} is not matched to another expression already,{} and that either \spad{var} is an optional pattern variable or that \spad{expr} is not equal to val (usually an identity).');
INSERT INTO olibdb VALUES('o','addMIN',2,'n','(%,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addMIN(f,{}g)} uses addALS(\spad{f},{}\spad{g}) with minimization.');
INSERT INTO olibdb VALUES('o','addmod',3,'x','(%,%,%)->%','cIntegerNumberSystem',NULL,'\spad{addmod(a,{} b,{} p)},{} \spad{0<=a,{} b<p>1},{} means \spad{a+b mod p}.');
INSERT INTO olibdb VALUES('o','addNode!',3,'n','(%,String,Scene(PT))->%','dSceneNamedPoints(PT)',NULL,'\spad{addNode!(n,{} ptName,{} sc)} adds a scene node.');
INSERT INTO olibdb VALUES('o','addObject!',2,'n','(A,Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addObject!',2,'n','(A,S)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addObject',2,'n','(A,S)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','addObject!',2,'n','(%,Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))->%','cFiniteGraph(S)',NULL,'\spad{addObject!(s,{} n)} adds object with coordinates \spad{n} to the graph \spad{s}.');
INSERT INTO olibdb VALUES('o','addObject!',2,'n','(%,S)->%','cFiniteGraph(S)',NULL,'\spad{addObject!(s,{} n)} adds object \spad{n} to the graph \spad{s}. Use this version if you don\spad{''t} intend to create diagrams and therefore don\spad{''t} care about \spad{x},{} \spad{y} coordinates.');
INSERT INTO olibdb VALUES('o','addObject',2,'n','(%,S)->%','cPoset(S)',NULL,'\spad{addObject(s,{} n)} constructs new poset by adding object \spad{n} to the poset \spad{s}.');
INSERT INTO olibdb VALUES('o','addPlot1Din2D',4,'n','(%,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!');
INSERT INTO olibdb VALUES('o','addPlot1Din2D',4,'n','(%,(DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot1Din2D(n,{} f,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2D with addChild!');
INSERT INTO olibdb VALUES('o','addPlot1Din2Dparametric',4,'n','(%,ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot1Din2Dparametric(n,{} ppc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din2Dparametric with addChild!');
INSERT INTO olibdb VALUES('o','addPlot1Din3Dparametric',4,'n','(%,(DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot1Din3Dparametric(n,{} pcfun,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!');
INSERT INTO olibdb VALUES('o','addPlot1Din3Dparametric',4,'n','(%,ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot1Din3Dparametric(n,{} psc,{} tRange,{} numPts)} is a convenience function which combines createPlot1Din3Dparametric with addChild!');
INSERT INTO olibdb VALUES('o','addPlot2Din3D',5,'n','(%,(DoubleFloat,DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot2Din3D(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3D with addChild!');
INSERT INTO olibdb VALUES('o','addPlot2Din3Dparametric',5,'n','(%,(DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!');
INSERT INTO olibdb VALUES('o','addPlot2Din3Dparametric',5,'n','(%,ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{addPlot2Din3Dparametric(n,{} f,{} uSeg,{} vSeg,{} numPts)} is a convenience function which combines createPlot2Din3Dparametric with addChild!');
INSERT INTO olibdb VALUES('o','addPoint2',2,'n','(%,Point(R))->%','dSubSpace(n,R)',NULL,'\spad{addPoint2(s,{} p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. The subspace \spad{s} is returned with the additional point.');
INSERT INTO olibdb VALUES('o','addPoint',2,'n','(%,Point(R))->NonNegativeInteger','dSubSpace(n,R)',NULL,'\spad{addPoint(s,{} p)} adds the point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s},{} and returns the new total number of points in \spad{s}.');
INSERT INTO olibdb VALUES('o','addPoint',3,'n','(%,List(NonNegativeInteger),NonNegativeInteger)->%','dSubSpace(n,R)',NULL,'\spad{addPoint(s,{} \spad{li},{} i)} adds the 4 dimensional point indicated by the index location,{} \spad{i},{} to the 3 dimensional subspace,{} \spad{s}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\spad{''s} length should range from 0 to \spad{n - 1} where \spad{n} is the dimension of the subspace. If the length is \spad{n - 1},{} then a specific lowest level component is being referenced. If it is less than \spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \spad{s} is returned with the additional point.');
INSERT INTO olibdb VALUES('o','addPoint',3,'n','(%,List(NonNegativeInteger),Point(R))->%','dSubSpace(n,R)',NULL,'\spad{addPoint(s,{} \spad{li},{} p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\spad{''s} length should range from 0 to \spad{n - 1} where \spad{n} is the dimension of the subspace. If the length is \spad{n - 1},{} then a specific lowest level component is being referenced. If it is less than \spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \spad{s} is returned with the additional point.');
INSERT INTO olibdb VALUES('o','addPointLast',4,'n','(%,%,Point(R),NonNegativeInteger)->%','dSubSpace(n,R)',NULL,'\spad{addPointLast(s,{} s2,{} \spad{li},{} p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. \spad{s2} point to the end of the subspace \spad{s}. \spad{n} is the path in the \spad{s2} component. The subspace \spad{s} is returned with the additional point.');
INSERT INTO olibdb VALUES('o','addPoints!',3,'n','(%,String,%)->%','dSceneNamedPoints(PT)',NULL,'\spad{addPoints!(n,{} ptName,{} pts)} adds a points node.');
INSERT INTO olibdb VALUES('o','add_poly',3,'n','(PA,PA,MD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{add_poly(pol1,{} pol2,{} md)} add polynomials \spad{pol1} and \spad{pol2}.');
INSERT INTO olibdb VALUES('o','addRows!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addRows!(f,{} i,{} j,{} alpha)} adds alpha*row(\spad{i}) to row(\spad{j}) in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','addRows!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{addRows!(p,{} i,{} j,{} alpha)} adds alpha*row(\spad{i}) to row(\spad{j}) in all matrices of the linear pencil \spad{p}.');
INSERT INTO olibdb VALUES('o','addRowsColumns!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addRowsColumns!(f,{} i,{} j,{} alpha)} adds alpha*row(\spad{i}) to row(\spad{j}) and subtracts alpha*column(\spad{j}) from column(\spad{i}) in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','addSceneArrow',6,'n','(%,String,String,PT,Symbol,DoubleFloat)->%','dScene(PT)',NULL,'\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size)} is a convenience function which combines createSceneArrow with addChild!');
INSERT INTO olibdb VALUES('o','addSceneArrow',7,'n','(%,%,%,PT,Symbol,DoubleFloat,DoubleFloat)->%','dScene(PT)',NULL,'\spad{addSceneArrow(n,{} st,{} en,{} offset,{} mode,{} size,{} fontScale)} is a convenience function which combines createSceneArrow with addChild!');
INSERT INTO olibdb VALUES('o','addSceneArrows',4,'n','(%,List(List(PT)),Symbol,DoubleFloat)->%','dScene(PT)',NULL,'\spad{addSceneArrows(n,{} line,{} mode,{} size)} is a convenience function which combines createSceneArrows with addChild!');
INSERT INTO olibdb VALUES('o','addSceneBox',2,'n','(%,DoubleFloat)->%','dScene(PT)',NULL,'\spad{addSceneBox(n,{} size)} is a convenience function which combines createSceneBox with addChild!');
INSERT INTO olibdb VALUES('o','addSceneClip',2,'n','(%,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addSceneClip(n,{} bb)} is a convenience function which combines createSceneClip with addChild!');
INSERT INTO olibdb VALUES('o','addSceneDef',3,'n','(%,String,%)->%','dScene(PT)',NULL,'\spad{addSceneDef(n,{} nam,{} nde)} is a convenience function which combines createSceneDef with addChild!');
INSERT INTO olibdb VALUES('o','addSceneGraph',5,'n','(%,DirectedGraph(String),NonNegativeInteger,NonNegativeInteger,Boolean)->%','dScene(PT)',NULL,'\spad{addSceneGraph(n,{} g,{} x,{} y,{} dispArrowName)} is a convenience function which combines createSceneGraph with addChild!');
INSERT INTO olibdb VALUES('o','addSceneGrid',2,'n','(%,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addSceneGrid(n,{} bb)} is a convenience function which combines createSceneGrid with addChild!');
INSERT INTO olibdb VALUES('o','addSceneGrid',3,'n','(%,DoubleFloat,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addSceneGrid(n,{} stepSize,{} bb)} is a convenience function which combines createSceneGrid with addChild!');
INSERT INTO olibdb VALUES('o','addSceneGroup',1,'n','(%)->%','dScene(PT)',NULL,'\spad{addSceneGroup(n)} is a convenience function which combines createSceneGroup with addChild!');
INSERT INTO olibdb VALUES('o','addSceneIFS',2,'n','(%,SceneIFS(PT))->%','dScene(PT)',NULL,'\spad{addSceneIFS(n,{} in1)} is a convenience function which combines createSceneIFS with addChild!');
INSERT INTO olibdb VALUES('o','addSceneIFS',3,'n','(%,List(List(NonNegativeInteger)),List(PT))->%','dScene(PT)',NULL,'\spad{addSceneIFS(n,{} inx,{} pts)} is a convenience function which combines createSceneIFS with addChild!');
INSERT INTO olibdb VALUES('o','addSceneLine',2,'n','(%,List(PT))->%','dScene(PT)',NULL,'\spad{addSceneLine(n,{} line)} is a convenience function which combines createSceneLine with addChild!');
INSERT INTO olibdb VALUES('o','addSceneLine',4,'n','(%,%,%,DoubleFloat)->%','dScene(PT)',NULL,'\spad{addSceneLine(n,{} st,{} en,{} fontScale)} is a convenience function which combines createSceneLine with addChild!');
INSERT INTO olibdb VALUES('o','addSceneLine',5,'n','(%,%,%,DoubleFloat,Boolean)->%','dScene(PT)',NULL,'\spad{addSceneLine(n,{} st,{} en,{} fontScale)} is a convenience function which combines createSceneLine with addChild!');
INSERT INTO olibdb VALUES('o','addSceneLines',2,'n','(%,List(List(PT)))->%','dScene(PT)',NULL,'\spad{addSceneLines(n,{} line)} is a convenience function which combines createSceneLines with addChild!');
INSERT INTO olibdb VALUES('o','addSceneMaterial',2,'n','(%,Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat))->%','dScene(PT)',NULL,'\spad{addSceneMaterial(n,{} mat)} is a convenience function which combines createSceneMaterial with addChild!');
INSERT INTO olibdb VALUES('o','addSceneMaterial',4,'n','(%,DoubleFloat,String,String)->%','dScene(PT)',NULL,'\spad{addSceneMaterial(n,{} lineW,{} lineC,{} fillC)} is a convenience function which combines createSceneMaterial with addChild!');
INSERT INTO olibdb VALUES('o','addSceneNamedPoints',2,'n','(%,SceneNamedPoints(PT))->%','dScene(PT)',NULL,'\spad{addSceneNamedPoints(n,{} np)} is a convenience function which combines createSceneNamedPoints with addChild!');
INSERT INTO olibdb VALUES('o','addScenePattern',4,'n','(%,Symbol,NonNegativeInteger,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addScenePattern(n,{} ptype,{} step,{} bb)} is a convenience function which combines createScenePattern with addChild!');
INSERT INTO olibdb VALUES('o','addSceneRuler',4,'n','(%,Symbol,PT,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addSceneRuler(n,{} ptype,{} offset,{} bb)} is a convenience function which combines createSceneRuler with addChild!');
INSERT INTO olibdb VALUES('o','addSceneShape',2,'n','(%,Record(shptype:Symbol,centre:PT,size:PT,fill:Boolean))->%','dScene(PT)',NULL,'\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!');
INSERT INTO olibdb VALUES('o','addSceneShape',2,'n','(%,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{addSceneShape(n,{} shape)} is a convenience function which combines createSceneShape with addChild!');
INSERT INTO olibdb VALUES('o','addSceneText',2,'n','(%,Record(txt:String,siz:NonNegativeInteger,pos:PT,np:List(String)))->%','dScene(PT)',NULL,'\spad{addSceneText(n,{} text)} is a convenience function which combines createSceneText with addChild!');
INSERT INTO olibdb VALUES('o','addSceneText',4,'n','(%,List(String),NonNegativeInteger,PT)->%','dScene(PT)',NULL,'\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!');
INSERT INTO olibdb VALUES('o','addSceneText',4,'n','(%,String,NonNegativeInteger,PT)->%','dScene(PT)',NULL,'\spad{addSceneText(n,{} str,{} sz,{} pz)} is a convenience function which combines createSceneText with addChild!');
INSERT INTO olibdb VALUES('o','addSceneTransform',2,'n','(%,STransform(PT))->%','dScene(PT)',NULL,'\spad{addSceneTransform(n,{} tran)} is a convenience function which combines createSceneTransform with addChild!');
INSERT INTO olibdb VALUES('o','addSceneUse',2,'n','(%,String)->%','dScene(PT)',NULL,'\spad{addSceneUse(n,{} nam)} is a convenience function which combines createSceneUse with addChild!');
INSERT INTO olibdb VALUES('o','addSimplex',2,'n','(%,OrientedFacet)->%','dFiniteSimplicialComplex(VS)',NULL,'Add a facet to this simplex If the facet is also in the list then,{} do not append,{} instead change the multiplier. Used by boundary function');
INSERT INTO olibdb VALUES('o','add_slots',2,'n','(List(Integer),%)->Void','dVectorModularReconstructor',NULL,'\spad{add_slots(\spad{li})} extend reconstructor adding zeros at positions in \spad{li}.');
INSERT INTO olibdb VALUES('o','addVertex2',2,'n','(%,Record(left:NonNegativeInteger,right:NonNegativeInteger))->%','dProductFacet',NULL,'used by cone. Adds a vertex to face.');
INSERT INTO olibdb VALUES('o','addVertex',2,'n','(%,NonNegativeInteger)->%','dOrientedFacet',NULL,'used by cone. Adds a vertex to face.');
INSERT INTO olibdb VALUES('o','addWarning',1,'n','(OutputForm)->Void','pUnittestCount',NULL,'\spad{addWarning s} is an internal function that adds \spad{s},{} together with an indication of the current testcase and the current testsuite to the list of warnings.');
INSERT INTO olibdb VALUES('o','addWArrow!',5,'n','(%,String,NonNegativeInteger,NonNegativeInteger,W)->%','dWeightedGraph(S,W)',NULL,'\spad{addWArrow!(s,{} name,{} n1,{} n2,{} w)} adds a weighted arrow to the graph \spad{s},{} where \spad{name} is \spad{name} of the arrow,{} \spad{w} is weight of the arrow,{} \spad{n1} is starting point of the arrow,{} \spad{n2} is endpoint of the arrow.');
INSERT INTO olibdb VALUES('o','adjacencyMatrix',1,'n','(A)->Matrix(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','adjacencyMatrix',1,'n','(%)->Matrix(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{adjacencyMatrix(s)} returns an \spad{n} by \spad{n} matrix A,{} where \spad{n} is the number of vertices in the graph. If there is an edge from a vertex \spad{x} to a vertex \spad{y},{} then the element ax,{} \spad{y} is 1 (or in general the number of xy edges),{} otherwise it is 0. In computing,{} this matrix makes it easy to find subgraphs,{} and to reverse a directed graph.');
INSERT INTO olibdb VALUES('o','adjoint',1,'n','(%)->%','dOperator(R)','has(R,CommutativeRing)',NULL);
INSERT INTO olibdb VALUES('o','adjoint',1,'n','(%)->%','dPartialDifferentialOperator(R,Var)',NULL,'\spad{adjoint(p)} returns the adjoint of operator \spad{p}.');
INSERT INTO olibdb VALUES('o','adjoint',1,'n','(S)->S','xLinearOrdinaryDifferentialOperatorCategory&(S,A)',NULL,NULL);
INSERT INTO olibdb VALUES('o','adjoint',1,'x','(%)->%','cLinearOrdinaryDifferentialOperatorCategory(A)',NULL,'\spad{adjoint(a)} returns the adjoint operator of a.');
INSERT INTO olibdb VALUES('o','adjoint',1,'x','(%)->%','dModuleOperator(R,M)','has(R,CommutativeRing)','\spad{adjoint(op)} returns the adjoint of the operator \spad{op}.');
INSERT INTO olibdb VALUES('o','adjoint',1,'x','(M)->Record(adjMat:M,detMat:R)','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,IntegralDomain)','\spad{adjoint(m)} returns the ajoint matrix of \spad{m} (\spadignore{i.e.} the matrix \spad{n} such that \spad{m*n} = determinant(\spad{m})*id) and the detrminant of \spad{m}.');
INSERT INTO olibdb VALUES('o','adjoint',2,'n','(%,%)->%','dOperator(R)','has(R,CommutativeRing)',NULL);
INSERT INTO olibdb VALUES('o','adjoint',2,'x','(%,%)->%','dModuleOperator(R,M)','has(R,CommutativeRing)','\spad{adjoint(op1,{} op2)} sets the adjoint of \spad{op1} to be \spad{op2}. \spad{op1} must be a basic operator');
INSERT INTO olibdb VALUES('o','admissibleLinearSystem',1,'n','(%)->OutputForm','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{admissibleLinearSystem(f)} output as ALS.');
INSERT INTO olibdb VALUES('o','airyAi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{airyAi(x)} returns the Airy \spad{Ai} function applied to \spad{x}.');
INSERT INTO olibdb VALUES('o','airyAi',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyAi',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{airyAi(x)} is the Airy function \spad{\spad{Ai}(x)}.');
INSERT INTO olibdb VALUES('o','airyAi',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyAiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{airyAiPrime(x)} returns the derivative of Airy \spad{Ai} function applied to \spad{x}.');
INSERT INTO olibdb VALUES('o','airyAiPrime',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyAiPrime',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{airyAiPrime(x)} is the derivative of the Airy function \spad{\spad{Ai}(x)}.');
INSERT INTO olibdb VALUES('o','airyAiPrime',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyBi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{airyBi(x)} returns the Airy \spad{Bi} function applied to \spad{x}.');
INSERT INTO olibdb VALUES('o','airyBi',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyBi',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{airyBi(x)} is the Airy function \spad{\spad{Bi}(x)}.');
INSERT INTO olibdb VALUES('o','airyBi',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyBiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{airyBiPrime(x)} returns the derivative of Airy \spad{Bi} function applied to \spad{x}.');
INSERT INTO olibdb VALUES('o','airyBiPrime',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','airyBiPrime',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{airyBiPrime(x)} is the derivative of the Airy function \spad{\spad{Bi}(x)}.');
INSERT INTO olibdb VALUES('o','airyBiPrime',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Aleph',1,'x','(NonNegativeInteger)->%','dCardinalNumber',NULL,'\spad{Aleph(n)} provides the named (infinite) cardinal number.');
INSERT INTO olibdb VALUES('o','algDepHP',2,'n','(List(List(AlgebraicNumber)),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(AlgebraicNumber))->Stream(UnivariateFormalPowerSeries(AlgebraicNumber)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(AlgebraicNumber))->AlgebraicNumber,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(AlgebraicNumber))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','algDepHP',2,'x','(List(List(F)),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(F))->F,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(F))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algDepHP',2,'x','(List(List(F)),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(EXPRR,Symbol)->Stream(EXPRR),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(S))->S,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,EXPRR)->EXPRR,C:(NonNegativeInteger)->List(S))','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{algDepHP(list,{} options)} returns a specification for Hermite-Pade approximation looking for algebraic dependencies');
INSERT INTO olibdb VALUES('o','algDepHP',2,'x','(List(List(Fraction(Integer))),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Integer)))->Stream(UnivariateFormalPowerSeries(Fraction(Integer))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Integer))->Integer,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','algDepHP',2,'x','(List(List(Fraction(Polynomial(Integer)))),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(Integer)))->Polynomial(Integer),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(Integer)))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','algDepHP',2,'x','(List(List(Fraction(Polynomial(R)))),List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(R))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(R)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(R)))->Polynomial(R),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(R)))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algDsolve',2,'n','(LinearOrdinaryDifferentialOperator1(R),List(R))->Record(particular:List(Record(ratpart:R,coeffs:Vector(F))),basis:List(R))','pPureAlgebraicLODE(F,UP,UPUP,R)',NULL,'\spad{algDsolve(op,{} lg)} is a parametric version of algDsolve(\spad{op},{} \spad{g})');
INSERT INTO olibdb VALUES('o','algDsolve',2,'n','(LinearOrdinaryDifferentialOperator1(R),R)->Record(particular:Union(R,failed),basis:List(R))','pPureAlgebraicLODE(F,UP,UPUP,R)',NULL,'\spad{algDsolve(op,{} g)} returns \spad{[failed,{} []]} if the equation \spad{op y = g} has no solution in \spad{R}. Otherwise,{} it returns \spad{[f,{} [y1,{} ...,{} ym]]} where \spad{f} is a particular rational solution and the \spad{y_i''s} form a basis for the solutions in \spad{R} of the homogeneous equation.');
INSERT INTO olibdb VALUES('o','algebraic?',1,'n','(S)->Boolean','xExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraic?',1,'n','(S)->Boolean','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraic?',1,'x','(%)->Boolean','cExtensionField(F)',NULL,'\spad{algebraic?(a)} tests whether an element \spad{a} is algebraic with respect to the ground field \spad{F}.');
INSERT INTO olibdb VALUES('o','algebraic?',2,'n','(V,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraic?',2,'x','(V,%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{algebraic?(v,{} ts)} returns \spad{true} iff \spad{v} is the main variable of some polynomial in \spad{ts}.');
INSERT INTO olibdb VALUES('o','algebraicCoefficients?',2,'n','(P,S)->Boolean','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraicCoefficients?',2,'x','(P,%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{algebraicCoefficients?(p,{} ts)} returns \spad{true} iff every variable of \spad{p} which is not the main one of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','algebraicDecompose',2,'x','(P,TS)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraicDecompose',3,'x','(P,TS,Boolean)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraicGcd',6,'n','(Polynomial(Integer),Polynomial(Integer),List(Polynomial(Integer)),List(Symbol),Symbol,List(Symbol))->Polynomial(Integer)','pModularAlgebraicGcd(MPT,MD,MO)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraicGcd',6,'n','(PT,PT,List(PT),List(Symbol),Symbol,List(Symbol))->Polynomial(Integer)','pModularAlgebraicGcd2(PT,MP,MPT,MD,ME,MO)',NULL,'\spad{algebraicGcd(x,{} y,{} lm,{} lp,{} v,{} la)} computes \spad{gcd} of \spad{x} and \spad{y} modulo polynomials in \spad{lm}. la is list of algebraic parameters,{} \spad{lp} is a list of transcendental parameters,{} \spad{v} is main variable.');
INSERT INTO olibdb VALUES('o','algebraicOf',2,'x','(RightOpenIntervalRootCharacterization(%,SparseUnivariatePolynomial(%)),OutputForm)->%','dRealClosure(TheField)',NULL,'\spad{algebraicOf(char)} is the external number');
INSERT INTO olibdb VALUES('o','algebraicSort',1,'x','(List(TS))->List(TS)','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{algebraicSort(lts)} sorts \spad{lts} \spad{w}.\spad{r}.\spad{t} \spadopFrom{supDimElseRittWu?}{QuasiComponentPackage}.');
INSERT INTO olibdb VALUES('o','algebraicSort',1,'x','(List(TS))->List(TS)','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{algebraicSort(lts)} sorts \spad{lts} \spad{w}.\spad{r}.\spad{t} \spadopFrom{supDimElseRittWu}{QuasiComponentPackage}.');
INSERT INTO olibdb VALUES('o','algebraicVariables',1,'n','(S)->List(V)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algebraicVariables',1,'x','(%)->List(V)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{algebraicVariables(ts)} returns the decreasingly sorted list of the main variables of the polynomials of \spad{ts}.');
INSERT INTO olibdb VALUES('o','algextint',5,'n','((UP)->UP,(List(Fraction(UP)))->List(Record(ratpart:Fraction(UP),coeffs:Vector(F))),(Fraction(UP),List(Fraction(UP)))->List(Record(ratpart:Fraction(UP),coeffs:Vector(F))),(Matrix(F))->List(Vector(F)),List(R))->List(Record(ratpart:R,coeffs:Vector(F)))','pAlgebraicIntegrate2(R0,F,UP,UPUP,R)',NULL,'\spad{algextint(der,{} ext,{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solutions of the homogeneous system \spad{h'' + c1*g1 + ... + cn*gn = 0}. Argument \spad{ext} is an extended integration function on \spad{F},{} \spad{rde} is RDE solver,{} \spad{csolve} is linear solver over constants.');
INSERT INTO olibdb VALUES('o','algextint',7,'n','(Kernel(F),Kernel(F),(SparseUnivariatePolynomial(F))->SparseUnivariatePolynomial(F),(List(Fraction(SparseUnivariatePolynomial(F))))->List(Record(ratpart:Fraction(SparseUnivariatePolynomial(F)),coeffs:Vector(F))),(Fraction(SparseUnivariatePolynomial(F)),List(Fraction(SparseUnivariatePolynomial(F))))->List(Record(ratpart:Fraction(SparseUnivariatePolynomial(F)),coeffs:Vector(F))),(Matrix(F))->List(Vector(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F)))','pAlgebraicIntegration(R,F)',NULL,'\spad{algextint(x,{} y,{} d,{} ext,{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns \spad{[h,{} [c1,{} ...,{} cn]]} such that \spad{f = dh/dx + sum(\spad{ci} \spad{gi})} and dci/dx = 0,{} if such \spad{[h,{} [c1,{} ...,{} cn]]} exist,{} failed otherwise.');
INSERT INTO olibdb VALUES('o','algextint_base',3,'n','((UP)->UP,(Matrix(F))->List(Vector(F)),List(R))->List(Record(ratpart:R,coeffs:Vector(F)))','pAlgebraicIntegrate2(R0,F,UP,UPUP,R)',NULL,'\spad{algextint_base(der,{} csolve,{} [g1,{} ...,{} gn])} is like algextint(\spad{der},{} ext,{} rde,{} \spad{csolve},{} [\spad{g1},{} ...,{} \spad{gn}]),{} but assumes that field is algebraic extension of rational functions and that \spad{gi}-\spad{s} have no poles at infinity.');
INSERT INTO olibdb VALUES('o','algextint_base',5,'n','(Kernel(F),Kernel(F),(SparseUnivariatePolynomial(F))->SparseUnivariatePolynomial(F),(Matrix(F))->List(Vector(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F)))','pAlgebraicIntegration(R,F)',NULL,'\spad{algextint_base(x,{} y,{} d,{} csolve,{} [g1,{} ...,{} gn])} is like algextint but assumes that \spad{y} and \spad{gi}-\spad{s} are purely algebraic');
INSERT INTO olibdb VALUES('o','algint',5,'n','(F,Kernel(F),Kernel(F),(SparseUnivariatePolynomial(F))->SparseUnivariatePolynomial(F),(F)->IntegrationResult(F))->IntegrationResult(F)','pAlgebraicIntegration(R,F)',NULL,'\spad{algint(f,{} x,{} y,{} d)} returns the integral of \spad{f(x,{} y)dx} where \spad{y} is an algebraic function of \spad{x}; \spad{d} is the derivation to use on \spad{k[x]}.');
INSERT INTO olibdb VALUES('o','algintegrate',3,'n','(R,(UP)->UP,(F)->IntegrationResult(F))->IntegrationResult(R)','pAlgebraicIntegrate(R0,F,UP,UPUP,R)',NULL,'\spad{algintegrate(f,{} d,{} rec)} integrates \spad{f} with respect to the derivation \spad{d}.');
INSERT INTO olibdb VALUES('o','alg_reduce0',4,'n','(SparseMultivariatePolynomial(Integer,Symbol),SparseMultivariatePolynomial(Integer,Symbol),List(Symbol),Symbol)->SparseMultivariatePolynomial(Integer,Symbol)','pPrimGCD',NULL,'\spad{alg_reduce0(x,{} m,{} lv,{} z)} performs single reduction step.');
INSERT INTO olibdb VALUES('o','alg_reduce',4,'n','(SparseMultivariatePolynomial(Integer,Symbol),List(SparseMultivariatePolynomial(Integer,Symbol)),List(Symbol),List(Symbol))->SparseMultivariatePolynomial(Integer,Symbol)','pPrimGCD',NULL,'\spad{alg_reduce(x,{} lm,{} lv,{} lz)} reduces \spad{x} modulo elements of \spad{lm}.');
INSERT INTO olibdb VALUES('o','alg_split_root0',3,'n','(F,Kernel(F),Integer)->List(F)','pRootFSSplit(R,F)',NULL,'\spad{alg_split_root0(f,{} r,{} n)} returns \spad{[a1,{} ...,{} an]} such that \spad{f = a1 + a2*r + ... an*r^(n - 1)}. \spad{r} must be a root and \spad{n} must be its degree.');
INSERT INTO olibdb VALUES('o','alg_split_roots',3,'n','(List(F),Kernel(F),Kernel(F))->List(Record(funs:List(F),nroot:F,npow1:Integer,npow2:Integer))','pRootFSSplit(R,F)',NULL,'\spad{alg_split_roots(lf,{} r1,{} r2)} splits each \spad{f} in \spad{lf} into linear combination of product of powers of \spad{r1} and \spad{r2} which must be independent roots.');
INSERT INTO olibdb VALUES('o','algSplitSimple',2,'n','(S,(UP)->UP)->Record(num:S,den:UP,derivden:UP,gd:UP)','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algSplitSimple',2,'x','(%,(UP)->UP)->Record(num:%,den:UP,derivden:UP,gd:UP)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{algSplitSimple(f,{} D)} returns \spad{[h,{} d,{} d'',{} g]} such that \spad{f=h/d},{} \spad{h} is integral at all the normal places \spad{w}.\spad{r}.\spad{t}. \spad{D},{} \spad{d'' = Dd},{} \spad{g = gcd(d,{} discriminant())} and \spad{D} is the derivation to use. \spad{f} must have at most simple finite poles.');
INSERT INTO olibdb VALUES('o','algtower',1,'n','(List(S))->List(K)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algtower',1,'n','(S)->List(K)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','algtower',1,'x','(%)->List(K)','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{algtower(f)} is algtower([\spad{f}])');
INSERT INTO olibdb VALUES('o','algtower',1,'x','(List(%))->List(K)','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{algtower([f1,{} ...,{} fn])} returns list of kernels \spad{[ak1,{} ...,{} akl]} such that each toplevel algebraic kernel in one of \spad{f1},{} ...,{} \spad{fn} or in arguments of \spad{ak1},{} ...,{} akl is one of \spad{ak1},{} ...,{} akl.');
INSERT INTO olibdb VALUES('o','alg_trial_division',5,'n','(SparseMultivariatePolynomial(Integer,Symbol),SparseMultivariatePolynomial(Integer,Symbol),List(SparseMultivariatePolynomial(Integer,Symbol)),List(Symbol),List(Symbol))->Boolean','pPrimGCD',NULL,'\spad{alg_trial_division(x,{} y,{} lm,{} lv,{} lz)} checks if \spad{x} is divisible by \spad{y} in algebraic extension defined by \spad{lm}. \spad{lz} is list of algebraic variables,{} \spad{lv} is list of independent (polynomial) variables. Other variables serve as parameters.');
INSERT INTO olibdb VALUES('o','aLinear',2,'n','(F,F)->F','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{aLinear(f,{} g)} \undocumented');
INSERT INTO olibdb VALUES('o','allDegrees',1,'n','(List(GuessOption))->Boolean','dGuessOptionFunctions0',NULL,'\spad{allDegrees returns} whether all possibilities of the degree vector should be tried,{} the default being \spad{false}.');
INSERT INTO olibdb VALUES('o','allDegrees',1,'x','(Boolean)->%','dGuessOption',NULL,'\spad{allDegrees(d)} specifies whether all possibilities of the degree vector - taking into account maxDegree - should be tried. This is mainly interesting for rational interpolation. This option is expressed in the form \spad{allDegrees == d}.');
INSERT INTO olibdb VALUES('o','allIndices',1,'n','(%)->List(C)','dSparseEchelonMatrix(C,D)',NULL,'\spad{allIndices(A)} returns all indices used for enumerating the columns of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','allRepeated',1,'n','(List(NonNegativeInteger))->List(List(PositiveInteger))','cJetBundleCategory',NULL,'\spad{allRepeated(ind)} returns a list of all possible realizations of a given multi-index as repeated index.');
INSERT INTO olibdb VALUES('o','allRepeated',1,'n','(List(NonNegativeInteger))->List(List(PositiveInteger))','xJetBundleCategory&(S)',NULL,'\spad{allRepeated(ind)} returns a list of all possible realizations of a given multi-index as repeated index.');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(Polynomial(Fraction(Integer)))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(Polynomial(Integer))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(Polynomial(S))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(SparseUnivariatePolynomial(Fraction(Integer)))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(SparseUnivariatePolynomial(Integer))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'n','(SparseUnivariatePolynomial(S))->List(S)','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(Polynomial(Fraction(Integer)))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(Polynomial(Integer))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(Polynomial(%))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(SparseUnivariatePolynomial(Fraction(Integer)))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(SparseUnivariatePolynomial(Integer))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(SparseUnivariatePolynomial(%))->List(%)','cRealClosedField',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} naming each uniquely');
INSERT INTO olibdb VALUES('o','allRootsOf',1,'x','(ThePols)->List(%)','cRealRootCharacterizationCategory(TheField,ThePols)',NULL,'\spad{allRootsOf(pol)} creates all the roots of \spad{pol} in the Real Closure,{} assumed in order.');
INSERT INTO olibdb VALUES('o','allSimpleCells',2,'n','(List(ThePols),Symbol)->List(%)','dSimpleCell(TheField,ThePols)',NULL,'\spad{allSimpleCells(lp,{} sym)} returns decomposition into cells such that each \spad{p} in \spad{lp} has constant sign on each member of decomposition');
INSERT INTO olibdb VALUES('o','allSimpleCells',2,'n','(ThePols,Symbol)->List(%)','dSimpleCell(TheField,ThePols)',NULL,'\spad{allSimpleCells(p,{} sym)} is allSimpleCells([\spad{p}],{} \spad{sym})');
INSERT INTO olibdb VALUES('o','allSubsets',2,'n','(%,NonNegativeInteger)->List(%)','dCubicalFacet',NULL,'\spad{allSubsets of} a given facet returned in reverse order subsets returned are not oriented');
INSERT INTO olibdb VALUES('o','allSubsets',2,'n','(%,NonNegativeInteger)->List(%)','dOrientedFacet',NULL,'\spad{allSubsets of} a given facet returned in reverse order subsets returned are not oriented');
INSERT INTO olibdb VALUES('o','allSubsets',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(%)','dCubicalFacet',NULL,'\spad{allSubsets of} a given length returned in reverse order subsets returned are not oriented');
INSERT INTO olibdb VALUES('o','allSubsets',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(%)','dOrientedFacet',NULL,'\spad{allSubsets of} a given length returned in reverse order subsets returned are not oriented');
INSERT INTO olibdb VALUES('o','Alpha',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Alpha()} returns symbol for capital greek letter alpha.');
INSERT INTO olibdb VALUES('o','alpha',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{alpha()} returns symbol for small greek letter alpha.');
INSERT INTO olibdb VALUES('o','alpha',2,'n','(NonNegativeInteger,List(NonNegativeInteger))->List(NonNegativeInteger)','pCartanKuranishi(JB,D)',NULL,'\spad{alpha(q,{} beta)} computes the Cartan characters for a differential equation of order \spad{q} and with characters \spad{beta}.');
INSERT INTO olibdb VALUES('o','alphabetic',0,'x','()->%','dCharacterClass',NULL,'\spad{alphabetic()} returns the class of all characters for which \spadfunFrom{alphabetic?}{Character} is \spad{true}.');
INSERT INTO olibdb VALUES('o','alphabetic?',1,'x','(%)->Boolean','dCharacter',NULL,'\spad{alphabetic?(c)} tests if \spad{c} is a letter,{} \spadignore{i.e.} one of a..\spad{z} or A..\spad{Z}.');
INSERT INTO olibdb VALUES('o','alphaHilbert',1,'n','(SparseUnivariatePolynomial(Fraction(Integer)))->List(NonNegativeInteger)','pCartanKuranishi(JB,D)',NULL,'\spad{alphaHilbert(hp)} computes the Cartan characters for the Hilbert polynomial \spad{hp}.');
INSERT INTO olibdb VALUES('o','alphanumeric',0,'x','()->%','dCharacterClass',NULL,'\spad{alphanumeric()} returns the class of all characters for which \spadfunFrom{alphanumeric?}{Character} is \spad{true}.');
INSERT INTO olibdb VALUES('o','alphanumeric?',1,'x','(%)->Boolean','dCharacter',NULL,'\spad{alphanumeric?(c)} tests if \spad{c} is either a letter or number,{} \spadignore{i.e.} one of 0..9,{} a..\spad{z} or A..\spad{Z}.');
INSERT INTO olibdb VALUES('o','alternating',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{alternating n} is the cycle index of the \indented{1}{alternating group of degree \spad{n}.}');
INSERT INTO olibdb VALUES('o','alternatingGroup',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{alternatingGroup(\spad{li})} constructs the alternating group acting on the integers in the list {\em \spad{li}},{} generators are in general the {\em n-2}-cycle {\em (\spad{li}.3,{} ...,{} \spad{li}.n)} and the 3-cycle {\em (\spad{li}.1,{} \spad{li}.2,{} \spad{li}.3)},{} if \spad{n} is odd and product of the 2-cycle {\em (\spad{li}.1,{} \spad{li}.2)} with {\em n-2}-cycle {\em (\spad{li}.3,{} ...,{} \spad{li}.n)} and the 3-cycle {\em (\spad{li}.1,{} \spad{li}.2,{} \spad{li}.3)},{} if \spad{n} is even. Note: duplicates in the list will be removed.');
INSERT INTO olibdb VALUES('o','alternatingGroup',1,'x','(PositiveInteger)->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{alternatingGroup(n)} constructs the alternating group {\em An} acting on the integers 1,{} ...,{} \spad{n},{} generators are in general the {\em n-2}-cycle {\em (3,{} ...,{} n)} and the 3-cycle {\em (1,{} 2,{} 3)} if \spad{n} is odd and the product of the 2-cycle {\em (1,{} 2)} with {\em n-2}-cycle {\em (3,{} ...,{} n)} and the 3-cycle {\em (1,{} 2,{} 3)} if \spad{n} is even.');
INSERT INTO olibdb VALUES('o','alternative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{alternative?()} tests if \spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','alternative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{alternative?()} tests if \spad{2*associator(a,{} a,{} b) = 0 = 2*associator(a,{} b,{} b)} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','altsupersub',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{altsupersub(p)} returns a handler such that \spad{altsupersub(p)(prec,{} args)} formats the first argument with respect to the precedence \spad{p}. The remaining arguments are formatted without parentheses and interpreted as subscript,{} superscript,{} subscript,{} superscript,{} etc. where the subscripts and superscripts are pairwise aligned. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','analyseSymbol',1,'n','(SparseEchelonMatrix(JB,D))->Record(Rank:NonNegativeInteger,NumMultVar:NonNegativeInteger,Betas:List(NonNegativeInteger))','dJetDifferentialEquation(JB,D)',NULL,'\spad{analyseSymbol(symb)} computes the multiplicative variables of the symbol \spad{symb}.');
INSERT INTO olibdb VALUES('o','And',2,'n','(%,%)->%','dIndexedBits(mn)',NULL,'\spad{And(n,{} m)} returns the bit-by-bit logical {\em And} of \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','and',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f and g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','AND',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{AND(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x and y}.');
INSERT INTO olibdb VALUES('o','and',2,'x','(%,%)->%','cBitAggregate',NULL,'\spad{a and b} returns the logical {\em and} of bit aggregates \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','and',2,'x','(%,%)->%','dBoolean',NULL,'\spad{a and b} returns the logical {\em and} of Boolean \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','And',2,'x','(%,%)->%','dSingleInteger',NULL,'\spad{And(n,{} m)} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','angerJ',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{angerJ(v,{} z)} is the Anger \spad{J} function.');
INSERT INTO olibdb VALUES('o','angerJ',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{angerJ(v,{} z)} is the Anger \spad{J} function.');
INSERT INTO olibdb VALUES('o','annihilate?',2,'n','(S,S)->Boolean','xEntireRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','annihilate?',2,'n','(S,S)->Boolean','xRng&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','annihilate?',2,'x','(%,%)->Boolean','cRng',NULL,'\spad{annihilate?(x,{}y)} holds when the product of \spad{x} and \spad{y} is \spad{0}.');
INSERT INTO olibdb VALUES('o','ansatz',0,'n','()->JetVectorField(JB1,JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{ansatz()} returns a general ansatz for a symmetry generator.');
INSERT INTO olibdb VALUES('o','antiAssociative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \spadignore{i.e.} \spad{(a*b)*c + a*(b*c) = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra.');
INSERT INTO olibdb VALUES('o','antiAssociative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \spadignore{i.e.} \spad{(a*b)*c + a*(b*c) = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra.');
INSERT INTO olibdb VALUES('o','antiCommutative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{antiCommutative?()} tests if \spad{a*a = 0} for all \spad{a} in the algebra. Note: this implies \spad{a*b + b*a = 0} for all \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','antiCommutative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{antiCommutative?()} tests if \spad{a*a = 0} for all \spad{a} in the algebra. Note: this implies \spad{a*b + b*a = 0} for all \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','antiCommutator',2,'n','(%,%)->%','cNonAssociativeSemiRng',NULL,'\spad{antiCommutator(a,{} b)} returns \spad{a*b+b*a}.');
INSERT INTO olibdb VALUES('o','antiCommutator',2,'n','(S,S)->S','xNonAssociativeSemiRng&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','anticoord',3,'n','(List(F),DistributedMultivariatePolynomial(lv,F),List(DistributedMultivariatePolynomial(lv,F)))->DistributedMultivariatePolynomial(lv,F)','pLinGroebnerPackage(lv,F)',NULL,'\spad{anticoord }\undocumented');
INSERT INTO olibdb VALUES('o','antipode',1,'x','(%)->%','cHopfAlgebra(R,MxM)',NULL,'\spad{antipode(x)} computes the antipode of an element \spad{x}.');
INSERT INTO olibdb VALUES('o','antisymmetric?',1,'n','(S)->Boolean','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','antisymmetric?',1,'n','(S)->Boolean','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','antisymmetric?',1,'x','(%)->Boolean','cMatrixCategory(R,Row,Col)','has(R,AbelianGroup)','\spad{antisymmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and antisymmetric (\spadignore{i.e.} \spad{m[i,{} j] = -m[j,{} i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','antisymmetric?',1,'x','(%)->Boolean','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,AbelianGroup)','\spad{antisymmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and antisymmetric (\spadignore{i.e.} \spad{m[i,{} j] = -m[j,{} i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','antisymmetric?',1,'x','(%)->Boolean','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{antisymmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and antisymmetric (\spadignore{i.e.} \spad{m[i,{} j] = -m[j,{} i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','antisymmetricTensors',2,'x','(List(Matrix(R)),PositiveInteger)->List(Matrix(R))','pRepresentationPackage1(R)','has(R,CommutativeRing)','\spad{antisymmetricTensors(la,{} n)} applies to each \spad{m}-by-\spad{m} square matrix in the list {\em la} the irreducible,{} polynomial representation of the general linear group {\em GLm} which corresponds to the partition {\em (1,{} 1,{} ...,{} 1,{} 0,{} 0,{} ...,{} 0)} of \spad{n}. Error: if \spad{n} is greater than \spad{m}. Note: this corresponds to the symmetrization of the representation with the sign representation of the symmetric group {\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \spad{n}-fold tensor product.');
INSERT INTO olibdb VALUES('o','antisymmetricTensors',2,'x','(Matrix(R),PositiveInteger)->Matrix(R)','pRepresentationPackage1(R)','has(R,CommutativeRing)','\spad{antisymmetricTensors(a,{} n)} applies to the square matrix {\em a} the irreducible,{} polynomial representation of the general linear group {\em GLm},{} where \spad{m} is the number of rows of {\em a},{} which corresponds to the partition {\em (1,{} 1,{} ...,{} 1,{} 0,{} 0,{} ...,{} 0)} of \spad{n}. Error: if \spad{n} is greater than \spad{m}. Note: this corresponds to the symmetrization of the representation with the sign representation of the symmetric group {\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \spad{n}-fold tensor product.');
INSERT INTO olibdb VALUES('o','any?',2,'n','((Entry)->Boolean,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'n','((R)->Boolean,S)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'n','((Record(key:Key,entry:Entry))->Boolean,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'n','((S)->Boolean,A)->Boolean','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'n','((S)->Boolean,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'n','((S)->Boolean,A)->Boolean','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','any?',2,'x','((S)->Boolean,%)->Boolean','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{any?(p,{} u)} tests if \spad{p(x)} is \spad{true} for any element \spad{x} of \spad{u}. Note: for collections,{} \spad{any?(p,{} u) = reduce(or,{} map(p,{} u),{} false,{} true)}. However,{} \spad{any?(p,{} u)} returns as soon as it finds an element for which \spad{p} gives \spad{true}.');
INSERT INTO olibdb VALUES('o','any',2,'x','(SExpression,None)->%','dAny',NULL,'\spad{any(type,{} object)} is a technical function for creating an object of \spadtype{Any}. Argument \spad{type} is a \spadgloss{LISP} form for the \spad{type} of \spad{object}.');
INSERT INTO olibdb VALUES('o','append!',2,'n','(%,NonNegativeInteger)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{append!(p,{} l)} appends \spad{l} matrices to the linear pencil.');
INSERT INTO olibdb VALUES('o','append',2,'n','(%,NonNegativeInteger)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{append(p,{} l)} appends \spad{l} matrices to the linear pencil.');
INSERT INTO olibdb VALUES('o','append',2,'x','(%,%)->%','dList(S)',NULL,'\spad{append(u1,{} u2)} appends the elements of list \spad{u1} onto the front of list \spad{u2}. This new list and \spad{u2} will share some structure.');
INSERT INTO olibdb VALUES('o','appendPoint',2,'n','(%,Point(DoubleFloat))->Void','dGraphImage',NULL,'\spad{appendPoint(\spad{gi},{} pt)} appends the point \spad{pt} to the end of the list of points component for the graph,{} \spad{\spad{gi}},{} which is of the domain \spadtype{GraphImage}.');
INSERT INTO olibdb VALUES('o','appendRow!',2,'n','(%,Record(Indices:List(C),Entries:List(D)))->Void','dSparseEchelonMatrix(C,D)',NULL,'\spad{appendRow!(A,{} r)} appends the row \spad{r} at the end of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','appendSupport!',2,'n','(%,List(FreeMonoid(VAR)))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{appendSupport! (f,{} lst)} appends variables not in the support.');
INSERT INTO olibdb VALUES('o','apply',2,'n','(Matrix(R),S)->S','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','apply',2,'n','(%,NonNegativeInteger)->NonNegativeInteger','dFunctionGraph(S)',NULL,'\spad{apply ''}function'' represented by this graph to vertex index ''a''');
INSERT INTO olibdb VALUES('o','apply',2,'n','(%,Partition)->R','cSequenceCategory(R)',NULL,'\spad{elt(mm,{} \spad{pi})} returns the product of the entries indexed by the integer partition \spad{pi} (as in partitionend moments)');
INSERT INTO olibdb VALUES('o','apply',2,'x','(Matrix(R),%)->%','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{apply(m,{} a)} defines a left operation of \spad{n} by \spad{n} matrices where \spad{n} is the rank of the algebra in terms of matrix-vector multiplication,{} this is a substitute for a left module structure. Error: if shape of matrix doesn\spad{''t} fit.');
INSERT INTO olibdb VALUES('o','apply',2,'x','(UPS,Distribution(R))->Distribution(S)','pDistributionPolynomialPackage(R,S,UPS)',NULL,'\spad{apply(p,{} d)} computes the distribution of the random variable \spad{p(X)}\$ where \spad{X} has distribution \spad{d}.');
INSERT INTO olibdb VALUES('o','apply',3,'n','(%,Integer,Integer)->R','dIncidenceAlgebra(R,S)',NULL,'\spad{A(i,{} j)} returns \$A_{\spad{i},{} \spad{j}}\$');
INSERT INTO olibdb VALUES('o','apply',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','dMultifunctionGraph(S)',NULL,'\spad{apply ''}function'' represented by this graph to vertex index ''a''');
INSERT INTO olibdb VALUES('o','apply',3,'n','(P,(M)->M,M)->M','pApplyUnivariateSkewPolynomial(R,M,P)',NULL,'\spad{apply(p,{} f,{} m)} returns \spad{p(m)} where the action is given by \spad{x m = f(m)}. \spad{f} must be an \spad{R}-pseudo linear map on \spad{M}.');
INSERT INTO olibdb VALUES('o','apply',3,'n','(%,P,P)->Integer','dFiniteMoebiusFunction(P)',NULL,'\spad{mf(\spad{pi},{} \spad{si})} evaluates the Moebius function \spad{mf} at \spad{pi} and \spad{si}');
INSERT INTO olibdb VALUES('o','apply',3,'n','(%,P,P)->R','dGeneralizedFiniteMoebiusFunction(P,R)',NULL,'\spad{mf(\spad{pi},{} \spad{si})} evaluates the Moebius function \spad{mf} at \spad{pi} and \spad{si}');
INSERT INTO olibdb VALUES('o','apply',3,'n','(%,S,S)->R','dIncidenceAlgebra(R,S)',NULL,'\spad{A(s,{} t)} returns \$A_{\spad{i},{} \spad{j}}\$,{} where \$\spad{i}\$,{} \$\spad{j}\$ are the positions of \$\spad{s}\$ and \$\spad{t}\$ in the index list.');
INSERT INTO olibdb VALUES('o','apply',3,'x','(%,R,R)->R','cUnivariateSkewPolynomialCategory(R)',NULL,'\spad{apply(p,{} c,{} m)} returns \spad{p(m)} where the action is given by \spad{x m = c sigma(m) + delta(m)}.');
INSERT INTO olibdb VALUES('o','apply',5,'n','(C,R,R,Automorphism(R),(R)->R)->R','pUnivariateSkewPolynomialCategoryOps(R,C)',NULL,'\spad{apply(p,{} c,{} m,{} sigma,{} delta)} returns \spad{p(m)} where the action is given by \spad{x m = c sigma(m) + delta(m)}.');
INSERT INTO olibdb VALUES('o','applyQuote',2,'n','(Symbol,List(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','applyQuote',2,'n','(Symbol,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','applyQuote',2,'x','(Symbol,%)->%','cFunctionSpace2(R,K)',NULL,'\spad{applyQuote(foo,{} x)} returns \spad{''foo(x)}.');
INSERT INTO olibdb VALUES('o','applyQuote',2,'x','(Symbol,List(%))->%','cFunctionSpace2(R,K)',NULL,'\spad{applyQuote(foo,{} [x1,{} ...,{} xn])} returns \spad{''foo(x1,{} ...,{} xn)}.');
INSERT INTO olibdb VALUES('o','applyQuote',3,'n','(Symbol,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','applyQuote',3,'x','(Symbol,%,%)->%','cFunctionSpace2(R,K)',NULL,'\spad{applyQuote(foo,{} x,{} y)} returns \spad{''foo(x,{} y)}.');
INSERT INTO olibdb VALUES('o','applyQuote',4,'n','(Symbol,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','applyQuote',4,'x','(Symbol,%,%,%)->%','cFunctionSpace2(R,K)',NULL,'\spad{applyQuote(foo,{} x,{} y,{} z)} returns \spad{''foo(x,{} y,{} z)}.');
INSERT INTO olibdb VALUES('o','applyQuote',5,'n','(Symbol,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','applyQuote',5,'x','(Symbol,%,%,%,%)->%','cFunctionSpace2(R,K)',NULL,'\spad{applyQuote(foo,{} x,{} y,{} z,{} t)} returns \spad{''foo(x,{} y,{} z,{} t)}.');
INSERT INTO olibdb VALUES('o','applyRules',2,'n','(List(RewriteRule(Base,R,F)),F)->F','pApplyRules(Base,R,F)',NULL,'\spad{applyRules([r1,{} ...,{} rn],{} expr)} applies the rules \spad{r1},{} ...,{} \spad{rn} to \spad{f} an unlimited number of times,{} \spadignore{i.e.} until none of \spad{r1},{} ...,{} \spad{rn} is applicable to the expression.');
INSERT INTO olibdb VALUES('o','applyRules',3,'n','(List(RewriteRule(Base,R,F)),F,PositiveInteger)->F','pApplyRules(Base,R,F)',NULL,'\spad{applyRules([r1,{} ...,{} rn],{} expr,{} n)} applies the rules \spad{r1},{} ...,{} \spad{rn} to \spad{f} a most \spad{n} times.');
INSERT INTO olibdb VALUES('o','apply_taylor',2,'n','(Stream(Coef),%)->%','dGeneralizedUnivariatePowerSeries(Coef,Expon,var,cen)',NULL,'\spad{apply_taylor(ts,{} s)} applies Taylor series with coefficients \spad{ts} to \spad{s},{} that is computes infinite sum \spad{ts}(0) + \spad{ts}(1)\spad{*s} + \spad{ts}(2)\spad{*s^2} + ... Note: \spad{s} must be of positive order');
INSERT INTO olibdb VALUES('o','apply_taylor',2,'n','(UTS,PS)->PS','cTaylorSeriesExpansion(Coef,Expon,Var,PS,UTS)',NULL,'\spad{apply_taylor(g,{} f)} applies \spad{g} to \spad{f}');
INSERT INTO olibdb VALUES('o','applyTaylor',2,'n','((UTS)->UTS,PS)->PS','cTaylorSeriesExpansion(Coef,Expon,Var,PS,UTS)',NULL,'\spad{applyTaylor(g,{} f)} applies \spad{g} to \spad{f}');
INSERT INTO olibdb VALUES('o','approximants',1,'x','(%)->Stream(Fraction(R))','dContinuedFraction(R)',NULL,'\spad{approximants(x)} returns the stream of approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be infinite and periodic with period 1.');
INSERT INTO olibdb VALUES('o','approximate',2,'n','(%,Integer)->Fraction(Integer)','dBalancedPAdicRational(p)',NULL,NULL);
INSERT INTO olibdb VALUES('o','approximate',2,'n','(%,Integer)->Fraction(Integer)','dPAdicRationalConstructor(p,PADIC)',NULL,'\spad{approximate(x,{} n)} returns a rational number \spad{y} such that \spad{y = x (mod p^n)}.');
INSERT INTO olibdb VALUES('o','approximate',2,'n','(%,Integer)->Fraction(Integer)','dPAdicRational(p)',NULL,NULL);
INSERT INTO olibdb VALUES('o','approximate',2,'x','(%,Expon)->Coef','cUnivariatePowerSeriesCategory(Coef,Expon)','AND(has(Coef,SIGNATURE(^,Coef(Coef,Expon))),has(Coef,SIGNATURE(coerce,Coef(Symbol))))','\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain.');
INSERT INTO olibdb VALUES('o','approximate',2,'x','(%,%)->Fraction(Integer)','cRealClosedField',NULL,'\spad{approximate(n,{} p)} gives an approximation of \spad{n} that has precision \spad{p}');
INSERT INTO olibdb VALUES('o','approximate',2,'x','(%,Integer)->Integer','cPAdicIntegerCategory(p)',NULL,'\spad{approximate(x,{} n)} returns an integer \spad{y} such that \spad{y = x (mod p^n)} when \spad{n} is positive,{} and 0 otherwise.');
INSERT INTO olibdb VALUES('o','approximate',3,'x','(ThePols,%,TheField)->TheField','cRealRootCharacterizationCategory(TheField,ThePols)',NULL,'\spad{approximate(term,{} root,{} prec)} gives an approximation of \spad{term} over \spad{root} with precision \spad{prec}');
INSERT INTO olibdb VALUES('o','approxNthRoot',2,'x','(I,NonNegativeInteger)->I','pIntegerRoots(I)',NULL,'\spad{approxRoot(n,{} r)} returns an approximation \spad{x} to \spad{n^(1/r)} such that \spad{-1 < x - n^(1/r) < 1}');
INSERT INTO olibdb VALUES('o','approxSqrt',1,'x','(I)->I','pIntegerRoots(I)',NULL,'\spad{approxSqrt(n)} returns an approximation \spad{x} to \spad{sqrt(n)} such that \spad{-1 < x - sqrt(n) < 1}. Returns 0 if \spad{n} is negative. A variable precision Newton iteration is used. The running time is \spad{O( log(n)^2 )}.');
INSERT INTO olibdb VALUES('o','aQuadratic',3,'n','(F,F,F)->F','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{aQuadratic(f,{} g,{} h)} \undocumented');
INSERT INTO olibdb VALUES('o','aQuartic',5,'n','(F,F,F,F,F)->F','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{aQuartic(f,{} g,{} h,{} i,{} k)} \undocumented');
INSERT INTO olibdb VALUES('o','arbFunctions',3,'n','(NonNegativeInteger,Integer,List(NonNegativeInteger))->List(Integer)','pCartanKuranishi(JB,D)',NULL,'\spad{arbFunctions(q,{} j,{} cc)} uses the Cartan characters \spad{cc} to compute the number of arbitrary functions of differentiation order \spad{j} in the general solution of a differential equation of order \spad{q}.');
INSERT INTO olibdb VALUES('o','arcsineDistribution',1,'x','(R)->Distribution(R)','pDistributionPackage(R)','has(R,Algebra(Fraction(Integer)))','\spad{arcsineDistribution(a)} produces the arcsine distribution of variance \spad{a}.');
INSERT INTO olibdb VALUES('o','areEquivalent?',2,'x','(List(Matrix(R)),List(Matrix(R)))->Matrix(R)','pRepresentationPackage2(R)','has(R,Field)','\spad{areEquivalent?(aG0,{} aG1)} calls {\em areEquivalent?(aG0,{} aG1,{} true,{} 25)}. Note: the choice of 25 was rather arbitrary.');
INSERT INTO olibdb VALUES('o','areEquivalent?',3,'x','(List(Matrix(R)),List(Matrix(R)),Integer)->Matrix(R)','pRepresentationPackage2(R)','has(R,Field)','\spad{areEquivalent?(aG0,{} aG1,{} numberOfTries)} calls {\em areEquivalent?(aG0,{} aG1,{} true,{} 25)}. Note: the choice of 25 was rather arbitrary.');
INSERT INTO olibdb VALUES('o','areEquivalent?',4,'x','(List(Matrix(R)),List(Matrix(R)),Boolean,Integer)->Matrix(R)','pRepresentationPackage2(R)','has(R,Field)','\spad{areEquivalent?(aG0,{} aG1,{} randomelements,{} numberOfTries)} tests whether the two lists of matrices,{} all assumed of same square shape,{} can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators,{} the representations are equivalent. The algorithm tries {\em numberOfTries} times to create elements in the generated algebras in the same fashion. If their ranks differ,{} they are not equivalent. If an isomorphism is assumed,{} then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (\spadignore{e.g.} irreducibility !) we use {\em standardBasisOfCyclicSubmodule} to create the only possible transition matrix. The method checks whether the matrix conjugates all corresponding matrices from {\em aGi}. The way to choose the singular matrices is as in {\em meatAxe}. If the two representations are equivalent,{} this routine returns the transformation matrix {\em TM} with {\em aG0.i * TM = TM * aG1.i} for all \spad{i}. If the representations are not equivalent,{} a small 0-matrix is returned. Note: the case with different sets of group generators cannot be handled.');
INSERT INTO olibdb VALUES('o','arg1',2,'n','(A,C)->A','pMappingPackageInternalHacks2(A,C)',NULL,'\spad{arg1(a,{} c)} selects its first argument.');
INSERT INTO olibdb VALUES('o','arg2',2,'n','(A,C)->C','pMappingPackageInternalHacks2(A,C)',NULL,'\spad{arg2(a,{} c)} selects its second argument.');
INSERT INTO olibdb VALUES('o','argscript',2,'x','(%,List(OutputForm))->%','dSymbol',NULL,'\spad{argscript(s,{} [a1,{} ...,{} an])} returns \spad{s} arg-scripted by \spad{[a1,{} ...,{} an]}.');
INSERT INTO olibdb VALUES('o','argument',1,'n','(%)->E','dFourierComponent(E)',NULL,'\spad{argument(x)} returns the argument of a given sin/cos expressions');
INSERT INTO olibdb VALUES('o','argument',1,'n','(%)->List(S)','cKernelCategory(S)',NULL,'\spad{argument(op(a1,{} ...,{} an))} returns \spad{[a1,{} ...,{} an]}.');
INSERT INTO olibdb VALUES('o','argument',1,'n','(S)->R','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','argument',1,'x','(%)->R','cComplexCategory(R)','has(R,TranscendentalFunctionCategory)','\spad{argument(x)} returns the angle made by (1,{} 0) and \spad{x}.');
INSERT INTO olibdb VALUES('o','argumentList!',1,'n','(List(Symbol))->Void','dTheSymbolTable',NULL,'\spad{argumentList!(l)} declares that the argument list for the current subprogram in the global symbol table is \spad{l}.');
INSERT INTO olibdb VALUES('o','argumentList!',2,'n','(Symbol,List(Symbol))->Void','dTheSymbolTable',NULL,'\spad{argumentList!(f,{} l)} declares that the argument list for subprogram \spad{f} in the global symbol table is \spad{l}.');
INSERT INTO olibdb VALUES('o','argumentList!',3,'n','(Symbol,List(Symbol),%)->Void','dTheSymbolTable',NULL,'\spad{argumentList!(f,{} l,{} tab)} declares that the argument list for subprogram \spad{f} in symbol table tab is \spad{l}.');
INSERT INTO olibdb VALUES('o','argumentListOf',2,'n','(Symbol,%)->List(Symbol)','dTheSymbolTable',NULL,'\spad{argumentListOf(f,{} tab)} returns the argument list of \spad{f}');
INSERT INTO olibdb VALUES('o','arguments',1,'n','(OutputForm)->List(OutputForm)','pOutputFormTools',NULL,'\spad{arguments(f)} gives arguments of form \spad{f}. Valid only when atom?(\spad{f}) is \spad{false}');
INSERT INTO olibdb VALUES('o','arity',1,'x','(%)->Union(NonNegativeInteger,failed)','dBasicOperator',NULL,'\spad{arity(op)} returns \spad{n} if \spad{op} is \spad{n}-ary,{} and failed if \spad{op} has arbitrary arity.');
INSERT INTO olibdb VALUES('o','aromberg',8,'x','((F)->F,F,F,F,F,Integer,Integer,Integer)->Record(value:F,error:F,totalpts:Integer,success:Boolean)','pNumericalQuadrature(F)',NULL,'\spad{aromberg(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive romberg method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.');
INSERT INTO olibdb VALUES('o','array2',1,'n','(List(List(R)))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','array2',1,'x','(List(List(R)))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{array2(ll)} constructs a 2-dimensional array,{} the inner list being the rows.');
INSERT INTO olibdb VALUES('o','arrayStack',1,'x','(List(S))->%','dArrayStack(S)',NULL,'\spad{arrayStack([x,{} y,{} ...,{} z])} creates an array stack with first (top) element \spad{x},{} second element \spad{y},{} ...,{} and last element \spad{z}.');
INSERT INTO olibdb VALUES('o','arrowName',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->String','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowName',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->String','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowName',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->String','cFiniteGraph(S)',NULL,'\spad{arrowName(s,{} a,{} b)} retrieves the name of arrow a-\spad{>b} if it does not exist then return \spad{?}');
INSERT INTO olibdb VALUES('o','arrowsFromArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsFromArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsFromArrow',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'index of all arrows leading to a given arrow');
INSERT INTO olibdb VALUES('o','arrowsFromNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsFromNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsFromNode',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{arrowsFromNode(s,{} a)} gives list of all arrows leading to a given node');
INSERT INTO olibdb VALUES('o','arrowsToArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsToArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsToArrow',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{arrowsToArrow(s,{} a)} returns index of all arrows leading from a given arrow');
INSERT INTO olibdb VALUES('o','arrowsToNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsToNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','arrowsToNode',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{arrowsToNode(s,{} a)} gives list of all arrows leading from a given node');
INSERT INTO olibdb VALUES('o','asec',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{asec(x)} applies the inverse secant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','asec',1,'n','(S)->S','xArcTrigonometricFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asec',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asec',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{asec(st)} computes arcsecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asec',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{asec(st)} computes arcsecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asec',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{asec(z)} returns the arc-secant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','asec',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{asec(z)} returns the arc-secant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','asec',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{asec(x)} returns the arc-secant of \spad{x}.');
INSERT INTO olibdb VALUES('o','asech',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{asech(x)} applies the inverse hyperbolic secant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','asech',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asech',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asech',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{asech(st)} computes the inverse hyperbolic secant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asech',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{asech(st)} computes the inverse hyperbolic secant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asech',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{asech(z)} returns the inverse hyperbolic secant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','asech',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{asech(z)} returns the inverse hyperbolic secant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','asech',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{asech(x)} returns the hyperbolic arc-secant of \spad{x}.');
INSERT INTO olibdb VALUES('o','asechIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{asechIfCan(z)} returns asech(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','asecIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{asecIfCan(z)} returns asec(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','asimpson',8,'x','((F)->F,F,F,F,F,Integer,Integer,Integer)->Record(value:F,error:F,totalpts:Integer,success:Boolean)','pNumericalQuadrature(F)',NULL,'\spad{asimpson(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive simpson method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.');
INSERT INTO olibdb VALUES('o','asin',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{asin(x)} represents the Fortran intrinsic function ASIN');
INSERT INTO olibdb VALUES('o','asin',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{asin(x)} applies the inverse sine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','asin',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asin',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asin',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asin',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{asin(st)} computes arcsine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asin',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{asin(st)} computes arcsine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asin',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{asin(z)} returns the arc-sine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','asin',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{asin(z)} returns the arc-sine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','asin',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{asin(x)} returns the arc-sine of \spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for asin lies along the negative real axis to the left of \spad{-1} (inclusive),{} continuous with the upper half plane,{} the other along the positive real axis to the right of 1 (inclusive),{} continuous with the lower half plane.');
INSERT INTO olibdb VALUES('o','asinh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{asinh(x)} applies the inverse hyperbolic sine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','asinh',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asinh',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asinh',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','asinh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asinh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','asinh',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{asinh(z)} returns the inverse hyperbolic sine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','asinh',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{asinh(z)} returns the inverse hyperbolic sine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','asinh',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{asinh(x)} returns the hyperbolic arc-sine of \spad{x}.');
INSERT INTO olibdb VALUES('o','asinhIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{asinhIfCan(z)} returns asinh(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','asinIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{asinIfCan(z)} returns asin(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','assert',2,'x','(%,Symbol)->%','dBasicOperator',NULL,'\spad{assert(op,{} s)} attaches property \spad{s} to \spad{op}. Argument \spad{op} is modified in place,{} \spadignore{i.e.} no copy is made.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{assign(f,{} g)} creates a form for the assignment \spad{f := g}.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(Complex(Float)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(Float))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(Integer))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(MachineComplex))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(MachineFloat))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Expression(MachineInteger))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(Complex(Float))))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(Float)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(Integer)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(MachineComplex)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(MachineFloat)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(Expression(MachineInteger)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(MachineComplex))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(MachineFloat))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Matrix(MachineInteger))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,String)->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(Complex(Float))))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(Float)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(Integer)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(MachineComplex)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(MachineFloat)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(Expression(MachineInteger)))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(MachineComplex))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(MachineFloat))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',2,'n','(Symbol,Vector(MachineInteger))->%','dFortranCode',NULL,'\spad{assign(x,{} y)} creates a representation of the FORTRAN expression x=y.');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(Complex(Float)))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(Float))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(Integer))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(MachineComplex))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(MachineFloat))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assign',3,'n','(Symbol,List(Polynomial(Integer)),Expression(MachineInteger))->%','dFortranCode',NULL,'\spad{assign(x,{} l,{} y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{''}th element of array \spad{x} (\spad{l} is a list of indices).');
INSERT INTO olibdb VALUES('o','assoc',2,'x','(Key,%)->Union(Record(key:Key,entry:Entry),failed)','cAssociationListAggregate(Key,Entry)',NULL,'\spad{assoc(k,{} u)} returns the element \spad{x} in association list \spad{u} stored with key \spad{k},{} or failed if \spad{u} has no key \spad{k}.');
INSERT INTO olibdb VALUES('o','associatedEquations',2,'n','(L,PositiveInteger)->Record(minor:List(PositiveInteger),eq:L,minors:List(List(PositiveInteger)),ops:List(L))','pAssociatedEquations(R,L)','has(R,Field)','\spad{associatedEquations(op,{} m)} returns \spad{[w,{} eq,{} lw,{} lop]} such that \spad{eq(w) = 0} where \spad{w} is the given minor,{} and \spad{lw_i = lop_i(w)} for all the other minors.');
INSERT INTO olibdb VALUES('o','associatedSystem',2,'n','(L,PositiveInteger)->Record(mat:Matrix(R),vec:Vector(List(PositiveInteger)))','pAssociatedEquations(R,L)',NULL,'\spad{associatedSystem(op,{} m)} returns \spad{[M,{} w]} such that the \spad{m}-th associated equation system to \spad{L} is \spad{w'' = M w}.');
INSERT INTO olibdb VALUES('o','associates?',2,'n','(S,S)->Boolean','xEntireRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','associates?',2,'n','(S,S)->Boolean','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','associates?',2,'x','(%,%)->Boolean','cEntireRing',NULL,'\spad{associates?(x,{} y)} tests whether \spad{x} and \spad{y} are associates,{} \spadignore{i.e.} differ by a unit factor.');
INSERT INTO olibdb VALUES('o','associative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{associative?()} tests if multiplication in algebra is associative.');
INSERT INTO olibdb VALUES('o','associative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{associative?()} tests if multiplication in algebra is associative.');
INSERT INTO olibdb VALUES('o','associator',3,'n','(S,S,S)->S','xNonAssociativeRng&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','associator',3,'x','(%,%,%)->%','cNonAssociativeRng',NULL,'\spad{associator(a,{} b,{} c)} returns \spad{(a*b)*c-a*(b*c)}.');
INSERT INTO olibdb VALUES('o','associatorDependence',0,'n','()->List(Vector(R))','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{associatorDependence()} looks for the associator identities,{} \spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \spad{associator(a,{} b,{} c)} which yield 0,{} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra. The order of the permutations is \spad{123 231 312 132 321 213}.');
INSERT INTO olibdb VALUES('o','associatorDependence',0,'x','()->List(Vector(R))','cFiniteRankNonAssociativeAlgebra(R)','has(R,IntegralDomain)','\spad{associatorDependence()} looks for the associator identities,{} \spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \spad{associator(a,{} b,{} c)} which yield 0,{} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra. The order of the permutations is \spad{123 231 312 132 321 213}.');
INSERT INTO olibdb VALUES('o','atan1',1,'n','(UPS)->UPS','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{atan1 should} be local but conditional');
INSERT INTO olibdb VALUES('o','atan',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{atan(x)} represents the Fortran intrinsic function ATAN');
INSERT INTO olibdb VALUES('o','atan',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{atan(x)} applies the inverse tangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','atan',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','atan',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','atan',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{atan(st)} computes arctangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','atan',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{atan(st)} computes arctangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','atan',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{atan(z)} returns the arc-tangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','atan',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{atan(z)} returns the arc-tangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','atan',1,'x','(%)->%','cArcTrigonometricFunctionCategory',NULL,'\spad{atan(x)} returns the arc-tangent of \spad{x}. When evaluated into some subset of the complex numbers,{} one branch cut for atan lies along the positive imaginary axis above \%\spad{i} (exclusive),{} continuous with the left half plane,{} the other along the negative imaginary axis below -\%\spad{i} (exclusive) continuous with the right half plane. The domain does not contain \%\spad{i} and -\%\spad{i}.');
INSERT INTO olibdb VALUES('o','atan',2,'x','(%,%)->%','dDoubleFloat',NULL,'\spad{atan(x,{} y)} computes the arc tangent from \spad{x} with phase \spad{y}.');
INSERT INTO olibdb VALUES('o','atan',2,'x','(%,%)->%','dFloat',NULL,'\spad{atan(x,{} y)} computes the arc tangent from \spad{x} with phase \spad{y}.');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatElementaryFunctions',NULL,'\spad{atanh(x)} computes \spad{atanh}.');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{atanh(x)} applies the inverse hyperbolic tangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','atanh',1,'n','(S)->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','atanh',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','atanh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{atanh(z)} returns the inverse hyperbolic tangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','atanh',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{atanh(z)} returns the inverse hyperbolic tangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','atanh',1,'x','(%)->%','cArcHyperbolicFunctionCategory',NULL,'\spad{atanh(x)} returns the hyperbolic arc-tangent of \spad{x}.');
INSERT INTO olibdb VALUES('o','atanhIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{atanhIfCan(z)} returns atanh(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','atanIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{atanIfCan(z)} returns atan(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(%)->Boolean','dILogic',NULL,'returns \spad{true} if this is an atom,{} that is a leaf node otherwise return \spad{false} if this is a compound term');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'returns \spad{true} if this is an atom,{} that is free or bound variable otherwise return \spad{false} if this is a compound or lambda definition');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(%)->Boolean','dLatticeJoinOfMeets',NULL,'returns \spad{true} if this is an atom,{} that is a leaf node otherwise return \spad{false} if this is a compound term');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(%)->Boolean','dLatticeMeetOfJoins',NULL,'returns \spad{true} if this is an atom,{} that is a leaf node otherwise return \spad{false} if this is a compound term');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(%)->Boolean','dSKICombinators(UT)',NULL,'returns \spad{true} if this is an atom,{} that is a leaf node otherwise return \spad{false} if this is a compound term');
INSERT INTO olibdb VALUES('o','atom?',1,'n','(OutputForm)->Boolean','pOutputFormTools',NULL,'\spad{atom?(f)} checks if form \spad{f} is atomic,{} \spad{false} means composite');
INSERT INTO olibdb VALUES('o','atom?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{atom?(s)} is \spad{true} if \spad{s} is a Lisp atom.');
INSERT INTO olibdb VALUES('o','atoms',1,'n','(%)->PatternMatchResult(R,S)','dPatternMatchListResult(R,S,L)',NULL,'\spad{atoms(r)} returns the list of matches that match atoms (elements of the lists).');
INSERT INTO olibdb VALUES('o','atom_to_string',1,'n','(OutputForm)->String','pOutputFormTools',NULL,'\spad{atom_to_string(f)} converts \spad{f} to string form.');
INSERT INTO olibdb VALUES('o','atrapezoidal',8,'x','((F)->F,F,F,F,F,Integer,Integer,Integer)->Record(value:F,error:F,totalpts:Integer,success:Boolean)','pNumericalQuadrature(F)',NULL,'\spad{atrapezoidal(fn,{} a,{} b,{} epsrel,{} epsabs,{} nmin,{} nmax,{} nint)} uses the adaptive trapezoidal method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.');
INSERT INTO olibdb VALUES('o','atType',1,'n','(InputForm)->InputForm','pInputFormFunctions1(R)',NULL,'\spad{atType(f)} returns the input form corresponding to \spad{f@R}');
INSERT INTO olibdb VALUES('o','augment',2,'n','(List(P),List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','augment',2,'n','(List(P),S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','augment',2,'n','(P,List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','augment',2,'n','(P,S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','augment',2,'x','(List(P),%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{augment(lp,{} ts)} returns \spad{ts} if \spad{empty? lp},{} \spad{augment(p,{} ts)} if \spad{lp = [p]},{} otherwise \spad{augment(first lp,{} augment(rest lp,{} ts))}');
INSERT INTO olibdb VALUES('o','augment',2,'x','(List(P),List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{augment(lp,{} lts)} returns the same as \spad{concat([augment(lp,{} ts) for ts in lts])}');
INSERT INTO olibdb VALUES('o','augment',2,'x','(P,%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{augment(p,{} ts)} assumes that \spad{p} is a non-constant polynomial whose main variable is greater than any variable of \spad{ts}. This operation assumes also that if \spad{p} is added to \spad{ts} the resulting set,{} say \spad{ts+p},{} is a regular triangular set. Then it returns a split of Kalkbrener of \spad{ts+p}. This may not be \spad{ts+p} itself,{} if for instance \spad{ts+p} is required to be square-free.');
INSERT INTO olibdb VALUES('o','augment',2,'x','(P,List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{augment(p,{} lts)} returns the same as \spad{concat([augment(p,{} ts) for ts in lts])}');
INSERT INTO olibdb VALUES('o','autoReduce',1,'n','(List(%))->List(%)','cJetBundleFunctionCategory(JB)',NULL,'\spad{autoReduce(sys)} tries to simplify a system by solving each equation for its leading term and substituting it into the other equations.');
INSERT INTO olibdb VALUES('o','autoReduce',1,'n','(List(S))->List(S)','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','autoReduced?',2,'n','(S,(P,List(P))->Boolean)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','autoReduced?',2,'x','(%,(P,List(P))->Boolean)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{autoReduced?(ts,{} redOp?)} returns \spad{true} iff every element of \spad{ts} is reduced \spad{w}.\spad{r}.\spad{t} to every other in the sense of \spad{redOp?}');
INSERT INTO olibdb VALUES('o','axes',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{axes(v,{} s)} displays the axes of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is on,{} or does not display the axes if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','axes',3,'n','(%,PositiveInteger,Palette)->Void','dTwoDimensionalViewport',NULL,'\spad{axes(v,{} n,{} c)} displays the axes of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with the axes color set to the given palette color \spad{c}.');
INSERT INTO olibdb VALUES('o','axes',3,'n','(%,PositiveInteger,String)->Void','dTwoDimensionalViewport',NULL,'\spad{axes(v,{} n,{} s)} displays the axes of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is on,{} or does not display the axes if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','axesColorDefault',0,'x','()->Palette','pViewDefaultsPackage',NULL,'\spad{axesColorDefault()} returns the default color of the axes in a 2D viewport.');
INSERT INTO olibdb VALUES('o','axesColorDefault',1,'x','(Palette)->Palette','pViewDefaultsPackage',NULL,'\spad{axesColorDefault(p)} sets the default color of the axes in a 2D viewport to the palette \spad{p}.');
INSERT INTO olibdb VALUES('o','B1solve',1,'n','(Record(mat:Matrix(Fraction(Polynomial(R))),vec:List(Fraction(Polynomial(R))),rank:NonNegativeInteger,rows:List(Integer),cols:List(Integer)))->Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{B1solve(s)} solves the system (\spad{s}.mat) \spad{z} = \spad{s}.vec for the variables given by the column indices of \spad{s}.cols in terms of the other variables and the right hand side \spad{s}.vec by assuming that the rank is \spad{s}.rank,{} that the system is consistent,{} with the linearly independent equations indexed by the given row indices \spad{s}.rows; the coefficients in \spad{s}.mat involving parameters are treated as polynomials. B1solve(\spad{s}) returns a particular solution to the system and a basis of the homogeneous system (\spad{s}.mat) \spad{z} = 0.');
INSERT INTO olibdb VALUES('o','back',1,'x','(%)->S','cQueueAggregate(S)',NULL,'\spad{back(q)} returns the element at the back of the queue. The queue \spad{q} is unchanged by this operation. Error: if \spad{q} is empty.');
INSERT INTO olibdb VALUES('o','backOldPos',1,'x','(Record(mval:Matrix(F),invmval:Matrix(F),genIdeal:%))->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{backOldPos(genPos)} takes the result produced by \spadfunFrom{generalPosition}{PolynomialIdeal} and performs the inverse transformation,{} returning the original ideal \spad{backOldPos(generalPosition(I,{} listvar))} = \spad{I}.');
INSERT INTO olibdb VALUES('o','badNum',1,'n','(UP)->Record(den:Integer,gcdnum:Integer)','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{badNum(p)} \undocumented');
INSERT INTO olibdb VALUES('o','badNum',1,'n','(UPUP)->Integer','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{badNum(u)} \undocumented');
INSERT INTO olibdb VALUES('o','badValues',1,'n','(Pattern(R))->List(D)','pPatternFunctions1(R,D)',NULL,'\spad{badValues(p)} returns the list of bad values for \spad{p}; \spad{p} is not allowed to match any of its bad values.');
INSERT INTO olibdb VALUES('o','balancedBinaryTree',2,'x','(NonNegativeInteger,S)->%','dBalancedBinaryTree(S)',NULL,'\spad{balancedBinaryTree(n,{} s)} creates a balanced binary tree with \spad{n} nodes each with value \spad{s}.');
INSERT INTO olibdb VALUES('o','balancedFactorisation',2,'n','(UP,List(UP))->Factored(UP)','pBalancedFactorisation(R,UP)',NULL,'\spad{balancedFactorisation(a,{} [b1,{} ...,{} bn])} returns a factorisation \spad{a = p1^e1 ... pm^em} such that each \spad{pi} is balanced with respect to \spad{[b1,{} ...,{} bm]}.');
INSERT INTO olibdb VALUES('o','balancedFactorisation',2,'n','(UP,UP)->Factored(UP)','pBalancedFactorisation(R,UP)',NULL,'\spad{balancedFactorisation(a,{} b)} returns a factorisation \spad{a = p1^e1 ... pm^em} such that each \spad{\spad{pi}} is balanced with respect to \spad{b}.');
INSERT INTO olibdb VALUES('o','band',0,'n','()->FiniteCubicalComplex(Integer)','pCubicalComplexFactory',NULL,'Generate a cubical complex of the surface of a cylinder without ends');
INSERT INTO olibdb VALUES('o','band',0,'n','()->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'Generate a minimal triangulation of the surface of a cylinder without ends');
INSERT INTO olibdb VALUES('o','bandedHessian',3,'n','(F,FLAS,NonNegativeInteger)->Matrix(F)','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{bandedHessian(v,{} xlist,{} k)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in \spad{xlist},{} \spad{k} is the semi-bandwidth,{} the number of nonzero subdiagonals,{} 2*k+1 being actual bandwidth. Stores the nonzero band in lower triangle in a matrix,{} dimensions \spad{k+1} by \#xlist,{} whose rows are the vectors formed by diagonal,{} subdiagonal,{} etc. of the real,{} full-matrix,{} hessian. (The notation conforms to LAPACK/NAG-\spad{F07} conventions.)');
INSERT INTO olibdb VALUES('o','bandedJacobian',4,'n','(FLAF,FLAS,NonNegativeInteger,NonNegativeInteger)->Matrix(F)','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{bandedJacobian(vf,{} xlist,{} kl,{} ku)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in \spad{xlist},{} \spad{kl} is the number of nonzero subdiagonals,{} ku is the number of nonzero superdiagonals,{} \spad{kl+ku+1} being actual bandwidth. Stores the nonzero band in a matrix,{} dimensions \spad{kl+ku+1} by \#xlist. The upper triangle is in the top ku rows,{} the diagonal is in row \spad{ku+1},{} the lower triangle in the last \spad{kl} rows. Entries in a column in the band store correspond to entries in same column of full store. (The notation conforms to LAPACK/NAG-\spad{F07} conventions.)');
INSERT INTO olibdb VALUES('o','bandMatrix',2,'n','(M,List(Integer))->M','pMatrixManipulation(R,Row,Col,M)','has(R,AbelianMonoid)','\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals.');
INSERT INTO olibdb VALUES('o','bandMatrix',2,'n','(M,Segment(Integer))->M','pMatrixManipulation(R,Row,Col,M)','has(R,AbelianMonoid)','\spad{bandMatrix} returns multiple diagonals out of a matrix. The diagonals are put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals.');
INSERT INTO olibdb VALUES('o','base',0,'n','()->PositiveInteger','dMachineFloat',NULL,'\spad{base()} returns the base of the model');
INSERT INTO olibdb VALUES('o','base',0,'x','()->%','cIntegerNumberSystem',NULL,'\spad{base()} returns the base for the operations of \spad{IntegerNumberSystem}.');
INSERT INTO olibdb VALUES('o','base',0,'x','()->PositiveInteger','cFloatingPointSystem',NULL,'\spad{base()} returns the base of the \spadfunFrom{exponent}{FloatingPointSystem}.');
INSERT INTO olibdb VALUES('o','base',1,'n','(PositiveInteger)->PositiveInteger','dMachineFloat',NULL,'\spad{base(b)} sets the base of the model to \spad{b}');
INSERT INTO olibdb VALUES('o','base',1,'x','(%)->List(S)','dPermutationGroup(S)',NULL,'\spad{base(gp)} returns a base for the group {\em gp}.');
INSERT INTO olibdb VALUES('o','BasicMethod',1,'n','(I)->Factored(I)','pIntegerFactorizationPackage(I)',NULL,'\spad{BasicMethod(n)} returns the factorization of integer \spad{n} by trial division');
INSERT INTO olibdb VALUES('o','basicSet',2,'n','(List(P),(P,P)->Boolean)->Union(Record(bas:S,top:List(P)),failed)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','basicSet',2,'x','(List(P),(P,P)->Boolean)->Union(Record(bas:%,top:List(P)),failed)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{basicSet(ps,{} redOp?)} returns \spad{[bs,{} ts]} where \spad{concat(bs,{} ts)} is \spad{ps} and \spad{bs} is a basic set in Wu Wen Tsun sense of \spad{ps} \spad{w}.\spad{r}.\spad{t} the reduction-test \spad{redOp?},{} if no non-zero constant polynomial lie in \spad{ps},{} otherwise \spad{failed} is returned.');
INSERT INTO olibdb VALUES('o','basicSet',3,'n','(List(P),(P)->Boolean,(P,P)->Boolean)->Union(Record(bas:S,top:List(P)),failed)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','basicSet',3,'x','(List(P),(P)->Boolean,(P,P)->Boolean)->Union(Record(bas:%,top:List(P)),failed)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{basicSet(ps,{} pred?,{} redOp?)} returns the same as \spad{basicSet(qs,{} redOp?)} where \spad{qs} consists of the polynomials of \spad{ps} satisfying property \spad{pred?}.');
INSERT INTO olibdb VALUES('o','basis',0,'n','()->Vector(%)','cFramedModule(R)',NULL,'\spad{basis()} returns the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','basis',0,'n','()->Vector(S)','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','basis',0,'n','()->Vector(S)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','basis',1,'n','(List(Vector(R)))->%','dVectorSpaceBasis(R)',NULL,'\spad{basis LV} extracts a basis of the subspace spanned by the list of vectors \spad{LV}.');
INSERT INTO olibdb VALUES('o','basis',1,'n','(PositiveInteger)->Vector(Vector(GF))','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{basis(n)} \undocumented{} See \spadfunFrom{basis}{FiniteAlgebraicExtensionField}');
INSERT INTO olibdb VALUES('o','basis',1,'n','(%)->Vector(A)','dFractionalIdealAsModule(R,F,UP,A,ibasis)',NULL,'\spad{basis((f1,{} ...,{} fn))} = the vector \spad{[f1,{} ...,{} fn]}.');
INSERT INTO olibdb VALUES('o','basis',1,'n','(%)->Vector(A)','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{basis((f1,{} ...,{} fn))} returns the vector \spad{[f1,{} ...,{} fn]}.');
INSERT INTO olibdb VALUES('o','basis',1,'x','(PositiveInteger)->Vector(%)','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{basis(n)} returns a fixed basis of a subfield of \% as \spad{F}-vector space.');
INSERT INTO olibdb VALUES('o','basis',1,'x','(Vector(A))->Vector(A)','pAlgebraPackage(R,A)','has(R,EuclideanDomain)','\spad{basis(va)} selects a basis from the elements of \spad{va}.');
INSERT INTO olibdb VALUES('o','basis',2,'x','(NonNegativeInteger,NonNegativeInteger)->Vector(List(Integer))','pHallBasis',NULL,'\spad{basis(numberOfGens,{} maximalWeight)} generates a vector of elements of the form [left,{} weight,{} right] which represents a \spad{P}. Hall basis element for the free lie algebra on \spad{numberOfGens} generators. We only generate those basis elements of weight less than or equal to maximalWeight');
INSERT INTO olibdb VALUES('o','basisOfCenter',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfCenter()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{commutator(x,{} a) = 0} and \spad{associator(x,{} a,{} b) = associator(a,{} x,{} b) = associator(a,{} b,{} x) = 0} for all \spad{a},{} \spad{b} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfCentroid',0,'x','()->List(Matrix(R))','pAlgebraPackage(R,A)',NULL,'\spad{basisOfCentroid()} returns a basis of the centroid,{} \spadignore{i.e.} the endomorphism ring of \spad{A} considered as \spad{(A,{} A)}-bimodule.');
INSERT INTO olibdb VALUES('o','basisOfCommutingElements',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfCommutingElements()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = commutator(x,{} a)} for all \spad{a} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfLeftAnnihilator',1,'x','(A)->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfLeftAnnihilator(a)} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = x*a}.');
INSERT INTO olibdb VALUES('o','basisOfLeftNucleus',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfLeftNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(x,{} a,{} b)} for all \spad{a},{} \spad{b} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfLeftNucloid',0,'x','()->List(Matrix(R))','pAlgebraPackage(R,A)',NULL,'\spad{basisOfLeftNucloid()} returns a basis of the space of endomorphisms of \spad{A} as right module. Note: left nucloid coincides with left nucleus if \spad{A} has a unit.');
INSERT INTO olibdb VALUES('o','basisOfMiddleNucleus',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfMiddleNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(a,{} x,{} b)} for all \spad{a},{} \spad{b} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfNucleus',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{associator(x,{} a,{} b) = associator(a,{} x,{} b) = associator(a,{} b,{} x) = 0} for all \spad{a},{} \spad{b} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfRightAnnihilator',1,'x','(A)->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfRightAnnihilator(a)} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = a*x}.');
INSERT INTO olibdb VALUES('o','basisOfRightNucleus',0,'x','()->List(A)','pAlgebraPackage(R,A)',NULL,'\spad{basisOfRightNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(a,{} b,{} x)} for all \spad{a},{} \spad{b} in \spad{A}.');
INSERT INTO olibdb VALUES('o','basisOfRightNucloid',0,'x','()->List(Matrix(R))','pAlgebraPackage(R,A)',NULL,'\spad{basisOfRightNucloid()} returns a basis of the space of endomorphisms of \spad{A} as left module. Note: right nucloid coincides with right nucleus if \spad{A} has a unit.');
INSERT INTO olibdb VALUES('o','bat1',1,'n','(List(List(List(S))))->List(List(S))','pTableauxBumpers(S)',NULL,'\spad{bat1(llp)} unbumps a tableau \spad{llp}. Operation \spad{bat1} is the inverse of \spad{tab1}.');
INSERT INTO olibdb VALUES('o','bat',1,'n','(Tableau(List(S)))->List(List(S))','pTableauxBumpers(S)',NULL,'\spad{bat(ls)} unbumps a tableau \spad{ls}');
INSERT INTO olibdb VALUES('o','beauzamyBound',1,'n','(UP)->Integer','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{beauzamyBound(p)} returns a bound on the larger coefficient of any factor of \spad{p}.');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','pAlgebraicFunction(R,F)',NULL,'\spad{belong?(op)} is \spad{true} if \spad{op} is an algebraic operator,{} that is,{} an \spad{n}th root or implicit algebraic operator.');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','pCombinatorialFunction(R,F)',NULL,'\spad{belong?(op)} returns \spad{true} if \spad{op} is a combinatorial operator.');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','pElementaryFunction(R,F)',NULL,'\spad{belong?(p)} returns \spad{true} if operator \spad{p} is elementary');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','pFunctionalSpecialFunction(R,F)',NULL,'\spad{belong?(op)} returns \spad{true} if \spad{op} is a special function operator.');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','pLiouvillianFunction(R,F)',NULL,'\spad{belong?(op)} checks if \spad{op} is Liouvillian');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','xExpressionSpace2&(S,K)',NULL,'\spad{belong?(op)} tests if \% accepts \spad{op} as applicable to its elements.');
INSERT INTO olibdb VALUES('o','belong?',1,'n','(BasicOperator)->Boolean','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','belong?',1,'x','(BasicOperator)->Boolean','cExpressionSpace2(K)',NULL,'\spad{belong?(op)} tests if \% accepts \spad{op} as applicable to its elements.');
INSERT INTO olibdb VALUES('o','bernoulli',1,'n','(Integer)->SparseUnivariatePolynomial(Fraction(Integer))','pPolynomialNumberTheoryFunctions',NULL,'\spad{bernoulli(n)} returns the \spad{n}th Bernoulli polynomial \spad{B[n](x)}. Note: Bernoulli polynomials denoted \spad{B(n,{} x)} computed by solving the differential equation \spad{differentiate(B(n,{} x),{} x) = n B(n-1,{} x)} where \spad{B(0,{} x) = 1} and initial condition comes from \spad{B(n) = B(n,{} 0)}.');
INSERT INTO olibdb VALUES('o','bernoulli',1,'x','(Integer)->Fraction(Integer)','pIntegerNumberTheoryFunctions',NULL,'\spad{bernoulli(n)} returns the \spad{n}th Bernoulli number. this is \spad{B(n,{} 0)},{} where \spad{B(n,{} x)} is the \spad{n}th Bernoulli polynomial.');
INSERT INTO olibdb VALUES('o','bernoulliB',2,'x','(NonNegativeInteger,R)->R','pNumberTheoreticPolynomialFunctions(R)','has(R,Algebra(Fraction(Integer)))','\spad{bernoulliB(n,{} r)} returns value of the \spad{n}th Bernoulli polynomial at \spad{r}.');
INSERT INTO olibdb VALUES('o','bernoulliDistribution01',1,'x','(R)->Distribution(R)','pDistributionPackage(R)',NULL,'\spad{bernoulliDistribution01(a)} produces the distribution of a projection of trace a');
INSERT INTO olibdb VALUES('o','besselI',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{besselI(x,{} y)} returns the Bessel \spad{I} function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','besselI',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions',NULL,'\spad{besselI(v,{} x)} is the modified Bessel function of the first kind,{} \spad{I(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) - (x^2+v^2)w(x) = 0}.}');
INSERT INTO olibdb VALUES('o','besselI',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{besselI(v,{} z)} is the modified Bessel function of the first kind.');
INSERT INTO olibdb VALUES('o','besselI',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions',NULL,'\spad{besselI(v,{} x)} is the modified Bessel function of the first kind,{} \spad{I(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) - (x^2+v^2)w(x) = 0}.}');
INSERT INTO olibdb VALUES('o','besselJ',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{besselJ(x,{} y)} returns the Bessel \spad{J} function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','besselJ',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions',NULL,'\spad{besselJ(v,{} x)} is the Bessel function of the first kind,{} \spad{J(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) + (x^2-v^2)w(x) = 0}.}');
INSERT INTO olibdb VALUES('o','besselJ',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{besselJ(v,{} z)} is the Bessel function of the first kind.');
INSERT INTO olibdb VALUES('o','besselJ',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions',NULL,'\spad{besselJ(v,{} x)} is the Bessel function of the first kind,{} \spad{J(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) + (x^2-v^2)w(x) = 0}.}');
INSERT INTO olibdb VALUES('o','besselK',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{besselK(x,{} y)} returns the Bessel \spad{K} function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','besselK',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions',NULL,'\spad{besselK(v,{} x)} is the modified Bessel function of the second kind,{} \spad{K(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) - (x^2+v^2)w(x) = 0}.} Note: The default implementation uses the relation \indented{2}{\spad{K(v,{} x) = \%pi/2*(I(-v,{} x) - I(v,{} x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.');
INSERT INTO olibdb VALUES('o','besselK',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{besselK(v,{} z)} is the modified Bessel function of the second kind.');
INSERT INTO olibdb VALUES('o','besselK',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions',NULL,'\spad{besselK(v,{} x)} is the modified Bessel function of the second kind,{} \spad{K(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) - (x^2+v^2)w(x) = 0}.} Note: The default implementation uses the relation \indented{2}{\spad{K(v,{} x) = \%pi/2*(I(-v,{} x) - I(v,{} x))/sin(v*\%\spad{pi})}.} so is not valid for integer values of \spad{v}.');
INSERT INTO olibdb VALUES('o','besselY',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{besselY(x,{} y)} returns the Bessel \spad{Y} function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','besselY',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions',NULL,'\spad{besselY(v,{} x)} is the Bessel function of the second kind,{} \spad{Y(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) + (x^2-v^2)w(x) = 0}.} Note: The default implementation uses the relation \indented{2}{\spad{Y(v,{} x) = (J(v,{} x) cos(v*\%\spad{pi}) - J(-v,{} x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.');
INSERT INTO olibdb VALUES('o','besselY',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{besselY(v,{} z)} is the Bessel function of the second kind.');
INSERT INTO olibdb VALUES('o','besselY',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions',NULL,'\spad{besselY(v,{} x)} is the Bessel function of the second kind,{} \spad{Y(v,{} x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''''(x) + x w''(x) + (x^2-v^2)w(x) = 0}.} Note: The default implementation uses the relation \indented{2}{\spad{Y(v,{} x) = (J(v,{} x) cos(v*\%\spad{pi}) - J(-v,{} x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.');
INSERT INTO olibdb VALUES('o','Beta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Beta()} returns symbol for capital greek letter beta.');
INSERT INTO olibdb VALUES('o','beta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{beta()} returns symbol for small greek letter beta.');
INSERT INTO olibdb VALUES('o','Beta',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{Beta(x,{} y)} returns the beta function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','Beta',2,'n','(NonNegativeInteger,NonNegativeInteger)->()->Float','pRandomFloatDistributions',NULL,'\spad{Beta(n,{} m)} \undocumented');
INSERT INTO olibdb VALUES('o','Beta',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Beta',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{Beta(x,{} y)} is the Euler Beta function.');
INSERT INTO olibdb VALUES('o','Beta',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{Beta(x,{} y)} is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.');
INSERT INTO olibdb VALUES('o','Beta',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Beta',2,'x','(Float,Float)->Float','pFloatSpecialFunctions',NULL,'\spad{Beta(x,{} y)} is the Euler Beta function.');
INSERT INTO olibdb VALUES('o','Beta',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{Beta(x,{} a,{} b)} is incomplete Beta function applied to \spad{x},{} a and \spad{b}.');
INSERT INTO olibdb VALUES('o','Beta',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{Beta(x,{} a,{} b)} is the incomplete Beta function.');
INSERT INTO olibdb VALUES('o','bezoutDiscriminant',1,'n','(UP)->R','pBezoutMatrix(R,UP,M,Row,Col)','has(R,CommutativeRing)','\spad{bezoutDiscriminant(p)} computes the discriminant of a polynomial \spad{p} by computing the determinant of a Bezout matrix.');
INSERT INTO olibdb VALUES('o','bezoutDiscriminant',1,'n','(UP)->R','pBezoutMatrixWrapper(R,UP)','has(R,CommutativeRing)',NULL);
INSERT INTO olibdb VALUES('o','bezoutMatrix',2,'n','(UP,UP)->Matrix(R)','pBezoutMatrixWrapper(R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','bezoutMatrix',2,'n','(UP,UP)->M','pBezoutMatrix(R,UP,M,Row,Col)',NULL,'\spad{bezoutMatrix(p,{} q)} returns the Bezout matrix for the two polynomials \spad{p} and \spad{q}.');
INSERT INTO olibdb VALUES('o','bezoutResultant',2,'n','(UP,UP)->R','pBezoutMatrix(R,UP,M,Row,Col)','has(R,CommutativeRing)','\spad{bezoutResultant(p,{} q)} computes the resultant of the two polynomials \spad{p} and \spad{q} by computing the determinant of a Bezout matrix.');
INSERT INTO olibdb VALUES('o','bezoutResultant',2,'n','(UP,UP)->R','pBezoutMatrixWrapper(R,UP)','has(R,CommutativeRing)',NULL);
INSERT INTO olibdb VALUES('o','binary',1,'x','(Fraction(Integer))->%','dBinaryExpansion',NULL,'\spad{binary(r)} converts a rational number to a binary expansion.');
INSERT INTO olibdb VALUES('o','binary',2,'n','((Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{binary(h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument according to \spad{h1} and the second argument by \spad{h2}. Both boxes will be horizontally concatenated. binary(\spad{h1},{} \spad{h2}) is equal to infix(\spad{"},{} maxPrecedence(),{} \spad{h1},{} \spad{h2})');
INSERT INTO olibdb VALUES('o','binary',2,'n','((Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{binary(h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument according to \spad{h1} and the second argument by \spad{h2}. Both boxes will be horizontally concatenated. binary(\spad{h1},{} \spad{h2}) is equal to infix(\spad{"},{} maxPrecedence(),{} \spad{h1},{} \spad{h2})');
INSERT INTO olibdb VALUES('o','binary',2,'n','(%,List(%))->%','dInputForm',NULL,'\spad{binary(op,{} [a1,{} ...,{} an])} returns the input form corresponding to \spad{a1 op a2 op ... op an}.');
INSERT INTO olibdb VALUES('o','binaryFunction',1,'n','(Symbol)->(D1,D2)->I','pMakeBinaryCompiledFunction(S,D1,D2,I)',NULL,'\spad{binaryFunction(s)} is a local function');
INSERT INTO olibdb VALUES('o','binarySearch',2,'n','(S,(S,S)->Integer)->Union(S,failed)','pSortedCache(S)',NULL,'\spad{binarySearch(x,{} f)} searches \spad{x} in the cache,{} calling \spad{f(x,{} y)} to determine order. It returns \spad{y} from cache if \spad{f}(\spad{x},{} \spad{y}) is 0 or failed if no such \spad{y} exists.');
INSERT INTO olibdb VALUES('o','binarySearchTree',1,'x','(List(S))->%','dBinarySearchTree(S)',NULL,'\spad{binarySearchTree(l)} constructs a binary search tree with elements from list \spad{l}.');
INSERT INTO olibdb VALUES('o','binaryTournament',1,'x','(List(S))->%','dBinaryTournament(S)',NULL,'\spad{binaryTournament(ls)} creates a binary tournament with the elements of \spad{ls} as values of the nodes.');
INSERT INTO olibdb VALUES('o','binaryTree',1,'x','(S)->%','dBinaryTree(S)',NULL,'\spad{binaryTree(v)} is an non-empty binary tree with value \spad{v},{} and left and right empty.');
INSERT INTO olibdb VALUES('o','binaryTree',3,'x','(%,S,%)->%','dBinaryTree(S)',NULL,'\spad{binaryTree(l,{} v,{} r)} creates a binary tree with value \spad{v} and left subtree \spad{l} and right subtree \spad{r}.');
INSERT INTO olibdb VALUES('o','bind',1,'n','(%)->%','dLambda(UT)',NULL,'if this is a lambda term then replace string name in sub-nodes with De Bruijn index');
INSERT INTO olibdb VALUES('o','binomial',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{binomial(n,{} m)} creates a form for the binomial coefficient of \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','binomial',2,'n','(F,F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{binomial(n,{} r)} returns the number of subsets of \spad{r} objects taken among \spad{n} objects,{} \spadignore{i.e.} \spad{n!/}(\spad{r!} * (\spad{n}-\spad{r})!).');
INSERT INTO olibdb VALUES('o','binomial',2,'n','(Integer,Fraction(Integer))->()->Integer','pRandomIntegerDistributions',NULL,'\spad{binomial(n,{} f)} \undocumented');
INSERT INTO olibdb VALUES('o','binomial',2,'n','(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{binomial} is a handler such that \spad{binomial(prec,{}args)} formats a binomial expression of the first two arguments.');
INSERT INTO olibdb VALUES('o','binomial',2,'n','(S,S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','binomial',2,'x','(%,%)->%','cCombinatorialFunctionCategory',NULL,'\spad{binomial(n,{} r)} returns the \spad{(n,{} r)} binomial coefficient (often denoted in the literature by \spad{C(n,{} r)}). Note: \spad{C(n,{} r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.');
INSERT INTO olibdb VALUES('o','binomial',2,'x','(I,I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{binomial(n,{} r)} returns the binomial coefficient \spad{C(n,{} r) = n!/(r! (n-r)!)},{} where \spad{n >= r >= 0}. This is the number of combinations of \spad{n} objects taken \spad{r} at a time.');
INSERT INTO olibdb VALUES('o','binomThmExpt',3,'n','(S,S,NonNegativeInteger)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','binomThmExpt',3,'x','(%,%,NonNegativeInteger)->%','cFiniteAbelianMonoidRing(R,E)','has(%,CommutativeRing)','\spad{binomThmExpt(p,{} q,{} n)} returns \spad{(p+q)^n} by means of the binomial theorem trick.');
INSERT INTO olibdb VALUES('o','bipolar',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{bipolar(a)} transforms from bipolar coordinates to Cartesian coordinates: \spad{bipolar(a)} is a function which will map the point \spad{(u,{} v)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \spad{y = a*sin(u)/(cosh(v)-cos(u))}.');
INSERT INTO olibdb VALUES('o','bipolarCylindrical',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{bipolarCylindrical(a)} transforms from bipolar cylindrical coordinates to Cartesian coordinates: \spad{bipolarCylindrical(a)} is a function which \spad{++} will map the point \spad{(u,{} v,{} z)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \spad{y = a*sin(u)/(cosh(v)-cos(u))},{} \spad{z}.');
INSERT INTO olibdb VALUES('o','biRank',1,'x','(A)->NonNegativeInteger','pAlgebraPackage(R,A)',NULL,'\spad{biRank(x)} determines the number of linearly independent elements in \spad{x},{} \spad{x*bi},{} \spad{bi*x},{} \spad{bi*x*bj},{} \spad{i,{} j=1,{} ...,{} n},{} where \spad{b=[b1,{} ...,{} bn]} is a basis. Note: if \spad{A} has a unit,{} then \spadfunFrom{doubleRank}{AlgebraPackage},{} \spadfunFrom{weakBiRank}{AlgebraPackage} and \spadfunFrom{biRank}{AlgebraPackage} coincide.');
INSERT INTO olibdb VALUES('o','birth',1,'n','(%)->%','dSubSpace(n,R)',NULL,'\spad{birth(x)} \undocumented');
INSERT INTO olibdb VALUES('o','bit?',2,'n','(S,S)->Boolean','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','bit?',2,'x','(%,%)->Boolean','cIntegerNumberSystem',NULL,'\spad{bit?(n,{} i)} returns \spad{true} if and only if \spad{i}-th bit of \spad{n} is a 1.');
INSERT INTO olibdb VALUES('o','bitCoef',2,'n','(Integer,NonNegativeInteger)->Integer','pIntegerBits',NULL,'\spad{bitCoef(n,{} m)} returns the coefficient of 2^m in two complement representation of \spad{n}.');
INSERT INTO olibdb VALUES('o','bits',0,'x','()->PositiveInteger','cFloatingPointSystem',NULL,'\spad{bits()} returns ceiling\spad{''s} precision in bits.');
INSERT INTO olibdb VALUES('o','bits',1,'x','(PositiveInteger)->PositiveInteger','cFloatingPointSystem','has(%,arbitraryPrecision)','\spad{bits(n)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{n} bits.');
INSERT INTO olibdb VALUES('o','bits',2,'x','(NonNegativeInteger,Boolean)->%','dBits',NULL,'\spad{bits(n,{} b)} creates bits with \spad{n} values of \spad{b}');
INSERT INTO olibdb VALUES('o','bitTruth',2,'n','(Integer,NonNegativeInteger)->Boolean','pIntegerBits',NULL,'\spad{bitTruth(n,{} m)} returns \spad{true} if coefficient of 2^m in two complement representation of \spad{n} is 1.');
INSERT INTO olibdb VALUES('o','bivariate?',1,'n','(P)->Boolean','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{bivariate?(p)} returns \spad{true} iff \spad{p} involves two and only two variables.');
INSERT INTO olibdb VALUES('o','bivariatePolynomials',1,'n','(List(P))->Record(goodPols:List(P),badPols:List(P))','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{bivariatePolynomials(lp)} returns \spad{bps,{} nbps} where \spad{bps} is a list of the bivariate polynomials,{} and \spad{nbps} are the other ones.');
INSERT INTO olibdb VALUES('o','bivariateSLPEBR',3,'n','(List(SparseUnivariatePolynomial(S)),SparseUnivariatePolynomial(S),VarSet)->Union(List(SparseUnivariatePolynomial(S)),failed)','pPolynomialFactorizationByRecursion(R,E,VarSet,S)',NULL,'\spad{bivariateSLPEBR(lp,{} p,{} v)} implements the bivariate case of \spadfun{solveLinearPolynomialEquationByRecursion}; its implementation depends on \spad{R}');
INSERT INTO olibdb VALUES('o','blankSeparate',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{blankSeparate(l)} creates the form separating the elements of \spad{l} by blanks.');
INSERT INTO olibdb VALUES('o','block',1,'n','(List(%))->%','dFortranCode',NULL,'\spad{block(l)} creates a representation of the statements in \spad{l} as a block.');
INSERT INTO olibdb VALUES('o','blockConcat',1,'n','(List(List(S)))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','blockConcat',1,'x','(List(List(%)))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{blockConcat(ll)} concatenates arrays row and column wise,{} building a array from blocks. The order is row major as in \spad{matrix}.');
INSERT INTO olibdb VALUES('o','blockElimination',5,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Matrix(F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{blockElimination(f,{} rsrc,{} rdst,{} csrc,{} cdst)} flg_u = \spad{true},{} flg_v = \spad{true}');
INSERT INTO olibdb VALUES('o','blockElimination',7,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),Boolean,List(NonNegativeInteger),List(NonNegativeInteger),Boolean)->List(Matrix(F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{blockElimination(f,{} rsrc,{} rdst,{} flg_u,{} csrc,{} cdst,{} flg_v)} returns transformation matrices if it is possible to eliminate all entries in \spad{rdst} \spad{x} \spad{cdst} (including columns in \spad{u} if \spad{flg_u} = \spad{true},{} including rows in \spad{v} if flg_v = \spad{true}) by using rows in \spad{rsrc} and columns in \spad{csrc}. Otherwise an empty list.');
INSERT INTO olibdb VALUES('o','blockElimination',7,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Matrix(R))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{blockElimination(p,{} rsrc,{} rdst,{} rext,{} csrc,{} cdst,{} cext)} r___ rows,{} c___ columns _src source,{} _dst destination,{} _ext extra (zeros) Uses a linear system of equations to determine row and column transformation matrices to eliminate the entries in rdst+rext \times cdst+cext and returns an empty list if there is no solution.');
INSERT INTO olibdb VALUES('o','blockSplit',3,'n','(M,List(NonNegativeInteger),PositiveInteger)->List(List(M))','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{blockSplit} splits a matrix into multiple submatrices row and column wise,{} dividing a matrix into blocks.');
INSERT INTO olibdb VALUES('o','blockSplit',3,'n','(M,PositiveInteger,List(NonNegativeInteger))->List(List(M))','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{blockSplit} splits a matrix into multiple submatrices row and column wise,{} dividing a matrix into blocks.');
INSERT INTO olibdb VALUES('o','blockSplit',3,'n','(S,List(NonNegativeInteger),List(NonNegativeInteger))->List(List(S))','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','blockSplit',3,'n','(S,PositiveInteger,PositiveInteger)->List(List(S))','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','blockSplit',3,'x','(%,List(NonNegativeInteger),List(NonNegativeInteger))->List(List(%))','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{blockSplit(a,{} [n1,{}...,{}\spad{ni}],{} [m1,{}...,{}\spad{mi}])} splits a into multiple subarraus row and column wise,{} such that element at position \spad{k},{} \spad{l} has \spad{nk} rows and \spad{ml} columns. Error: if number of rows of a is different than \spad{n1} + ... + \spad{ni} or number of columns of a is different than \spad{m1} + ... + \spad{mj}');
INSERT INTO olibdb VALUES('o','blockSplit',3,'x','(%,PositiveInteger,PositiveInteger)->List(List(%))','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{blockSplit(a,{} n,{} m)} splits a into \spad{n*m} subarrays of equal size row and column wise,{} dividing a into blocks. Error: if number of rows of a is not divisible by \spad{n} or number of columns of a is not divisible by \spad{m}.');
INSERT INTO olibdb VALUES('o','blockStructure',1,'n','(%)->Matrix(NonNegativeInteger)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{blockStructure(f)} analyzes the structure of the ALS of \spad{f} and detects blocks with respect to an upper triangular structure. Entry (\spad{i},{}1) contains the first row,{} (\spad{i},{}2) the last row,{} (\spad{i},{}3) the size and (\spad{i},{}4) if block \spad{i} is refined.');
INSERT INTO olibdb VALUES('o','blue',0,'x','()->%','dColor',NULL,'\spad{blue()} returns the position of the blue hue from total hues.');
INSERT INTO olibdb VALUES('o','bombieriNorm',1,'n','(UP)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{bombieriNorm(p)} returns quadratic Bombieri\spad{''s} norm of \spad{p}.');
INSERT INTO olibdb VALUES('o','bombieriNorm',2,'n','(UP,PositiveInteger)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{bombieriNorm(p,{} n)} returns the \spad{n}th Bombieri\spad{''s} norm of \spad{p}.');
INSERT INTO olibdb VALUES('o','booleanConvolution',2,'n','(%,%)->%','cDistributionCategory(R)',NULL,'\spad{booleanConvolution(x,{} y)} returns the boolean convolution of the distributions \spad{x} and \spad{y}');
INSERT INTO olibdb VALUES('o','booleanCumulant2moment',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{booleanCumulant2moment(cc)} computes the sequence of moments from the sequence of boolean cumulants \spad{cc}');
INSERT INTO olibdb VALUES('o','booleanCumulant',2,'n','(%,PositiveInteger)->R','cDistributionCategory(R)',NULL,'\spad{booleanCumulant(x,{} n)} returns the \spad{n}-th boolean cumulant of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','booleanCumulantFromJacobi',3,'x','(Integer,Sequence(R),Sequence(R))->R','dDistribution(R)',NULL,'\spad{booleanCumulantFromJacobi(n,{} aa,{} bb)} computes the \spad{n}th Boolean cumulant from the given Jacobiparameters \spad{aa} and \spad{bb}.');
INSERT INTO olibdb VALUES('o','booleanCumulants',1,'n','(%)->Sequence(R)','cDistributionCategory(R)',NULL,'\spad{booleanCumulants(x)} returns the sequence of boolean cumulants of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','boolWordPermute',2,'n','(NonNegativeInteger,NonNegativeInteger)->List(List(Boolean))','dOrientedFacet',NULL,'boolean word permutation find all permutations of numZeros and numOnes used by product to calculate all paths through lattice');
INSERT INTO olibdb VALUES('o','boolWordPermute',3,'n','(List(List(Boolean)),NonNegativeInteger,NonNegativeInteger)->List(List(Boolean))','dOrientedFacet',NULL,'recursive part of boolWordPermute');
INSERT INTO olibdb VALUES('o','bottom',1,'n','(Stream(List(R)))->Stream(R)','pPathArrayPackage(R)',NULL,'\spad{bottom(x)} returns the bottom entry of each column.');
INSERT INTO olibdb VALUES('o','bottom',1,'x','(%)->S','cDequeueAggregate(S)',NULL,'\spad{bottom(d)} returns the element at the bottom (back) of the dequeue.');
INSERT INTO olibdb VALUES('o','bound',3,'n','(NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','pCartanKuranishi(JB,D)',NULL,'\spad{bound(n,{} m,{} q)} computes an upper bound for the number of prolongations needed to make the symbol of an equation of order \spad{q} with \spad{n} independent and \spad{m} dependent variables involutive.');
INSERT INTO olibdb VALUES('o','boundary',1,'n','(%)->%','dFiniteCubicalComplex(VS)',NULL,'Boundary operator. Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can.');
INSERT INTO olibdb VALUES('o','boundary',1,'n','(%)->%','dFiniteSimplicialComplex(VS)',NULL,'Step down to the next lower dimension,{} this is like hollowing out the complex. It takes the highest dimension entries and replaces them with their boundaries,{} cancelling out where it can.');
INSERT INTO olibdb VALUES('o','boundary',1,'n','(%)->List(%)','dCubicalFacet',NULL,'construct the boundary. This is like hollowing out the facet.');
INSERT INTO olibdb VALUES('o','boundary',1,'n','(%)->List(%)','dOrientedFacet',NULL,'construct the boundary. This is like hollowing out the facet.');
INSERT INTO olibdb VALUES('o','boundary',2,'n','(%,DoubleFloat)->SBoundary(PT)','dScene(PT)',NULL,'\spad{boundary(n,{} fontScale)} returns the boundary of a given node,{} so if this is called on the root node,{} it will return the boundary of the whole scene. There is a difficulty involving text nodes,{} that is they have a fixed font size. But we want to calculate the boundary in local coordinates,{} to do this conversion we need to know the total boundary size but that is what we are trying to calculate! To get round this contradiction the parameter fontScale is required since fonts are rendered at a fixed size we need a scaling factor so that we can give the boundary in our coordinate system. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if this node,{} or its subnodes,{} do not contain a text node then its value is not significant.');
INSERT INTO olibdb VALUES('o','boundOfCauchy',1,'x','(ThePols)->TheField','pRealPolynomialUtilitiesPackage(TheField,ThePols)','has(TheField,OrderedRing)','\spad{boundOfCauchy(p)} bounds the roots of \spad{p}');
INSERT INTO olibdb VALUES('o','box',1,'n','(%)->%','dOutputForm',NULL,'\spad{box(f)} encloses \spad{f} in a box.');
INSERT INTO olibdb VALUES('o','box',1,'n','((Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{box(hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the arguments via \spad{hh(prec,{} args)} and then draws a box frame around the resulting box.');
INSERT INTO olibdb VALUES('o','box',1,'n','(S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','box',1,'n','(String)->%','dOutputBox',NULL,'\spad{box(s)} creates a box that contains the string \spad{s}.');
INSERT INTO olibdb VALUES('o','box',1,'x','(%)->%','cExpressionSpace2(K)',NULL,'\spad{box(f)} returns \spad{f} with a ''box'' around it that prevents \spad{f} from being evaluated when operators are applied to it. For example,{} \spad{log(1)} returns 0,{} but \spad{log(box 1)} returns the formal kernel log(1).');
INSERT INTO olibdb VALUES('o','boxBoundary',2,'n','(PT,PT)->%','dSBoundary(PT)',NULL,'\spad{boxBoundary(c1,{} c2)} constructs a box boundary (\spad{n}-dimensional axis-aligned rectangle) with given parameters \spad{c1:} \spad{PT} holds minimum coordinates \spad{c2:} \spad{PT} holds maximum coordinates');
INSERT INTO olibdb VALUES('o','brace',1,'n','(%)->%','dOutputForm',NULL,'\spad{brace(f)} creates the form enclosing \spad{f} in braces (curly brackets).');
INSERT INTO olibdb VALUES('o','brace',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{brace(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in curly brackets.');
INSERT INTO olibdb VALUES('o','bracket',1,'n','(%)->%','dOutputForm',NULL,'\spad{bracket(f)} creates the form enclosing \spad{f} in square brackets.');
INSERT INTO olibdb VALUES('o','bracket',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{bracket(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in square brackets.');
INSERT INTO olibdb VALUES('o','bracket',3,'n','(String,String,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{bracket(lb,{} rb,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats its first argument according to \spad{hh} and then put left and right brackets given by \spad{lb} and \spad{rb} around the resulting box.');
INSERT INTO olibdb VALUES('o','bracket',3,'n','(String,String,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{bracket(lb,{} rb,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats its first argument according to \spad{hh} and then put left and right brackets given by \spad{lb} and \spad{rb} around the resulting box.');
INSERT INTO olibdb VALUES('o','branchIfCan',8,'x','(List(P),TS,List(P),Boolean,Boolean,Boolean,Boolean,Boolean)->Union(Record(eq:List(P),tower:TS,ineq:List(P)),failed)','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{branchIfCan(leq,{} ts,{} lineq,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','branchIfCan',8,'x','(List(P),TS,List(P),Boolean,Boolean,Boolean,Boolean,Boolean)->Union(Record(eq:List(P),tower:TS,ineq:List(P)),failed)','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{branchIfCan(leq,{} ts,{} lineq,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','branchPoint?',1,'x','(F)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{branchPoint?(a)} tests whether \spad{x = a} is a branch point.');
INSERT INTO olibdb VALUES('o','branchPoint?',1,'x','(UP)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{branchPoint?(p)} tests whether \spad{p(x) = 0} is a branch point.');
INSERT INTO olibdb VALUES('o','branchPointAtInfinity?',0,'x','()->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{branchPointAtInfinity?()} tests if there is a branch point at infinity.');
INSERT INTO olibdb VALUES('o','bright',1,'x','(Color)->%','dPalette',NULL,'\spad{bright(c)} sets the shade of a hue,{} \spad{c},{} above dim,{} but below pastel.');
INSERT INTO olibdb VALUES('o','bright',1,'x','(List(String))->List(String)','pDisplayPackage',NULL,'\spad{bright(l)} sets the font property of a list of strings,{} \spad{l},{} to bold-face type.');
INSERT INTO olibdb VALUES('o','bright',1,'x','(String)->List(String)','pDisplayPackage',NULL,'\spad{bright(s)} sets the font property of the string \spad{s} to bold-face type.');
INSERT INTO olibdb VALUES('o','brillhartIrreducible?',1,'n','(UP)->Boolean','pBrillhartTests(UP)',NULL,'\spad{brillhartIrreducible?(p)} returns \spad{true} if \spad{p} can be shown to be irreducible by a remark of Brillhart,{} \spad{false} is inconclusive.');
INSERT INTO olibdb VALUES('o','brillhartIrreducible?',2,'n','(UP,Boolean)->Boolean','pBrillhartTests(UP)',NULL,'\spad{brillhartIrreducible?(p,{} noLinears)} returns \spad{true} if \spad{p} can be shown to be irreducible by a remark of Brillhart,{} \spad{false} else. If noLinears is \spad{true},{} we are being told \spad{p} has no linear factors \spad{false} does not mean that \spad{p} is reducible.');
INSERT INTO olibdb VALUES('o','brillhartTrials',0,'n','()->NonNegativeInteger','pBrillhartTests(UP)',NULL,'\spad{brillhartTrials()} returns the number of tests in \spadfun{brillhartIrreducible?}.');
INSERT INTO olibdb VALUES('o','brillhartTrials',1,'n','(NonNegativeInteger)->NonNegativeInteger','pBrillhartTests(UP)',NULL,'\spad{brillhartTrials(n)} sets to \spad{n} the number of tests in \spadfun{brillhartIrreducible?} and returns the previous value.');
INSERT INTO olibdb VALUES('o','bringDown',1,'n','(F)->Fraction(Integer)','pFunctionSpaceReduce(R,F)',NULL,'\spad{bringDown(f)} replaces transcendental kernels in \spad{f} by random integers. Error if \spad{f} contains algebraic kernel.');
INSERT INTO olibdb VALUES('o','bringDown',2,'n','(F,Kernel(F))->SparseUnivariatePolynomial(Fraction(Integer))','pFunctionSpaceReduce(R,F)',NULL,'\spad{bringDown(f,{} k)} is like bringDown(\spad{f}) but \spad{k} is algebraic kernel and the result is reduced modulo minimal polynomial of \spad{k}.');
INSERT INTO olibdb VALUES('o','bsolve',5,'n','(Matrix(GR),List(Fraction(Polynomial(R))),NonNegativeInteger,String,Integer)->Record(rgl:List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R))))))),rgsz:Integer)','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{bsolve(c,{} w,{} r,{} s,{} m)} returns a list of regimes and solutions of the system \spad{c} \spad{z} = \spad{w} for ranks at least \spad{r}; depending on the mode \spad{m} chosen,{} it writes the output to a file given by the string \spad{s}.');
INSERT INTO olibdb VALUES('o','btwFact',4,'n','(UP,Boolean,Set(NonNegativeInteger),NonNegativeInteger)->Record(contp:Integer,factors:List(Record(irr:UP,pow:NonNegativeInteger)))','pGaloisGroupFactorizer(UP)',NULL,'\spad{btwFact(p,{} sqf,{} pd,{} r)} returns the factorization of \spad{p},{} the result is a Record such that \spad{contp=}content \spad{p},{} \spad{factors=}List of irreducible factors of \spad{p} with exponent. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors). \spad{pd} is the \spadtype{Set} of possible degrees. \spad{r} is a lower bound for the number of factors of \spad{p}. Please do not use this function in your code because its design may change.');
INSERT INTO olibdb VALUES('o','bubbleSort!',1,'n','(A)->A','pSortPackage(S,A)','has(S,OrderedSet)','\spad{bubbleSort!(a)} \undocumented');
INSERT INTO olibdb VALUES('o','bubbleSort!',2,'n','(A,(S,S)->Boolean)->A','pSortPackage(S,A)',NULL,'\spad{bubbleSort!(a,{} f)} \undocumented');
INSERT INTO olibdb VALUES('o','build',3,'n','(R,IS,E)->%','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{build(r,{} i,{} e)} \undocumented');
INSERT INTO olibdb VALUES('o','BumInSepFFE',1,'n','(Record(flag:Union(nil,sqfr,irred,prime),factor:P,exponent:NonNegativeInteger))->Record(flag:Union(nil,sqfr,irred,prime),factor:P,exponent:NonNegativeInteger)','pUnivariatePolynomialSquareFree(RC,P)',NULL,'\spad{BumInSepFFE(f)} is a local function,{} exported only because it has multiple conditional definitions.');
INSERT INTO olibdb VALUES('o','bumprow',3,'n','((S,S)->Boolean,List(S),List(List(S)))->Record(fs:Boolean,sd:List(S),td:List(List(S)))','pTableauxBumpers(S)',NULL,'\spad{bumprow(cf,{} pr,{} r)} is an auxiliary function which bumps a row \spad{r} with a pair \spad{pr} using comparison function \spad{cf},{} and returns a record');
INSERT INTO olibdb VALUES('o','bumptab1',2,'n','(List(S),List(List(List(S))))->List(List(List(S)))','pTableauxBumpers(S)',NULL,'\spad{bumptab1(pr,{} t)} bumps a tableau \spad{t} with a pair \spad{pr} using comparison function \spadfun{<},{} returning a new tableau');
INSERT INTO olibdb VALUES('o','bumptab',3,'n','((S,S)->Boolean,List(S),List(List(List(S))))->List(List(List(S)))','pTableauxBumpers(S)',NULL,'\spad{bumptab(cf,{} pr,{} t)} bumps a tableau \spad{t} with a pair \spad{pr} using comparison function \spad{cf},{} returning a new tableau');
INSERT INTO olibdb VALUES('o','BY',2,'x','(%,Integer)->%','cSegmentCategory(S)',NULL,'\spad{s by n} creates a new segment in which only every \spad{n}\spad{-}th element is used.');
INSERT INTO olibdb VALUES('o','cAcos',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcos(f)} computes the arccosine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAcosh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcosh(f)} computes the inverse hyperbolic cosine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAcot',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcot(f)} computes the arccotangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAcoth',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcoth(f)} computes the inverse hyperbolic cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAcsc',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcsc(f)} computes the arccosecant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAcsch',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAcsch(f)} computes the inverse hyperbolic cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','calcRanges',1,'n','(List(List(Point(DoubleFloat))))->List(Segment(DoubleFloat))','pPlotTools',NULL,'\spad{calcRanges(l)} \undocumented');
INSERT INTO olibdb VALUES('o','call',1,'n','(String)->%','dFortranCode',NULL,'\spad{call(s)} creates a representation of a FORTRAN CALL statement');
INSERT INTO olibdb VALUES('o','canonicalBasis',1,'n','(NonNegativeInteger)->%','dVectorSpaceBasis(R)',NULL,'\spad{canonicalBasis n} builds the canonical basis of the vector space of dimension \spad{n}.');
INSERT INTO olibdb VALUES('o','canonicalIfCan',2,'n','(MPT,MD)->Union(MPT,failed)','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{canonicalIfCan(x,{} m)} tries to divide \spad{x} by its leading coefficient modulo \spad{m}.');
INSERT INTO olibdb VALUES('o','canonicalMoebiusFunction',1,'n','(List(P))->%','dGeneralizedFiniteMoebiusFunction(P,R)',NULL,'\spad{canonicalMoebiusFunction(pp)} inverts the canonical zeta function');
INSERT INTO olibdb VALUES('o','cap',2,'x','(SymmetricPolynomial(Fraction(Integer)),SymmetricPolynomial(Fraction(Integer)))->Fraction(Integer)','pCycleIndicators',NULL,'\spad{cap(s1,{} s2)},{} introduced by Redfield,{} \indented{1}{is the scalar product of two cycle indices.}');
INSERT INTO olibdb VALUES('o','car',1,'x','(%)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{car((a1,{} ...,{} an))} returns \spad{a1}.');
INSERT INTO olibdb VALUES('o','cardinality',1,'n','(A)->NonNegativeInteger','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cardinality',1,'x','(%)->NonNegativeInteger','cFiniteSetAggregate(S)',NULL,'\spad{cardinality(u)} returns the number of elements of \spad{u}. Note: \spad{cardinality(u) = \#u}.');
INSERT INTO olibdb VALUES('o','carmichaelLambda',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{carmichaelLambda(n)} returns exponent of the multiplicative group of integers modulo \spad{n},{} that is smallest positive integer \spad{k} such that \spad{i^k rem n = 1} for all \spad{i} relatively prime to \spad{n}.');
INSERT INTO olibdb VALUES('o','cartesian',1,'n','(List(List(T)))->List(List(T))','pListPackage(T)',NULL,'\spad{cartesian([S1,{} S2,{} ...])} returns the set of lists [\spad{s1},{} \spad{s2},{} ...] with \spad{si} in \spad{Si}');
INSERT INTO olibdb VALUES('o','cartesian',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{cartesian(pt)} returns the Cartesian coordinates of point \spad{pt}.');
INSERT INTO olibdb VALUES('o','cartesian',2,'n','(%,%)->DirectedGraph(Product(S,S))','dDirectedGraph(S)',NULL,'\spad{cartesian(a,{} b)} returns a Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u'' is adjacent with \spad{v''} in \spad{H},{} or u'' = \spad{v''} and \spad{u} is adjacent with \spad{v} in \spad{G}.');
INSERT INTO olibdb VALUES('o','cartesian',2,'n','(%,%)->MultifunctionGraph(Product(S,S))','dMultifunctionGraph(S)',NULL,'Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node');
INSERT INTO olibdb VALUES('o','cartesian',2,'n','(%,%)->UndirectedGraph(Product(S,S))','dUndirectedGraph(S)',NULL,'Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u'' is adjacent with \spad{v''} in \spad{H},{} or u'' = \spad{v''} and \spad{u} is adjacent with \spad{v} in \spad{G}.');
INSERT INTO olibdb VALUES('o','cartesian',2,'n','(%,%)->WeightedGraph(Product(S,S),W)','dWeightedGraph(S,W)',NULL,'Cartesian product: the vertex set of \spad{G} \spad{o} \spad{H} is the Cartesian product \spad{V}(\spad{G}) \times \spad{V}(\spad{H}) and any two vertices (\spad{u},{} u'') and (\spad{v},{} \spad{v''}) \indented{1}{are adjacent in \spad{G} \spad{o} \spad{H} if and only if either} \spad{u} = \spad{v} and u'' is adjacent with \spad{v''} in \spad{H},{} or u'' = \spad{v''} and \spad{u} is adjacent with \spad{v} in \spad{G}.');
INSERT INTO olibdb VALUES('o','cartesianPower',2,'n','(List(T),NonNegativeInteger)->List(List(T))','pListPackage(T)',NULL,'\spad{cartesianPower(S,{} n)} returns the \spad{n}-th cartesian power of the list \spad{S}');
INSERT INTO olibdb VALUES('o','cAsec',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAsec(f)} computes the arcsecant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAsech',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAsech(f)} computes the inverse hyperbolic secant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAsin',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAsin(f)} computes the arcsine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAsinh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAsinh(f)} computes the inverse hyperbolic sine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','catalan',1,'x','(I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{catalan(n)} returns the \spad{n}-th Catalan number');
INSERT INTO olibdb VALUES('o','cAtan',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAtan(f)} computes the arctangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cAtanh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cAtanh(f)} computes the inverse hyperbolic tangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCos',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCos(f)} computes the cosine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCosh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCosh(f)} computes the hyperbolic cosine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCot',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCot(f)} computes the cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCoth',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCoth(f)} computes the hyperbolic cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCsc',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCsc(f)} computes the cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cCsch',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cCsch(f)} computes the hyperbolic cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cdr',1,'x','(%)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{cdr((a1,{} ...,{} an))} returns \spad{(a2,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','ceiling',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ceiling(x)} returns the smallest integer above or equal \spad{x}.');
INSERT INTO olibdb VALUES('o','ceiling',1,'n','(S)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ceiling',1,'x','(%)->%','cRealNumberSystem',NULL,'\spad{ceiling x} returns the small integer \spad{>= x}.');
INSERT INTO olibdb VALUES('o','ceiling',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{ceiling(x)} returns the smallest integer above or equal \spad{x}.');
INSERT INTO olibdb VALUES('o','ceiling',1,'x','(%)->S','cQuotientFieldCategory(S)','has(S,IntegerNumberSystem)','\spad{ceiling(x)} returns the smallest integral element above \spad{x}.');
INSERT INTO olibdb VALUES('o','center',1,'n','(%)->%','dOutputForm',NULL,'\spad{center(f)} centers form \spad{f} in total space.');
INSERT INTO olibdb VALUES('o','center',1,'x','(%)->Coef','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{center(f)} returns the point about which the series \spad{f} is expanded.');
INSERT INTO olibdb VALUES('o','center',2,'n','(%,Integer)->%','dOutputForm',NULL,'\spad{center(f,{} n)} centers form \spad{f} within space of width \spad{n}.');
INSERT INTO olibdb VALUES('o','center',3,'x','(List(String),Integer,String)->List(String)','pDisplayPackage',NULL,'\spad{center(l,{} i,{} s)} takes a list of strings \spad{l},{} and centers them within a list of strings which is \spad{i} characters long,{} in which the remaining spaces are filled with strings composed of as many repetitions as possible of the last string parameter \spad{s}.');
INSERT INTO olibdb VALUES('o','center',3,'x','(String,Integer,String)->String','pDisplayPackage',NULL,'\spad{center(s,{} i,{} s)} takes the first string \spad{s},{} and centers it within a string of length \spad{i},{} in which the other elements of the string are composed of as many replications as possible of the second indicated string,{} \spad{s} which must have a length greater than that of an empty string.');
INSERT INTO olibdb VALUES('o','certainlySubVariety?',2,'n','(List(P),List(P))->Boolean','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{certainlySubVariety?(newlp,{} lp)} returns \spad{true} iff for every \spad{p} in \spad{lp} the remainder of \spad{p} by \spad{newlp} using the division algorithm of Groebner techniques is zero.');
INSERT INTO olibdb VALUES('o','cExp',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cExp(f)} computes the exponential of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','chain',1,'n','(%)->ChainComplex','dDeltaComplex(VS)',NULL,'returns a matrix sequence representing the face maps in linear algebra form');
INSERT INTO olibdb VALUES('o','chain',1,'n','(%)->ChainComplex','dFiniteCubicalComplex(VS)',NULL,'returns a matrix sequence representing the face maps in linear algebra form');
INSERT INTO olibdb VALUES('o','chain',1,'n','(%)->ChainComplex','dFiniteSimplicialComplex(VS)',NULL,'returns a matrix sequence representing the face maps in linear algebra form For more information: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','chainComplex',1,'n','(List(Matrix(Integer)))->%','dChainComplex',NULL,'constructor');
INSERT INTO olibdb VALUES('o','chainSubResultants',2,'n','(polR,polR)->List(polR)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{chainSubResultants(P,{} Q)} computes the list of non zero subresultants of \spad{P} and \spad{Q}.');
INSERT INTO olibdb VALUES('o','changeBase',3,'n','(Integer,Integer,PositiveInteger)->%','dMachineFloat',NULL,'\spad{changeBase(exp,{} man,{} base)} \undocumented{}');
INSERT INTO olibdb VALUES('o','changeBase',4,'n','(Matrix(K),Matrix(K),Automorphism(K),(K)->K)->Matrix(K)','pPseudoLinearNormalForm(K)',NULL,'\spad{changeBase(M,{} A,{} sig,{} der)}: computes the new matrix of a pseudo-linear transform given by the matrix \spad{M} under the change of base A');
INSERT INTO olibdb VALUES('o','changeExprLength',1,'n','(Integer)->Void','pFortranCodeTools',NULL,'\spad{changeExprLength(i)} changes limit on expression length by \spad{i}.');
INSERT INTO olibdb VALUES('o','changeVar',2,'n','(L,Fraction(UP))->L','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{changeVar(+/[\spad{ai} D^i],{} a)} returns the operator \spad{+/[\spad{ai} (D+a)\spad{^i}]}.');
INSERT INTO olibdb VALUES('o','changeVar',2,'n','(L,UP)->L','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{changeVar(+/[\spad{ai} D^i],{} a)} returns the operator \spad{+/[\spad{ai} (D+a)\spad{^i}]}.');
INSERT INTO olibdb VALUES('o','changeWeightLevel',1,'n','(NonNegativeInteger)->Void','dOrdinaryWeightedPolynomials(R,vl,wl,wtlevel)',NULL,NULL);
INSERT INTO olibdb VALUES('o','changeWeightLevel',1,'n','(NonNegativeInteger)->Void','dWeightedPolynomials(R,VarSet,E,P,vl,wl,wtlevel)',NULL,'\spad{changeWeightLevel(n)} changes the weight level to the new value given: \spad{NB:} previously calculated terms are not affected');
INSERT INTO olibdb VALUES('o','char',1,'x','(Integer)->%','dCharacter',NULL,'\spad{char(i)} provides a character corresponding to the integer code \spad{i}. It is always \spad{true} that \spad{ord char i = i}.');
INSERT INTO olibdb VALUES('o','char',1,'x','(String)->%','dCharacter',NULL,'\spad{char(s)} provides a character from a string \spad{s} of length one.');
INSERT INTO olibdb VALUES('o','character?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{character?(t)} tests whether \spad{t} is equivalent to the FORTRAN type CHARACTER.');
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'n','()->NonNegativeInteger','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristic',0,'x','()->NonNegativeInteger','cNonAssociativeRing',NULL,'\spad{characteristic()} returns the characteristic of the ring.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(E)->PolR','pCharacteristicPolynomialInMonogenicalAlgebra(R,PolR,E)',NULL,'\spad{characteristicPolynomial(e)} returns the characteristic polynomial of \spad{e} using resultants');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(Matrix(F))->SparseUnivariatePolynomial(F)','pInnerEigenPackage(F)',NULL,'\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \spad{m}');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(Matrix(R))->SparseUnivariatePolynomial(R)','pCharacteristicPolynomial(R)',NULL,'\spad{characteristicPolynomial(m)} computes the characteristic polynomial of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(S)->SparseUnivariatePolynomial(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(S)->UP','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'n','(S)->UP','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'x','(Matrix(Complex(Fraction(Integer))))->Polynomial(Complex(Fraction(Integer)))','pNumericComplexEigenPackage(Par)',NULL,'\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over complex rationals with a new symbol as variable.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'x','(Matrix(Fraction(Integer)))->Polynomial(Fraction(Integer))','pNumericRealEigenPackage(Par)',NULL,'\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over \spad{RN} with a new symbol as variable.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'x','(Matrix(Fraction(Polynomial(R))))->Polynomial(R)','pEigenPackage(R)',NULL,'\spad{characteristicPolynomial(m)} returns the characteristicPolynomial of the matrix \spad{m} using a new generated symbol symbol as the main variable.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',1,'x','(%)->UP','cFiniteRankAlgebra(R,UP)',NULL,'\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \spad{a} with respect to any basis.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',2,'n','(Matrix(R),R)->R','pCharacteristicPolynomial(R)',NULL,'\spad{characteristicPolynomial(m,{} r)} computes the characteristic polynomial of the matrix \spad{m} evaluated at the point \spad{r}. In particular,{} if \spad{r} is the polynomial \spad{''x},{} then it returns the characteristic polynomial expressed as a polynomial in \spad{''x}.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',2,'x','(Matrix(Complex(Fraction(Integer))),Symbol)->Polynomial(Complex(Fraction(Integer)))','pNumericComplexEigenPackage(Par)',NULL,'\spad{characteristicPolynomial(m,{} x)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over Complex Rationals with variable \spad{x}.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',2,'x','(Matrix(Fraction(Integer)),Symbol)->Polynomial(Fraction(Integer))','pNumericRealEigenPackage(Par)',NULL,'\spad{characteristicPolynomial(m,{} x)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over \spad{RN} with variable \spad{x}.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',2,'x','(Matrix(Fraction(Polynomial(R))),Symbol)->Polynomial(R)','pEigenPackage(R)',NULL,'\spad{characteristicPolynomial(m,{} var)} returns the characteristicPolynomial of the matrix \spad{m} using the symbol var as the main variable.');
INSERT INTO olibdb VALUES('o','characteristicPolynomial',2,'x','(Matrix(R),R)->R','pCharacteristicPolynomialPackage(R)',NULL,'\spad{characteristicPolynomial(m,{} r)} computes the characteristic polynomial of the matrix \spad{m} evaluated at the point \spad{r}. In particular,{} if \spad{r} is the polynomial \spad{''x},{} then it returns the characteristic polynomial expressed as a polynomial in \spad{''x}.');
INSERT INTO olibdb VALUES('o','characteristicSerie',1,'x','(List(P))->List(%)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{characteristicSerie(ps)} returns the same as \spad{characteristicSerie(ps,{} initiallyReduced?,{} initiallyReduce)}.');
INSERT INTO olibdb VALUES('o','characteristicSerie',3,'x','(List(P),(P,P)->Boolean,(P,P)->P)->List(%)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{characteristicSerie(ps,{} redOp?,{} redOp)} returns a list \spad{lts} of triangular sets such that the zero set of \spad{ps} is the union of the regular zero sets of the members of \spad{lts}. This is made by the Ritt and Wu Wen Tsun process applying the operation \spad{characteristicSet(ps,{} redOp?,{} redOp)} to compute characteristic sets in Wu Wen Tsun sense.');
INSERT INTO olibdb VALUES('o','characteristicSet',1,'x','(List(P))->Union(%,failed)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{characteristicSet(ps)} returns the same as \spad{characteristicSet(ps,{} initiallyReduced?,{} initiallyReduce)}.');
INSERT INTO olibdb VALUES('o','characteristicSet',3,'x','(List(P),(P,P)->Boolean,(P,P)->P)->Union(%,failed)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{characteristicSet(ps,{} redOp?,{} redOp)} returns a non-contradictory characteristic set of \spad{ps} in Wu Wen Tsun sense \spad{w}.\spad{r}.\spad{t} the reduction-test \spad{redOp?} (using \spad{redOp} to reduce polynomials \spad{w}.\spad{r}.\spad{t} a \spad{redOp?} basic set),{} if no non-zero constant polynomial appear during those reductions,{} else \spad{failed} is returned. The operations \spad{redOp} and \spad{redOp?} must satisfy the following conditions: \spad{redOp?(redOp(p,{} q),{} q)} holds for every polynomials \spad{p,{} q} and there exists an integer \spad{e} and a polynomial \spad{f} such that we have \spad{init(q)^e*p = f*q + redOp(p,{} q)}.');
INSERT INTO olibdb VALUES('o','charClass',1,'x','(List(Character))->%','dCharacterClass',NULL,'\spad{charClass(l)} creates a character class which contains exactly the characters given in the list \spad{l}.');
INSERT INTO olibdb VALUES('o','charClass',1,'x','(String)->%','dCharacterClass',NULL,'\spad{charClass(s)} creates a character class which contains exactly the characters given in the string \spad{s}.');
INSERT INTO olibdb VALUES('o','charlierC',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{charlierC(n,{} a,{} z)} is the Charlier polynomial.');
INSERT INTO olibdb VALUES('o','charlierC',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{charlierC(n,{} a,{} z)} is the Charlier polynomial.');
INSERT INTO olibdb VALUES('o','char_pol',1,'n','(Matrix(F))->SparseUnivariatePolynomial(F)','pCharacteristicPolynomial2(F)',NULL,'\spad{char_pol(m)} computes characteristic polynomial of \spad{m}.');
INSERT INTO olibdb VALUES('o','charpol',1,'n','(Matrix(K))->SparseUnivariatePolynomial(K)','pInnerNumericEigenPackage(K,F,Par)',NULL,'\spad{charpol(m)} computes the characteristic polynomial of a matrix \spad{m} with entries in \spad{K}.');
INSERT INTO olibdb VALUES('o','char_pol_via_berkovitz',1,'n','(Matrix(R))->SparseUnivariatePolynomial(R)','pCharacteristicPolynomial4(R)',NULL,'\spad{char_pol_via_berkovitz(m)} computes characteristic polynomial of \spad{m}.');
INSERT INTO olibdb VALUES('o','char_pol_via_den_interpolation',1,'n','(Matrix(Fraction(R)))->SparseUnivariatePolynomial(Fraction(R))','pCharacteristicPolynomial3(R)','has(R,GcdDomain)','\spad{char_pol_via_den_interpolation(m)} computes characteristic polynomial of \spad{m}.');
INSERT INTO olibdb VALUES('o','char_pol_via_interpolation',1,'n','(Matrix(R))->SparseUnivariatePolynomial(R)','pCharacteristicPolynomial3(R)',NULL,'\spad{char_pol_via_interpolation(m)} computes characteristic polynomial of \spad{m}.');
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->S','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->S','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->Union(S,failed)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->Union(S,failed)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->Union(S,failed)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'n','(S)->Union(S,failed)','xPolynomialFactorizationExplicit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','charthRoot',1,'x','(%)->%','cFiniteFieldCategory',NULL,'\spad{charthRoot(a)} takes the characteristic''th root of {\em a}. Note: such a root is always defined in finite fields.');
INSERT INTO olibdb VALUES('o','charthRoot',1,'x','(%)->Union(%,failed)','cCharacteristicNonZero',NULL,'\spad{charthRoot(x)} returns the \spad{p}th root of \spad{x} where \spad{p} is the characteristic of the ring.');
INSERT INTO olibdb VALUES('o','charthRoot',1,'x','(%)->Union(%,failed)','cPolynomialFactorizationExplicit','has(%,CharacteristicNonZero)','\spad{charthRoot(r)} returns the \spad{p}\spad{-}th root of \spad{r},{} or failed if none exists in the domain.');
INSERT INTO olibdb VALUES('o','chebyshevT',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pPolynomialNumberTheoryFunctions',NULL,'\spad{chebyshevT(n)} returns the \spad{n}th Chebyshev polynomial \spad{T[n](x)}. Note: Chebyshev polynomials of the first kind,{} denoted \spad{T[n](x)},{} computed from the two term recurrence. The generating function \spad{(1-t*x)/(1-2*t*x+t^2) = sum(T[n](x)*t^n,{} n=0..infinity)}.');
INSERT INTO olibdb VALUES('o','chebyshevT',2,'x','(NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)',NULL,'\spad{chebyshevT(n,{} x)} is the \spad{n}-th Chebyshev polynomial of the first kind,{} \spad{T[n](x)}. These are defined by \spad{(1-t*x)/(1-2*t*x+t^2) = sum(T[n](x) *t^n,{} n = 0..)}.');
INSERT INTO olibdb VALUES('o','chebyshevU',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pPolynomialNumberTheoryFunctions',NULL,'\spad{chebyshevU(n)} returns the \spad{n}th Chebyshev polynomial \spad{U[n](x)}. Note: Chebyshev polynomials of the second kind,{} denoted \spad{U[n](x)},{} computed from the two term recurrence. The generating function \spad{1/(1-2*t*x+t^2) = sum(T[n](x)*t^n,{} n=0..infinity)}.');
INSERT INTO olibdb VALUES('o','chebyshevU',2,'x','(NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)',NULL,'\spad{chebyshevU(n,{} x)} is the \spad{n}-th Chebyshev polynomial of the second kind,{} \spad{U[n](x)}. These are defined by \spad{1/(1-2*t*x+t^2) = sum(T[n](x) *t^n,{} n = 0..)}.');
INSERT INTO olibdb VALUES('o','check',1,'n','(List(GuessOption))->Union(skip,MonteCarlo,deterministic)','dGuessOptionFunctions0',NULL,'\spad{check(d)} specifies how we want to check the solution. If the value is skip,{} we return the solutions found by the interpolation routine without checking. If the value is MonteCarlo,{} we use a probabilistic check. The default is deterministic.');
INSERT INTO olibdb VALUES('o','check',1,'x','(%)->%','cThreeSpaceCategory(R)',NULL,'\spad{check(s)} returns lllpt,{} list of lists of lists of point information about the \spadtype{ThreeSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','check',1,'x','(Union(skip,MonteCarlo,deterministic))->%','dGuessOption',NULL,'\spad{check(d)} specifies how we want to check the solution. If the value is skip,{} we return the solutions found by the interpolation routine without checking. If the value is MonteCarlo,{} we use a probabilistic check. This option is expressed in the form \spad{check == d}');
INSERT INTO olibdb VALUES('o','check',2,'n','(List(Record(factor:SparseUnivariatePolynomial(R),exponent:NonNegativeInteger)),List(Record(factor:SparseUnivariatePolynomial(R),exponent:NonNegativeInteger)))->Boolean','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{check should} be local');
INSERT INTO olibdb VALUES('o','checkExtraValues',1,'n','(List(GuessOption))->Boolean','dGuessOptionFunctions0',NULL,'\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. The default is \spad{true}.');
INSERT INTO olibdb VALUES('o','checkExtraValues',1,'x','(Boolean)->%','dGuessOption',NULL,'\spad{checkExtraValues(d)} specifies whether we want to check the solution beyond the order given by the degree bounds. This option is expressed in the form \spad{checkExtraValues == d}');
INSERT INTO olibdb VALUES('o','checkForZero',4,'n','(SparseUnivariatePolynomial(F),OrderedCompletion(F),OrderedCompletion(F),Boolean)->Union(Boolean,failed)','pDefiniteIntegrationTools(R,F)',NULL,'\spad{checkForZero(p,{} a,{} b,{} incl?)} is \spad{true} if \spad{p} has a zero between a and \spad{b},{} \spad{false} otherwise,{} failed if this cannot be determined. Check for a and \spad{b} inclusive if incl? is \spad{true},{} exclusive otherwise.');
INSERT INTO olibdb VALUES('o','checkForZero',5,'n','(Polynomial(R),Symbol,OrderedCompletion(F),OrderedCompletion(F),Boolean)->Union(Boolean,failed)','pDefiniteIntegrationTools(R,F)',NULL,'\spad{checkForZero(p,{} x,{} a,{} b,{} incl?)} is \spad{true} if \spad{p} has a zero for \spad{x} between a and \spad{b},{} \spad{false} otherwise,{} failed if this cannot be determined. Check for a and \spad{b} inclusive if incl? is \spad{true},{} exclusive otherwise.');
INSERT INTO olibdb VALUES('o','checkOptions',1,'n','(List(GuessOption))->Void','dGuessOptionFunctions0',NULL,'\spad{checkOptions checks} whether the given options are consistent,{} and yields an error otherwise');
INSERT INTO olibdb VALUES('o','checkRur',2,'n','(TS,List(TS))->Boolean','pInternalRationalUnivariateRepresentationPackage(R,E,V,P,TS)',NULL,'\spad{checkRur(ts,{} lus)} returns \spad{true} if \spad{lus} is a rational univariate representation of \spad{ts}.');
INSERT INTO olibdb VALUES('o','check_sol1a',6,'n','(Vector(U32Vector),List(U32Vector),(List(U32Vector),Integer,Integer)->Vector(U32Vector),Integer,Integer,Integer)->U32Vector','pModularHermitePade',NULL,'\spad{check_sol1a performs} one round of modular Monte Carlo check for solutions.');
INSERT INTO olibdb VALUES('o','checkType',1,'n','(String)->String','pFortranCodeTools',NULL,'\spad{checkType(t)}');
INSERT INTO olibdb VALUES('o','Chi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Chi()} returns symbol for capital greek letter chi.');
INSERT INTO olibdb VALUES('o','chi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{chi()} returns symbol for small greek letter chi.');
INSERT INTO olibdb VALUES('o','Chi',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{Chi(f)} denotes the hyperbolic cosine integral');
INSERT INTO olibdb VALUES('o','Chi',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{Chi(x)} returns the hyperbolic cosine integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{cosh(x) / x dx}.');
INSERT INTO olibdb VALUES('o','Chi',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{Chi(f)} denotes the hyperbolic cosine integral');
INSERT INTO olibdb VALUES('o','Chi',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Chi',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{Chi(f)} denotes the hyperbolic cosine integral');
INSERT INTO olibdb VALUES('o','child?',2,'n','(A,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','child?',2,'n','(A,A)->Boolean','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','child',2,'n','(%,NonNegativeInteger)->%','dSubSpace(n,R)',NULL,'\spad{child(x,{} n)} \undocumented');
INSERT INTO olibdb VALUES('o','child?',2,'x','(%,%)->Boolean','cRecursiveAggregate(S)','has(S,BasicType)','\spad{child?(u,{} v)} tests if node \spad{u} is a child of node \spad{v}.');
INSERT INTO olibdb VALUES('o','children',1,'n','(A)->List(A)','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','children',1,'n','(A)->List(A)','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','children',1,'n','(A)->List(A)','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','children',1,'n','(%)->List(%)','dSubSpace(n,R)',NULL,'\spad{children(x)} \undocumented');
INSERT INTO olibdb VALUES('o','children',1,'x','(%)->List(%)','cRecursiveAggregate(S)',NULL,'\spad{children(u)} returns a list of the children of aggregate \spad{u}. Error: if \spad{u} is empty.');
INSERT INTO olibdb VALUES('o','chineseRemainder',2,'x','(List(List(R)),List(R))->List(R)','pCRApackage(R)',NULL,'\spad{chineseRemainder(llv,{} lm)} returns a list of values,{} each of which corresponds to the Chinese remainder of the associated element of \spad{llv} and \spad{lm}. This is more efficient than applying chineseRemainder several times.');
INSERT INTO olibdb VALUES('o','chineseRemainder',2,'x','(List(R),List(R))->R','pCRApackage(R)',NULL,'\spad{chineseRemainder(lv,{} lm)} returns a value \spad{v} such that,{} if \spad{x} is \spad{lv.i} modulo \spad{lm.i} for all \spad{i},{} then \spad{x} is \spad{v} modulo \spad{lm(1)*lm(2)*...*lm(n)}.');
INSERT INTO olibdb VALUES('o','chineseRemainder',3,'n','(List(UP),List(Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))),NonNegativeInteger)->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pChineseRemainderToolsForIntegralBases(K,R,UP)',NULL,'\spad{chineseRemainder(lu,{} lr,{} n)} \undocumented');
INSERT INTO olibdb VALUES('o','chineseRemainder',4,'x','(Integer,Integer,Integer,Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{chineseRemainder(x1,{} m1,{} x2,{} m2)} returns \spad{w},{} where \spad{w} is such that \spad{w = x1 mod m1} and \spad{w = x2 mod m2}. Note: \spad{m1} and \spad{m2} must be relatively prime.');
INSERT INTO olibdb VALUES('o','chinese_update',3,'n','(U32Vector,Integer,%)->Void','dVectorIntegerReconstructor',NULL,'\spad{chinese_update(v,{} p,{} r)} informs \spad{r} about evaluation at \spad{p}');
INSERT INTO olibdb VALUES('o','chinese_update',3,'n','(U32Vector,Integer,%)->Void','dVectorModularReconstructor',NULL,'\spad{chinese_update(v,{} pt,{} r)} informs \spad{r} that evaluation at \spad{pt} gave vector of values \spad{v}');
INSERT INTO olibdb VALUES('o','chiSquare1',1,'n','(NonNegativeInteger)->Float','pRandomFloatDistributions',NULL,'\spad{chiSquare1(n)} \undocumented');
INSERT INTO olibdb VALUES('o','chiSquare',1,'n','(NonNegativeInteger)->()->Float','pRandomFloatDistributions',NULL,'\spad{chiSquare(n)} \undocumented');
INSERT INTO olibdb VALUES('o','choosemon',2,'n','(DistributedMultivariatePolynomial(lv,F),List(DistributedMultivariatePolynomial(lv,F)))->DistributedMultivariatePolynomial(lv,F)','pLinGroebnerPackage(lv,F)',NULL,'\spad{choosemon }\undocumented');
INSERT INTO olibdb VALUES('o','chvar',2,'n','(List(UPUP),UPUP)->Record(func:List(UPUP),poly:UPUP,c1:Fraction(UP),c2:Fraction(UP),deg:NonNegativeInteger)','pChangeOfVariable(F,UP,UPUP)',NULL,'\spad{chvar(lf,{} p)} is like chvar(\spad{f},{} \spad{p}) but handles list of functions');
INSERT INTO olibdb VALUES('o','chvar',2,'n','(UPUP,UPUP)->Record(func:UPUP,poly:UPUP,c1:Fraction(UP),c2:Fraction(UP),deg:NonNegativeInteger)','pChangeOfVariable(F,UP,UPUP)',NULL,'\spad{chvar(f(x,{} y),{} p(x,{} y))} returns \spad{[g(z,{} t),{} q(z,{} t),{} c1(x),{} c2(x),{} n]} such that under the change of variable \spad{z = c1(x)},{} \spad{t = y * c2(x)},{} one gets \spad{f(x,{} y) = c1''(x)g(c1(x),{} c2(x)y)} The algebraic relation between \spad{x} and \spad{y} is \spad{p(x,{} y) = 0}. The algebraic relation between \spad{z} and \spad{t} is \spad{q(z,{} t) = 0}.');
INSERT INTO olibdb VALUES('o','Ci',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{\spad{Ci}(f)} denotes the cosine integral');
INSERT INTO olibdb VALUES('o','Ci',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{\spad{Ci}(x)} returns the cosine integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{cos(x) / x dx}.');
INSERT INTO olibdb VALUES('o','Ci',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{\spad{Ci}(f)} denotes the cosine integral');
INSERT INTO olibdb VALUES('o','Ci',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Ci',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{\spad{Ci}(f)} denotes the cosine integral');
INSERT INTO olibdb VALUES('o','circle',0,'n','()->DeltaComplex(VS)','pDeltaComplexFactory(VS)',NULL,'Generate a minimal circle from an edge from vertex A to A.');
INSERT INTO olibdb VALUES('o','class',1,'n','(List(NonNegativeInteger))->NonNegativeInteger','cJetBundleCategory',NULL,'\spad{class(ind)} yields the class of the multi-index \spad{ind} (Position for first non-vanishing entry).');
INSERT INTO olibdb VALUES('o','class',1,'n','(List(NonNegativeInteger))->NonNegativeInteger','xJetBundleCategory&(S)',NULL,'\spad{class(ind)} yields the class of the multi-index \spad{ind} (Position for first non-vanishing entry).');
INSERT INTO olibdb VALUES('o','class',1,'n','(%)->NonNegativeInteger','cJetBundleCategory',NULL,'\spad{class(jv)} yields the class of the jet variable \spad{jv} (Class of multi-index for derivative,{} 0 else).');
INSERT INTO olibdb VALUES('o','class',1,'n','(%)->NonNegativeInteger','cJetBundleFunctionCategory(JB)',NULL,'\spad{class(f)} is defined as the highest class of the jet variables effectively occurring in \spad{f}.');
INSERT INTO olibdb VALUES('o','class',1,'n','(S)->NonNegativeInteger','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','class',1,'n','(S)->NonNegativeInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','classicalConvolution',2,'n','(%,%)->%','cDistributionCategory(R)',NULL,'\spad{classicalConvolution(x,{} y)} returns the classical convolution of the distributions \spad{x} and \spad{y}');
INSERT INTO olibdb VALUES('o','classicalCumulant',2,'n','(%,PositiveInteger)->R','cDistributionCategory(R)',NULL,'\spad{classicalCumulant(x,{} n)} returns the \spad{n}-th classical cumulant of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','classicalCumulants',1,'n','(%)->Sequence(R)','cDistributionCategory(R)',NULL,'\spad{classicalCumulants(x)} returns sequence of classical cumulants of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','clearCache',0,'n','()->Void','pSortedCache(S)',NULL,'\spad{clearCache()} empties the cache.');
INSERT INTO olibdb VALUES('o','clearDenominator',1,'n','(B)->A','pInnerCommonDenominator(R,Q,A,B)',NULL,'\spad{clearDenominator([q1,{} ...,{} qn])} returns \spad{[p1,{} ...,{} pn]} such that \spad{\spad{qi} = pi/d} where \spad{d} is a common denominator for the \spad{qi}\spad{''s}.');
INSERT INTO olibdb VALUES('o','clearDenominator',1,'n','(P)->P','pPolynomialCommonDenominator(R,Q,E,VarSet,P)',NULL,'\spad{clearDenominator(q)} returns \spad{p} such that \spad{q = p/d} where \spad{d} is a common denominator for the coefficients of \spad{q}.');
INSERT INTO olibdb VALUES('o','clearDenominator',1,'x','(A)->A','pCommonDenominator(R,Q,A)',NULL,'\spad{clearDenominator([q1,{} ...,{} qn])} returns \spad{[p1,{} ...,{} pn]} such that \spad{\spad{qi} = pi/d} where \spad{d} is a common denominator for the \spad{qi}\spad{''s}.');
INSERT INTO olibdb VALUES('o','clearDenominator',1,'x','(Matrix(Q))->Matrix(R)','pMatrixCommonDenominator(R,Q)',NULL,'\spad{clearDenominator(q)} returns \spad{p} such that \spad{q = p/d} where \spad{d} is a common denominator for the elements of \spad{q}.');
INSERT INTO olibdb VALUES('o','clearDenominator',1,'x','(UP)->UP','pUnivariatePolynomialCommonDenominator(R,Q,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','clearFortranOutputStack',0,'n','()->Stack(String)','pFortranOutputStackPackage',NULL,'\spad{clearFortranOutputStack()} clears the Fortran output stack');
INSERT INTO olibdb VALUES('o','clearTable!',0,'n','()->Void','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{clearTable!()} clears the hash-table and assumes that it will no longer be used.');
INSERT INTO olibdb VALUES('o','clearTheSymbolTable',0,'n','()->Void','dTheSymbolTable',NULL,'\spad{clearTheSymbolTable()} clears the current symbol table.');
INSERT INTO olibdb VALUES('o','clearTheSymbolTable',1,'n','(Symbol)->Void','dTheSymbolTable',NULL,'\spad{clearTheSymbolTable(x)} removes the symbol \spad{x} from the table');
INSERT INTO olibdb VALUES('o','clear_used_intrinsics',0,'n','()->Void','pFortranCodeTools',NULL,'\spad{clear_used_intrinsics()} clear list of used intrinsics');
INSERT INTO olibdb VALUES('o','clexSmaller?',2,'n','(SparseUnivariatePolynomial(GF),SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{clexSmaller?(f,{} g)} compares monic \spad{f} and \spad{g} of the same degree in the following order. Error: if \spad{f} or \spad{g} is not monic or if \spad{f} and \spad{g} have different degrees or if common degree is 0. \spad{f < g} if the constant term of \spad{f} is zero and constant term of \spad{g} is nonzero. If both constant term of \spad{f} and \spad{g} are nonzero then \spad{f < g} if the {\em lookup} of the constant term of \spad{f} is less than this number for \spad{g}. If these values are equal,{} then \spad{lexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','clip',1,'n','(List(List(Point(DoubleFloat))))->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clip(ll)} performs two-dimensional clipping on a list of lists of points,{} \spad{ll}; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \pspadfun{iClipParametric} subroutine,{} which is called by this function.');
INSERT INTO olibdb VALUES('o','clip',1,'n','(List(Point(DoubleFloat)))->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clip(l)} performs two-dimensional clipping on a curve \spad{l},{} which is a list of points; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \pspadfun{iClipParametric} subroutine,{} which is called by this function.');
INSERT INTO olibdb VALUES('o','clip',1,'n','(Plot)->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clip(p)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the graph of one variable,{} \spad{y = f(x)}; the default parameters \spad{1/4} for the fraction and \spad{5/1} for the scale are used in the \spadfun{clip} function.');
INSERT INTO olibdb VALUES('o','clip',1,'x','(Boolean)->%','dDrawOption',NULL,'\spad{clip(b)} turns 2D clipping on if \spad{b} is \spad{true},{} or off if \spad{b} is \spad{false}. This option is expressed in the form \spad{clip == b}.');
INSERT INTO olibdb VALUES('o','clip',1,'x','(List(Segment(Float)))->%','dDrawOption',NULL,'\spad{clip([l])} provides ranges for user-defined clipping as specified in the list \spad{l}. This option is expressed in the form \spad{clip == [l]}.');
INSERT INTO olibdb VALUES('o','clip',3,'n','(Plot,Fraction(Integer),Fraction(Integer))->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clip(p,{} frac,{} sc)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the graph of one variable \spad{y = f(x)}; the fraction parameter is specified by \spad{frac} and the scale parameter is specified by \spad{sc} for use in the \spadfun{clip} function.');
INSERT INTO olibdb VALUES('o','clipBoolean',2,'n','(List(DrawOption),Boolean)->Boolean','pDrawOptionFunctions0',NULL,'\spad{clipBoolean(l,{} b)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{clipBoolean}. If the option does not exist the value,{} \spad{b} is returned.');
INSERT INTO olibdb VALUES('o','clipParametric',1,'n','(Plot)->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clipParametric(p)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the parametric curve \spad{x = f(t)},{} \spad{y = g(t)}; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \pspadfun{iClipParametric} subroutine,{} which is called by this function.');
INSERT INTO olibdb VALUES('o','clipParametric',3,'n','(Plot,Fraction(Integer),Fraction(Integer))->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clipParametric(p,{} frac,{} sc)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the parametric curve \spad{x = f(t)},{} \spad{y = g(t)}; the fraction parameter is specified by \spad{frac} and the scale parameter is specified by \spad{sc} for use in the \pspadfun{iClipParametric} subroutine,{} which is called by this function.');
INSERT INTO olibdb VALUES('o','clipPointsDefault',0,'x','()->Boolean','pGraphicsDefaults',NULL,'\spad{clipPointsDefault()} determines whether or not automatic clipping is to be done.');
INSERT INTO olibdb VALUES('o','clipPointsDefault',1,'x','(Boolean)->Boolean','pGraphicsDefaults',NULL,'\spad{clipPointsDefault(true)} turns on automatic clipping; \spad{clipPointsDefault(false)} turns off automatic clipping. The default setting is \spad{true}.');
INSERT INTO olibdb VALUES('o','clipSurface',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{clipSurface(v,{} s)} displays the graph with the specified clipping region removed if \spad{s} is on,{} or displays the graph without clipping implemented if \spad{s} is off,{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','clipWithRanges',5,'n','(List(List(Point(DoubleFloat))),DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat)->Record(brans:List(List(Point(DoubleFloat))),xValues:Segment(DoubleFloat),yValues:Segment(DoubleFloat))','pTwoDimensionalPlotClipping',NULL,'\spad{clipWithRanges(pointLists,{} xMin,{} xMax,{} yMin,{} yMax)} performs clipping on a list of lists of points,{} \spad{pointLists}. Clipping is done within the specified ranges of \spad{xMin},{} \spad{xMax} and \spad{yMin},{} \spad{yMax}. This function is used internally by the \pspadfun{iClipParametric} subroutine in this package.');
INSERT INTO olibdb VALUES('o','cLog',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cLog(f)} computes the logarithm of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','close!',1,'n','(%)->Void','dBasicFile',NULL,'clos! closes the file.');
INSERT INTO olibdb VALUES('o','close!',1,'n','(%)->Void','dBasicKeyedAccessFile',NULL,'\spad{close! closes} the keyed access file.');
INSERT INTO olibdb VALUES('o','close',1,'n','(%)->Void','dTwoDimensionalViewport',NULL,'\spad{close(v)} closes the viewport window of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} and terminates the corresponding process ID.');
INSERT INTO olibdb VALUES('o','close!',1,'x','(%)->%','cFileCategory(Name,S)',NULL,'\spad{close!(f)} returns the file \spad{f} closed to input and output.');
INSERT INTO olibdb VALUES('o','close!',1,'x','(%)->%','dLibrary',NULL,'\spad{close!(f)} returns the library \spad{f} closed to input and output.');
INSERT INTO olibdb VALUES('o','close',1,'x','(%)->Void','dThreeDimensionalViewport',NULL,'\spad{close(v)} closes the viewport window of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} and terminates the corresponding process ID.');
INSERT INTO olibdb VALUES('o','close',2,'n','(%,Boolean)->Boolean','dSubSpaceComponentProperty',NULL,'\spad{close(x,{} b)} \undocumented');
INSERT INTO olibdb VALUES('o','closeComponent',3,'n','(%,List(NonNegativeInteger),Boolean)->%','dSubSpace(n,R)',NULL,'\spad{closeComponent(s,{} \spad{li},{} b)} sets the property of the component in the 3 dimensional subspace,{} \spad{s},{} to be closed if \spad{b} is \spad{true},{} or open if \spad{b} is \spad{false}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose closed property is to be set. The subspace,{} \spad{s},{} is returned with the component property modification.');
INSERT INTO olibdb VALUES('o','closed?',1,'n','(%)->Boolean','dSubSpaceComponentProperty',NULL,'\spad{closed?(x)} \undocumented');
INSERT INTO olibdb VALUES('o','closed?',1,'n','(%)->Boolean','dTubePlot(Curve)',NULL,'\spad{closed?(t)} tests whether the given tube plot \spad{t} is closed.');
INSERT INTO olibdb VALUES('o','closedCartesian',3,'n','(%,%,(S,S)->S)->%','dDirectedGraph(S)',NULL,'\spad{closedCartesian(a,{} b,{} f)} builds Cartesian product of a and \spad{b} and then maps it back to \% using \spad{f}.');
INSERT INTO olibdb VALUES('o','closedCartesian',3,'n','(%,%,(S,S)->S)->%','dMultifunctionGraph(S)',NULL,'Cartesian product doubles the size of next list in each object,{} that is it produces two arrows out of every node');
INSERT INTO olibdb VALUES('o','closedCartesian',3,'n','(%,%,(S,S)->S)->%','dUndirectedGraph(S)',NULL,'as Cartesian product but returns \%.');
INSERT INTO olibdb VALUES('o','closedCartesian',3,'n','(%,%,(S,S)->S)->%','dWeightedGraph(S,W)',NULL,'as Cartesian product but returns \%.');
INSERT INTO olibdb VALUES('o','closedCurve?',1,'x','(%)->Boolean','cThreeSpaceCategory(R)',NULL,'\spad{closedCurve?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} contains a single closed curve component,{} \spadignore{i.e.} the first element of the curve is also the last element,{} or \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','closedCurve',1,'x','(List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{closedCurve(lp)} sets a list of points defined by the first element of \spad{lp} through the last element of \spad{lp} and back to the first element again and returns a \spadtype{ThreeSpace} whose component is the closed curve defined by \spad{lp}.');
INSERT INTO olibdb VALUES('o','closedCurve',1,'x','(%)->List(Point(R))','cThreeSpaceCategory(R)',NULL,'\spad{closedCurve(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single closed curve component defined by a list of points in which the first point is also the last point,{} all of which are from the domain \spad{PointDomain(m,{} R)} and if so,{} returns the list of points. An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','closedCurve',2,'x','(%,List(List(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{closedCurve(s,{} [[lr0],{} [lr1],{} ...,{} [lrn],{} [lr0]])} adds a closed curve component defined by a list of points \spad{lr0} through \spad{lrn},{} which are lists of elements from the domain \spad{PointDomain(m,{} R)},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined and \spad{m} is the dimension of the points,{} in which the last element of the list of points contains a copy of the first element list,{} \spad{lr0}. The closed curve is added to the \spadtype{ThreeSpace},{} \spad{s}.');
INSERT INTO olibdb VALUES('o','closedCurve',2,'x','(%,List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{closedCurve(s,{} [p0,{} p1,{} ...,{} pn,{} p0])} adds a closed curve component which is a list of points defined by the first element \spad{p0} through the last element \spad{pn} and back to the first element \spad{p0} again,{} to the \spadtype{ThreeSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','closedTensor',3,'n','(%,%,(S,S)->S)->%','dDirectedGraph(S)',NULL,'\spad{closedTensor(a,{} b,{} f)} builds tensor product of a and \spad{b} and then maps it back to \% using \spad{f}.');
INSERT INTO olibdb VALUES('o','closedTensor',3,'n','(%,%,(S,S)->S)->%','dFunctionGraph(S)',NULL,'as tensor product but returns \%. Cartesian product does apply to function graph produces two arrows out of every node');
INSERT INTO olibdb VALUES('o','closedTensor',3,'n','(%,%,(S,S)->S)->%','dMultifunctionGraph(S)',NULL,'as tensor product but returns \%.');
INSERT INTO olibdb VALUES('o','closedTensor',3,'n','(%,%,(S,S)->S)->%','dUndirectedGraph(S)',NULL,'as tensor product but returns \%.');
INSERT INTO olibdb VALUES('o','closedTensor',3,'n','(%,%,(S,S)->S)->%','dWeightedGraph(S,W)',NULL,'as tensor product but returns \%.');
INSERT INTO olibdb VALUES('o','cmult',1,'n','(List(SparseMultivariatePolynomial(R0,Kernel(F))))->SparseMultivariatePolynomial(R0,Kernel(F))','pPointsOfFiniteOrder(R0,F,UP,UPUP,R)',NULL,'\spad{cmult(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','cnlexSmaller?',2,'n','(SparseUnivariatePolynomial(GF),SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{cnlexSmaller?(f,{} g)} compares monic \spad{f} and \spad{g} of the same degree \spad{n} in the following order. Error: if \spad{f} or \spad{g} is not monic or if \spad{f} and \spad{g} have different degrees or if common degree is 0. \spad{f < g} if the constant term of \spad{f} is zero and constant term of \spad{g} is nonzero. If both constant term of \spad{f} and \spad{g} are nonzero then \spad{f < g} if the {\em lookup} of the constant term of \spad{f} is less than this number for \spad{g}. If constant terms are equal then \spad{nlexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','coAdjoint',2,'n','(%,List(NonNegativeInteger))->Union(List(NonNegativeInteger),failed)','dFunctionGraph(S)',NULL,'given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph');
INSERT INTO olibdb VALUES('o','coAdjoint',2,'n','(%,List(NonNegativeInteger))->Union(List(NonNegativeInteger),failed)','dMultifunctionGraph(S)',NULL,'given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph');
INSERT INTO olibdb VALUES('o','coboundary',3,'n','(%,NonNegativeInteger,List(VS))->List(VS)','dCoChainComplex(VS)',NULL,'calculate coboundary at dimension \spad{n} for a given input');
INSERT INTO olibdb VALUES('o','coChain',1,'n','(%)->CoChainComplex(VS)','dDeltaComplex(VS)',NULL,'returns a matrix sequence representing the face maps in linear algebra form');
INSERT INTO olibdb VALUES('o','coChain',1,'n','(%)->CoChainComplex(VS)','dFiniteSimplicialComplex(VS)',NULL,'returns a matrix sequence representing the face maps in linear algebra form For more information: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/chain/cochain/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','coChainComplex',1,'n','(ChainComplex)->%','dCoChainComplex(VS)',NULL,'constructor from \spad{ChainComplex}');
INSERT INTO olibdb VALUES('o','coChainComplex',1,'n','(List(Matrix(Integer)))->%','dCoChainComplex(VS)',NULL,'constructor');
INSERT INTO olibdb VALUES('o','cocyclotomic_decomposition',1,'n','(Integer)->List(SparseUnivariatePolynomial(Integer))','pCyclotomicUtilities',NULL,'\spad{cocyclotomic_decomposition(n)} computes list of irreducible factors of \spad{x^n + 1} over integers.');
INSERT INTO olibdb VALUES('o','code',1,'n','(%)->Union(nullBranch:null,assignmentBranch:Record(var:Symbol,arrayIndex:List(Polynomial(Integer)),rand:Record(ints2Floats?:Boolean,expr:OutputForm)),arrayAssignmentBranch:Record(var:Symbol,rand:OutputForm,ints2Floats?:Boolean),conditionalBranch:Record(switch:Switch,thenClause:%,elseClause:%),returnBranch:Record(empty?:Boolean,value:Record(ints2Floats?:Boolean,expr:OutputForm)),blockBranch:List(%),commentBranch:List(String),callBranch:String,forBranch:Record(range:SegmentBinding(Polynomial(Integer)),span:Polynomial(Integer),body:%),labelBranch:SingleInteger,loopBranch:Record(switch:Switch,body:%),commonBranch:Record(name:Symbol,contents:List(Symbol)),printBranch:List(OutputForm))','dFortranCode',NULL,'\spad{code(f)} returns the internal representation of the object represented by \spad{f}.');
INSERT INTO olibdb VALUES('o','coef',2,'n','(%,E)->R','dXPolynomialRing(R,E)',NULL,'\spad{coef(p,{} e)} extracts the coefficient of the monomial \spad{e}. Returns zero if \spad{e} is not present.');
INSERT INTO olibdb VALUES('o','coef',2,'x','(%,FreeMonoid(vl))->R','cXFreeAlgebra(vl,R)',NULL,'\spad{coef(x,{} w)} returns the coefficient of the word \spad{w} in \spad{x}.');
INSERT INTO olibdb VALUES('o','coef',2,'x','(%,%)->R','cXFreeAlgebra(vl,R)',NULL,'\spad{coef(x,{} y)} returns scalar product of \spad{x} by \spad{y},{} the set of words being regarded as an orthogonal basis.');
INSERT INTO olibdb VALUES('o','coef',2,'x','(XRecursivePolynomial(VarSet,R),%)->R','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{coef(x,{} y)} returns the scalar product of \spad{x} by \spad{y},{} the set of words being regarded as an orthogonal basis.');
INSERT INTO olibdb VALUES('o','coefChoose',3,'n','(Integer,P,List(Record(factor:P,exponent:NonNegativeInteger)))->P','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{coefChoose should} be local');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,%)->Expression(CoefRing)','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{coefficient(df,{} u)},{} where \spad{df} is a differential form,{} returns the coefficient of \spad{df} containing the basis term \spad{u} if such a term exists,{} and 0 otherwise.');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,Integer)->R','dLaurentPolynomial(R,UP)',NULL,'\spad{coefficient(x,{} n)} \undocumented');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,JB)->D','dJetDifferential(JB,D)',NULL,'\spad{coefficient(om,{} jb)} returns the coefficient of \spad{om} for the differential of \spad{jb}.');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,JB)->D','dJetVectorField(JB,D)',NULL,'\spad{coefficient(v,{} jb)} returns the coefficient of \spad{v} in direction \spad{jb}.');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,NonNegativeInteger)->SMP','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{coefficient(s,{} n)} gives the terms of total degree \spad{n}.');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(%,%)->R','dAntiSymm(R,lVar)',NULL,'\spad{coefficient(p,{} u)} returns the coefficient of the term in \spad{p} containing the basis term \spad{u} if such a term exists,{} and 0 otherwise. Error: if the second argument \spad{u} is not a basis element.');
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(S,E)->R','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',2,'n','(S,IndexedExponents(Var))->Coef','xMultivariateTaylorSeriesCategory&(S,Coef,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',2,'x','(%,E)->R','cAbelianMonoidRing(R,E)',NULL,'\spad{coefficient(p,{} e)} extracts the coefficient of the monomial with exponent \spad{e} from polynomial \spad{p},{} or returns zero if exponent is not present.');
INSERT INTO olibdb VALUES('o','coefficient',2,'x','(%,List(PositiveInteger))->K','dCliffordAlgebra(n,K,bLin)',NULL,'\spad{coefficient(x,{} [i1,{} i2,{} ...,{} iN])} extracts the coefficient of \spad{e(i1)*e(i2)*...*e(iN)} in \spad{x}.');
INSERT INTO olibdb VALUES('o','coefficient',2,'x','(%,NonNegativeInteger)->Polynomial(Coef)','dTaylorSeries(Coef)',NULL,'\spad{coefficient(s,{} n)} gives the terms of total degree \spad{n}.');
INSERT INTO olibdb VALUES('o','coefficient',2,'x','(%,S)->R','cFreeModuleCategory(R,S)',NULL,'\spad{coefficient(x,{} s)} returns the coefficient of the basis element \spad{s}');
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(%,List(VarSet),List(NonNegativeInteger))->%','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{coefficient(p,{} lv,{} ln)} views the polynomial \spad{p} as a polynomial in the variables of \spad{lv} and returns the coefficient of the term \spad{lv^ln},{} \spadignore{i.e.} \spad{prod(lv_i ^ ln_i)}.');
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(S,List(Var),List(NonNegativeInteger))->S','xMultivariateTaylorSeriesCategory&(S,Coef,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(S,List(VarSet),List(NonNegativeInteger))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(S,Var,NonNegativeInteger)->S','xMultivariateTaylorSeriesCategory&(S,Coef,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(S,VarSet,NonNegativeInteger)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficient',3,'n','(%,VarSet,NonNegativeInteger)->%','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{coefficient(p,{} v,{} n)} views the polynomial \spad{p} as a univariate polynomial in \spad{v} and returns the coefficient of the \spad{v^n} term.');
INSERT INTO olibdb VALUES('o','coefficient',3,'x','(%,List(Var),List(NonNegativeInteger))->%','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{coefficient(f,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns the coefficient of \spad{x1^n1 * ... * xk^nk} in \spad{f}.');
INSERT INTO olibdb VALUES('o','coefficient',3,'x','(%,Var,NonNegativeInteger)->%','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{coefficient(f,{} x,{} n)} returns the coefficient of \spad{x^n} in \spad{f}.');
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(A)->List(R)','xFreeModuleCategory&(A,R,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(%)->List(D)','dJetDifferential(JB,D)',NULL,'\spad{coefficients(om)} yields the coefficients of \spad{om}.');
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(%)->List(D)','dJetVectorField(JB,D)',NULL,'\spad{coefficients(v)} yields the coefficients of \spad{v}.');
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(S)->List(R)','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(S)->List(R)','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(%)->Stream(Coef)','dInnerTaylorSeries(Coef)',NULL,'\spad{coefficients(x)} returns a stream of ring elements. \indented{1}{When \spad{x} is a univariate series,{} this is a stream of Taylor} \indented{1}{coefficients. When \spad{x} is a multivariate series,{} the} \indented{1}{\spad{n}th element of the stream is a form of} \indented{1}{degree \spad{n} in the power series variables.}');
INSERT INTO olibdb VALUES('o','coefficients',1,'n','(%)->Stream(SMP)','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{coefficients(s)} gives stream of coefficients of \spad{s},{} \spadignore{i.e.} [coefficient(\spad{s},{}0),{} coefficient(\spad{s},{}1),{} ...]');
INSERT INTO olibdb VALUES('o','coefficients',1,'x','(%)->List(R)','cFreeModuleCategory(R,S)',NULL,'\spad{coefficients(x)} returns the list of coefficients of \spad{x}.');
INSERT INTO olibdb VALUES('o','coefficients',1,'x','(%)->Stream(Coef)','cUnivariateTaylorSeriesCategory(Coef)',NULL,'\spad{coefficients(a0 + a1 x + a2 x^2 + ...)} returns a stream of coefficients: \spad{[a0,{} a1,{} a2,{} ...]}. The entries of the stream may be zero.');
INSERT INTO olibdb VALUES('o','coefficientSet',1,'n','(SparseUnivariatePolynomial(Polynomial(TheField)))->List(Polynomial(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coeffs0',3,'n','(SparseMultivariatePolynomial(Integer,Symbol),List(Symbol),List(SparseMultivariatePolynomial(Integer,Symbol)))->List(SparseMultivariatePolynomial(Integer,Symbol))','pPrimGCD',NULL,'\spad{coeffs0(x,{} lv,{} lp)} is used by \spad{coeffs1}');
INSERT INTO olibdb VALUES('o','coeffs1',2,'n','(SparseMultivariatePolynomial(Integer,Symbol),List(Symbol))->List(SparseMultivariatePolynomial(Integer,Symbol))','pPrimGCD',NULL,'\spad{coeffs1(x,{} lv)} computes list of coefficients of \spad{x} with respect to variables in \spad{lv}. Variables in \spad{lv} must be decreasing and bigger than all other variables of \spad{x}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xDictionaryOperations&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->OutputForm','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(A)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{coerce(r)} converts a ring element \spad{r} to a stream with one element.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Character)->S','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Coef)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Col)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Complex(DoubleFloat)','dSArgand',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Complex(DoubleFloat))->%','dSArgand',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Complex(Float)','dMachineComplex',NULL,'\spad{coerce(u)} transforms \spad{u} into a COmplex Float');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Complex(Float))->%','dMachineComplex',NULL,'\spad{coerce(u)} transforms \spad{u} into a MachineComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Complex(Integer))->%','dMachineComplex',NULL,'\spad{coerce(u)} transforms \spad{u} into a MachineComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Complex(MachineFloat))->%','dMachineComplex',NULL,'\spad{coerce(u)} transforms \spad{u} into a MachineComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Complex(MachineInteger))->%','dMachineComplex',NULL,'\spad{coerce(u)} transforms \spad{u} into a MachineComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(D)->%','dJetBundleLinearFunction(JB,D)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(D)->%','dJetLazyFunction(JB,D)',NULL,'\spad{coerce(d)} coerces an element of \spad{D} into the new domain. This includes the calculation of its leading derivative and its jet variables.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->D','dJetLazyFunction(JB,D)',NULL,'\spad{coerce(exp)} retracts an element to the base domain \spad{D}. This looses all information about its leading derivative and its jet variables and requires complete evaluation of the expression.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->DeltaComplex(VS)','dFiniteCubicalComplex(VS)',NULL,'\spad{coerce CubicalComplex} to DeltaComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->DeltaComplex(VS)','dFiniteSimplicialComplex(VS)',NULL,'\spad{coerce SimplicialComplex} to DeltaComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(E)->%','dXPolynomialRing(R,E)',NULL,'\spad{coerce(e)} returns \spad{1*e}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(Complex(Float))))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(Float)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(Integer)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(MachineComplex)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(MachineFloat)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Equation(Expression(MachineInteger)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(eq)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Complex(Float)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Float))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Integer))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Expression(Integer)','dJetBundleExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Integer))->%','dJetBundleExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Expression(Integer)','dJetBundleXExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Integer))->%','dJetBundleXExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(Integer))->Expression(%)','dMachineInteger',NULL,'\spad{coerce(x)} returns \spad{x} with coefficients in the domain');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(MachineComplex))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(MachineFloat))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Expression(MachineInteger))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(e)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Expression(R)','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{coerce(x)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{coerce(c)} converts the constant \spad{c} into an element of the free field represented by an ALS in minimal refined form.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FinitePoset(S))->%','dDirectedGraph(S)',NULL,'\spad{coerce FinitePoset} to graph');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FinitePoset(S))->%','dUndirectedGraph(S)',NULL,'\spad{coerce FinitePoset} to graph');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FinitePoset(S))->%','dWeightedGraph(S,W)',NULL,'\spad{coerce FinitePoset} to graph');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->FiniteSimplicialComplex(VS)','dDeltaComplex(VS)',NULL,'\spad{coerce DeltaComplex} to FiniteSimplicialComplex');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Float','dMachineFloat',NULL,'\spad{coerce(u)} transforms a MachineFloat to a standard Float');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','cFortranFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','cFortranMatrixCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','cFortranMatrixFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','cFortranVectorCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','cFortranVectorFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranCode)->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(fc)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FortranScalarType)->%','dFortranType',NULL,'\spad{coerce(t)} creates an element from a scalar type');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FPol)->%','dResidueRing(F,Expon,VarSet,FPol,LFPol)',NULL,'\spad{coerce(f)} produces the equivalence class of \spad{f} in the residue ring');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->A','xFullyRetractableTo&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Integer))->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Polynomial(Fraction(R))))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(Polynomial(R)))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Fraction(R))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->FreeMagma(VarSet)','dLyndonWord(VarSet)',NULL,'\spad{coerce(x)} returns the element of \spadtype{FreeMagma}(VarSet) corresponding to \spad{x}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(FreeMonoid(VAR))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{coerce(m)} converts the monoid \spad{m} into an element of the free field represented by an ALS in minimal refined form.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->FreeMonoid(VarSet)','dFreeMagma(VarSet)',NULL,'\spad{coerce(x)} returns the element of \spadtype{FreeMonoid}(VarSet) corresponding to \spad{x} by removing parentheses.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->FreeMonoid(VarSet)','dLyndonWord(VarSet)',NULL,'\spad{coerce(x)} returns the element of \spadtype{FreeMonoid}(VarSet) corresponding to \spad{x}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->FreeMonoid(VarSet)','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,'\spad{coerce([l1]*[l2]*...[ln])} returns the word \spad{l1*l2*...*ln},{} where \spad{[l_i]} is the backeted form of the Lyndon word \spad{l_i}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(GraphImage)->TwoDimensionalViewport','pViewportPackage',NULL,'\spad{coerce(\spad{gi})} converts the indicated \spadtype{GraphImage},{} \spad{gi},{} into the \spadtype{TwoDimensionalViewport} form.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->A','xFullyRetractableTo&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xLeftAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xNonAssociativeRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Integer)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(JB)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{coerce(jv)} coerces the jet variable \spad{jv} into a local section.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(K)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Lambda(UT))->SKICombinators(UT)','pcompUtil(UT)',NULL,'\spad{coerce Lambda} term to SKI combinators. this process is known as abstraction elimination. it is done by applying the following rules until all lambda terms have been eliminated. rule LS1: Lam[\spad{x}] \spad{=>} \spad{x} rule LS2: Lam[(\spad{E1} \spad{E2})] \spad{=>} (Lam[\spad{E1}] Lam[\spad{E2}]) rule LS3: Lam[\spad{x}.\spad{E}] \spad{=>} (\spad{K} Lam[\spad{E}]) (if \spad{x} does not occur free in \spad{E}) rule LS4: Lam[\spad{x}.\spad{x}] \spad{=>} \spad{I} rule LS5: Lam[\spad{x}.\spad{y}.\spad{E}] \spad{=>} Lam[\spad{x}.Lam[\spad{y}.\spad{E}]] (if \spad{x} occurs free in \spad{E}) rule LS6: Lam[\spad{x}.(\spad{E1} \spad{E2})] \spad{=>} (\spad{S} Lam[\spad{x}.\spad{E1}] Lam[\spad{x}.\spad{E2}])');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->LatticeMeetOfJoins','dLatticeJoinOfMeets',NULL,'convert lattice from join-of-meets to meet-of-joins');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(LatticeMeetOfJoins)->%','dLatticeJoinOfMeets',NULL,'convert lattice from meet-of-joins to join-of-meets');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(LiePolynomial(VarSet,R))->%','dXPBWPolynomial(VarSet,R)',NULL,'\spad{coerce(p)} returns \spad{p}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','cFortranFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','cFortranMatrixCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','cFortranMatrixFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','cFortranVectorCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','cFortranVectorFunctionCategory',NULL,'\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(FortranCode))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(lfc)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(Integer))->%','dExtAlgBasis',NULL,'\spad{coerce(l)} converts a list of 0\spad{''s} and 1\spad{''s} into a basis element,{} where 1 (respectively 0) designates that the variable of the corresponding index of \spad{l} is (respectively,{} is not) present. Error: if an element of \spad{l} is not 0 or 1.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->List(Integer)','dPartition',NULL,'\spad{coerce(p)} coerces a partition into a list of integers');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(List(Point(DoubleFloat))))->%','dGraphImage',NULL,'\spad{coerce(llp)} creates and returns a graph of the domain \spadtype{GraphImage} which is composed of the list of list of points given by \spad{llp},{} and whose point colors,{} line colors and point sizes are determined by the default functions \spadfun{pointColorDefault},{} \spadfun{lineColorDefault},{} and \spadfun{pointSizeDefault}. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(S))->%','dDirectedGraph(S)',NULL,'\spad{coerce List} to graph');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(List(%))->SparseEchelonMatrix(JB,D)','dJetBundleLinearFunction(JB,D)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->List(String)','dXmlElement',NULL,'\spad{coerce(x)} outputs \spad{x} as a list of strings. Each element in the list represents a new line. This is an alternative to creating a long single string with ''newline'' embedded in it.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->List(Vector(R))','dVectorSpaceBasis(R)',NULL,'\spad{coerce b} returns the basis as a list of vectors.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(MachineInteger)->%','dMachineFloat',NULL,'\spad{coerce(u)} transforms a MachineInteger into a MachineFloat');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Matrix(D)','dSparseEchelonMatrix(C,D)',NULL,'\spad{coerce(A)} yields the matrix \spad{A} in the usual matrix type.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Matrix(MachineFloat))->%','cFortranMatrixCategory',NULL,'\spad{coerce(v)} produces an ASP which returns the value of \spad{v}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Matrix(R)','dRectangularMatrix(m,n,R)',NULL,'\spad{coerce(m)} converts a matrix of type \spadtype{RectangularMatrix} to a matrix of type \spad{Matrix}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Matrix(R)','dSquareMatrix(ndim,R)',NULL,'\spad{coerce(m)} converts a matrix of type \spadtype{SquareMatrix} to a matrix of type \spadtype{Matrix}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','cSPointCategory',NULL,'output');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dFortranCode',NULL,'\spad{coerce(f)} returns an object of type OutputForm.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dFortranType',NULL,'\spad{coerce(x)} provides a printable form for \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{coerce(f)} prints the ALS of \spad{f} if the debug flag is set and a rational expression if the alternative output flag is set.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dGraphImage',NULL,'\spad{coerce(\spad{gi})} returns the indicated graph,{} \spad{\spad{gi}},{} of domain \spadtype{GraphImage} as output of the domain \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dJetDifferentialEquation(JB,D)',NULL,'\spad{coerce(de)} transforms the differential equation \spad{de} to \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{coerce(p)} prints the linear pencil \spad{p} in list form.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dSBoundary(PT)',NULL,'\spad{coerce(bd)} outputs description of \spad{bd} as formatted text');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dSceneIFS(PT)',NULL,'\spad{coerce(me)} list this instance to the command line');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dScene(PT)',NULL,'output a full scenegraph could contain a lot of data and so we have to be careful to restrict the output to what is reasonable on the command line. Therefore we do not display all subnodes or the full information from nodes such as IFS.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dSTransform(PT)',NULL,'\spad{coerce(tr)} output');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(OutputForm)->%','dTexFormat',NULL,'\spad{coerce(o)} changes \spad{o} in the standard output format to TeX format.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->OutputForm','dTwoDimensionalViewport',NULL,'\spad{coerce(v)} returns the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport} as output of the domain \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(OutputForm)->String','dHTMLFormat',NULL,'\spad{coerce(o)} changes \spad{o} in the standard output format to html format.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(OutputForm)->String','dMathMLFormat',NULL,'\spad{coerce(o)} changes \spad{o} in the standard output format to MathML format.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(OutputForm)->String','dTexmacsFormat',NULL,'\spad{coerce(o)} changes \spad{o} in the standard output format to Texmacs format.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->P','dWeightedPolynomials(R,VarSet,E,P,vl,wl,wtlevel)',NULL,'convert back into a \spad{P},{} ignoring weights');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(P)->%','dWeightedPolynomials(R,VarSet,E,P,vl,wl,wtlevel)',NULL,'\spad{coerce(p)} coerces \spad{p} into Weighted form,{} applying weights and ignoring terms');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(PermutationGroup(S))->%','dDirectedGraph(S)',NULL,'\spad{coerce PermutationGroup} to graph');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(PermutationGroup(S))->%','dMultifunctionGraph(S)',NULL,'\spad{coerce PermutationGroup} to graph which represents the generators of the group');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Polynomial(Fraction(R)))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Polynomial(R)','dOrdinaryWeightedPolynomials(R,vl,wl,wtlevel)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Polynomial(R))->%','dOrdinaryWeightedPolynomials(R,vl,wl,wtlevel)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Polynomial(R))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->(PositiveInteger)->Coef','dDirichletRing(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','((PositiveInteger)->Coef)->%','dDirichletRing(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(PrimitiveArray(PrimitiveArray(PrimitiveArray(R))))->%','dThreeDimensionalMatrix(R)',NULL,'\spad{coerce(p)} moves from the representation type (PrimitiveArray PrimitiveArray PrimitiveArray \spad{R}) to the domain');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->PrimitiveArray(PrimitiveArray(PrimitiveArray(R)))','dThreeDimensionalMatrix(R)',NULL,'\spad{coerce(x)} moves from the domain to the representation type');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(PrimitiveArray(S))->%','dTuple(S)',NULL,'\spad{coerce(a)} makes a tuple from primitive array a');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->R','dEuclideanModularRing(S,R,Mod,reduction,merge,exactQuo)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->R','dModularField(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->R','dModularRing(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Record(index:IS,exponent:E)','dModuleMonomial(IS,E,ff)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(index:IS,exponent:E))->%','dModuleMonomial(IS,E,ff)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','cFortranFunctionCategory',NULL,'\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','cFortranMatrixCategory',NULL,'\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','cFortranMatrixFunctionCategory',NULL,'\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','cFortranVectorCategory',NULL,'\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','cFortranVectorFunctionCategory',NULL,'\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Record(localSymbols:SymbolTable,code:List(FortranCode)))->%','dFortranProgram(name,returnType,arguments,symbols)',NULL,'\spad{coerce(r)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xLeftAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(R)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->A','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->A','xFullyRetractableTo&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->%','cCoercibleFrom(S)',NULL,'\spad{coerce(a)} transforms a into an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->%','dMakeCachableSet(S)',NULL,'\spad{coerce(s)} returns \spad{s} viewed as an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->SExpression','dFortranScalarType',NULL,'\spad{coerce(x)} returns the \spad{s}-expression associated with \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->Expression(Integer)','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SingletonAsOrderedSet)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SKICombinators(UT))->ILogic','pcompUtil(UT)',NULL,'\spad{coerce combinators} to intuitionistic logic this is known as the Curry-Howard isomorphism it uses the following rules: rule SI1: Ski[Kab] \spad{=>} a \spad{->} (\spad{b} \spad{->} a),{} rule SI2: Ski[Sabc] \spad{=>} (a \spad{->} (\spad{b} \spad{->} \spad{c})) \spad{->} ((a \spad{->} \spad{b}) \spad{->} (a \spad{->} \spad{c})),{} rule SI3: Ski[a a-\spad{>b}] \spad{=>} \spad{b} the last rule is function application (modus ponens)');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SKICombinators(UT))->Lambda(UT)','pcompUtil(UT)',NULL,'\spad{coerce SKI} combinators to Lambda term. this conversion is done by applying the following rules rule SL1: Ski[\spad{I}] = \spad{x}.0 rule SL2: Ski[\spad{K}] = \spad{x}.\spad{y}.1 rule SL3: Ski[\spad{S}] = \spad{x}.\spad{y}.\spad{z}.(2 0 (1 0)) rule SL4: Ski[(\spad{E1} \spad{E2})] = (Ski[\spad{E1}] Ski[\spad{E2}])');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->List(P)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->List(P)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SMP)->%','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{coerce(poly)} regroups the terms by total degree and forms a series.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xAssociationListAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xLeftAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xNonAssociativeRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->OutputForm','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SparseEchelonMatrix(JB,D))->List(%)','dJetBundleLinearFunction(JB,D)',NULL,'coercion to matrices over ground domain.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SparseMultivariatePolynomial(Expression(Integer),JB))->%','dJetBundleExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SparseMultivariatePolynomial(Integer,Kernel(%)))->%','dJetBundleExpression(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(SparseMultivariatePolynomial(R,K))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->Polynomial(R)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Stream(Coef)','dDirichletRing(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Stream(Coef))->%','dDirichletRing(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Stream(R))->%','cSequenceCategory(R)',NULL,'\spad{coerce(x)} creation of elements');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(String)->%','dFortranScalarType',NULL,'\spad{coerce(s)} transforms the string \spad{s} into an element of FortranScalarType provided \spad{s} is one of real,{} double precision,{} complex,{} logical,{} integer,{} character,{} REAL,{} COMPLEX,{} LOGICAL,{} INTEGER,{} CHARACTER,{} DOUBLE PRECISION');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->String','dFortranScalarType',NULL,'\spad{coerce(x)} returns the uppercase string associated with \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->String','dXmlAttribute',NULL,'\spad{coerce(x)} outputs \spad{x} as a string');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(S)->Vector(R)','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->%','dFortranScalarType',NULL,'\spad{coerce(s)} transforms the symbol \spad{s} into an element of FortranScalarType provided \spad{s} is one of real,{} complex,{} double precision,{} logical,{} integer,{} character,{} REAL,{} COMPLEX,{} LOGICAL,{} INTEGER,{} CHARACTER,{} DOUBLE PRECISION');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Symbol','dFortranScalarType',NULL,'\spad{coerce(x)} returns the symbol associated with \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->%','dJetBundle(IVar,DVar)',NULL,'\spad{coerce(sy)} allows for the input of jet variables as symbols. Yields an error,{} if the symbol is not contained in \spad{IVar} or \spad{DVar}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->%','dJetBundleSymAna(JB1,xi,eta)',NULL,'\spad{coerce(s)} allows for the input of jet variables as symbols.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->%','dSwitch',NULL,'\spad{coerce(s)} \undocumented{}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Symbol','dVariable(sym)',NULL,'\spad{coerce(x)} returns the symbol');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Symbol)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->Table(Symbol,FortranType)','dSymbolTable',NULL,'\spad{coerce(x)} returns a table view of \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(UnivariatePolynomial(var,Coef))->%','dSparseUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{coerce(p)} converts a univariate polynomial \spad{p} in the variable \spad{var} to a univariate Taylor series in \spad{var}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(UnivariatePolynomial(var,Coef))->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{coerce(p)} converts a univariate polynomial \spad{p} in the variable \spad{var} to a univariate Taylor series in \spad{var}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(UnivariatePolynomial(''x,Coef))->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(UnivariatePuiseuxSeries(FE,var,cen))->%','dExponentialExpansion(R,FE,var,cen)',NULL,'\spad{coerce(f)} converts a \spadtype{UnivariatePuiseuxSeries} to an \spadtype{ExponentialExpansion}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Var)->%','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{coerce(var)} converts a variable to a Taylor series');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dSparseUnivariateLaurentSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a Laurent series.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dSparseUnivariatePuiseuxSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dSparseUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a \indented{1}{Taylor series.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dUnivariateLaurentSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a Laurent series.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dUnivariatePuiseuxSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(var))->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a \indented{1}{Taylor series.}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(''x))->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Variable(x))->%','dUnivariateSkewPolynomial(x,R,sigma,delta)',NULL,'\spad{coerce(x)} returns \spad{x} as a skew-polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(VarSet)->%','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,'\spad{coerce(v)} return \spad{v}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(V)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Vector(Fraction(Polynomial(R))))->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{coerce(v)} assumes that it is called with a vector of length equal to the dimension of the algebra,{} then a linear combination with the basis element is formed');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Vector(MachineFloat))->%','cFortranVectorCategory',NULL,'\spad{coerce(v)} produces an ASP which returns the value of \spad{v}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(Vector(Matrix(R)))->Vector(Matrix(Fraction(Polynomial(R))))','pCoerceVectorMatrixPackage(R)',NULL,'\spad{coerce(v)} coerces a vector \spad{v} with entries in \spadtype{Matrix R} as vector over \spadtype{Matrix Fraction Polynomial R}');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->XDistributedPolynomial(VAR,F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{coerce(f)} converts the element to XDPOLY (if possible).');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(XDistributedPolynomial(VAR,F))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{coerce(p)} converts the polynomial \spad{p} to an element in the free field represented by an minimal admissible linear system.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->XDistributedPolynomial(VarSet,R)','dLieExponentials(VarSet,R,Order)',NULL,'\spad{coerce(g)} returns the internal representation of \spad{g}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->XDistributedPolynomial(VarSet,R)','dXPBWPolynomial(VarSet,R)',NULL,'\spad{coerce(p)} returns \spad{p} as a distributed polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->XPBWPolynomial(VarSet,R)','dLieExponentials(VarSet,R,Order)',NULL,'\spad{coerce(g)} returns the internal representation of \spad{g}.');
INSERT INTO olibdb VALUES('o','coerce',1,'n','(%)->XRecursivePolynomial(VarSet,R)','dXPBWPolynomial(VarSet,R)',NULL,'\spad{coerce(p)} returns \spad{p} as a recursive polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(A)->()->A','pMappingPackage1(A)',NULL,'\spad{coerce A} changes its argument into a \indented{1}{nullary function.}');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(A)->%','dAssociatedJordanAlgebra(R,A)',NULL,'\spad{coerce(a)} coerces the element \spad{a} of the algebra \spad{A} to an element of the Jordan algebra \spadtype{AssociatedJordanAlgebra}(\spad{R},{} A).');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(A)->%','dAssociatedLieAlgebra(R,A)',NULL,'\spad{coerce(a)} coerces the element \spad{a} of the algebra \spad{A} to an element of the Lie algebra \spadtype{AssociatedLieAlgebra}(\spad{R},{} A).');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Character)->%','cStringAggregate',NULL,'\spad{coerce(c)} returns \spad{c} as a string \spad{s} with the character \spad{c}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Col)->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{coerce(col)} converts the column \spad{col} to a column matrix.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Color)->%','dPalette',NULL,'\spad{coerce(c)} sets the average shade for the palette to that of the indicated color \spad{c}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(DirectProduct(dim,R))->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{coerce(v)} views a vector as a rank 1 tensor.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Distribution(R1))->Distribution(R2)','pDistributionFunctions2(R1,R2)',NULL,'\spad{coerce(x)} coerces a distribution from the ring \spad{R1} to \spad{R2}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Exit)->S','pResolveLatticeCompletion(S)',NULL,'\spad{coerce(e)} is never really evaluated. This coercion is used for formal type correctness when a function will not return directly to its caller.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(F1)->F2','pFiniteFieldHomomorphisms(F1,GF,F2)',NULL,'\spad{coerce(x)} is the homomorphic image of \spad{x} from {\em F1} in {\em F2}. Thus {\em coerce} is a field homomorphism between the fields extensions {\em F1} and {\em F2} both over ground field {\em GF} (the second argument to the package). Error: if the extension degree of {\em F1} doesn\spad{''t} divide the extension degree of {\em F2}. Note that the other coercion function in the \spadtype{FiniteFieldHomomorphisms} is a left inverse.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(F2)->F1','pFiniteFieldHomomorphisms(F1,GF,F2)',NULL,'\spad{coerce(x)} is the homomorphic image of \spad{x} from {\em F2} in {\em F1},{} where {\em coerce} is a field homomorphism between the fields extensions {\em F2} and {\em F1} both over ground field {\em GF} (the second argument to the package). Error: if the extension degree of {\em F2} doesn\spad{''t} divide the extension degree of {\em F1}. Note that the other coercion function in the \spadtype{FiniteFieldHomomorphisms} is a left inverse.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(FourierComponent(E))->%','dFourierSeries(R,E)',NULL,'\spad{coerce(c)} converts sin/cos terms into Fourier Series');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Fraction(Factored(R)))->%','dPartialFraction(R)',NULL,'\spad{coerce(f)} takes a fraction with numerator and denominator in factored form and creates a partial fraction. It is necessary for the parts to be factored because it is not known in general how to factor elements of \spad{R} and this is needed to decompose into partial fractions.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Fraction(Integer)','dBinaryExpansion',NULL,'\spad{coerce(b)} converts a binary expansion to a rational number.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Fraction(Integer)','dDecimalExpansion',NULL,'\spad{coerce(d)} converts a decimal expansion to a rational number.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Fraction(Integer)','dHexadecimalExpansion',NULL,'\spad{coerce(h)} converts a hexadecimal expansion to a rational number.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Fraction(Integer)','dRadixExpansion(bb)',NULL,'\spad{coerce(rx)} converts a radix expansion to a rational number.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Fraction(Polynomial(AlgebraicNumber)))->Expression(Integer)','pPolynomialAN2Expression',NULL,'\spad{coerce(rf)} converts \spad{rf},{} a fraction of polynomial \spad{p} with algebraic number coefficients to \spadtype{Expression Integer}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Fraction(Polynomial(Fraction(R))))->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{coerce(f)} returns \spad{f} as an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Fraction(R))->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{coerce(q)} returns \spad{q} as an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Fraction(R)','dPartialFraction(R)',NULL,'\spad{coerce(p)} sums up the components of the partial fraction and returns a single fraction.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Integer)->%','cNonAssociativeRing',NULL,'\spad{coerce(n)} coerces the integer \spad{n} to an element of the ring.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Integer)->%','dOrdSetInts',NULL,'\spad{coerce(i)} returns the element corresponding to \spad{i}');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(%))->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{coerce([t_1,{} ...,{} t_dim])} allows tensors to be constructed using lists.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(DPoly))->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{coerce(polyList)} converts the list of polynomials \spad{polyList} to an ideal.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(List(S)))->%','dPermutation(S)',NULL,'\spad{coerce(lls)} coerces a list of cycles {\em lls} to a permutation,{} each cycle being a list with no repetitions,{} is coerced to the permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are multiplied. Error: if repetitions occur in one cycle.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->List(Permutation(S))','dPermutationGroup(S)',NULL,'\spad{coerce(gp)} returns the generators of the group {\em gp}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(Permutation(S)))->%','dPermutationGroup(S)',NULL,'\spad{coerce(ls)} coerces a list of permutations {\em ls} to the group generated by this list.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(R))->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{coerce([r_1,{} ...,{} r_dim])} allows tensors to be constructed using lists.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(Record(k:M,c:R)))->%','cMonoidRingCategory(R,M)',NULL,'\spad{coerce(lt)} converts a list of terms and coefficients to a member of the domain.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(S))->%','dDatabase(S)',NULL,'\spad{coerce(l)} makes a database out of a list');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(S))->%','dDataList(S)',NULL,'\spad{coerce(l)} creates a datalist from \spad{l}');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->List(S)','dDataList(S)',NULL,'\spad{coerce(x)} returns the list of elements in \spad{x}');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(S))->%','dPermutation(S)',NULL,'\spad{coerce(ls)} coerces a cycle {\em ls},{} \spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(List(S))->%','dStream(S)',NULL,'\spad{coerce(l)} converts a list \spad{l} to a stream.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->OutputForm','cThreeSpaceCategory(R)',NULL,'\spad{coerce(s)} returns the \spadtype{ThreeSpace} \spad{s} to Output format.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->OutputForm','dVoid',NULL,'\spad{coerce(v)} coerces void object to OutputForm.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(PiDomain)->Expression(R)','pPiCoercions(R)',NULL,'\spad{coerce(f)} returns \spad{f} as an Expression(\spad{R}).');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Polynomial(AlgebraicNumber))->Expression(Integer)','pPolynomialAN2Expression',NULL,'\spad{coerce(p)} converts the polynomial \spad{p} with algebraic number coefficients to \spadtype{Expression Integer}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Polynomial(Coef))->%','dTaylorSeries(Coef)',NULL,'\spad{coerce(s)} regroups terms of \spad{s} by total degree \indented{1}{and forms a series.}');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Polynomial(Fraction(R)))->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{coerce(p)} returns \spad{p} as an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->RadixExpansion(10)','dDecimalExpansion',NULL,'\spad{coerce(d)} converts a decimal expansion to a radix expansion with base 10.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->RadixExpansion(16)','dHexadecimalExpansion',NULL,'\spad{coerce(h)} converts a hexadecimal expansion to a radix expansion with base 16.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->RadixExpansion(2)','dBinaryExpansion',NULL,'\spad{coerce(b)} converts a binary expansion to a radix expansion with base 2.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->%','cAlgebra(R)',NULL,'\spad{coerce(r)} maps the ring element \spad{r} to a member of the algebra.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->%','cLeftAlgebra(R)',NULL,'\spad{coerce(r)} returns \spad{r} * 1 where 1 is the identity of the left algebra.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->%','cXAlgebra(R)',NULL,'\spad{coerce(r)} equals \spad{r*1}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->%','dFourierSeries(R,E)',NULL,'\spad{coerce(r)} converts coefficients into Fourier Series');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->R','dOrdinaryDifferentialRing(Kernels,R,var)',NULL,'\spad{coerce(p)} views \spad{p} as a valie in the partial differential ring.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->%','dOrdinaryDifferentialRing(Kernels,R,var)',NULL,'\spad{coerce(r)} views \spad{r} as a value in the ordinary differential ring.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(R)->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{coerce(r)} returns \spad{r} viewed as a rational function over \spad{R}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(S)->Any','pAnyFunctions1(S)',NULL,'\spad{coerce(s)} creates an object of \spadtype{Any} from the object \spad{s} of type \spad{S}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->S','cCoercibleTo(S)',NULL,'\spad{coerce(a)} transforms a into an element of \spad{S}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(S)->%','cDifferentialVariableCategory(S)',NULL,'\spad{coerce(s)} returns \spad{s},{} viewed as the zero-th order derivative of \spad{s}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(SegmentBinding(Expression(R)))->SegmentBinding(Float)','pDrawNumericHack(R)',NULL,'\spad{coerce(x = a..b)} returns \spad{x = c..d} where \spad{c} and \spad{d} are the numerical values of \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Segment(S))->%','dUniversalSegment(S)',NULL,'\spad{coerce(x)} allows \spadtype{Segment} values to be used as \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(S)->None','pNoneFunctions1(S)',NULL,'\spad{coerce(x)} changes \spad{x} into an object of type \spadtype{None}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(SparseMultivariatePolynomial(Integer,Kernel(%)))->%','dAlgebraicNumber',NULL,'\spad{coerce(p)} returns \spad{p} viewed as an algebraic number.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(SparseMultivariatePolynomial(R,K))->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{coerce(p)} returns \spad{p} as an element of \%.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(SquareMatrix(dim,R))->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{coerce(m)} views a matrix as a rank 2 tensor.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(S)->TexFormat','pTexFormat1(S)',NULL,'\spad{coerce(s)} provides a direct coercion from a domain \spad{S} to TeX format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to TeX format.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->String','cFileNameCategory',NULL,'\spad{coerce(fn)} produces a string for a file name according to operating system-dependent conventions.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(String)->%','cFileNameCategory',NULL,'\spad{coerce(s)} converts a string to a file name according to operating system-dependent conventions.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(String)->%','dIndexCard',NULL,'\spad{coerce(s)} converts \spad{s} into an \spad{IndexCard}. Warning: if \spad{s} is not of the right format then an error will occur when using it.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(String)->%','dSymbol',NULL,'\spad{coerce(s)} converts the string \spad{s} to a symbol.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(S)->Void','pResolveLatticeCompletion(S)',NULL,'\spad{coerce(s)} throws all information about \spad{s} away. This coercion allows values of any type to appear in contexts where they will not be used. For example,{} it allows the resolution of different types in the \spad{then} and \spad{else} branches when an \spad{if} is in a context where the resulting value is not used.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Symbol)->%','dOpenMathErrorKind',NULL,'\spad{coerce(u)} creates an OpenMath error object of an appropriate type if \spad{u} is one of \spad{OMParseError},{} \spad{OMReadError},{} \spad{OMUnknownCD} or \spad{OMUnknownSymbol},{} otherwise it raises a runtime error.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Symbol)->%','dTaylorSeries(Coef)',NULL,'\spad{coerce(s)} converts a variable to a Taylor series');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->Tree(S)','dPendantTree(S)',NULL,'\spad{coerce(x)} \undocumented');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(ULS)->%','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{coerce(f(x))} converts the Laurent series \spad{f(x)} to a Puiseux series.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(UnivariatePuiseuxSeries(Coef,var,cen))->%','dGeneralUnivariatePowerSeries(Coef,var,cen)',NULL,'\spad{coerce(f)} converts a Puiseux series to a general power series.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(UTS)->%','cUnivariateLaurentSeriesConstructorCategory(Coef,UTS)',NULL,'\spad{coerce(f(x))} converts the Taylor series \spad{f(x)} to a Laurent series.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Variable(var))->%','dGeneralUnivariatePowerSeries(Coef,var,cen)',NULL,'\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Variable(x))->%','dUnivariatePolynomial(x,R)',NULL,'\spad{coerce(x)} converts the variable \spad{x} to a univariate polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(VarSet)->%','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{coerce(x)} returns \spad{x} as a Lie polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(Vector(R))->%','dAlgebraGivenByStructuralConstants(R,n,ls,gamma)',NULL,'\spad{coerce(v)} converts a vector to a member of the algebra by forming a linear combination with the basis element. Note: the vector is assumed to have length equal to the dimension of the algebra.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(vl)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{coerce(v)} returns \spad{v}.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->XDistributedPolynomial(VarSet,R)','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{coerce(x)} returns \spad{x} as distributed polynomial.');
INSERT INTO olibdb VALUES('o','coerce',1,'x','(%)->XRecursivePolynomial(VarSet,R)','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{coerce(x)} returns \spad{x} as a recursive polynomial.');
INSERT INTO olibdb VALUES('o','coerceImages',1,'x','(List(S))->%','dPermutation(S)','AND(has(S,Finite),not(has(S,IntegerNumberSystem)))','\spad{coerceImages(ls)} coerces the list {\em ls} to a permutation whose image is given by {\em ls} and the preimage is fixed to be {\em [1,{} ...,{} n]}. Note: {coerceImages(\spad{ls})=coercePreimagesImages([1,{} ...,{} \spad{n}],{} \spad{ls})}. We assume that both preimage and image do not contain repetitions.');
INSERT INTO olibdb VALUES('o','coerceImages',1,'x','(List(S))->%','dPermutation(S)','has(S,IntegerNumberSystem)','\spad{coerceImages(ls)} coerces the list {\em ls} to a permutation whose image is given by {\em ls} and the preimage is fixed to be {\em [1,{} ...,{} n]}. Note: {coerceImages(\spad{ls})=coercePreimagesImages([1,{} ...,{} \spad{n}],{} \spad{ls})}. We assume that both preimage and image do not contain repetitions.');
INSERT INTO olibdb VALUES('o','coerceL',1,'n','(OutputForm)->String','dHTMLFormat',NULL,'\spad{coerceL(o)} changes \spad{o} in the standard output format to html format and displays result as one long string.');
INSERT INTO olibdb VALUES('o','coerceL',1,'n','(OutputForm)->String','dMathMLFormat',NULL,'\spad{coerceL(o)} changes \spad{o} in the standard output format to MathML format and displays result as one long string.');
INSERT INTO olibdb VALUES('o','coerceL',1,'n','(OutputForm)->String','dTexmacsFormat',NULL,'\spad{coerceL(o)} changes \spad{o} in the standard output format to Texmacs format and displays result as one long string.');
INSERT INTO olibdb VALUES('o','coerceListOfPairs',1,'x','(List(List(S)))->%','dPermutation(S)',NULL,'\spad{coerceListOfPairs(lls)} coerces a list of pairs {\em lls} to a permutation. Error: if not consistent,{} \spadignore{i.e.} the set of the first elements coincides with the set of second elements. coerce(\spad{p}) generates output of the permutation \spad{p} with domain OutputForm.');
INSERT INTO olibdb VALUES('o','coerceP',1,'n','(Vector(Matrix(R)))->Vector(Matrix(Polynomial(R)))','pCoerceVectorMatrixPackage(R)',NULL,'\spad{coerceP(v)} coerces a vector \spad{v} with entries in \spadtype{Matrix R} as vector over \spadtype{Matrix Polynomial R}');
INSERT INTO olibdb VALUES('o','coercePreimagesImages',1,'x','(List(List(S)))->%','dPermutation(S)',NULL,'\spad{coercePreimagesImages(lls)} coerces the representation {\em lls} of a permutation as a list of preimages and images to a permutation. We assume that both preimage and image do not contain repetitions.');
INSERT INTO olibdb VALUES('o','coerce_Q',1,'n','(Fraction(Integer))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{coerce_Q(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','coerceS',1,'n','(OutputForm)->String','dHTMLFormat',NULL,'\spad{coerceS(o)} changes \spad{o} in the standard output format to html format and displays formatted result.');
INSERT INTO olibdb VALUES('o','coerceS',1,'n','(OutputForm)->String','dMathMLFormat',NULL,'\spad{coerceS(o)} changes \spad{o} in the standard output format to MathML format and displays formatted result.');
INSERT INTO olibdb VALUES('o','coerceToType',1,'n','(InputForm)->InputForm','pInputFormFunctions1(R)',NULL,'\spad{coerceToType(f)} returns the input form corresponding to f::R');
INSERT INTO olibdb VALUES('o','coHeight',1,'n','(S)->NonNegativeInteger','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coHeight',1,'x','(%)->NonNegativeInteger','cTriangularSetCategory(R,E,V,P)','has(V,Finite)','\spad{coHeight(ts)} returns \spad{size()\$V} minus \spad{\#ts}.');
INSERT INTO olibdb VALUES('o','coHomology',1,'n','(%)->List(Homology)','dCoChainComplex(VS)',NULL,'calculate homology using SmithNormalForm');
INSERT INTO olibdb VALUES('o','coHomology',1,'n','(%)->List(Homology)','dDeltaComplex(VS)',NULL,'calculate cohomology using SmithNormalForm');
INSERT INTO olibdb VALUES('o','coHomology',1,'n','(%)->List(Homology)','dFiniteSimplicialComplex(VS)',NULL,'calculate cohomology using SmithNormalForm \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/cohomol/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','coleman',3,'x','(List(Integer),List(Integer),List(Integer))->Matrix(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{coleman(alpha,{} beta,{} \spad{pi})}: there is a bijection from the set of matrices having nonnegative entries and row sums {\em alpha},{} column sums {\em beta} to the set of {\em Salpha - Sbeta} double cosets of the symmetric group {\em Sn}. ({\em Salpha} is the Young subgroup corresponding to the improper partition {\em alpha}). For a representing element {\em \spad{pi}} of such a double coset,{} coleman(\spad{alpha},{} \spad{beta},{} \spad{pi}) generates the Coleman-matrix corresponding to {\em alpha,{} beta,{} \spad{pi}}. Note: The permutation {\em \spad{pi}} of {\em {1,{} 2,{} ...,{} n}} has to be given in list form. Note: the inverse of this map is {\em inverseColeman} (if {\em \spad{pi}} is the lexicographical smallest permutation in the coset). For details see James/Kerber.');
INSERT INTO olibdb VALUES('o','colinearity',2,'n','(%,%)->DoubleFloat','cSPointCategory',NULL,'\spad{colinearity(x,{} y)} returns a measure of how parallel two vectors are independent of the length of the vectors: 1.0 is completely parallel 0.0 is completely perpendicular returned value will be between these');
INSERT INTO olibdb VALUES('o','colinearity',2,'n','(S,S)->DoubleFloat','xSPointCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collect',1,'n','(%)->%','dJetLazyFunction(JB,D)',NULL,'\spad{collect(exp)} collects former lazy terms which have been meanwhile evaluated.');
INSERT INTO olibdb VALUES('o','collect',2,'n','(S,VarSet)->S','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collect',2,'x','(%,VarSet)->%','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{collect(ps,{} v)} returns the set consisting of the polynomials of \spad{ps} with \spad{v} as main variable.');
INSERT INTO olibdb VALUES('o','collectQuasiMonic',1,'n','(S)->S','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collectQuasiMonic',1,'x','(%)->%','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{collectQuasiMonic(ts)} returns the subset of \spad{ts} consisting of the polynomials with initial in \spad{R}.');
INSERT INTO olibdb VALUES('o','collectUnder',2,'n','(S,VarSet)->S','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collectUnder',2,'n','(S,V)->S','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collectUnder',2,'x','(%,VarSet)->%','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{collectUnder(ps,{} v)} returns the set consisting of the polynomials of \spad{ps} with main variable less than \spad{v}.');
INSERT INTO olibdb VALUES('o','collectUpper',2,'n','(S,VarSet)->S','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collectUpper',2,'n','(S,V)->S','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','collectUpper',2,'x','(%,VarSet)->%','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{collectUpper(ps,{} v)} returns the set consisting of the polynomials of \spad{ps} with main variable greater than \spad{v}.');
INSERT INTO olibdb VALUES('o','color',1,'n','(Point(R))->R','pPointPackage(R)',NULL,'\spad{color(pt)} returns the fourth element of the point,{} \spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} color to express a fourth dimension.');
INSERT INTO olibdb VALUES('o','color',1,'x','(Integer)->%','dColor',NULL,'\spad{color(i)} returns a color of the indicated hue \spad{i}.');
INSERT INTO olibdb VALUES('o','colorDef',3,'x','(%,Color,Color)->Void','dThreeDimensionalViewport',NULL,'\spad{colorDef(v,{} c1,{} c2)} sets the range of colors along the colormap so that the lower end of the colormap is defined by \spad{c1} and the top end of the colormap is defined by \spad{c2},{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','colorFunction',1,'x','((DoubleFloat)->DoubleFloat)->%','dDrawOption',NULL,'\spad{colorFunction(f(z))} specifies the color based upon the \spad{z}-component of three dimensional plots. This option is expressed in the form \spad{colorFunction == f(z)}.');
INSERT INTO olibdb VALUES('o','colorFunction',1,'x','((DoubleFloat,DoubleFloat)->DoubleFloat)->%','dDrawOption',NULL,'\spad{colorFunction(f(u,{} v))} specifies the color for three dimensional plots as a function based upon the two parametric variables. This option is expressed in the form \spad{colorFunction == f(u,{} v)}.');
INSERT INTO olibdb VALUES('o','colorFunction',1,'x','((DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat)->%','dDrawOption',NULL,'\spad{colorFunction(f(x,{} y,{} z))} specifies the color for three dimensional plots as a function of \spad{x},{} \spad{y},{} and \spad{z} coordinates. This option is expressed in the form \spad{colorFunction == f(x,{} y,{} z)}.');
INSERT INTO olibdb VALUES('o','colSlice',1,'n','(S)->Segment(Integer)','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','colSlice',1,'x','(%)->Segment(Integer)','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{colSlice(m)} returns a segment \spad{s} such that for \spad{m} the access \spad{m}(\spad{i},{} \spad{s}) gives the \spad{i}-th row.');
INSERT INTO olibdb VALUES('o','column',2,'n','(S,Integer)->Col','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','column',2,'x','(%,Integer)->Col','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{column(m,{} j)} returns the \spad{j}th column of the matrix \spad{m}. Error: if the index outside the proper range.');
INSERT INTO olibdb VALUES('o','column',2,'x','(%,Integer)->Col','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{column(m,{} j)} returns the \spad{j}th column of \spad{m} error check to determine if index is in proper ranges');
INSERT INTO olibdb VALUES('o','columnMatrix',2,'n','(M,Integer)->M','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{columnMatrix} returns a single column out of a matrix. The column is put into a one by \spad{N} matrix.');
INSERT INTO olibdb VALUES('o','columns',2,'n','(M,List(Integer))->M','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix.');
INSERT INTO olibdb VALUES('o','columns',2,'n','(M,Segment(Integer))->M','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{columns} returns several columns out of a matrix. The columns are stacked into a matrix.');
INSERT INTO olibdb VALUES('o','columnSpace',1,'n','(Matrix(R))->%','dVectorSpaceBasis(R)',NULL,'\spad{columnSpace M} builds a basis of the image space of the linear transformation defined by the matrix \spad{M}. This function calls the \spad{columnSpace} from the \spad{Matrix} domain. Only the signature changes.');
INSERT INTO olibdb VALUES('o','columnSpace',1,'n','(S)->List(Col)','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','columnSpace',1,'x','(%)->List(Col)','cMatrixCategory(R,Row,Col)','has(R,EuclideanDomain)','\spad{columnSpace(m)} returns a sublist of columns of the matrix \spad{m} forming a basis of its column space');
INSERT INTO olibdb VALUES('o','columnSpace',1,'x','(%)->List(Col)','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,EuclideanDomain)','\spad{columnSpace(m)} returns a sublist of columns of the matrix \spad{m} forming a basis of its column space.');
INSERT INTO olibdb VALUES('o','columnSpan',1,'n','(%)->Stream(Matrix(XDistributedPolynomial(VAR,F)))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{columnSpan(f)} computes the column span for a regular element,{} that is (\spad{v''},{} \spad{Mv''},{} M^2v'',{} ...) where PAs=Pv=v'' with PA = \spad{I}-\spad{M}.');
INSERT INTO olibdb VALUES('o','commaSeparate',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{commaSeparate(l)} creates the form separating the elements of \spad{l} by commas.');
INSERT INTO olibdb VALUES('o','comment',1,'n','(List(String))->%','dFortranCode',NULL,'\spad{comment(s)} creates a representation of the Strings \spad{s} as a multi-line FORTRAN comment.');
INSERT INTO olibdb VALUES('o','comment',1,'n','(String)->%','dFortranCode',NULL,'\spad{comment(s)} creates a representation of the String \spad{s} as a single FORTRAN comment.');
INSERT INTO olibdb VALUES('o','common',2,'n','(Symbol,List(Symbol))->%','dFortranCode',NULL,'\spad{common(name,{} contents)} creates a representation a named common block.');
INSERT INTO olibdb VALUES('o','commonDenominator',1,'n','(B)->R','pInnerCommonDenominator(R,Q,A,B)',NULL,'\spad{commonDenominator([q1,{} ...,{} qn])} returns a common denominator \spad{d} for \spad{q1},{} ...,{} \spad{qn}.');
INSERT INTO olibdb VALUES('o','commonDenominator',1,'n','(P)->R','pPolynomialCommonDenominator(R,Q,E,VarSet,P)',NULL,'\spad{commonDenominator(q)} returns a common denominator \spad{d} for the coefficients of \spad{q}.');
INSERT INTO olibdb VALUES('o','commonDenominator',1,'x','(A)->R','pCommonDenominator(R,Q,A)',NULL,'\spad{commonDenominator([q1,{} ...,{} qn])} returns a common denominator \spad{d} for \spad{q1},{} ...,{} \spad{qn}.');
INSERT INTO olibdb VALUES('o','commonDenominator',1,'x','(Matrix(Q))->R','pMatrixCommonDenominator(R,Q)',NULL,'\spad{commonDenominator(q)} returns a common denominator \spad{d} for the elements of \spad{q}.');
INSERT INTO olibdb VALUES('o','commonDenominator',1,'x','(UP)->R','pUnivariatePolynomialCommonDenominator(R,Q,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','commutative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{commutative?()} tests if multiplication in the algebra is commutative.');
INSERT INTO olibdb VALUES('o','commutative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{commutative?()} tests if multiplication in the algebra is commutative.');
INSERT INTO olibdb VALUES('o','commutator',2,'n','(%,%)->%','dJetVectorField(JB,D)',NULL,'\spad{commutator(v,{} w)} calculates the commutator of two vector fields.');
INSERT INTO olibdb VALUES('o','commutator',2,'n','(S,S)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','commutator',2,'n','(S,S)->S','xNonAssociativeRng&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','commutator',2,'x','(%,%)->%','cGroup',NULL,'\spad{commutator(p,{} q)} computes \spad{inv(p) * inv(q) * p * q}.');
INSERT INTO olibdb VALUES('o','commutator',2,'x','(%,%)->%','cNonAssociativeRng',NULL,'\spad{commutator(a,{} b)} returns \spad{a*b-b*a}.');
INSERT INTO olibdb VALUES('o','comp',3,'n','((B)->C,(A)->B,A)->C','pMappingPackageInternalHacks3(A,B,C)',NULL,'\spad{comp(f,{} g,{} x)} is \spad{f(g x)}.');
INSERT INTO olibdb VALUES('o','compactFraction',1,'x','(%)->%','dPartialFraction(R)',NULL,'\spad{compactFraction(p)} normalizes the partial fraction \spad{p} to the compact representation. In this form,{} the partial fraction has only one fractional term per prime in the denominator.');
INSERT INTO olibdb VALUES('o','companionBlocks',2,'n','(Matrix(K),List(Vector(K)))->List(Record(C:Matrix(K),lg:List(Vector(K))))','pPseudoLinearNormalForm(K)',NULL,'\spad{companionBlocks(m,{} lv)} returns \spad{[[C_1,{} lg_1],{} ...,{} [C_k,{} lg_k]]} such that each \spad{C_i} is a companion block and \spad{m = diagonal(C_1,{} ...,{} C_k)}.');
INSERT INTO olibdb VALUES('o','comparison',2,'x','(%,(%,%)->Boolean)->%','dBasicOperator',NULL,'\spad{comparison(op,{} foo?)} attaches foo? as the \%less? property to \spad{op}. If \spad{op1} and \spad{op2} have the same name,{} and one of them has a \%less? property \spad{f},{} then \spad{f(op1,{} op2)} is called to decide whether \spad{op1 < op2}.');
INSERT INTO olibdb VALUES('o','compBound',2,'n','(BP,List(BP))->NonNegativeInteger','pGenExEuclid(R,BP)',NULL,'\spad{compBound(p,{} lp)} computes a bound for the coefficients of the solution polynomials. Given a polynomial right hand side \spad{p},{} and a list \spad{lp} of left hand side polynomials. Exported because it depends on the valuation.');
INSERT INTO olibdb VALUES('o','compdegd',1,'n','(List(Record(factor:SparseUnivariatePolynomial(R),exponent:NonNegativeInteger)))->Integer','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{compdegd should} be local');
INSERT INTO olibdb VALUES('o','compile',2,'n','(Symbol,List(%))->Symbol','dInputForm',NULL,'\spad{compile(f,{} [t1,{} ...,{} tn])} forces the interpreter to compile the function \spad{f} with signature \spad{(t1,{} ...,{} tn) -> ?}. returns the symbol \spad{f} if successful. Error: if \spad{f} was not defined beforehand in the interpreter,{} or if the \spad{ti}\spad{''s} are not valid types,{} or if the compiler fails.');
INSERT INTO olibdb VALUES('o','compiledFunction',2,'n','(S,Symbol)->(D)->I','pMakeUnaryCompiledFunction(S,D,I)',NULL,'\spad{compiledFunction(expr,{} x)} returns a function \spad{f: D -> I} defined by \spad{f(x) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spad{D}.');
INSERT INTO olibdb VALUES('o','compiledFunction',3,'n','(S,Symbol,Symbol)->(D1,D2)->I','pMakeBinaryCompiledFunction(S,D1,D2,I)',NULL,'\spad{compiledFunction(expr,{} x,{} y)} returns a function \spad{f: (D1,{} D2) -> I} defined by \spad{f(x,{} y) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spad{(D1,{} D2)}');
INSERT INTO olibdb VALUES('o','complement',1,'n','(A)->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','complement',1,'n','(%)->%','dSubsetLattice(S,top)',NULL,'pseudo complement');
INSERT INTO olibdb VALUES('o','complement',1,'x','(%)->%','cFiniteSetAggregate(S)','has(S,Finite)','\spad{complement(u)} returns the complement of the set \spad{u},{} \spadignore{i.e.} the set of all values not in \spad{u}.');
INSERT INTO olibdb VALUES('o','complement',2,'n','(%,List(S))->%','dSubsetLattice(S,top)',NULL,'pseudo complement');
INSERT INTO olibdb VALUES('o','complementaryBasis',1,'n','(Vector(S))->Vector(S)','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','complementaryBasis',1,'x','(Vector(%))->Vector(%)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{complementaryBasis(b1,{} ...,{} bn)} returns the complementary basis \spad{(b1'',{} ...,{} bn'')} of \spad{(b1,{} ...,{} bn)}.');
INSERT INTO olibdb VALUES('o','complementSpace',1,'n','(%)->%','dVectorSpaceBasis(R)',NULL,'\spad{complementSpace B} builds a complement space of the basis \spad{B} from some vectors of the canonical basis. This function fails with the empty basis.');
INSERT INTO olibdb VALUES('o','complementSpace',1,'n','(List(Vector(R)))->%','dVectorSpaceBasis(R)',NULL,'\spad{complementSpace Lv} builds a complement space of the subspace spanned by the list of vectors \spad{LV}. This function fails with the empty basis.');
INSERT INTO olibdb VALUES('o','complementSpace',2,'n','(List(Vector(R)),NonNegativeInteger)->%','dVectorSpaceBasis(R)',NULL,'\spad{complementSpace(Lv,{} n)} builds a complement space of the subspace spanned by the list of vectors \spad{LV}. The integer \spad{n} provides the length of the vectors in the case of the empty basis.');
INSERT INTO olibdb VALUES('o','complementSpace',2,'n','(%,NonNegativeInteger)->%','dVectorSpaceBasis(R)',NULL,'\spad{complementSpace(B,{} n)} builds a complement space of the basis \spad{B} from some vectors of the canonical basis \spad{B}. The integer \spad{n} provides the length of the vectors in the case of the empty basis.');
INSERT INTO olibdb VALUES('o','complete',1,'n','(A)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','complete',1,'n','(JetDifferentialEquation(JB,D))->Void','pCartanKuranishi(JB,D)',NULL,'\spad{complete(de)} completes \spad{de} to an involutive equation. No result is returned; the display depends of the setting of the output flags with \spadfun{setOutput}.');
INSERT INTO olibdb VALUES('o','complete',1,'x','(%)->%','cLazyStreamAggregate(S)',NULL,'\spad{complete(st)} causes all entries of ''st'' to be computed. this function should only be called on streams which are known to be finite.');
INSERT INTO olibdb VALUES('o','complete',1,'x','(%)->%','cPAdicIntegerCategory(p)',NULL,'\spad{complete(x)} forces the computation of all digits.');
INSERT INTO olibdb VALUES('o','complete',1,'x','(%)->%','cPowerSeriesCategory(Coef,Expon,Var)',NULL,'\spad{complete(f)} causes all terms of \spad{f} to be computed. Note: this results in an infinite loop if \spad{f} has infinitely many terms.');
INSERT INTO olibdb VALUES('o','complete',1,'x','(%)->%','dContinuedFraction(R)',NULL,'\spad{complete(x)} causes all entries in \spadvar{\spad{x}} to be computed. Normally entries are only computed as needed. If \spadvar{\spad{x}} is an infinite continued fraction,{} a user-initiated interrupt is necessary to stop the computation.');
INSERT INTO olibdb VALUES('o','complete',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{complete n} is the \spad{n} th complete homogeneous \indented{1}{symmetric function expressed in terms of power sums.} \indented{1}{Alternatively it is the cycle index of the symmetric} \indented{1}{group of degree \spad{n}.}');
INSERT INTO olibdb VALUES('o','complete2',1,'n','(JetDifferentialEquation(JB,D))->Record(IDe:JetDifferentialEquation(JB,D),ISys:List(D),Order:NonNegativeInteger,NumProj:NonNegativeInteger,Dim:NonNegativeInteger,CarChar:List(NonNegativeInteger))','pCartanKuranishi(JB,D)',NULL,'\spad{complete2(de)} is like \spadfun{complete} but returns the involutive equation \spad{IDe},{} a basis \spad{ISys} for the involutive system without prolongations,{} its order \spad{Order},{} the number \spad{NumProj} of needed projections and the Cartan characters \spad{CarChar}.');
INSERT INTO olibdb VALUES('o','completeDecompose',1,'x','(UP)->List(UP)','pUnivariatePolynomialDecompositionPackage(R,UP)','has(R,Field)','\spad{completeDecompose(f)} returns a list of factors of \spad{f} for the functional decomposition of \spad{f}. [\spad{f1},{} ...,{} \spad{fn}] means \spad{f} = \spad{f1} \spad{o} ... \spad{o} \spad{fn}.');
INSERT INTO olibdb VALUES('o','completeEchelonBasis',1,'x','(Vector(Vector(R)))->Matrix(R)','pRepresentationPackage2(R)',NULL,'\spad{completeEchelonBasis(lv)} completes the basis {\em lv} assumed to be in echelon form of a subspace of {\em R^n} (\spad{n} the length of all the vectors in {\em lv}) with unit vectors to a basis of {\em R^n}. It is assumed that the argument is not an empty vector and that it is not the basis of the 0-subspace. Note: the rows of the result correspond to the vectors of the basis.');
INSERT INTO olibdb VALUES('o','completeEval',3,'n','(SparseUnivariatePolynomial(P),List(OV),List(R))->SparseUnivariatePolynomial(R)','pFactoringUtilities(E,OV,R,P)',NULL,'\spad{completeEval(upoly,{} lvar,{} lval)} evaluates the polynomial \spad{upoly} with each variable in \spad{lvar} replaced by the corresponding value in lval. Substitutions are done for all variables in \spad{upoly} producing a univariate polynomial over \spad{R}.');
INSERT INTO olibdb VALUES('o','completeHensel',4,'n','(TP,List(TP),RP,PositiveInteger)->List(TP)','pGeneralHenselPackage(RP,TP)',NULL,'\spad{completeHensel(pol,{} lfact,{} prime,{} bound)} lifts \spad{lfact},{} the factorization mod \spad{prime} of \spad{pol},{} to the factorization mod prime^k>bound. Factors are recombined on the way.');
INSERT INTO olibdb VALUES('o','completeHermite',1,'x','(M)->Record(Hermite:M,eqMat:M)','pSmithNormalForm(R,Row,Col,M)',NULL,'\spad{completeHermite} returns a record that contains the Hermite normal form \spad{H} of the matrix and the equivalence matrix \spad{U} such that U*m = \spad{H}');
INSERT INTO olibdb VALUES('o','completelyOrderedSet',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a completely ordered set');
INSERT INTO olibdb VALUES('o','completeSmith',1,'x','(M)->Record(Smith:M,leftEqMat:M,rightEqMat:M)','pSmithNormalForm(R,Row,Col,M)',NULL,'\spad{completeSmith} returns a record that contains the Smith normal form \spad{H} of the matrix and the left and right equivalence matrices \spad{U} and \spad{V} such that U*m*v = \spad{H}');
INSERT INTO olibdb VALUES('o','completeSmith',2,'n','(Matrix(Integer),(Matrix(Integer))->Record(Smith:Matrix(Integer),leftEqMat:Matrix(Integer),rightEqMat:Matrix(Integer)))->Record(Smith:Matrix(Integer),leftEqMat:Matrix(Integer),rightEqMat:Matrix(Integer))','pIntegerSmithNormalForm',NULL,'\spad{completeSmith(m,{} full)} computes record containing Smith normal form of \spad{m} and the left and right equivalence matrices. It first reduces \spad{m} to smaller matrix and then uses full to finish.');
INSERT INTO olibdb VALUES('o','complex?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{complex?(t)} tests whether \spad{t} is equivalent to the FORTRAN type COMPLEX.');
INSERT INTO olibdb VALUES('o','complex',2,'x','(R,R)->%','cComplexCategory(R)',NULL,'\spad{complex(x,{} y)} constructs \spad{x} + \%i*y.');
INSERT INTO olibdb VALUES('o','complex_curve',1,'x','(VT)->%','dParametricComplexCurve(VT)',NULL,NULL);
INSERT INTO olibdb VALUES('o','complexEigenvalues',2,'x','(Matrix(Complex(Fraction(Integer))),Par)->List(Complex(Par))','pNumericComplexEigenPackage(Par)',NULL,'\spad{complexEigenvalues(m,{} eps)} computes the eigenvalues of the matrix \spad{m} to precision eps. The eigenvalues are expressed as complex floats or complex rational numbers depending on the type of eps (float or rational).');
INSERT INTO olibdb VALUES('o','complexEigenvectors',2,'x','(Matrix(Complex(Fraction(Integer))),Par)->List(Record(outval:Complex(Par),outmult:Integer,outvect:List(Matrix(Complex(Par)))))','pNumericComplexEigenPackage(Par)',NULL,'\spad{complexEigenvectors(m,{} eps)} returns a list of records each one containing a complex eigenvalue,{} its algebraic multiplicity,{} and a list of associated eigenvectors. All these results are computed to precision eps and are expressed as complex floats or complex rational numbers depending on the type of eps (float or rational).');
INSERT INTO olibdb VALUES('o','complexElementary',1,'x','(F)->F','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{complexElementary(f)} rewrites \spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.');
INSERT INTO olibdb VALUES('o','complexElementary',1,'x','(F)->F','pTrigonometricManipulations(R,F)',NULL,'\spad{complexElementary(f)} rewrites \spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.');
INSERT INTO olibdb VALUES('o','complexElementary',2,'x','(F,Symbol)->F','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{complexElementary(f,{} x)} rewrites the kernels of \spad{f} involving \spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.');
INSERT INTO olibdb VALUES('o','complexElementary',2,'x','(F,Symbol)->F','pTrigonometricManipulations(R,F)',NULL,'\spad{complexElementary(f,{} x)} rewrites the kernels of \spad{f} involving \spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.');
INSERT INTO olibdb VALUES('o','complexExpand',1,'x','(IntegrationResult(F))->F','pIntegrationResultToFunction(R,F)',NULL,'\spad{complexExpand(i)} returns the expanded complex function corresponding to \spad{i}.');
INSERT INTO olibdb VALUES('o','complexExpand',1,'x','(IntegrationResult(Fraction(Polynomial(R))))->Expression(R)','pIntegrationResultRFToFunction(R)',NULL,'\spad{complexExpand(i)} returns the expanded complex function corresponding to \spad{i}.');
INSERT INTO olibdb VALUES('o','complexForm',1,'x','(F)->Complex(Expression(R))','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{complexForm(f)} returns \spad{[real f,{} imag f]}.');
INSERT INTO olibdb VALUES('o','complexForm',1,'x','(F)->Complex(F)','pTrigonometricManipulations(R,F)',NULL,'\spad{complexForm(f)} returns \spad{[real f,{} imag f]}.');
INSERT INTO olibdb VALUES('o','complexIntegrate',2,'x','(Fraction(Polynomial(R)),Symbol)->Expression(R)','pIntegrationResultRFToFunction(R)','has(R,CharacteristicZero)','\spad{complexIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.');
INSERT INTO olibdb VALUES('o','complexIntegrate',2,'x','(F,Symbol)->F','pFunctionSpaceComplexIntegration(R,F)',NULL,'\spad{complexIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.');
INSERT INTO olibdb VALUES('o','complexLimit',2,'x','(FE,Equation(OnePointCompletion(FE)))->Union(OnePointCompletion(FE),failed)','pPowerSeriesLimitPackage(R,FE)',NULL,'\spad{complexLimit(f(x),{} x = a)} computes the complex limit \spad{lim(x -> a,{} f(x))}.');
INSERT INTO olibdb VALUES('o','complexLimit',2,'x','(Fraction(Polynomial(R)),Equation(Fraction(Polynomial(R))))->OnePointCompletion(Fraction(Polynomial(R)))','pRationalFunctionLimitPackage(R)',NULL,'\spad{complexLimit(f(x),{} x = a)} computes the complex limit of \spad{f} as its argument \spad{x} approaches \spad{a}.');
INSERT INTO olibdb VALUES('o','complexLimit',2,'x','(Fraction(Polynomial(R)),Equation(OnePointCompletion(Polynomial(R))))->OnePointCompletion(Fraction(Polynomial(R)))','pRationalFunctionLimitPackage(R)',NULL,'\spad{complexLimit(f(x),{} x = a)} computes the complex limit of \spad{f} as its argument \spad{x} approaches \spad{a}.');
INSERT INTO olibdb VALUES('o','complexNormalize',1,'x','(F)->F','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{complexNormalize(f)} rewrites \spad{f} using the least possible number of complex independent kernels.');
INSERT INTO olibdb VALUES('o','complexNormalize',1,'x','(F)->F','pTrigonometricManipulations(R,F)',NULL,'\spad{complexNormalize(f)} rewrites \spad{f} using the least possible number of complex independent kernels.');
INSERT INTO olibdb VALUES('o','complexNormalize',2,'x','(F,Symbol)->F','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{complexNormalize(f,{} x)} rewrites \spad{f} using the least possible number of complex independent kernels involving \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNormalize',2,'x','(F,Symbol)->F','pTrigonometricManipulations(R,F)',NULL,'\spad{complexNormalize(f,{} x)} rewrites \spad{f} using the least possible number of complex independent kernels involving \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Complex(S))->Complex(Float)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Expression(Complex(S)))->Complex(Float)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Expression(S))->Complex(Float)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Fraction(Polynomial(Complex(S))))->Complex(Float)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Fraction(Polynomial(S)))->Complex(Float)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Polynomial(Complex(S)))->Complex(Float)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(Polynomial(S))->Complex(Float)','pNumeric(S)','has(S,Ring)','\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',1,'x','(S)->Complex(Float)','pNumeric(S)',NULL,'\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Complex(S),PositiveInteger)->Complex(Float)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Expression(Complex(S)),PositiveInteger)->Complex(Float)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Expression(S),PositiveInteger)->Complex(Float)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Fraction(Polynomial(Complex(S))),PositiveInteger)->Complex(Float)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Fraction(Polynomial(S)),PositiveInteger)->Complex(Float)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x}');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Polynomial(Complex(S)),PositiveInteger)->Complex(Float)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(Polynomial(S),PositiveInteger)->Complex(Float)','pNumeric(S)','has(S,Ring)','\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumeric',2,'x','(S,PositiveInteger)->Complex(Float)','pNumeric(S)',NULL,'\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Expression(Complex(S)))->Union(Complex(Float),failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Expression(S))->Union(Complex(Float),failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Fraction(Polynomial(Complex(S))))->Union(Complex(Float),failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Fraction(Polynomial(S)))->Union(Complex(Float),failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Polynomial(Complex(S)))->Union(Complex(Float),failed)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',1,'x','(Polynomial(S))->Union(Complex(Float),failed)','pNumeric(S)','has(S,Ring)','\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Expression(Complex(S)),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Expression(S),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Fraction(Polynomial(Complex(S))),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Fraction(Polynomial(S)),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Polynomial(Complex(S)),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','has(S,CommutativeRing)','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complexNumericIfCan',2,'x','(Polynomial(S),PositiveInteger)->Union(Complex(Float),failed)','pNumeric(S)','has(S,Ring)','\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','complex_roots',1,'n','(SparseUnivariatePolynomial(F))->Union(Record(reals:List(F),complexes:List(Record(real:F,imag:F))),failed)','pRootUtilities(R,F)',NULL,'\spad{complex_roots(p)} computes roots of \spad{p} in terms of radicals separating real and complex roots. Returns failed when unsuccessful.');
INSERT INTO olibdb VALUES('o','complexRoots',2,'x','(Fraction(Polynomial(Complex(Integer))),Par)->List(Complex(Par))','pFloatingComplexPackage(Par)',NULL,'\spad{complexRoots(rf,{} eps)} finds all the complex solutions of a univariate rational function with rational number coefficients. The solutions are computed to precision eps.');
INSERT INTO olibdb VALUES('o','complexRoots',3,'x','(List(Fraction(Polynomial(Complex(Integer)))),List(Symbol),Par)->List(List(Complex(Par)))','pFloatingComplexPackage(Par)',NULL,'\spad{complexRoots(lrf,{} lv,{} eps)} finds all the complex solutions of a list of rational functions with rational number coefficients with respect the variables appearing in \spad{lv}. Each solution is computed to precision eps and returned as list corresponding to the order of variables in \spad{lv}.');
INSERT INTO olibdb VALUES('o','complexSolve',2,'x','(Equation(Fraction(Polynomial(Complex(Integer)))),Par)->List(Equation(Polynomial(Complex(Par))))','pFloatingComplexPackage(Par)',NULL,'\spad{complexSolve(eq,{} eps)} finds all the complex solutions of the equation \spad{eq} of rational functions with rational rational coefficients with respect to all the variables appearing in \spad{eq},{} with precision eps.');
INSERT INTO olibdb VALUES('o','complexSolve',2,'x','(Fraction(Polynomial(Complex(Integer))),Par)->List(Equation(Polynomial(Complex(Par))))','pFloatingComplexPackage(Par)',NULL,'\spad{complexSolve(p,{} eps)} find all the complex solutions of the rational function \spad{p} with complex rational coefficients with respect to all the variables appearing in \spad{p},{} with precision eps.');
INSERT INTO olibdb VALUES('o','complexSolve',2,'x','(List(Equation(Fraction(Polynomial(Complex(Integer))))),Par)->List(List(Equation(Polynomial(Complex(Par)))))','pFloatingComplexPackage(Par)',NULL,'\spad{complexSolve(leq,{} eps)} finds all the complex solutions to precision eps of the system \spad{leq} of equations of rational functions over complex rationals with respect to all the variables appearing in \spad{lp}.');
INSERT INTO olibdb VALUES('o','complexSolve',2,'x','(List(Fraction(Polynomial(Complex(Integer)))),Par)->List(List(Equation(Polynomial(Complex(Par)))))','pFloatingComplexPackage(Par)',NULL,'\spad{complexSolve(lp,{} eps)} finds all the complex solutions to precision eps of the system \spad{lp} of rational functions over the complex rationals with respect to all the variables appearing in \spad{lp}.');
INSERT INTO olibdb VALUES('o','complexZeros',1,'n','(UP)->List(Complex(R))','pComplexRootFindingPackage(R,UP)',NULL,'\spad{complexZeros(p)} tries to determine all complex zeros of the polynomial \spad{p} with accuracy given by the package constant {\em globalEps} which you may change by {\em setErrorBound}.');
INSERT INTO olibdb VALUES('o','complexZeros',2,'n','(UP,R)->List(Complex(R))','pComplexRootFindingPackage(R,UP)',NULL,'\spad{complexZeros(p,{} eps)} tries to determine all complex zeros of the polynomial \spad{p} with accuracy given by {\em eps}.');
INSERT INTO olibdb VALUES('o','complexZeros',2,'x','(UP,Par)->List(Complex(Par))','pComplexRootPackage(UP,Par)',NULL,'\spad{complexZeros(poly,{} eps)} finds the complex zeros of the univariate polynomial \spad{poly} to precision eps with solutions returned as complex floats or rationals depending on the type of eps.');
INSERT INTO olibdb VALUES('o','component',2,'n','(%,Point(DoubleFloat))->Void','dGraphImage',NULL,'\spad{component(\spad{gi},{} pt)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color,{} line color and point size are determined by the default functions \spadfun{pointColorDefault},{} \spadfun{lineColorDefault},{} and \spadfun{pointSizeDefault}.');
INSERT INTO olibdb VALUES('o','component',5,'n','(%,List(Point(DoubleFloat)),Palette,Palette,PositiveInteger)->Void','dGraphImage',NULL,'\spad{component(\spad{gi},{} lp,{} pal1,{} pal2,{} p)} sets the components of the graph,{} \spad{\spad{gi}} of the domain \spadtype{GraphImage},{} to the values given. The point list for \spad{\spad{gi}} is set to the list \spad{lp},{} the color of the points in \spad{lp} is set to the palette color \spad{pal1},{} the color of the lines which connect the points \spad{lp} is set to the palette color \spad{pal2},{} and the size of the points in \spad{lp} is given by the integer \spad{p}.');
INSERT INTO olibdb VALUES('o','component',5,'n','(%,Point(DoubleFloat),Palette,Palette,PositiveInteger)->Void','dGraphImage',NULL,'\spad{component(\spad{gi},{} pt,{} pal1,{} pal2,{} ps)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color is set to the palette color \spad{pal1},{} line color is set to the palette color \spad{pal2},{} and point size is set to the positive integer \spad{ps}.');
INSERT INTO olibdb VALUES('o','components',1,'x','(%)->List(%)','cThreeSpaceCategory(R)',NULL,'\spad{components(s)} takes the \spadtype{ThreeSpace} \spad{s},{} and creates a list containing a unique \spadtype{ThreeSpace} for each single component of \spad{s}. If \spad{s} has no components defined,{} the list returned is empty.');
INSERT INTO olibdb VALUES('o','compose',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{compose(a,{} b)} composes the power series \spad{a} with the power series \spad{b}.');
INSERT INTO olibdb VALUES('o','composite',1,'x','(List(%))->%','cThreeSpaceCategory(R)',NULL,'\spad{composite([s1,{} s2,{} ...,{} sn])} will create a new \spadtype{ThreeSpace} that is a union of all the components from each \spadtype{ThreeSpace} in the parameter list,{} grouped as a composite.');
INSERT INTO olibdb VALUES('o','composite',2,'n','(Fraction(S),S)->Union(Fraction(S),failed)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','composite',2,'n','(S,S)->Union(S,failed)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','composite',2,'x','(Fraction(%),%)->Union(Fraction(%),failed)','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{composite(f,{} q)} returns \spad{h} if \spad{f} = \spad{h}(\spad{q}),{} and failed is no such \spad{h} exists.');
INSERT INTO olibdb VALUES('o','composite',2,'x','(%,%)->Union(%,failed)','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{composite(p,{} q)} returns \spad{h} if \spad{p = h(q)},{} and failed no such \spad{h} exists.');
INSERT INTO olibdb VALUES('o','composites',1,'x','(%)->List(%)','cThreeSpaceCategory(R)',NULL,'\spad{composites(s)} takes the \spadtype{ThreeSpace} \spad{s},{} and creates a list containing a unique \spadtype{ThreeSpace} for each single composite of \spad{s}. If \spad{s} has no composites defined (composites need to be explicitly created),{} the list returned is empty. Note that not all the components need to be part of a composite.');
INSERT INTO olibdb VALUES('o','compound',2,'n','(%,%)->%','dSTransform(PT)',NULL,'\spad{compound(tr,{} inpt)} combine two transforms');
INSERT INTO olibdb VALUES('o','computeBasis',1,'n','(List(HomogeneousDistributedMultivariatePolynomial(lv,F)))->List(HomogeneousDistributedMultivariatePolynomial(lv,F))','pLinGroebnerPackage(lv,F)',NULL,'\spad{computeBasis(l)} is a helper function which computes a basis of a linear space which contains a lexicographic Groebner basis. It expects a basis (ordered by total degree,{} reverse lexicographic) of a zero dimensional ideal.');
INSERT INTO olibdb VALUES('o','computeCycleEntry',2,'n','(ST,ST)->ST','pCyclicStreamTools(S,ST)',NULL,'\spad{computeCycleEntry(x,{} cycElt)},{} where cycElt is a pointer to a node in the cyclic part of the cyclic stream \spad{x},{} returns a pointer to the first node in the cycle');
INSERT INTO olibdb VALUES('o','computeCycleLength',1,'n','(ST)->NonNegativeInteger','pCyclicStreamTools(S,ST)',NULL,'\spad{computeCycleLength(s)} returns the length of the cycle of a cyclic stream \spad{t},{} where \spad{s} is a pointer to a node in the cyclic part of \spad{t}.');
INSERT INTO olibdb VALUES('o','computeInt',5,'n','(Kernel(F),F,OrderedCompletion(F),OrderedCompletion(F),Boolean)->Union(OrderedCompletion(F),failed)','pDefiniteIntegrationTools(R,F)',NULL,'\spad{computeInt(x,{} g,{} a,{} b,{} eval?)} returns the integral of \spad{f} for \spad{x} between a and \spad{b},{} assuming that \spad{g} is an indefinite integral of \spad{f} and \spad{f} has no pole between a and \spad{b}. If \spad{eval?} is \spad{true},{} then \spad{g} can be evaluated safely at \spad{a} and \spad{b},{} provided that they are finite values. Otherwise,{} limits must be computed.');
INSERT INTO olibdb VALUES('o','concat',1,'n','(List(A))->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',1,'n','(List(A))->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',1,'n','(List(A))->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',1,'n','(List(A))->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',1,'n','(List(A))->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',1,'n','(List(A))->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',1,'x','(List(%))->%','cLinearAggregate(S)',NULL,'\spad{concat(u)},{} where \spad{u} is a list of aggregates \spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \spad{a} followed by those of \spad{b} followed ... by the elements of \spad{c}. Note: \spad{concat([a,{} b,{} ...,{} c]) = concat(a,{} concat([b,{} ...,{} c]))}.');
INSERT INTO olibdb VALUES('o','concat!',1,'x','(List(%))->%','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{concat!(lu)},{} where \spad{lu} is a list of aggregates \spad{[a,{} b,{} ...,{} c]},{} returns a single aggregate consisting of the elements of \spad{a} followed by those of \spad{b} followed ... by the elements of \spad{c}. This function may destructively modify the aggregates in \spad{lu}.');
INSERT INTO olibdb VALUES('o','concat',1,'x','(Stream(Stream(S)))->Stream(S)','pStreamFunctions1(S)',NULL,'\spad{concat(u)} returns the left-to-right concatenation of the streams in \spad{u}. Note: \spad{concat(u) = reduce(concat,{} u)}.');
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,A)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,A)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,A)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,A)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,A)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,S)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,S)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,S)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,S)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,S)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(A,S)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'n','(A,S)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(S,A)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(S,A)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(S,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(S,A)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat',2,'n','(S,A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','concat!',2,'x','(%,%)->%','cDoublyLinkedAggregate(S)','has(%,shallowlyMutable)','\spad{concat!(u,{} v)} destructively concatenates doubly-linked aggregate \spad{v} to the end of doubly-linked aggregate \spad{u}.');
INSERT INTO olibdb VALUES('o','concat!',2,'x','(%,%)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{concat!(u,{} v)} destructively appends \spad{v} to the end of \spad{u}. \spad{v} is unchanged');
INSERT INTO olibdb VALUES('o','concat',2,'x','(%,%)->%','cLinearAggregate(S)',NULL,'\spad{concat(u,{} v)} returns an aggregate consisting of the elements of \spad{u} followed by the elements of \spad{v}. Note: if \spad{w = concat(u,{} v)} then \spad{w.i = u.i for i in indices u} and \spad{w.(j + maxIndex u) = v.j for j in indices v}.');
INSERT INTO olibdb VALUES('o','concat!',2,'x','(%,%)->%','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{concat!(u,{} v)} destructively concatenates \spad{v} to the end of \spad{u}.');
INSERT INTO olibdb VALUES('o','concat',2,'x','(%,%)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{concat(u,{} v)} returns an aggregate \spad{w} consisting of the elements of \spad{u} followed by the elements of \spad{v}. Note: \spad{v = rest(w,{} \#u)}.');
INSERT INTO olibdb VALUES('o','concat!',2,'x','(%,S)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{concat!(u,{} x)} destructively adds element \spad{x} to the end of \spad{u}.');
INSERT INTO olibdb VALUES('o','concat',2,'x','(%,S)->%','cLinearAggregate(S)',NULL,'\spad{concat(u,{} x)} returns aggregate \spad{u} with additional element \spad{x} at the end. Note: for lists,{} \spad{concat(u,{} x) = concat(u,{} [x])}.');
INSERT INTO olibdb VALUES('o','concat',2,'x','(S,%)->%','cLinearAggregate(S)',NULL,'\spad{concat(x,{} u)} returns aggregate \spad{u} with additional element \spad{x} at the front. Note: for lists: \spad{concat(x,{} u) = concat([x],{} u)}.');
INSERT INTO olibdb VALUES('o','concat!',2,'x','(%,S)->%','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{concat!(u,{} x)} destructively adds element \spad{x} to the end of \spad{u}. Note: \spad{concat!(a,{} x) = concat!(a,{} [x])}.');
INSERT INTO olibdb VALUES('o','concat',2,'x','(S,%)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{concat(x,{} u)} returns aggregate consisting of \spad{x} followed by the elements of \spad{u}. Note: if \spad{v = concat(x,{} u)} then \spad{x = first v} and \spad{u = rest v}.');
INSERT INTO olibdb VALUES('o','cond',2,'n','(Switch,%)->%','dFortranCode',NULL,'\spad{cond(s,{} e)} creates a representation of the FORTRAN expression IF (\spad{s}) THEN \spad{e}.');
INSERT INTO olibdb VALUES('o','cond',3,'n','(Switch,%,%)->%','dFortranCode',NULL,'\spad{cond(s,{} e,{} f)} creates a representation of the FORTRAN expression IF (\spad{s}) THEN \spad{e} ELSE \spad{f}.');
INSERT INTO olibdb VALUES('o','condition',1,'n','(%)->C','dSplittingNode(V,C)',NULL,'\spad{condition(n)} returns the condition of the node \spad{n}.');
INSERT INTO olibdb VALUES('o','conditionP',1,'n','(Matrix(S))->Union(Vector(S),failed)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conditionP',1,'n','(Matrix(S))->Union(Vector(S),failed)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conditionP',1,'x','(Matrix(%))->Union(Vector(%),failed)','cPolynomialFactorizationExplicit','has(%,CharacteristicNonZero)','\spad{conditionP(m)} returns a vector of elements,{} not all zero,{} whose \spad{p}\spad{-}th powers (\spad{p} is the characteristic of the domain) are a solution of the homogeneous linear system represented by \spad{m},{} or failed is there is no such vector.');
INSERT INTO olibdb VALUES('o','conditions',1,'n','(%)->List(C)','dSplittingTree(V,C)',NULL,'\spad{conditions(a)} returns the list of the conditions of the leaves of a');
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',0,'n','()->List(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis');
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',0,'n','()->List(Polynomial(R))','xFramedNonAssociativeAlgebra&(S,R)',NULL,'\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',0,'x','()->List(Polynomial(R))','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',1,'n','(Vector(%))->List(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \spad{R}-module basis \spad{v1},{} ...,{} \spad{vn}');
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',1,'n','(Vector(S))->List(Polynomial(R))','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',1,'n','(Vector(S))->List(Polynomial(R))','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conditionsForIdempotents',1,'x','(Vector(%))->List(Polynomial(R))','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{conditionsForIdempotents([v1,{} ...,{} vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \spad{R}-module basis \spad{v1},{} ...,{} \spad{vn}.');
INSERT INTO olibdb VALUES('o','cone',2,'n','(%,NonNegativeInteger)->%','dFiniteSimplicialComplex(VS)',NULL,'The ''cone'' of a simplicial complex is formed by adding the vertex to every facet. ''vertex'' should not already be included in existing faces,{} this is not checked and so will lead to simplexes with duplicate vertices.');
INSERT INTO olibdb VALUES('o','conical',2,'x','(R,R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{conical(a,{} b)} transforms from conical coordinates to Cartesian coordinates: \spad{conical(a,{} b)} is a function which will map the point \spad{(lambda,{} mu,{} nu)} to \spad{x = lambda*mu*nu/(a*b)},{} \spad{y = lambda/a*sqrt((mu^2-a^2)*(nu^2-a^2)/(a^2-b^2))},{} \spad{z = lambda/b*sqrt((mu^2-b^2)*(nu^2-b^2)/(b^2-a^2))}.');
INSERT INTO olibdb VALUES('o','conj',1,'x','(%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'implements Clifford conjugate for a multivector by involution and reverse of each term separately using: grade: 0 1 2 3... multi: 1 \spad{-1} \spad{-1} 1...');
INSERT INTO olibdb VALUES('o','conjug',1,'n','(R)->R','dOperator(R)','has(R,CommutativeRing)',NULL);
INSERT INTO olibdb VALUES('o','conjug',1,'x','(R)->R','dModuleOperator(R,M)','has(R,CommutativeRing)','\spad{conjug(x)}should be local but conditional');
INSERT INTO olibdb VALUES('o','conjugate',1,'n','(%)->%','dPartition',NULL,'\spad{conjugate(p)} returns the conjugate partition of a partition \spad{p}');
INSERT INTO olibdb VALUES('o','conjugate',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{conjugate(f)} returns the conjugate value operator applied to \spad{f}.');
INSERT INTO olibdb VALUES('o','conjugate',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conjugate',1,'n','(S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conjugate',1,'n','(S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conjugate',1,'x','(%)->%','cComplexCategory(R)',NULL,'\spad{conjugate(x + \%i y)} returns \spad{x} - \%\spad{i} \spad{y}.');
INSERT INTO olibdb VALUES('o','conjugate',1,'x','(%)->%','cOctonionCategory(R)',NULL,'\spad{conjugate(o)} negates the imaginary parts \spad{i},{} \spad{j},{} \spad{k},{} \spad{E},{} \spad{I},{} \spad{J},{} \spad{K} of octonian \spad{o}.');
INSERT INTO olibdb VALUES('o','conjugate',1,'x','(%)->%','cQuaternionCategory(R)',NULL,'\spad{conjugate(q)} negates the imaginary parts of quaternion \spad{q}.');
INSERT INTO olibdb VALUES('o','conjugate',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{conjugate(x)} returns the conjugate of \spad{x}.');
INSERT INTO olibdb VALUES('o','conjugate',1,'x','(List(Integer))->List(Integer)','pPartitionsAndPermutations',NULL,'\spad{conjugate(pt)} is the conjugate of the partition \spad{pt}.');
INSERT INTO olibdb VALUES('o','conjugate',2,'n','(S,S)->S','xGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','conjugate',2,'x','(%,%)->%','cGroup',NULL,'\spad{conjugate(p,{} q)} computes \spad{inv(q) * p * q}; this is ''right action by conjugation''.');
INSERT INTO olibdb VALUES('o','conjugates',1,'x','(Stream(List(Integer)))->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{conjugates(lp)} is the stream of conjugates of a stream \indented{1}{of partitions \spad{lp}.}');
INSERT INTO olibdb VALUES('o','connect',3,'n','(%,PositiveInteger,String)->Void','dTwoDimensionalViewport',NULL,'\spad{connect(v,{} n,{} s)} displays the lines connecting the graph points in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is on,{} or does not display the lines if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','cons',2,'n','(R,%)->%','cSequenceCategory(R)',NULL,'\spad{cons(r,{} s)} prepends \spad{r} to the stream \spad{s}');
INSERT INTO olibdb VALUES('o','cons',2,'x','(S,%)->%','dList(S)',NULL,'\spad{cons(element,{} u)} appends \spad{element} onto the front of list \spad{u} and returns the new list. This new list and the old one will share some structure.');
INSERT INTO olibdb VALUES('o','cons',2,'x','(S,%)->%','dStream(S)',NULL,'\spad{cons(a,{} s)} returns a stream whose \spad{first} is \spad{a} and whose \spad{rest} is \spad{s}. Note: \spad{cons(a,{} s) = concat(a,{} s)}.');
INSERT INTO olibdb VALUES('o','consnewpol',3,'n','(SparseUnivariatePolynomial(P),SparseUnivariatePolynomial(R),Integer)->Record(pol:SparseUnivariatePolynomial(P),polval:SparseUnivariatePolynomial(R))','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{consnewpol should} be local');
INSERT INTO olibdb VALUES('o','consRow!',2,'n','(%,Record(Indices:List(C),Entries:List(D)))->Void','dSparseEchelonMatrix(C,D)',NULL,'\spad{consRow!(A,{} r)} inserts the row \spad{r} at the top of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','const?',1,'n','(%)->Boolean','cJetBundleFunctionCategory(JB)',NULL,'\spad{const?(f)} checks whether \spad{f} depends of jet variables.');
INSERT INTO olibdb VALUES('o','const',1,'n','(%)->R','dDistributedJetBundlePolynomial(R,JB,LJV,E)',NULL,'\spad{const(p)} coerces a polynomial into an element of the coefficient ring,{} if it is constant. Otherwise an error occurs.');
INSERT INTO olibdb VALUES('o','const?',1,'n','(S)->Boolean','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','const',1,'x','(C)->(A)->C','pMappingPackage2(A,C)',NULL,'\spad{const c} is a function which produces \spad{c} when \indented{1}{applied to its argument.}');
INSERT INTO olibdb VALUES('o','constant?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{constant?(p)} tests if \spad{p} contains no matching variables.');
INSERT INTO olibdb VALUES('o','constant?',1,'n','(%)->Boolean','dXPolynomialRing(R,E)',NULL,'\spad{constant?(p)} tests whether the polynomial \spad{p} belongs to the coefficient ring.');
INSERT INTO olibdb VALUES('o','constant',1,'n','(%)->R','dXPolynomialRing(R,E)',NULL,'\spad{constant(p)} return the constant term of \spad{p}.');
INSERT INTO olibdb VALUES('o','constant?',1,'x','(%)->Boolean','cXFreeAlgebra(vl,R)',NULL,'\spad{constant?(x)} returns \spad{true} if \spad{x} is constant.');
INSERT INTO olibdb VALUES('o','constant',1,'x','(()->C)->(A)->C','pMappingPackage2(A,C)',NULL,'\spad{constant(f)} is the function \spad{g} \indented{1}{such that \spad{g a= f ()}.}');
INSERT INTO olibdb VALUES('o','constant',1,'x','(F)->F','pFunctionSpaceAssertions(R,F)',NULL,'\spad{constant(x)} tells the pattern matcher that \spad{x} should match only the symbol \spad{''x} and no other quantity. Error: if \spad{x} is not a symbol.');
INSERT INTO olibdb VALUES('o','constant',1,'x','(%)->R','cXFreeAlgebra(vl,R)',NULL,'\spad{constant(x)} returns the constant term of \spad{x}.');
INSERT INTO olibdb VALUES('o','constant',1,'x','(Symbol)->Expression(Integer)','pPatternMatchAssertions',NULL,'\spad{constant(x)} tells the pattern matcher that \spad{x} should match only the symbol \spad{''x} and no other quantity.');
INSERT INTO olibdb VALUES('o','constantCoefficientRicDE',2,'n','(L,(UP)->List(F))->List(Record(constant:F,eq:L))','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{constantCoefficientRicDE(op,{} ric)} returns \spad{[[a1,{} L1],{} [a2,{} L2],{} ... ,{} [ak,{} Lk]]} such that any rational solution with no polynomial part of the associated Riccati equation of \spad{op y = 0} must be one of the \spad{ai}\spad{''s} in which case the equation for \spad{z = y e^{-int \spad{ai}}} is \spad{\spad{Li} z = 0}. \spad{ric} is a Riccati equation solver over \spad{F},{} whose input is the associated linear equation.');
INSERT INTO olibdb VALUES('o','constantIfCan',1,'x','(Kernel(S))->Union(R,failed)','pKernelFunctions2(R,S)',NULL,'\spad{constantIfCan(k)} \undocumented');
INSERT INTO olibdb VALUES('o','constantKernel',1,'x','(R)->Kernel(S)','pKernelFunctions2(R,S)',NULL,'\spad{constantKernel(r)} \undocumented');
INSERT INTO olibdb VALUES('o','constantLeft',1,'x','((B)->C)->(A,B)->C','pMappingPackage3(A,B,C)',NULL,'\spad{constantLeft(f)} is the function \spad{g} \indented{1}{such that \spad{g (a,{} b)= f b}.}');
INSERT INTO olibdb VALUES('o','constantOperator',1,'x','(A)->BasicOperator','pBasicOperatorFunctions1(A)',NULL,'\spad{constantOperator(a)} returns a nullary operator op such that \spad{op()} always evaluate to \spad{a}.');
INSERT INTO olibdb VALUES('o','constantOpIfCan',1,'x','(BasicOperator)->Union(A,failed)','pBasicOperatorFunctions1(A)',NULL,'\spad{constantOpIfCan(op)} returns \spad{a} if \spad{op} is the constant nullary operator always returning \spad{a},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','constantRight',1,'x','((A)->C)->(A,B)->C','pMappingPackage3(A,B,C)',NULL,'\spad{constantRight(f)} is the function \spad{g} \indented{1}{such that \spad{g (a,{} b)= f a}.}');
INSERT INTO olibdb VALUES('o','constant_subspace',2,'n','(List(Vector(F)),List((F)->F))->Record(transform:Matrix(F),basis:List(Vector(F)))','pConstantLinearDependence(R,F)',NULL,'\spad{constant_subspace(b,{} ld)} returns [\spad{M},{} \spad{nb}] such that \spad{nb} is basis of subspace spanned by \spad{b} over \spad{F} consistng of vectors with constant coordinates. \spad{M} is the transformation matrix,{} \spadignore{i.e.} \spad{mnb} = \spad{M} \spad{mb} where \spad{mb} (\spad{mnb} respectively) is matrix having \spad{b} (\spad{nb} respectively) as rows.');
INSERT INTO olibdb VALUES('o','constantToUnaryFunction',1,'n','(DoubleFloat)->(DoubleFloat)->DoubleFloat','pExpressionTubePlot',NULL,'\spad{constantToUnaryFunction(s)} is a local function which takes the value of \spad{s},{} which may be a function of a constant,{} and returns a function which always returns the value \spadtype{DoubleFloat} \spad{s}.');
INSERT INTO olibdb VALUES('o','constDsolve',3,'n','(L,F,Symbol)->Record(particular:F,basis:List(F))','pConstantLODE(R,F,L)',NULL,'\spad{constDsolve(op,{} g,{} x)} returns \spad{[f,{} [y1,{} ...,{} ym]]} where \spad{f} is a particular solution of the equation \spad{op y = g},{} and the \spad{\spad{yi}}\spad{''s} form a basis for the solutions of \spad{op y = 0}.');
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(List(List(R))))->%','dThreeDimensionalMatrix(R)',NULL,'\spad{construct(lll)} creates a 3-\spad{D} matrix from a List List List \spad{R} \spad{lll}');
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(P))->S','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(Record(key:Symbol,entry:S)))->%','dPatternMatchResult(R,S)',NULL,'\spad{construct([v1,{} e1],{} ...,{} [vn,{} en])} returns the match result containing the matches (\spad{v1},{} \spad{e1}),{} ...,{} (\spad{vn},{} en).');
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(Record(k:S,c:A)))->%','cIndexedProductCategory(A,S)',NULL,'\spad{construct(l)} takes a list of terms and creates the object with these components. First components of elements of \spad{l} should be different.');
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(Record(val:V,tower:C)))->List(%)','dSplittingNode(V,C)',NULL,'\spad{construct(lvt)} returns the same as \spad{[construct(vt.val,{} vt.tower) for vt in lvt]}');
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(S))->A','xBagAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(S))->A','xDictionaryOperations&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(S))->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(S))->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(List(S))->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','construct',1,'n','(Record(val:V,tower:C))->%','dSplittingNode(V,C)',NULL,'\spad{construct(vt)} returns the same as \spad{construct(vt.val,{} vt.tower)}');
INSERT INTO olibdb VALUES('o','construct',1,'n','(SplittingNode(V,C))->%','dSplittingTree(V,C)',NULL,'\spad{construct(s)} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \spad{s} and no children. Thus,{} if the status of \spad{s} is \spad{false},{} \spad{[s]} represents the starting point of the evaluation \spad{value(s)} under the hypothesis \spad{condition(s)}.');
INSERT INTO olibdb VALUES('o','construct',1,'x','(List(Record(exponent:NonNegativeInteger,center:UP,num:UP)))->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{construct(l)} is the inverse of fracPart.');
INSERT INTO olibdb VALUES('o','construct',1,'x','(List(S))->%','cCollection(S)',NULL,'\spad{construct([x,{} y,{} ...,{} z])} returns the collection of elements \spad{x,{} y,{} ...,{} z} ordered as given. Equivalently written as \spad{[x,{} y,{} ...,{} z]\$D},{} where \spad{D} is the domain. \spad{D} may be omitted for those of type List.');
INSERT INTO olibdb VALUES('o','construct',1,'x','(%)->Stream(S)','dInfiniteTuple(S)',NULL,'\spad{construct(t)} converts an infinite tuple to a stream.');
INSERT INTO olibdb VALUES('o','construct',2,'n','(A,B)->%','dProduct(A,B)',NULL,'\spad{construct(a,{} b)} creates element of the product with components a and \spad{b}.');
INSERT INTO olibdb VALUES('o','construct',2,'n','(IS,E)->%','dModuleMonomial(IS,E,ff)',NULL,'\spad{construct(i,{} e)} \undocumented');
INSERT INTO olibdb VALUES('o','construct',2,'n','(%,LyndonWord(VarSet))->%','dLiePolynomial(VarSet,R)',NULL,'\spad{construct(x,{} y)} returns the Lie bracket \spad{[x,{} y]}.');
INSERT INTO olibdb VALUES('o','construct',2,'n','(LyndonWord(VarSet),%)->%','dLiePolynomial(VarSet,R)',NULL,'\spad{construct(x,{} y)} returns the Lie bracket \spad{[x,{} y]}.');
INSERT INTO olibdb VALUES('o','construct',2,'n','(LyndonWord(VarSet),LyndonWord(VarSet))->%','dLiePolynomial(VarSet,R)',NULL,'\spad{construct(x,{} y)} returns the Lie bracket \spad{[x,{} y]}.');
INSERT INTO olibdb VALUES('o','construct',2,'n','(OutputForm,List(OutputForm))->OutputForm','pOutputFormTools',NULL,'\spad{construct(op,{} la)} creates OutputForm with operator \spad{op} and arguments la');
INSERT INTO olibdb VALUES('o','construct',2,'n','(S1,S2)->%','dSuchThat(S1,S2)',NULL,'\spad{construct(s,{} t)} makes a form \spad{s:} \spad{t}');
INSERT INTO olibdb VALUES('o','construct',2,'n','(V,C)->%','dSplittingNode(V,C)',NULL,'\spad{construct(v,{} t)} returns the same as \spad{construct(v,{} t,{} false)}');
INSERT INTO olibdb VALUES('o','construct',2,'n','(V,List(C))->List(%)','dSplittingNode(V,C)',NULL,'\spad{construct(v,{} lt)} returns the same as \spad{[construct(v,{} t) for t in lt]}');
INSERT INTO olibdb VALUES('o','construct',2,'x','(%,%)->%','cLieAlgebra(R)',NULL,'\spad{construct(x,{} y)} returns the Lie bracket of \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','construct',3,'n','(Union(fst:FortranScalarType,void:void),List(Polynomial(Integer)),Boolean)->%','dFortranType',NULL,'\spad{construct(type,{} dims)} creates an element of FortranType');
INSERT INTO olibdb VALUES('o','construct',3,'n','(Union(fst:FortranScalarType,void:void),List(Symbol),Boolean)->%','dFortranType',NULL,'\spad{construct(type,{} dims)} creates an element of FortranType');
INSERT INTO olibdb VALUES('o','construct',3,'n','(V,C,Boolean)->%','dSplittingNode(V,C)',NULL,'\spad{construct(v,{} t,{} b)} returns the non-empty node with value \spad{v},{} condition \spad{t} and flag \spad{b}');
INSERT INTO olibdb VALUES('o','construct',3,'n','(V,C,List(%))->%','dSplittingTree(V,C)',NULL,'\spad{construct(v,{} t,{} la)} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \spad{[v,{} t]\$S} and with \spad{la} as children list.');
INSERT INTO olibdb VALUES('o','construct',3,'n','(V,C,List(SplittingNode(V,C)))->%','dSplittingTree(V,C)',NULL,'\spad{construct(v,{} t,{} ls)} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \spad{[v,{} t]\$S} and with children list given by \spad{[[s]\$\% for s in ls]}.');
INSERT INTO olibdb VALUES('o','construct',4,'n','(V,C,V,List(C))->%','dSplittingTree(V,C)',NULL,'\spad{construct(v1,{} t,{} v2,{} lt)} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \spad{[v,{} t]\$S} and with children list given by \spad{[[[v,{} t]\$S]\$\% for s in ls]}.');
INSERT INTO olibdb VALUES('o','construct',4,'x','(Sequence(R),Sequence(R),Sequence(R),Sequence(R))->%','dDistribution(R)',NULL,'\spad{construct(mom,{} ccum,{} fcum,{} bcum)} constructs a distribution with moments \spad{mom},{} classical cumulants \spad{ccum},{} free cumulants \spad{fcum} and boolean cumulants \spad{bcum}. The user must make sure that these are consistent,{} otherwise the results are unpredictable!');
INSERT INTO olibdb VALUES('o','constructOrdered',1,'n','(List(Record(k:S,c:A)))->%','cIndexedProductCategory(A,S)','has(S,Comparable)','\spad{constructOrdered(l)} takes a list of terms and creates the object with these components. The list is assumed to be sorted (in reverse order) with respect to the ordering of \spad{S}. If \spad{R} is a monoid,{} then the list is assumed to contain no zero elements. Caution: No checking is performed,{} so this should only be used in cases where those conditions are assured. If in doubt use \spad{construct}.');
INSERT INTO olibdb VALUES('o','contains?',2,'x','(%,R)->Boolean','cIntervalCategory(R)',NULL,'\spad{contains?(i,{} f)} returns \spad{true} if \spad{f} is contained within the interval \spad{i},{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','containsPoint?',2,'n','(%,PT)->Boolean','dSBoundary(PT)',NULL,'\spad{containsPoint?(n,{} p)} returns \spad{true} if the point is inside \indented{2}{the boundary.} \spad{n} is the boundary \spad{p} is the point');
INSERT INTO olibdb VALUES('o','content',1,'n','(List(BP))->List(Integer)','pHeuGcd(BP)',NULL,'\spad{content([f1,{} ..,{} fk])} = content of a list of univariate polynonials');
INSERT INTO olibdb VALUES('o','content',1,'n','(S)->R','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',1,'n','(S)->R','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',1,'n','(S)->R','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',1,'n','(S)->R','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',1,'x','(%)->R','cFiniteAbelianMonoidRing(R,E)','has(R,GcdDomain)','\spad{content(p)} gives the \spad{gcd} of the coefficients of polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','content',2,'n','(S,SingletonAsOrderedSet)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',2,'n','(S,VarSet)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','content',2,'x','(%,VarSet)->%','cPolynomialCategory(R,E,VarSet)','has(R,GcdDomain)','\spad{content(p,{} v)} is the \spad{gcd} of the coefficients of the polynomial \spad{p} when \spad{p} is viewed as a univariate polynomial with respect to the variable \spad{v}. Thus,{} for polynomial 7*x^2*y + 14*x*y^2,{} the \spad{gcd} of the coefficients with respect to \spad{x} is 7*y.');
INSERT INTO olibdb VALUES('o','continue',1,'n','(SingleInteger)->%','dFortranCode',NULL,'\spad{continue(l)} creates a representation of a FORTRAN CONTINUE labelled with \spad{l}');
INSERT INTO olibdb VALUES('o','continuedFraction',1,'n','(%)->ContinuedFraction(Fraction(Integer))','dBalancedPAdicRational(p)',NULL,NULL);
INSERT INTO olibdb VALUES('o','continuedFraction',1,'n','(%)->ContinuedFraction(Fraction(Integer))','dPAdicRationalConstructor(p,PADIC)',NULL,'\spad{continuedFraction(x)} converts the \spad{p}-adic rational number \spad{x} to a continued fraction.');
INSERT INTO olibdb VALUES('o','continuedFraction',1,'n','(%)->ContinuedFraction(Fraction(Integer))','dPAdicRational(p)',NULL,NULL);
INSERT INTO olibdb VALUES('o','continuedFraction',1,'x','(F)->ContinuedFraction(Integer)','pNumericContinuedFraction(F)',NULL,'\spad{continuedFraction(f)} converts the floating point number \spad{f} to a reduced continued fraction.');
INSERT INTO olibdb VALUES('o','continuedFraction',1,'x','(Fraction(R))->%','dContinuedFraction(R)',NULL,'\spad{continuedFraction(r)} converts the fraction \spadvar{\spad{r}} with components of type \spad{R} to a continued fraction over \spad{R}.');
INSERT INTO olibdb VALUES('o','continuedFraction',3,'x','(R,Stream(R),Stream(R))->%','dContinuedFraction(R)',NULL,'\spad{continuedFraction(b0,{} a,{} b)} constructs a continued fraction in the following way: if \spad{a = [a1,{} a2,{} ...]} and \spad{b = [b1,{} b2,{} ...]} then the result is the continued fraction \spad{b0 + a1/(b1 + a2/(b2 + ...))}.');
INSERT INTO olibdb VALUES('o','contraAdjoint',2,'n','(%,List(NonNegativeInteger))->Union(List(NonNegativeInteger),failed)','dFunctionGraph(S)',NULL,'given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph');
INSERT INTO olibdb VALUES('o','contraAdjoint',2,'n','(%,List(NonNegativeInteger))->Union(List(NonNegativeInteger),failed)','dMultifunctionGraph(S)',NULL,'given a mapping from this graph this function tries to calculate a unique reverse mapping back to this graph');
INSERT INTO olibdb VALUES('o','contract',2,'n','(JetVectorField(JB,D),%)->D','dJetDifferential(JB,D)',NULL,'\spad{contract(v,{} om)} computes the interior derivative of \spad{om} with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','contract',2,'x','(PolynomialIdeal(Fraction(Integer),DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl),DistributedMultivariatePolynomial(vl,Fraction(Integer))),List(OrderedVariableList(vl)))->PolynomialIdeal(Fraction(Integer),DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl),DistributedMultivariatePolynomial(vl,Fraction(Integer)))','pIdealDecompositionPackage(vl)',NULL,'\spad{contract(I,{} lvar)} contracts the ideal \spad{I} to the polynomial ring \spad{F[lvar]}.');
INSERT INTO olibdb VALUES('o','contract',3,'x','(%,Integer,Integer)->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{contract(t,{} i,{} j)} is the contraction of tensor \spad{t} which sums along the \spad{i}\spad{-}th and \spad{j}\spad{-}th indices. For example,{} if \spad{r = contract(t,{} 1,{} 3)} for a rank 4 tensor \spad{t},{} then \spad{r} is the rank 2 \spad{(= 4 - 2)} tensor given by \indented{4}{\spad{r(i,{} j) = sum(h=1..dim,{} t(h,{} i,{} h,{} j))}.}');
INSERT INTO olibdb VALUES('o','contract',4,'x','(%,Integer,%,Integer)->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{contract(t,{} i,{} s,{} j)} is the inner product of tenors \spad{s} and \spad{t} which sums along the \spad{k1}\spad{-}th index of \spad{t} and the \spad{k2}\spad{-}th index of \spad{s}. For example,{} if \spad{r = contract(s,{} 2,{} t,{} 1)} for rank 3 tensors rank 3 tensors \spad{s} and \spad{t},{} then \spad{r} is the rank 4 \spad{(= 3 + 3 - 2)} tensor given by \indented{4}{\spad{r(i,{} j,{} k,{} l) = sum(h=1..dim,{} s(i,{} h,{} j)*t(h,{} k,{} l))}.}');
INSERT INTO olibdb VALUES('o','contractSolve',2,'x','(Equation(Fraction(Polynomial(R))),Symbol)->SuchThat(List(Expression(R)),List(Equation(Expression(R))))','pRadicalSolvePackage(R)',NULL,'\spad{contractSolve(eq,{} x)} finds the solutions expressed in terms of radicals of the equation of rational functions \spad{eq} with respect to the symbol \spad{x}. The result contains new symbols for common subexpressions in order to reduce the size of the output.');
INSERT INTO olibdb VALUES('o','contractSolve',2,'x','(Fraction(Polynomial(R)),Symbol)->SuchThat(List(Expression(R)),List(Equation(Expression(R))))','pRadicalSolvePackage(R)',NULL,'\spad{contractSolve(rf,{} x)} finds the solutions expressed in terms of radicals of the equation \spad{rf} = 0 with respect to the symbol \spad{x},{} where \spad{rf} is a rational function. The result contains new symbols for common subexpressions in order to reduce the size of the output.');
INSERT INTO olibdb VALUES('o','controlPanel',2,'n','(%,String)->Void','dTwoDimensionalViewport',NULL,'\spad{controlPanel(v,{} s)} displays the control panel of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is on,{} or hides the control panel if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','controlPanel',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{controlPanel(v,{} s)} displays the control panel of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is on,{} or hides the control panel if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','convergents',1,'x','(%)->Stream(Fraction(R))','dContinuedFraction(R)',NULL,'\spad{convergents(x)} returns the stream of the convergents of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->DoubleFloat','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->Float','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->InputForm','xCollection&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->InputForm','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->Pattern(Float)','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(A)->Pattern(Integer)','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(CS)->Pattern(R)','pComplexPattern(R,S,CS)',NULL,'\spad{convert(cs)} converts the complex expression \spad{cs} to a pattern');
INSERT INTO olibdb VALUES('o','convert',1,'n','(Factored(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(%)->JetBundlePolynomial(R,JB)','dDistributedJetBundlePolynomial(R,JB,LJV,E)',NULL,'\spad{convert(p)} converts a polynomial \spad{p} in distributive representation into a polynomial in recursive representation.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(JetBundlePolynomial(R,JB))->%','dDistributedJetBundlePolynomial(R,JB,LJV,E)',NULL,'\spad{convert(p)} converts a polynomial \spad{p} in recursive representation into a polynomial in distributive representation.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(LinearOrdinaryDifferentialOperator1(R))->LinearOrdinaryDifferentialOperator3(Coeff,Ab,R)','pLODOConvertions(Coeff,Ab,R)',NULL,'\spad{convert(l1)} converts an operator \spad{l1} from \spadtype{LinearOrdinaryDifferentialOperator1} to \spadtype{LinearOrdinaryDifferentialOperator3} such that the resultant operator gives the same result as the original one on application to an element of domain \spad{R}.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(LinearOrdinaryDifferentialOperator3(Coeff,Ab,R))->LinearOrdinaryDifferentialOperator1(R)','pLODOConvertions(Coeff,Ab,R)',NULL,'\spad{convert(l3)} converts an operator \spad{l3} from \spadtype{LinearOrdinaryDifferentialOperator3} to \spadtype{LinearOrdinaryDifferentialOperator1} such that the resultant operator gives the same result as the original one on application to an element of domain \spad{R}.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(List(%))->%','dPattern(R)',NULL,'\spad{convert([a1,{} ...,{} an])} returns the pattern \spad{[a1,{} ...,{} an]}.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(List(P))->%','dGeneralPolynomialSet(R,E,VarSet,P)',NULL,'\spad{convert(lp)} returns the polynomial set whose members are the polynomials of \spad{lp}.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(Polynomial(Fraction(Integer)))->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Polynomial(Integer))->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Polynomial(R))->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->%','cConvertibleFrom(S)',NULL,'\spad{convert(a)} transforms a into element of \%.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Complex(DoubleFloat)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Complex(Float)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->DoubleFloat','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->DoubleFloat','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(SExpression)->%','dInputForm',NULL,'\spad{convert(s)} makes \spad{s} into an input form.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Float','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Float','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xFinite&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->InputForm','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Integer','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(SparseUnivariatePolynomial(R))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Float)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Float)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Float)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Float)','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Float)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Integer)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Integer)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Integer)','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Integer)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Pattern(Integer)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Polynomial(R)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->SparseUnivariatePolynomial(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->String','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->UP','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Vector(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Vector(R)','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Vector(R)','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(S)->Vector(R)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(%)->Symbol','dSingletonAsOrderedSet',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(UP)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Vector(R))->%','cFramedModule(R)',NULL,'\spad{convert([a1,{} ..,{} an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed basis.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(%)->Vector(R)','cFramedModule(R)',NULL,'\spad{convert(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','convert',1,'n','(Vector(R))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Vector(R))->S','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Vector(R))->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'n','(Vector(R))->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'x','(DoubleFloat)->%','dFloat',NULL,'\spad{convert(x)} converts a \spadtype{DoubleFloat} \spad{x} to a \spadtype{Float}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Factored(%))->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{convert(f1\^e1 ... fm\^em)} returns \spad{(f1)\^e1 ... (fm)\^em} as an element of \%,{} using formal kernels created using a \spadfunFrom{paren}{ExpressionSpace}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Flt)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{convert(x)} returns the Lisp atom \spad{x}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Int)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{convert(x)} returns the Lisp atom \spad{x}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(List(%))->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{convert([a1,{} ...,{} an])} returns the \spad{S}-expression \spad{(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(List(R))->%','cPointCategory(R)',NULL,'\spad{convert(l)} takes a list of elements,{} \spad{l},{} from the domain Ring and returns the form of point category.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls2)))->Polynomial(RealClosure(Fraction(R)))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{convert(q)} converts \spad{q}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls)))->NewSparseMultivariatePolynomial(R,OrderedVariableList(ls2))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{convert(q)} converts \spad{q}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Polynomial(Fraction(Integer)))->%','cRecursivePolynomialCategory(R,E,V)','AND(has(R,Algebra(Fraction(Integer))),has(V,ConvertibleTo(Symbol)))','\spad{convert(p)} returns the same as \spad{retract(p)}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Polynomial(Integer))->%','cRecursivePolynomialCategory(R,E,V)','AND(has(R,Algebra(Integer)),has(V,ConvertibleTo(Symbol)))','\spad{convert(p)} returns the same as \spad{retract(p)}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Polynomial(R))->%','cRecursivePolynomialCategory(R,E,V)','has(V,ConvertibleTo(Symbol))','\spad{convert(p)} returns the same as \spad{retract(p)}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Polynomial(R))->Polynomial(RealClosure(Fraction(R)))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{convert(p)} converts \spad{p}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Record(val:List(P),tower:TS))->String','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'x','(Record(val:List(P),tower:TS))->String','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert',1,'x','(%)->S','cConvertibleTo(S)',NULL,'\spad{convert(a)} transforms a into an element of \spad{S}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(S)->%','cSegmentCategory(S)',NULL,'\spad{convert(i)} creates the segment \spad{i..i}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(SparseUnivariatePolynomial(R))->SparseUnivariatePolynomial(RealClosure(Fraction(R)))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{convert(u)} converts \spad{u}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(SquareFreeRegularTriangularSet(R,IndexedExponents(OrderedVariableList(ls2)),OrderedVariableList(ls2),NewSparseMultivariatePolynomial(R,OrderedVariableList(ls2))))->List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls2)))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{convert(st)} returns the members of \spad{st}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(SquareMatrix(n,R))->%','dLieSquareMatrix(n,R)',NULL,'converts a SquareMatrix to a LieSquareMatrix');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Str)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{convert(x)} returns the Lisp atom \spad{x}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Symbol)->%','dRomanNumeral',NULL,'\spad{convert(n)} creates a roman numeral for symbol \spad{n}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(Sym)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{convert(x)} returns the Lisp atom \spad{x}.');
INSERT INTO olibdb VALUES('o','convert',1,'x','(UP)->%','cMonogenicAlgebra(R,UP)',NULL,'\spad{convert(up)} converts the univariate polynomial \spad{up} to an algebra element,{} reducing by the \spad{definingPolynomial()} if necessary.');
INSERT INTO olibdb VALUES('o','convert',2,'n','(List(S),List(FreeGroup(S)))->GroupPresentation','pGroupPresentationFunctions1(S)',NULL,'\spad{convert(lg,{} lr)} builds group presentation from list of generators \spad{lg} and list of relations \spad{lr}.');
INSERT INTO olibdb VALUES('o','convert',2,'n','(OutputForm,Integer)->%','cOutputFormatterCategory',NULL,'\spad{convert(o,{} step)} changes \spad{o} in standard output format to given format and also adds the given step number.');
INSERT INTO olibdb VALUES('o','convert',2,'n','(OutputForm,Integer)->%','dTexFormat',NULL,'\spad{convert(o,{} step)} changes \spad{o} in standard output format to TeX format and also adds the given step number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter step numbers.');
INSERT INTO olibdb VALUES('o','convert',3,'n','(OutputForm,Integer,OutputForm)->%','dTexFormat',NULL,'\spad{convert(o,{} step,{} type)} changes \spad{o} in standard output format to TeX format and also adds the given \spad{step} number and type. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \spad{step} numbers.');
INSERT INTO olibdb VALUES('o','convert_mr',3,'n','(Record(mantissa:Integer,exponent:Integer),Integer,Record(default?:Boolean,trim_trailing_zeros?:Boolean,out_mode:String,spacing:Integer,separator:Character))->String','pFloatingPointConvertion',NULL,NULL);
INSERT INTO olibdb VALUES('o','convert_to_decimal',2,'n','(Record(mantissa:Integer,exponent:Integer),Integer)->Record(mantissa:Integer,exponent:Integer)','pFloatingPointConvertion',NULL,NULL);
INSERT INTO olibdb VALUES('o','coord',1,'x','((Point(DoubleFloat))->Point(DoubleFloat))->%','dDrawOption',NULL,'\spad{coord(p)} specifies a change of coordinates of point \spad{p}. This option is expressed in the form \spad{coord == p}.');
INSERT INTO olibdb VALUES('o','coord',2,'n','(HomogeneousDistributedMultivariatePolynomial(lv,F),List(HomogeneousDistributedMultivariatePolynomial(lv,F)))->Vector(F)','pLinGroebnerPackage(lv,F)',NULL,'\spad{coord }\undocumented');
INSERT INTO olibdb VALUES('o','coord',2,'n','(List(DrawOption),(Point(DoubleFloat))->Point(DoubleFloat))->(Point(DoubleFloat))->Point(DoubleFloat)','pDrawOptionFunctions0',NULL,'\spad{coord(l,{} p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{coord}. If the option does not exist the value,{} \spad{p} is returned.');
INSERT INTO olibdb VALUES('o','coordinate',2,'x','(%,NonNegativeInteger)->ComponentFunction','dParametricPlaneCurve(ComponentFunction)',NULL,'\spad{coordinate(c,{} i)} returns a coordinate function for \spad{c} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component \spad{i} of the plane curve is.');
INSERT INTO olibdb VALUES('o','coordinate',2,'x','(%,NonNegativeInteger)->ComponentFunction','dParametricSpaceCurve(ComponentFunction)',NULL,'\spad{coordinate(c,{} i)} returns a coordinate function of \spad{c} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component,{} \spad{i},{} of the space curve is.');
INSERT INTO olibdb VALUES('o','coordinate',2,'x','(%,NonNegativeInteger)->ComponentFunction','dParametricSurface(ComponentFunction)',NULL,'\spad{coordinate(s,{} i)} returns a coordinate function of \spad{s} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component,{} \spad{i},{} of the surface is.');
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(R)','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(R)','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(S)->Vector(R)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(%))->Matrix(R)','cFramedModule(R)',NULL,'\spad{coordinates([v1,{} ...,{} vm])} returns the coordinates of the \spad{vi}\spad{''s} with to the fixed basis. The coordinates of \spad{vi} are contained in the \spad{i}th row of the matrix returned by this function.');
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(%)->Vector(R)','cFramedModule(R)',NULL,'\spad{coordinates(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(R)','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(R)','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'n','(Vector(S))->Matrix(R)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',1,'x','((Point(DoubleFloat))->Point(DoubleFloat))->%','dDrawOption',NULL,'\spad{coordinates(p)} specifies a change of coordinate systems of point \spad{p}. This option is expressed in the form \spad{coordinates == p}.');
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xFiniteRankAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(S,Vector(S))->Vector(R)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(R),%)->Vector(R)','dVectorSpaceBasis(R)',NULL,'\spad{coordinates(v,{} B)} computes the coordinates of the vector \spad{v} in the basis \spad{B} if possible and produces an error otherwise.');
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xFiniteRankAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'n','(Vector(S),Vector(S))->Matrix(R)','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coordinates',2,'x','(Matrix(R),List(Matrix(R)))->Vector(R)','pStructuralConstantsPackage(R)',NULL,'\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \spad{a} with respect to the \spad{R}-module basis \spad{v1},{} ...,{} \spad{vn}.');
INSERT INTO olibdb VALUES('o','coordinates',2,'x','(Vector(%),Vector(%))->Matrix(R)','cFiniteRankAlgebra(R,UP)',NULL,'\spad{coordinates([v1,{} ...,{} vm],{} basis)} returns the coordinates of the \spad{vi}\spad{''s} with to the basis \spad{basis}. The coordinates of \spad{vi} are contained in the \spad{i}th row of the matrix returned by this function.');
INSERT INTO olibdb VALUES('o','coordinates',2,'x','(Vector(%),Vector(%))->Matrix(R)','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{coordinates([a1,{} ...,{} am],{} [v1,{} ...,{} vn])} returns a matrix whose \spad{i}-th row is formed by the coordinates of \spad{\spad{ai}} with respect to the \spad{R}-module basis \spad{v1},{} ...,{} \spad{vn}.');
INSERT INTO olibdb VALUES('o','coordinates',2,'x','(%,Vector(%))->Vector(R)','cFiniteRankAlgebra(R,UP)',NULL,'\spad{coordinates(a,{} basis)} returns the coordinates of \spad{a} with respect to the basis \spad{basis}.');
INSERT INTO olibdb VALUES('o','coordinates',2,'x','(%,Vector(%))->Vector(R)','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{coordinates(a,{} [v1,{} ...,{} vn])} returns the coordinates of \spad{a} with respect to the \spad{R}-module basis \spad{v1},{} ...,{} \spad{vn}.');
INSERT INTO olibdb VALUES('o','coordinatesIfCan',2,'n','(Vector(R),%)->Union(Vector(R),failed)','dVectorSpaceBasis(R)',NULL,'\spad{coordinatesIfCan(v,{} B)} computes the coordinates of the vector \spad{v} in the basis \spad{B} if possible and returns \spad{failed} otherwise.');
INSERT INTO olibdb VALUES('o','copies',2,'x','(Integer,String)->String','pDisplayPackage',NULL,'\spad{copies(i,{} s)} will take a string \spad{s} and create a new string composed of \spad{i} copies of \spad{s}.');
INSERT INTO olibdb VALUES('o','coproduct',1,'x','(%)->MxM','cCoalgebra(R,MxM)',NULL,'\spad{coproduct(x)} computes the coproduct of an element \spad{x}');
INSERT INTO olibdb VALUES('o','copy',1,'n','(A)->A','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'n','(A)->A','xDictionaryOperations&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'n','(A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'n','(A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{copy(f)} gives a copy of the element \spad{f}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dJetDifferentialEquation(JB,D)',NULL,'\spad{copy(De)} returns a copy of the equation \spad{De}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dJetDifferential(JB,D)',NULL,'\spad{copy(om)} returns a copy of the differential \spad{om}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dJetVectorField(JB,D)',NULL,'\spad{copy(v)} returns a copy of the vector field \spad{v}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{copy(p)} returns a copy of the linear pencil \spad{p}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dPattern(R)',NULL,'\spad{copy(p)} returns a recursive copy of \spad{p}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{copy(A)} returns a copy of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dSplittingNode(V,C)',NULL,'\spad{copy(n)} returns a copy of \spad{n}.');
INSERT INTO olibdb VALUES('o','copy',1,'n','(%)->%','dSubSpaceComponentProperty',NULL,'\spad{copy(x)} \undocumented');
INSERT INTO olibdb VALUES('o','copy',1,'n','(S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'n','(S)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copy',1,'x','(%)->%','cAggregate',NULL,'\spad{copy(u)} returns a top-level (non-recursive) copy of \spad{u}. Note: for collections,{} \spad{copy(u) = [x for x in u]}.');
INSERT INTO olibdb VALUES('o','copy',1,'x','(%)->%','cIntegerNumberSystem',NULL,'\spad{copy(n)} gives a copy of \spad{n}.');
INSERT INTO olibdb VALUES('o','copy',1,'x','(%)->%','cThreeSpaceCategory(R)',NULL,'\spad{copy(s)} returns a new \spadtype{ThreeSpace} that is an exact copy of \spad{s}.');
INSERT INTO olibdb VALUES('o','copy',1,'x','(%)->%','dBasicOperator',NULL,'\spad{copy(op)} returns a copy of \spad{op}.');
INSERT INTO olibdb VALUES('o','copy',2,'n','(%,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{copy(f,{} alpha)} gives a copy of element \spad{f} multiplied by alpha.');
INSERT INTO olibdb VALUES('o','copy!',2,'n','(Matrix(R),Matrix(R))->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{copy!(c,{} a)} copies the matrix \spad{a} into the matrix \spad{c}. Error: if \spad{a} and \spad{c} do not have the same dimensions.');
INSERT INTO olibdb VALUES('o','copy_first',3,'n','(U32Vector,U32Vector,Integer)->Void','pU32VectorPolynomialOperations',NULL,'\spad{copy_first(v1,{} v2,{} n)} copies first \spad{n} elements of \spad{v2} into \spad{n} first positions in \spad{v1}.');
INSERT INTO olibdb VALUES('o','copyInto!',3,'n','(A,A,Integer)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copyInto!',3,'n','(A,A,Integer)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','copyInto!',3,'x','(%,%,Integer)->%','cLinearAggregate(S)','AND(has(%,finiteAggregate),has(%,shallowlyMutable))','\spad{copyInto!(u,{} v,{} i)} returns aggregate \spad{u} containing a copy of \spad{v} inserted at element \spad{i}.');
INSERT INTO olibdb VALUES('o','copy_mat_part',2,'n','(MMT,Integer)->MMT','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{copy_mat_part(man,{} nr)} creates copy of modular composition matrix stored in first \spad{nr} rows of mat.');
INSERT INTO olibdb VALUES('o','copy_poly',3,'n','(PA,Integer,MD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{copy_poly(pol,{} d,{} m)} creates copy of \spad{pol} with enough space to represent polynomials of degree smaller than \spad{d}. Error if degree of \spad{pol} is bigger or equal than \spad{d}.');
INSERT INTO olibdb VALUES('o','copy_slice',4,'n','(U32Vector,U32Vector,Integer,Integer)->Void','pU32VectorPolynomialOperations',NULL,'\spad{copy_slice(v1,{} v2,{} m,{} n)} copies the slice of \spad{v2} starting at \spad{m} elements and having \spad{n} elements into corresponding positions in \spad{v1}.');
INSERT INTO olibdb VALUES('o','corrPoly',6,'n','(SparseUnivariatePolynomial(P),List(OV),List(R),List(NonNegativeInteger),List(SparseUnivariatePolynomial(P)),(SparseUnivariatePolynomial(R))->Union(List(SparseUnivariatePolynomial(R)),failed))->Union(List(SparseUnivariatePolynomial(P)),failed)','pMultivariateLifting(E,OV,R,P)',NULL,'\spad{corrPoly(u,{} lv,{} lr,{} ln,{} lu,{} bsolv)} solves polynomial equation system u/f = sum(ai/lu(\spad{i})) where \spad{f} is product of \spad{lu}(\spad{i}) and deg(\spad{ai}) < deg(\spad{lu}(\spad{i})) using modular method. corrPoly returns failed if there are no solution. \spad{lv} is list of variables,{} \spad{lr} is list of corresponding evaluation points,{} bsolv is solver over \spad{R} specialized for modular images of \spad{lu}.');
INSERT INTO olibdb VALUES('o','cos',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{cos(x)} represents the Fortran intrinsic function COS');
INSERT INTO olibdb VALUES('o','cos',1,'n','(E)->%','dFourierComponent(E)',NULL,'\spad{cos(x)} makes a cos kernel for use in Fourier series');
INSERT INTO olibdb VALUES('o','cos',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{cos(x)} applies the cosine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','cos',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cos',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cos',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{cos(st)} computes cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cos',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{cos(st)} computes cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cos',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{cos(z)} returns the cosine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','cos',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{cos(z)} returns the cosine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','cos',1,'x','(%)->%','cTrigonometricFunctionCategory',NULL,'\spad{cos(x)} returns the cosine of \spad{x}.');
INSERT INTO olibdb VALUES('o','cos2sec',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{cos2sec(f)} converts every \spad{cos(u)} appearing in \spad{f} into \spad{1/sec(u)}.');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{cosh(x)} represents the Fortran intrinsic function COSH');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{cosh(x)} applies the hyperbolic cosine operator to \spad{x}');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cosh',1,'n','(S)->S','xHyperbolicFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cosh',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cosh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{cosh(st)} computes the hyperbolic cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{cosh(st)} computes the hyperbolic cosine of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{cosh(z)} returns the hyperbolic cosine of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','cosh',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{cosh(z)} returns the hyperbolic cosine of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','cosh',1,'x','(%)->%','cHyperbolicFunctionCategory',NULL,'\spad{cosh(x)} returns the hyperbolic cosine of \spad{x}.');
INSERT INTO olibdb VALUES('o','cosh2sech',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{cosh2sech(f)} converts every \spad{cosh(u)} appearing in \spad{f} into \spad{1/sech(u)}.');
INSERT INTO olibdb VALUES('o','coshIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{coshIfCan(z)} returns cosh(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','cosIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{cosIfCan(z)} returns cos(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','cosSinInfo',1,'n','(Integer)->List(List(DoubleFloat))','pTubePlotTools',NULL,'\spad{cosSinInfo(n)} returns the list of lists of values for \spad{n},{} in the form: \spad{[[cos(n - 1) a,{} sin(n - 1) a],{} ...,{} [cos 2 a,{} sin 2 a],{} [cos a,{} sin a]]} where \spad{a = 2 pi/n}. Note: \spad{n} should be greater than 2.');
INSERT INTO olibdb VALUES('o','cot',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{cot(x)} applies the cotangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','cot',1,'n','(S)->S','xTrigonometricFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cot',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cot',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{cot(st)} computes cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cot',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{cot(st)} computes cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','cot',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{cot(z)} returns the cotangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','cot',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{cot(z)} returns the cotangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','cot',1,'x','(%)->%','cTrigonometricFunctionCategory',NULL,'\spad{cot(x)} returns the cotangent of \spad{x}.');
INSERT INTO olibdb VALUES('o','cot2tan',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{cot2tan(f)} converts every \spad{cot(u)} appearing in \spad{f} into \spad{1/tan(u)}.');
INSERT INTO olibdb VALUES('o','cot2trig',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{cot2trig(f)} converts every \spad{cot(u)} appearing in \spad{f} into \spad{cos(u)/sin(u)}.');
INSERT INTO olibdb VALUES('o','coth',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{coth(x)} applies the hyperbolic cotangent operator to \spad{x}');
INSERT INTO olibdb VALUES('o','coth',1,'n','(S)->S','xHyperbolicFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coth',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coth',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{coth(st)} computes the hyperbolic cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','coth',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{coth(st)} computes the hyperbolic cotangent of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','coth',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{coth(z)} returns the hyperbolic cotangent of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','coth',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{coth(z)} returns the hyperbolic cotangent of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','coth',1,'x','(%)->%','cHyperbolicFunctionCategory',NULL,'\spad{coth(x)} returns the hyperbolic cotangent of \spad{x}.');
INSERT INTO olibdb VALUES('o','coth2tanh',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{coth2tanh(f)} converts every \spad{coth(u)} appearing in \spad{f} into \spad{1/tanh(u)}.');
INSERT INTO olibdb VALUES('o','coth2trigh',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{coth2trigh(f)} converts every \spad{coth(u)} appearing in \spad{f} into \spad{cosh(u)/sinh(u)}.');
INSERT INTO olibdb VALUES('o','cothIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{cothIfCan(z)} returns coth(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','cotIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{cotIfCan(z)} returns cot(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','counit',1,'x','(%)->R','cCoalgebra(R,MxM)',NULL,'\spad{counit(x)} evaluates the counit at an element \spad{x}');
INSERT INTO olibdb VALUES('o','count',2,'n','((Entry)->Boolean,S)->NonNegativeInteger','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(Entry,S)->NonNegativeInteger','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','((R)->Boolean,S)->NonNegativeInteger','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','((Record(key:Key,entry:Entry))->Boolean,S)->NonNegativeInteger','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(Record(key:Key,entry:Entry),S)->NonNegativeInteger','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(R,S)->NonNegativeInteger','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(S,A)->NonNegativeInteger','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(S,A)->NonNegativeInteger','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','(S,A)->NonNegativeInteger','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','((S)->Boolean,A)->NonNegativeInteger','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','((S)->Boolean,A)->NonNegativeInteger','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'n','((S)->Boolean,A)->NonNegativeInteger','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','count',2,'x','((S)->Boolean,%)->NonNegativeInteger','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{count(p,{} u)} returns the number of elements \spad{x} in \spad{u} such that \spad{p(x)} is \spad{true}. For collections,{} \spad{count(p,{} u) = reduce(+,{} [1 for x in u | p(x)],{} 0)}.');
INSERT INTO olibdb VALUES('o','count',2,'x','(S,%)->NonNegativeInteger','cHomogeneousAggregate(S)','AND(has(%,finiteAggregate),has(S,BasicType))','\spad{count(x,{} u)} returns the number of occurrences of \spad{x} in \spad{u}. For collections,{} \spad{count(x,{} u) = reduce(+,{} [1 for y in u | x = y],{} 0)}.');
INSERT INTO olibdb VALUES('o','countable?',1,'x','(%)->Boolean','dCardinalNumber',NULL,'\spad{countable?(\spad{a})} determines whether \spad{a} is a countable cardinal,{} \spadignore{i.e.} an integer or \spad{Aleph 0}.');
INSERT INTO olibdb VALUES('o','countRealRoots',1,'x','(UP)->Integer','pSturmHabichtPackage(R,UP)',NULL,'\spad{countRealRoots(p)} says how many real roots \spad{p} has');
INSERT INTO olibdb VALUES('o','countRealRootsMultiple',1,'x','(UP)->Integer','pSturmHabichtPackage(R,UP)','has(R,GcdDomain)','\spad{countRealRootsMultiple(p)} says how many real roots \spad{p} has,{} counted with multiplicity');
INSERT INTO olibdb VALUES('o','coverMatrix',1,'n','(A)->IncidenceAlgebra(Integer,S)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','coverMatrix',1,'n','(%)->IncidenceAlgebra(Integer,S)','cPoset(S)',NULL,'the covering matrix of a list of elements from a comparison function the list is assumed to be topologically sorted,{} \spadignore{i.e.} \spad{w}.\spad{r}. to a linear extension of the comparison function \spad{f} This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}');
INSERT INTO olibdb VALUES('o','cPower',2,'n','(%,Coef)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cPower(f,{} r)} computes \spad{f^r},{} where \spad{f} has constant coefficient 1. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cRationalPower',2,'n','(%,Fraction(Integer))->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cRationalPower(f,{} r)} computes \spad{f^r}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','create',0,'n','()->%','dSingletonAsOrderedSet',NULL,'\spad{create()} returns the only element of \spad{\%}.');
INSERT INTO olibdb VALUES('o','create3Space',0,'x','()->%','cThreeSpaceCategory(R)',NULL,'\spad{create3Space()} creates a \spadtype{ThreeSpace} object capable of holding point,{} curve,{} mesh components and any combination.');
INSERT INTO olibdb VALUES('o','create3Space',1,'x','(SubSpace(3,R))->%','cThreeSpaceCategory(R)',NULL,'\spad{create3Space(s)} creates a \spadtype{ThreeSpace} object containing objects pre-defined within some \spadtype{SubSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','createArrows2Din2D',4,'n','((PT)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createArrows2Din2D(ptFun,{} uSeg,{} vSeg,{} numPts)} creates arrows to represent output for each input point in other words this represents a two dimensional force field with the arrows showing the direction of the field');
INSERT INTO olibdb VALUES('o','createGenericMatrix',1,'x','(NonNegativeInteger)->Matrix(Polynomial(R))','pRepresentationPackage1(R)',NULL,'\spad{createGenericMatrix(m)} creates a square matrix of dimension \spad{k} whose entry at the \spad{i}-th row and \spad{j}-th column is the indeterminate {\em x[i,{} j]} (double subscripted).');
INSERT INTO olibdb VALUES('o','createIrreduciblePoly',1,'n','(PositiveInteger)->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{createIrreduciblePoly(n)}\$FFPOLY(\spad{GF}) generates a monic irreducible univariate polynomial of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','createLowComplexityNormalBasis',1,'n','(PositiveInteger)->Union(SparseUnivariatePolynomial(GF),Vector(List(Record(value:GF,index:SingleInteger))))','pFiniteFieldFunctions(GF)',NULL,'\spad{createLowComplexityNormalBasis(n)} tries to find a a low complexity normal basis of degree {\em n} over {\em GF} and returns its multiplication matrix If no low complexity basis is found it calls \spadfunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}(\spad{n}) to produce a normal polynomial of degree {\em n} over {\em GF}');
INSERT INTO olibdb VALUES('o','createLowComplexityTable',1,'n','(PositiveInteger)->Union(Vector(List(Record(value:GF,index:SingleInteger))),failed)','pFiniteFieldFunctions(GF)',NULL,'\spad{createLowComplexityTable(n)} tries to find a low complexity normal basis of degree {\em n} over {\em GF} and returns its multiplication matrix Fails,{} if it does not find a low complexity basis');
INSERT INTO olibdb VALUES('o','createMultiplicationMatrix',1,'n','(Vector(List(Record(value:GF,index:SingleInteger))))->Matrix(GF)','pFiniteFieldFunctions(GF)',NULL,'\spad{createMultiplicationMatrix(m)} forms the multiplication table {\em m} into a matrix over the ground field.');
INSERT INTO olibdb VALUES('o','createMultiplicationTable',1,'n','(SparseUnivariatePolynomial(GF))->Vector(List(Record(value:GF,index:SingleInteger)))','pFiniteFieldFunctions(GF)',NULL,'\spad{createMultiplicationTable(f)} generates a multiplication table for the normal basis of the field extension determined by {\em f}. This is needed to perform multiplications between elements represented as coordinate vectors to this basis. See \spadtype{FFNBP},{} \spadtype{FFNBX}.');
INSERT INTO olibdb VALUES('o','createNormalElement',0,'n','()->S','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','createNormalElement',0,'x','()->%','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{createNormalElement()} computes a normal element over the ground field \spad{F},{} that is,{} \spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \spad{F}-basis,{} where \spad{q = size()\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35.');
INSERT INTO olibdb VALUES('o','createNormalPoly',1,'n','(PositiveInteger)->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{createNormalPoly(n)}\$FFPOLY(\spad{GF}) generates a normal polynomial of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','createNormalPrimitivePoly',1,'n','(PositiveInteger)->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{createNormalPrimitivePoly(n)}\$FFPOLY(\spad{GF}) generates a normal and primitive polynomial of degree \spad{n} over the field {\em GF}. Note: this function is equivalent to createPrimitiveNormalPoly(\spad{n})');
INSERT INTO olibdb VALUES('o','createPlot1Din2D',3,'n','((DoubleFloat)->DoubleFloat,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates two dimensional function plot. Draws the graph of \spad{y} = \spad{f}(\spad{x}) as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}). \spad{tRange} is a..\spad{b}');
INSERT INTO olibdb VALUES('o','createPlot1Din2D',3,'n','((DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot1Din2D(f,{} tRange,{} numPts)} creates a two dimensional function plot draws the graph from a mapping of float to point as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}). \spad{tRange} is a..\spad{b}');
INSERT INTO olibdb VALUES('o','createPlot1Din2Dparametric',3,'n','(ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot1Din2Dparametric(ppc,{} tRange,{} numPts)} creates a node from plot using Parametric Plane Curve. This represents 1 dimension (line - possibly curved) in 2 dimensions (plane) In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \spad{PPC} is ParametricPlaneCurve(\spad{DF} \spad{->} \spad{DF}) which is created with curve(\spad{f1},{} \spad{f2}) where \spad{f1} and \spad{f2} are functions of type ComponentFunction,{} in this case \spad{DF} \spad{->} \spad{DF}');
INSERT INTO olibdb VALUES('o','createPlot1Din3Dparametric',3,'n','((DoubleFloat)->PT,Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot1Din3Dparametric(pcfun,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph PCFUN is a function from float to point: \spad{DF} \spad{->} \spad{PT}');
INSERT INTO olibdb VALUES('o','createPlot1Din3Dparametric',3,'n','(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot1Din3Dparametric(psc,{} tRange,{} numPts)} create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \spad{PSC} ParametricSpaceCurve(\spad{DF} \spad{->} \spad{DF}) is created with curve(\spad{f1},{} \spad{f2},{} \spad{f3}) where \spad{f1},{} \spad{f2} and \spad{f3} are functions of type ComponentFunction,{} in this case \spad{DF} \spad{->} \spad{DF}');
INSERT INTO olibdb VALUES('o','createPlot2Din3D',4,'n','((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot2Din3D(f,{} a..b,{} c..d)} returns a scene node which contains the graph of \spad{z} = \spad{f}(\spad{x},{} \spad{y}) as \spad{x} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}) and \spad{y} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). create a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node');
INSERT INTO olibdb VALUES('o','createPlot2Din3D',4,'n','((DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot2Din3D(ptFun,{} uSeg,{} vSeg,{} numPts)} create a surface (2D subspace) in 3D space. The surface is approximated by polygons which are represented by in indexed face set (IFS) node');
INSERT INTO olibdb VALUES('o','createPlot2Din3Dparametric',4,'n','((DoubleFloat,DoubleFloat)->PT,Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot2Din3Dparametric(f,{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \spad{f}(\spad{u},{} \spad{v}) as \spad{u} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}) and \spad{v} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node');
INSERT INTO olibdb VALUES('o','createPlot2Din3Dparametric',4,'n','(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),NonNegativeInteger)->%','dScene(PT)',NULL,'\spad{createPlot2Din3Dparametric(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a scene node which contains the graph of the parametric surface \spad{x} = \spad{f}(\spad{u},{} \spad{v}),{} \spad{y} = \spad{g}(\spad{u},{} \spad{v}),{} \spad{z} = \spad{h}(\spad{u},{} \spad{v}) as \spad{u} ranges from min(a,{} \spad{b}) to max(a,{} \spad{b}) and \spad{v} ranges from min(\spad{c},{} \spad{d}) to max(\spad{c},{} \spad{d}). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node');
INSERT INTO olibdb VALUES('o','createPrimitiveElement',0,'n','()->S','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','createPrimitiveElement',0,'x','()->%','cFiniteFieldCategory',NULL,'\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field.');
INSERT INTO olibdb VALUES('o','createPrimitiveNormalPoly',1,'n','(PositiveInteger)->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{createPrimitiveNormalPoly(n)}\$FFPOLY(\spad{GF}) generates a normal and primitive polynomial of degree \spad{n} over the field {\em GF}.');
INSERT INTO olibdb VALUES('o','createPrimitivePoly',1,'n','(PositiveInteger)->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{createPrimitivePoly(n)}\$FFPOLY(\spad{GF}) generates a primitive polynomial of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','createRandomElement',2,'x','(List(Matrix(R)),Matrix(R))->Matrix(R)','pRepresentationPackage2(R)',NULL,'\spad{createRandomElement(aG,{} x)} creates a random element of the group algebra generated by {\em aG}.');
INSERT INTO olibdb VALUES('o','createSceneArrow',5,'n','(String,String,PT,Symbol,DoubleFloat)->%','dScene(PT)',NULL,'\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size)} constructs an arrow node,{} in \spad{n}-dimensional space,{} going from \spad{st} to \spad{en}. ''st'' and ''en'' are determined from a list of points from named points node. \spad{st} is the start of the arrow \spad{en} is the end of the arrow ''mode'' and ''size'' parameters determine the size of the arrowhead. \spad{mode} can have the following values: \indented{2}{fixed::Symbol \spad{--} fixed size line width given by ''size'' parameter} \indented{2}{proportional::Symbol \spad{--} size as a proportion of the overall bounds} \indented{2}{variable::Symbol \spad{--} size as a proportion of the arrow length} So proportional would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. variable would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force.');
INSERT INTO olibdb VALUES('o','createSceneArrow',6,'n','(%,%,PT,Symbol,DoubleFloat,DoubleFloat)->%','dScene(PT)',NULL,'\spad{createSceneArrow(st,{} en,{} offset,{} mode,{} size,{} fontScale)} constructs an arrow node,{} in \spad{n}-dimensional space,{} going from \spad{st} to \spad{en}. ''st'' and ''en'' are nodes in the scene and the arrows will be drawn upto their boundary. \spad{st} is the node at the start of the arrow \spad{en} is the node at the end of the arrow ''mode'' and ''size'' parameters determine the \spad{size} of the arrowhead. \spad{mode} can have the following values: \indented{2}{fixed::Symbol \spad{--} fixed \spad{size} line width given by ''size'' parameter} \indented{2}{proportional::Symbol \spad{--} \spad{size} as a proportion of the overall bounds} \indented{2}{variable::Symbol \spad{--} \spad{size} as a proportion of the arrow length} So proportional would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. variable would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \spad{st} or \spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.');
INSERT INTO olibdb VALUES('o','createSceneArrows',3,'n','(List(List(PT)),Symbol,DoubleFloat)->%','dScene(PT)',NULL,'\spad{createSceneArrows(line,{} mode,{} size)} constructs an arrow node,{} this contains arrows (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created. ''mode'' and ''size'' parameters determine the size of the arrowhead. \spad{mode} can have the following values: \indented{2}{fixed::Symbol \spad{--} fixed size \spad{line} width given by ''size'' parameter} \indented{2}{proportional::Symbol \spad{--} size as a proportion of the overall bounds} \indented{2}{variable::Symbol \spad{--} size as a proportion of the arrow length} So proportional would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. variable would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force.');
INSERT INTO olibdb VALUES('o','createSceneBox',1,'n','(DoubleFloat)->%','dScene(PT)',NULL,'\spad{createSceneBox(size)} constructs an indexed face set node which is a 3D box of a given \spad{size}');
INSERT INTO olibdb VALUES('o','createSceneClip',1,'n','(SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneClip(bb)} constructs a clip node,{} clips its sub nodes in the coordinate system in force at the clip node.');
INSERT INTO olibdb VALUES('o','createSceneDef',2,'n','(String,%)->%','dScene(PT)',NULL,'\spad{createSceneDef(nam,{} nde)} defines a point in the scenegraph so that it can be used elsewhere.');
INSERT INTO olibdb VALUES('o','createSceneGraph',4,'n','(DirectedGraph(String),NonNegativeInteger,NonNegativeInteger,Boolean)->%','dScene(PT)',NULL,'\spad{createSceneGraph(g,{} x,{} y,{} dispArrowName)} creates a graph theory diagram');
INSERT INTO olibdb VALUES('o','createSceneGrid',1,'n','(SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneGrid(bb)} constructs a grid with narrow blue lines every 20 units wide blue lines every 100 units wide red lines every 200 units');
INSERT INTO olibdb VALUES('o','createSceneGrid',2,'n','(DoubleFloat,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneGrid(stepSize,{} bb)} constructs a grid,{} consists of a group,{} under which are vertical and horizontal lines. The spacing between lines is given by step.');
INSERT INTO olibdb VALUES('o','createSceneGroup',0,'n','()->%','dScene(PT)',NULL,'\spad{createSceneGroup()} constructs a group node,{} this node does not do anything itself but contains other nodes');
INSERT INTO olibdb VALUES('o','createSceneIFS',1,'n','(SceneIFS(PT))->%','dScene(PT)',NULL,'\spad{createSceneIFS(in1)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \spad{n}-dimensional space.');
INSERT INTO olibdb VALUES('o','createSceneIFS',2,'n','(List(List(NonNegativeInteger)),List(PT))->%','dScene(PT)',NULL,'\spad{createSceneIFS(inx,{} pts)} constructs an indexed face set node,{} this defines a surface represented by a set of polygons in \spad{n}-dimensional space.');
INSERT INTO olibdb VALUES('o','createSceneLine',1,'n','(List(PT))->%','dScene(PT)',NULL,'\spad{createSceneLine(line)} constructs a \spad{line} node,{} this contains a \spad{line} (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created.');
INSERT INTO olibdb VALUES('o','createSceneLine',3,'n','(%,%,DoubleFloat)->%','dScene(PT)',NULL,'\spad{createSceneLine(st,{} en,{} fontScale)} constructs a line node,{} that contains a line,{} in \spad{n}-dimensions,{} from \spad{st} to \spad{en}. ''st'' and ''en'' are nodes in the scene and the line will be drawn upto their boundary. \spad{st} is the node at the start of the line \spad{en} is the node at the end of the line fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \spad{st} or \spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant.');
INSERT INTO olibdb VALUES('o','createSceneLine',4,'n','(%,%,DoubleFloat,Boolean)->%','dScene(PT)',NULL,'\spad{createSceneLine(st,{} en,{} fontScale,{} shortenLine)} constructs a line node,{} that contains a line,{} in \spad{n}-dimensions,{} from \spad{st} to \spad{en}. ''st'' and ''en'' are nodes in the scene and the line will be drawn upto their boundary. \spad{st} is the node at the start of the line \spad{en} is the node at the end of the line \spad{fontScale} should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes,{} if \spad{st} or \spad{en},{} or its subnodes,{} do not contain a text node then its value is not significant. shortenLine if \spad{true} line drawn upto boundary rather than \indented{12}{centre of destination.}');
INSERT INTO olibdb VALUES('o','createSceneLines',1,'n','(List(List(PT)))->%','dScene(PT)',NULL,'\spad{createSceneLines(line)} constructs a \spad{line} node,{} this contains lines (represented by a list of points) in \spad{n}-dimensional space. The space is implicit in the \spad{PT} and \spad{TR} parameters supplied when this Scene was created.');
INSERT INTO olibdb VALUES('o','createSceneMaterial',1,'n','(Record(lineWidth:DoubleFloat,lineCol:String,fillCol:String,matOpacity:DoubleFloat))->%','dScene(PT)',NULL,'\spad{createSceneMaterial(mat)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy line width is expressed relative to the width of current boundary');
INSERT INTO olibdb VALUES('o','createSceneMaterial',3,'n','(DoubleFloat,String,String)->%','dScene(PT)',NULL,'\spad{createSceneMaterial(lineW,{} lineC,{} fillC)} constructs a material node This sets the lineWidth,{} lineCol and fillCol for all nodes under this,{} unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy');
INSERT INTO olibdb VALUES('o','createSceneNamedPoints',1,'n','(SceneNamedPoints(PT))->%','dScene(PT)',NULL,'\spad{createSceneNamedPoints(np)} constructs a named points node,{} this allows us to define a set of points which can be used multiple times in the scenegraph.');
INSERT INTO olibdb VALUES('o','createScenePattern',3,'n','(Symbol,NonNegativeInteger,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createScenePattern(ptype,{} step,{} bb)} creates a test pattern suitable for showing the effect of transforms. The pattern depends on \spad{ptype} parameter as follows: ptype=GRID::Symbol : construct a set of horizontal and vertical lines in the current clip boundary and current material with a spacing between lines given by the \spad{step} parameter. ptype=SIERPINSKI::Symbol: constructs a Sierpinski fractal. \spad{step} parameter gives the level of subdivision. ptype=HOUSE::Symbol: constructs a house shape.');
INSERT INTO olibdb VALUES('o','createSceneRoot',0,'n','()->%','dScene(PT)',NULL,'\spad{createSceneRoot()} constructs the root node,{} all other nodes are contained in a tree structure under this node');
INSERT INTO olibdb VALUES('o','createSceneRoot',1,'n','(SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneRoot(bb)} constructs the root node,{} all other nodes are contained in a tree structure under this node');
INSERT INTO olibdb VALUES('o','createSceneRoot',4,'n','(Integer,Integer,Integer,Integer)->%','dScene(PT)',NULL,'\spad{createSceneRoot(minx,{} miny,{} maxx,{} maxy)} constructs the root node,{} all other nodes are contained in a tree structure under this node');
INSERT INTO olibdb VALUES('o','createSceneRuler',3,'n','(Symbol,PT,SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneRuler(ptype,{} offset,{} bb)} creates a scale that can be used to provide numeric values for an axis: ptype= HORIZONTAL::Symbol : horizontal axis. ptype= VERTICAL::Symbol: vertical axis. ptype= DEBTH::Symbol: depth axis.');
INSERT INTO olibdb VALUES('o','createSceneShape',1,'n','(Record(shptype:Symbol,centre:PT,size:PT,fill:Boolean))->%','dScene(PT)',NULL,'\spad{createSceneShape(shape)} constructs a \spad{shape} node,{} this contains a \spad{shape} such as a rectangle or an ellipse.');
INSERT INTO olibdb VALUES('o','createSceneShape',1,'n','(SBoundary(PT))->%','dScene(PT)',NULL,'\spad{createSceneShape(shape)} constructs a \spad{shape} node from a boundary,{} this contains a \spad{shape} such as a rectangle or an ellipse.');
INSERT INTO olibdb VALUES('o','createSceneText',1,'n','(Record(txt:String,siz:NonNegativeInteger,pos:PT,np:List(String)))->%','dScene(PT)',NULL,'\spad{createSceneText(text)} constructs a \spad{text} node,{} \spad{text} can be used for labelling anything such as graphs,{} axes and so on.');
INSERT INTO olibdb VALUES('o','createSceneText',3,'n','(List(String),NonNegativeInteger,PT)->%','dScene(PT)',NULL,'\spad{createSceneText(str,{} sz,{} pz)} constructs a text node using information from named points node.');
INSERT INTO olibdb VALUES('o','createSceneText',3,'n','(String,NonNegativeInteger,PT)->%','dScene(PT)',NULL,'\spad{createSceneText(str,{} sz,{} pz)} constructs a text node,{} text can be used for labelling anything such as graphs,{} axes and so on.');
INSERT INTO olibdb VALUES('o','createSceneTransform',1,'n','(STransform(PT))->%','dScene(PT)',NULL,'\spad{createSceneTransform(tran)} constructs a transform node This transforms the points and vectors below this node If a given node has more than one transform node above it in the hierarchy then the transforms are compound');
INSERT INTO olibdb VALUES('o','createSceneUse',1,'n','(String)->%','dScene(PT)',NULL,'\spad{createSceneUse(nam)} uses another point in the scenegraph.');
INSERT INTO olibdb VALUES('o','createThreeSpace',0,'x','()->ThreeSpace(DoubleFloat)','pTopLevelThreeSpace',NULL,'\spad{createThreeSpace()} creates a \spadtype{ThreeSpace(DoubleFloat)} object capable of holding point,{} curve,{} mesh components and any combination.');
INSERT INTO olibdb VALUES('o','createWidth',1,'n','(NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph');
INSERT INTO olibdb VALUES('o','createWidth',1,'n','(NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,'\spad{createWidth(x)} can be used by domains which extend graph to help in creating coordinates for objects in a graph');
INSERT INTO olibdb VALUES('o','createWidth',1,'n','(NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','createX',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \spad{x} coordinate for objects in a graph');
INSERT INTO olibdb VALUES('o','createX',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,'\spad{createX(x,{} n)} can be used by domains which extend graph to help in creating the \spad{x} coordinate for objects in a graph');
INSERT INTO olibdb VALUES('o','createX',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','createY',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \spad{y} coordinate for objects in a graph');
INSERT INTO olibdb VALUES('o','createY',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,'\spad{createY(x,{} n)} can be used by domains which extend graph to help in creating the \spad{y} coordinate for objects in a graph');
INSERT INTO olibdb VALUES('o','createY',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','createZechTable',1,'n','(SparseUnivariatePolynomial(GF))->PrimitiveArray(SingleInteger)','pFiniteFieldFunctions(GF)',NULL,'\spad{createZechTable(f)} generates a Zech logarithm table for the cyclic group representation of a extension of the ground field by the primitive polynomial {\em f(x)},{} \spadignore{i.e.} \spad{Z(i)},{} defined by {\em x^Z(i) = 1+x^i} is stored at index \spad{i}. This is needed in particular to perform addition of field elements in finite fields represented in this way. See \spadtype{FFCGP},{} \spadtype{FFCGX}.');
INSERT INTO olibdb VALUES('o','credPol',2,'n','(Dpol,List(Dpol))->Dpol','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{credPol }\undocumented');
INSERT INTO olibdb VALUES('o','critB',4,'n','(Expon,Expon,Expon,Expon)->Boolean','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critB }\undocumented');
INSERT INTO olibdb VALUES('o','critBonD',2,'n','(Dpol,List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol)))->List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol))','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critBonD }\undocumented');
INSERT INTO olibdb VALUES('o','critM',2,'n','(Expon,Expon)->Boolean','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critM }\undocumented');
INSERT INTO olibdb VALUES('o','critMonD1',2,'n','(Expon,List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol)))->List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol))','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critMonD1 }\undocumented');
INSERT INTO olibdb VALUES('o','critMTonD1',1,'n','(List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol)))->List(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol))','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critMTonD1 }\undocumented');
INSERT INTO olibdb VALUES('o','critpOrder',2,'n','(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol),Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol))->Boolean','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critpOrder }\undocumented');
INSERT INTO olibdb VALUES('o','critT',1,'n','(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol))->Boolean','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{critT }\undocumented');
INSERT INTO olibdb VALUES('o','cross',2,'n','(Point(DoubleFloat),Point(DoubleFloat))->Point(DoubleFloat)','pTubePlotTools',NULL,'\spad{cross(p,{} q)} computes the cross product of the two points \spad{p} and \spad{q} using only the first three coordinates,{} and keeping the color of the first point \spad{p}. The result is returned as a point.');
INSERT INTO olibdb VALUES('o','cross',2,'n','(S,S)->S','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cross',2,'x','(%,%)->%','cPointCategory(R)',NULL,'\spad{cross(p,{} q)} computes the cross product of the two points \spad{p} and \spad{q}. Error if the \spad{p} and \spad{q} are not 3 dimensional');
INSERT INTO olibdb VALUES('o','cross',2,'x','(%,%)->%','cVectorCategory(R)','has(R,Ring)','\spad{cross(u,{} v)} constructs the cross product of \spad{u} and \spad{v}. Error: if \spad{u} and \spad{v} are not of length 3.');
INSERT INTO olibdb VALUES('o','crushedSet',1,'n','(List(P))->List(P)','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{crushedSet(lp)} returns \spad{lq} such that \spad{lp} and and \spad{lq} generate the same ideal and no rough basic sets reduce (in the sense of Groebner bases) the other polynomials in \spad{lq}.');
INSERT INTO olibdb VALUES('o','csc',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{csc(x)} applies the cosecant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','csc',1,'n','(S)->S','xTrigonometricFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','csc',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','csc',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{csc(st)} computes cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','csc',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{csc(st)} computes cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','csc',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{csc(z)} returns the cosecant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','csc',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{csc(z)} returns the cosecant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','csc',1,'x','(%)->%','cTrigonometricFunctionCategory',NULL,'\spad{csc(x)} returns the cosecant of \spad{x}.');
INSERT INTO olibdb VALUES('o','csc2sin',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{csc2sin(f)} converts every \spad{csc(u)} appearing in \spad{f} into \spad{1/sin(u)}.');
INSERT INTO olibdb VALUES('o','csch',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{csch(x)} applies the hyperbolic cosecant operator to \spad{x}');
INSERT INTO olibdb VALUES('o','csch',1,'n','(S)->S','xHyperbolicFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','csch',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','csch',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{csch(st)} computes the hyperbolic cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','csch',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{csch(st)} computes the hyperbolic cosecant of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','csch',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{csch(z)} returns the hyperbolic cosecant of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','csch',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{csch(z)} returns the hyperbolic cosecant of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','csch',1,'x','(%)->%','cHyperbolicFunctionCategory',NULL,'\spad{csch(x)} returns the hyperbolic cosecant of \spad{x}.');
INSERT INTO olibdb VALUES('o','csch2sinh',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{csch2sinh(f)} converts every \spad{csch(u)} appearing in \spad{f} into \spad{1/sinh(u)}.');
INSERT INTO olibdb VALUES('o','cschIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{cschIfCan(z)} returns csch(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','cscIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{cscIfCan(z)} returns \spad{csc}(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','cSec',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cSec(f)} computes the secant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cSech',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cSech(f)} computes the hyperbolic secant of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cSin',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cSin(f)} computes the sine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cSinh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cSinh(f)} computes the hyperbolic sine of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','csolve_pol',2,'n','((Matrix(F))->List(Vector(Q)),List(UP))->List(Vector(Q))','pLiftLinearDependence(F,Q,UP)',NULL,'\spad{csolve_pol(solf,{} lp)} uses \spad{solf} to solve linear dependence for univariate polynomials.');
INSERT INTO olibdb VALUES('o','csolve_rf',2,'n','((Matrix(F))->List(Vector(Q)),List(Fraction(UP)))->List(Vector(Q))','pLiftLinearDependence(F,Q,UP)',NULL,'\spad{csolve_rf(solf,{} lrf)} uses \spad{solf} to solve linear dependence for univariate rational functions.');
INSERT INTO olibdb VALUES('o','csolve_rmat',2,'n','((Matrix(F))->List(Vector(Q)),Matrix(Fraction(UP)))->List(Vector(Q))','pLiftLinearDependence(F,Q,UP)',NULL,'\spad{csolve_rmat(solf,{} mrf)} uses \spad{solf} to solve linear dependence for univariate rational functions.');
INSERT INTO olibdb VALUES('o','csubst',2,'n','(List(Var),List(Stream(SMP)))->(SMP)->Stream(SMP)','dSparseMultivariateTaylorSeries(Coef,Var,SMP)',NULL,'\spad{csubst(a,{} b)} is for internal use only');
INSERT INTO olibdb VALUES('o','cTan',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cTan(f)} computes the tangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cTanh',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{cTanh(f)} computes the hyperbolic tangent of the power series \spad{f}. For use when the coefficient ring is commutative.');
INSERT INTO olibdb VALUES('o','cubic',1,'n','(UP)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{cubic(u)} \undocumented');
INSERT INTO olibdb VALUES('o','cubic',4,'n','(F,F,F,F)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{cubic(f,{} g,{} h,{} i)} \undocumented');
INSERT INTO olibdb VALUES('o','cubicalComplex',1,'n','(List(VS))->%','dFiniteCubicalComplex(VS)',NULL,'construct empty cubical complex');
INSERT INTO olibdb VALUES('o','cubicalComplex',2,'n','(List(VS),List(CubicalFacet))->%','dFiniteCubicalComplex(VS)',NULL,'constructor where the cubes are supplied');
INSERT INTO olibdb VALUES('o','cubicalComplex',2,'n','(List(VS),List(List(List(Integer))))->%','dFiniteCubicalComplex(VS)',NULL,'constructor where the cubes are supplied');
INSERT INTO olibdb VALUES('o','cubicalComplex',2,'n','(List(VS),List(List(Segment(Integer))))->%','dFiniteCubicalComplex(VS)',NULL,'constructor where the cubes are supplied');
INSERT INTO olibdb VALUES('o','cubicalFacet',2,'n','(Integer,CubicalFacet)->%','dCubicalFacet',NULL,'Copy constructor which can change mul');
INSERT INTO olibdb VALUES('o','cubicalFacet',2,'n','(Integer,List(List(Integer)))->%','dCubicalFacet',NULL,'Constructor for cubical facet');
INSERT INTO olibdb VALUES('o','cubicalFacet',2,'n','(Integer,List(Segment(Integer)))->%','dCubicalFacet',NULL,'Constructor for cubical facet intervals are always stored in low..high order orientation is calculated by the number of intervals that have to be flipped to put it in order.');
INSERT INTO olibdb VALUES('o','cumulant2moment',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{cumulant2moment(cc)} computes the sequence of moments from the sequence of classical cumulants \spad{cc}');
INSERT INTO olibdb VALUES('o','cup',2,'x','(SymmetricPolynomial(Fraction(Integer)),SymmetricPolynomial(Fraction(Integer)))->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{cup(s1,{} s2)},{} introduced by Redfield,{} \indented{1}{is the scalar product of two cycle indices,{} in which the} \indented{1}{power sums are retained to produce a cycle index.}');
INSERT INTO olibdb VALUES('o','currentSubProgram',0,'n','()->Symbol','dTheSymbolTable',NULL,'\spad{currentSubProgram()} returns the name of the current subprogram being processed');
INSERT INTO olibdb VALUES('o','curry',2,'x','((A)->C,A)->()->C','pMappingPackage2(A,C)',NULL,'\spad{curry(f,{} a)} is the function \spad{g} \indented{1}{such that \spad{g ()= f a}.}');
INSERT INTO olibdb VALUES('o','curryLeft',2,'x','((A,B)->C,A)->(B)->C','pMappingPackage3(A,B,C)',NULL,'\spad{curryLeft(f,{} a)} is the function \spad{g} \indented{1}{such that \spad{g b = f(a,{} b)}.}');
INSERT INTO olibdb VALUES('o','curryRight',2,'x','((A,B)->C,B)->(A)->C','pMappingPackage3(A,B,C)',NULL,'\spad{curryRight(f,{} b)} is the function \spad{g} such that \indented{1}{\spad{g a = f(a,{} b)}.}');
INSERT INTO olibdb VALUES('o','curve?',1,'x','(%)->Boolean','cThreeSpaceCategory(R)',NULL,'\spad{curve?(s)} queries whether the \spadtype{ThreeSpace},{} \spad{s},{} is a curve,{} \spadignore{i.e.} has one component,{} a list of list of points,{} and returns \spad{true} if it is,{} or \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','curve',1,'x','(List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{curve([p0,{} p1,{} p2,{} ...,{} pn])} creates a space curve defined by the list of points \spad{p0} through \spad{pn},{} and returns the \spadtype{ThreeSpace} whose component is the curve.');
INSERT INTO olibdb VALUES('o','curve',1,'x','(%)->List(Point(R))','cThreeSpaceCategory(R)',NULL,'\spad{curve(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single curve defined by a list of points and if so,{} returns the curve,{} \spadignore{i.e.} list of points. An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','curve',2,'x','(ComponentFunction,ComponentFunction)->%','dParametricPlaneCurve(ComponentFunction)',NULL,'\spad{curve(c1,{} c2)} creates a plane curve from 2 component functions \spad{c1} and \spad{c2}.');
INSERT INTO olibdb VALUES('o','curve',2,'x','(%,List(List(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{curve(s,{} [[p0],{} [p1],{} ...,{} [pn]])} adds a space curve which is a list of points \spad{p0} through \spad{pn} defined by lists of elements from the domain \spad{PointDomain(m,{} R)},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined and \spad{m} is the dimension of the points,{} to the \spadtype{ThreeSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','curve',2,'x','(%,List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{curve(s,{} [p0,{} p1,{} ...,{} pn])} adds a space curve component defined by a list of points \spad{p0} through \spad{pn},{} to the \spadtype{ThreeSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','curve',3,'x','(ComponentFunction,ComponentFunction,ComponentFunction)->%','dParametricSpaceCurve(ComponentFunction)',NULL,'\spad{curve(c1,{} c2,{} c3)} creates a space curve from 3 component functions \spad{c1},{} \spad{c2},{} and \spad{c3}.');
INSERT INTO olibdb VALUES('o','curveColor',1,'x','(Float)->%','dDrawOption',NULL,'\spad{curveColor(v)} specifies a color,{} \spad{v},{} for 2D graph curves. This option is expressed in the form \spad{curveColor == v}.');
INSERT INTO olibdb VALUES('o','curveColor',1,'x','(Palette)->%','dDrawOption',NULL,'\spad{curveColor(p)} specifies a color index for 2D graph curves from the spadcolors palette \spad{p}. This option is expressed in the form \spad{curveColor ==p}.');
INSERT INTO olibdb VALUES('o','curveColorPalette',2,'n','(List(DrawOption),Palette)->Palette','pDrawOptionFunctions0',NULL,'\spad{curveColorPalette(l,{} p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{curveColorPalette}. If the option does not exist the value,{} \spad{p} is returned.');
INSERT INTO olibdb VALUES('o','curveLoops',3,'n','(List(PT),DoubleFloat,Integer)->List(List(PT))','dSceneIFS(PT)',NULL,'\spad{curveLoops(pts1,{} r,{} nn)} generates ifs from line given by \spad{pts1}');
INSERT INTO olibdb VALUES('o','cycle',1,'x','(List(S))->%','cPermutationCategory(S)',NULL,'\spad{cycle(ls)} coerces a cycle {\em ls},{} \spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur.');
INSERT INTO olibdb VALUES('o','cycleClosed',2,'n','(List(S),String)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleClosed',2,'n','(List(S),String)->%','cFiniteGraph(S)',NULL,'\spad{cycleClosed(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) connected in a cycle. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow');
INSERT INTO olibdb VALUES('o','cycleElt',1,'n','(ST)->Union(ST,failed)','pCyclicStreamTools(S,ST)',NULL,'\spad{cycleElt(s)} returns a pointer to a node in the cycle if the stream \spad{s} is cyclic and returns failed if \spad{s} is not cyclic');
INSERT INTO olibdb VALUES('o','cycleEntry',1,'n','(A)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleEntry',1,'n','(A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleEntry',1,'x','(%)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \spad{u},{} or \spad{empty()} if none exists.');
INSERT INTO olibdb VALUES('o','cycleLength',1,'n','(A)->NonNegativeInteger','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleLength',1,'n','(A)->NonNegativeInteger','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleLength',1,'x','(%)->NonNegativeInteger','cUnaryRecursiveAggregate(S)',NULL,'\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \spad{u},{} or 0 if \spad{u} has no such cycle.');
INSERT INTO olibdb VALUES('o','cycleOpen',2,'n','(List(S),String)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleOpen',2,'n','(List(S),String)->%','cFiniteGraph(S)',NULL,'\spad{cycleOpen(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) connected in a cycle but with one gap. The last vertex in the sequence loops back to itself so all vertices have one outgoing arrow. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow');
INSERT INTO olibdb VALUES('o','cyclePartition',1,'x','(%)->Partition','dPermutation(S)',NULL,'\spad{cyclePartition(p)} returns the cycle structure of a permutation \spad{p} including cycles of length 1 only if \spad{S} is finite.');
INSERT INTO olibdb VALUES('o','cycleRagits',1,'x','(%)->List(Integer)','dRadixExpansion(bb)',NULL,'\spad{cycleRagits(rx)} returns the cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \spad{x = 3/28 = 0.10 714285 714285 ...},{} then \spad{cycleRagits(x) = [7,{} 1,{} 4,{} 2,{} 8,{} 5]}.');
INSERT INTO olibdb VALUES('o','cycles',1,'x','(List(List(S)))->%','cPermutationCategory(S)',NULL,'\spad{cycles(lls)} coerces a list list of cycles {\em lls} to a permutation,{} each cycle being a list with not repetitions,{} is coerced to the permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are multiplied. Error: if repetitions occur in one cycle.');
INSERT INTO olibdb VALUES('o','cycleSplit!',1,'n','(A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleSplit!',1,'x','(%)->%','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or empty() if none exists. For example,{} if \spad{w = concat(u,{} v)} is the cyclic list where \spad{v} is the head of the cycle,{} \spad{cycleSplit!(w)} will drop \spad{v} off \spad{w} thus destructively changing \spad{w} to \spad{u},{} and returning \spad{v}.');
INSERT INTO olibdb VALUES('o','cycleTail',1,'n','(A)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleTail',1,'n','(A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cycleTail',1,'x','(%)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{cycleTail(u)} returns the last node in the cycle,{} or empty() if none exists.');
INSERT INTO olibdb VALUES('o','cyclic?',1,'n','(A)->Boolean','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cyclic?',1,'n','(A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cyclic?',1,'n','(A)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','cyclic?',1,'x','(%)->Boolean','cRecursiveAggregate(S)',NULL,'\spad{cyclic?(u)} tests if \spad{u} has a cycle.');
INSERT INTO olibdb VALUES('o','cyclic',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{cyclic n} is the cycle index of the \indented{1}{cyclic group of degree \spad{n}.}');
INSERT INTO olibdb VALUES('o','cyclicGroup',1,'n','(PositiveInteger)->%','dGroupPresentation',NULL,'\spad{cyclicGroup(n)} constructs the cyclic group of order \spad{n} acting on the integers 1,{} ...,{} \spad{n}.');
INSERT INTO olibdb VALUES('o','cyclicGroup',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{cyclicGroup([i1,{} ...,{} ik])} constructs the cyclic group of order \spad{k} acting on the integers {\em i1},{} ...,{} {\em ik}. Note: duplicates in the list will be removed.');
INSERT INTO olibdb VALUES('o','cyclicGroup',1,'x','(PositiveInteger)->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{cyclicGroup(n)} constructs the cyclic group of order \spad{n} acting on the integers 1,{} ...,{} \spad{n}.');
INSERT INTO olibdb VALUES('o','cyclicSubmodule',2,'x','(List(Matrix(R)),Vector(R))->Vector(Vector(R))','pRepresentationPackage2(R)','has(R,EuclideanDomain)','\spad{cyclicSubmodule(lm,{} v)} generates a basis as follows. It is assumed that the size \spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an \spad{A}-module in the natural way. cyclicSubmodule(\spad{lm},{} \spad{v}) generates the \spad{R}-Basis of {\em Av} as described in section 6 of \spad{R}. A. Parker\spad{''s} The Meat-Axe. Note: in contrast to the description in The Meat-Axe and to {\em standardBasisOfCyclicSubmodule} the result is in echelon form.');
INSERT INTO olibdb VALUES('o','cyclotomic',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pCyclotomicUtilities',NULL,'\spad{cyclotomic(n)} computes \spad{n}-th cyclotomic polynomial.');
INSERT INTO olibdb VALUES('o','cyclotomic',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pPolynomialNumberTheoryFunctions',NULL,'\spad{cyclotomic(n)} returns the \spad{n}th cyclotomic polynomial \spad{phi[n](x)}. Note: \spad{phi[n](x)} is the factor of \spad{x^n - 1} whose roots are the primitive \spad{n}th roots of unity.');
INSERT INTO olibdb VALUES('o','cyclotomic?',1,'n','(SparseUnivariatePolynomial(Integer))->Union(Integer,failed)','pCyclotomicUtilities',NULL,'\spad{cyclotomic?(p)} checks if \spad{p} is a cyclotomic polynomial. If yes returns \spad{n} such that \spad{p = cyclotomic(n)}. Otherwise returns failed.');
INSERT INTO olibdb VALUES('o','cyclotomic',2,'x','(NonNegativeInteger,R)->R','pNumberTheoreticPolynomialFunctions(R)',NULL,'\spad{cyclotomic(n,{} r)} returns value of the \spad{n}th cyclotomic polynomial at \spad{r}.');
INSERT INTO olibdb VALUES('o','cyclotomic_array',1,'n','(Integer)->PrimitiveArray(Integer)','pCyclotomicUtilities',NULL,'\spad{cyclotomic_array(n)} computes pa containing lower half of coefficients of \spad{n}-th cyclotomic polynomial. maximal index in \spad{pa} is \spad{eulerPhi(n)/2}. Due to symmetry this is enough to reconstruct cyclotomic polynomial from computed coefficients.');
INSERT INTO olibdb VALUES('o','cyclotomic_case?',1,'x','(SparseUnivariatePolynomial(Polynomial(R)))->Union(Integer,failed)','pRadicalSolvePackage(R)',NULL,'\spad{cyclotomic_case?(u)} should be local but conditional');
INSERT INTO olibdb VALUES('o','cyclotomic_decomposition',1,'n','(Integer)->List(SparseUnivariatePolynomial(Integer))','pCyclotomicUtilities',NULL,'\spad{cyclotomic_decomposition(n)} computes list of irreducible factors of \spad{x^n - 1} over integers.');
INSERT INTO olibdb VALUES('o','cyclotomic_roots',1,'n','(PositiveInteger)->List(Expression(R2))','pDegreeReductionPackage(R1,R2)',NULL,'\spad{cyclotomic_roots(n)} returns list of roots of \spad{n}-th cyclotomic polynomial.');
INSERT INTO olibdb VALUES('o','cylindrical',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{cylindrical(pt)} transforms \spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \spad{(r,{} theta,{} z)} to \spad{x = r * cos(theta)},{} \spad{y = r * sin(theta)},{} \spad{z}.');
INSERT INTO olibdb VALUES('o','cylindricalDecomposition',1,'n','(List(Polynomial(TheField)))->List(Cell(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,'\spad{cylindricalDecomposition(lp)} is cylindricalDecomposition(\spad{lp},{} \spad{lv}) where \spad{lv} is list of variables in \spad{lp}.');
INSERT INTO olibdb VALUES('o','cylindricalDecomposition',2,'n','(List(Polynomial(TheField)),List(Symbol))->List(Cell(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,'\spad{cylindricalDecomposition(lp,{} lv)} computes cylindrical decomposition of \spad{lp} in using variable order given by \spad{lv}');
INSERT INTO olibdb VALUES('o','D',0,'n','()->S','xLinearOrdinaryDifferentialOperatorCategory&(S,A)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',0,'x','()->%','cLinearOrdinaryDifferentialOperatorCategory(A)',NULL,'\spad{D()} provides the operator corresponding to a derivation in the ring \spad{A}.');
INSERT INTO olibdb VALUES('o','d',1,'n','(D)->%','dJetDifferential(JB,D)',NULL,'\spad{d(f)} computes the differential of \spad{f}.');
INSERT INTO olibdb VALUES('o','d',1,'n','(JB)->%','dJetDifferential(JB,D)',NULL,'\spad{d(jb)} returns the differential of \spad{jb}.');
INSERT INTO olibdb VALUES('o','D',1,'n','(S)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',1,'n','(S)->S','xDifferentialRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',1,'n','(Var)->%','dPartialDifferentialOperator(R,Var)',NULL,'\spad{D(v)} returns the operator corresponding to derivative with respect to \spad{v} in \spad{R}.');
INSERT INTO olibdb VALUES('o','D',1,'n','(Var)->%','dSparseMultivariateSkewPolynomial(R,Var,sigma,delta)',NULL,'\spad{D(v)} returns operator corresponding to derivative with respect to \spad{v} in \spad{R}.');
INSERT INTO olibdb VALUES('o','D',1,'x','(%)->%','cDifferentialRing',NULL,'\spad{D(x)} returns the derivative of \spad{x}. This function is a simple differential operator where no variable needs to be specified.');
INSERT INTO olibdb VALUES('o','D',1,'x','(%)->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{D(f)} returns the derivative of \spad{f}.');
INSERT INTO olibdb VALUES('o','D',2,'n','(A,List(S))->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(A,S)->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(S,List(Symbol))->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(S,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(S,NonNegativeInteger)->S','xDifferentialRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(S,(R)->R)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(S,Symbol)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',2,'n','(Symbol,List(Symbol))->%','dJetBundle(IVar,DVar)',NULL,'\spad{D(U,{} [X1,{} ...,{} Xq])} generates a derivative. \spad{U} must be in \spad{DVar}; all other symbols in \spad{IVar}.');
INSERT INTO olibdb VALUES('o','D',2,'n','(Symbol,List(Symbol))->%','dJetBundleSymAna(JB1,xi,eta)',NULL,'\spad{D(u,{} der)} generates a derivative.');
INSERT INTO olibdb VALUES('o','D',2,'x','(%,List(S))->%','cPartialDifferentialRing(S)',NULL,'\spad{D(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \spadignore{i.e.} \spad{D(...D(x,{} s1)...,{} sn)}.');
INSERT INTO olibdb VALUES('o','D',2,'x','(%,NonNegativeInteger)->%','cDifferentialRing',NULL,'\spad{D(x,{} n)} returns the \spad{n}-th derivative of \spad{x}.');
INSERT INTO olibdb VALUES('o','D',2,'x','(%,NonNegativeInteger)->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{D(f,{} n)} returns the \spad{n}-th derivative of \spad{f}.');
INSERT INTO olibdb VALUES('o','D',2,'x','(%,(R)->R)->%','cDifferentialExtension(R)',NULL,'\spad{D(x,{} deriv)} differentiates \spad{x} extending the derivation deriv on \spad{R}.');
INSERT INTO olibdb VALUES('o','D',2,'x','(%,S)->%','cPartialDifferentialRing(S)',NULL,'\spad{D(x,{} v)} computes the partial derivative of \spad{x} with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','D',3,'n','(A,List(S),List(NonNegativeInteger))->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',3,'n','(A,S,NonNegativeInteger)->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',3,'n','(S,(R)->R,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',3,'n','(S,Symbol,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','D',3,'x','(%,List(S),List(NonNegativeInteger))->%','cPartialDifferentialRing(S)',NULL,'\spad{D(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{D(...D(x,{} s1,{} n1)...,{} sn,{} nn)}.');
INSERT INTO olibdb VALUES('o','D',3,'x','(%,(R)->R,NonNegativeInteger)->%','cDifferentialExtension(R)',NULL,'\spad{D(x,{} deriv,{} n)} differentiate \spad{x} \spad{n} times using a derivation which extends \spad{deriv} on \spad{R}.');
INSERT INTO olibdb VALUES('o','D',3,'x','(%,S,NonNegativeInteger)->%','cPartialDifferentialRing(S)',NULL,'\spad{D(x,{} s,{} n)} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{n}-th derivative of \spad{x} with respect to \spad{s}.');
INSERT INTO olibdb VALUES('o','dAndcExp',3,'n','(Vector(GF),NonNegativeInteger,SingleInteger)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{dAndcExp(v,{} n,{} k)} computes \spad{v^e} interpreting \spad{v} as an element of normal basis field. A divide and conquer algorithm similar to the one from \spad{D}.\spad{R}.Stinson,{} Some observations on parallel Algorithms for fast exponentiation in \spad{GF}(2^n),{} Siam \spad{J}. Computation,{} Vol.19,{} No.4,{} \spad{pp}.711-717,{} August 1990 is used. Argument \spad{k} is a parameter of this algorithm.');
INSERT INTO olibdb VALUES('o','danilewski',1,'n','(Matrix(F))->Record(matrix:Matrix(F),block_list:List(Integer))','pCharacteristicPolynomial2(F)',NULL,'\spad{danilewski(m)} converts \spad{m} to block form where each block represents transposition of multiplication by a polynomial.');
INSERT INTO olibdb VALUES('o','dark',1,'x','(Color)->%','dPalette',NULL,'\spad{dark(c)} sets the shade of the indicated hue of \spad{c} to it\spad{''s} lowest value.');
INSERT INTO olibdb VALUES('o','datalist',1,'x','(List(S))->%','dDataList(S)',NULL,'\spad{datalist(l)} creates a datalist from \spad{l}');
INSERT INTO olibdb VALUES('o','ddfact',2,'n','(PA,MD)->List(Record(poly:PA,degree:NonNegativeInteger,separate_factors:()->List(PA)))','pModularFactorizationGeneral(PA,MMT,MD,PMD,MO)',NULL,'\spad{ddfact(pv,{} md)} computes distinct degree factorization of \spad{pv}. \spad{pv} is assumed square-free and monic,{} \spad{md} is info representing finite field.');
INSERT INTO olibdb VALUES('o','ddfact',2,'n','(PrimitiveArray(K),Record(i_mod:Integer,deg:Integer))->List(Record(poly:PrimitiveArray(K),degree:NonNegativeInteger,separate_factors:()->List(PrimitiveArray(K))))','pModularFactorizationK(K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ddfact',2,'n','(U32Vector,Integer)->List(Record(poly:U32Vector,degree:NonNegativeInteger,separate_factors:()->List(U32Vector)))','pModularFactorization',NULL,NULL);
INSERT INTO olibdb VALUES('o','debug',1,'n','(Boolean)->Boolean','dPlot',NULL,'\spad{debug(true)} turns debug mode on \spad{debug(false)} turns debug mode off');
INSERT INTO olibdb VALUES('o','debug',1,'n','(List(GuessOption))->Boolean','dGuessOptionFunctions0',NULL,'\spad{debug returns} whether we want additional output on the progress,{} default being \spad{false}');
INSERT INTO olibdb VALUES('o','debug',1,'x','(Boolean)->%','dGuessOption',NULL,'\spad{debug(d)} specifies whether we want additional output on the progress. This option is expressed in the form \spad{debug == d}.');
INSERT INTO olibdb VALUES('o','debug3D',1,'n','(Boolean)->Boolean','dPlot3D',NULL,'\spad{debug3D(true)} turns debug mode on; debug3D(\spad{false}) turns debug mode off.');
INSERT INTO olibdb VALUES('o','dec',1,'x','(%)->%','cIntegerNumberSystem',NULL,'\spad{dec(x)} returns \spad{x - 1}.');
INSERT INTO olibdb VALUES('o','decimal',1,'x','(Fraction(Integer))->%','dDecimalExpansion',NULL,'\spad{decimal(r)} converts a rational number to a decimal expansion.');
INSERT INTO olibdb VALUES('o','declare',1,'n','(List(%))->Symbol','dInputForm',NULL,'\spad{declare(t)} returns a name \spad{f} such that \spad{f} has been declared to the interpreter to be of type \spad{t},{} but has not been assigned a value yet. Note: \spad{t} should be created as \spad{devaluate(T)\$Lisp} where \spad{T} is the actual type of \spad{f} (this hack is required for the case where \spad{T} is a mapping type).');
INSERT INTO olibdb VALUES('o','declare!',2,'n','(Symbol,FortranType)->FortranType','dTheSymbolTable',NULL,'\spad{declare!(u,{} t)} declares the parameter \spad{u} to have type \spad{t} in the current level of the symbol table.');
INSERT INTO olibdb VALUES('o','declare!',3,'n','(List(Symbol),FortranType,%)->FortranType','dSymbolTable',NULL,'\spad{declare!(l,{} t,{} tab)} creates new entries in tab,{} declaring each of \spad{l} to be of type \spad{t}');
INSERT INTO olibdb VALUES('o','declare!',3,'n','(Symbol,FortranType,%)->FortranType','dSymbolTable',NULL,'\spad{declare!(u,{} t,{} tab)} creates a new entry in tab,{} declaring \spad{u} to be of type \spad{t}');
INSERT INTO olibdb VALUES('o','declare!',3,'n','(Symbol,FortranType,Symbol)->FortranType','dTheSymbolTable',NULL,'\spad{declare!(u,{} t,{} asp)} declares the parameter \spad{u} to have type \spad{t} in asp.');
INSERT INTO olibdb VALUES('o','declare!',4,'n','(List(Symbol),FortranType,Symbol,%)->FortranType','dTheSymbolTable',NULL,'\spad{declare!(u,{} t,{} asp,{} tab)} declares the parameters \spad{u} of subprogram \spad{asp} to have type \spad{t} in symbol table tab.');
INSERT INTO olibdb VALUES('o','declare!',4,'n','(Symbol,FortranType,Symbol,%)->FortranType','dTheSymbolTable',NULL,'\spad{declare!(u,{} t,{} asp,{} tab)} declares the parameter \spad{u} of subprogram \spad{asp} to have type \spad{t} in symbol table tab.');
INSERT INTO olibdb VALUES('o','decompose',1,'x','(%)->Record(id:FractionalIdeal(UP,Fraction(UP),UPUP,R),principalPart:R)','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{decompose(d)} returns \spad{[id,{} f]} where \spad{d = (id) + div(f)}.');
INSERT INTO olibdb VALUES('o','decompose',2,'n','(Fraction(UP),(UP)->UP)->Record(poly:UP,normal:Fraction(UP),special:Fraction(UP))','pMonomialExtensionTools(F,UP)',NULL,'\spad{decompose(f,{} D)} returns \spad{[p,{} n,{} s]} such that \spad{f = p+n+s},{} all the squarefree factors of \spad{denom(n)} are normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} \spad{denom(s)} is special \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and \spad{n} and \spad{s} are proper fractions (no pole at infinity). \spad{D} is the derivation to use.');
INSERT INTO olibdb VALUES('o','decompose',2,'n','(UP,List(UP))->List(UP)','pPartialFractionUtilities(F,UP)',NULL,'\spad{decompose(n,{} [p1,{} ...,{} pn])} returns numerators of partial fraction decomposition of \spad{n} divided by product of \spad{pi}-\spad{s} Note: decomposition is assumed to have no whole part.');
INSERT INTO olibdb VALUES('o','decompose',4,'x','(List(P),List(TS),Boolean,Boolean)->List(TS)','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','decompose',4,'x','(List(P),List(TS),Boolean,Boolean)->List(TS)','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','decompose',7,'x','(List(P),List(TS),Boolean,Boolean,Boolean,Boolean,Boolean)->List(TS)','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','decompose',7,'x','(List(P),List(TS),Boolean,Boolean,Boolean,Boolean,Boolean)->List(TS)','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','decomposeFunc',3,'n','(Fraction(SparseUnivariatePolynomial(Expression(R))),Fraction(SparseUnivariatePolynomial(Expression(R))),Fraction(SparseUnivariatePolynomial(Expression(R))))->Fraction(SparseUnivariatePolynomial(Expression(R)))','pTransSolvePackageService(R)',NULL,'\spad{decomposeFunc(func1,{} func2,{} newvar)} returns a function \spad{func3} where \spad{func1} = \spad{func3}(\spad{func2}) and expresses it in the new variable newvar. If there is no solution then \spad{func1} will be returned.');
INSERT INTO olibdb VALUES('o','decomposeIfCan',1,'x','(UP)->Union(Record(left:UP,right:UP),failed)','pUnivariatePolynomialDecompositionPackage(R,UP)','has(R,Field)','\spad{decomposeIfCan(f)} returns a functional decomposition of the polynomial \spad{f} or failed if it has not found any.');
INSERT INTO olibdb VALUES('o','decreasePrecision',1,'x','(Integer)->PositiveInteger','cFloatingPointSystem','has(%,arbitraryPrecision)','\spad{decreasePrecision(n)} decreases the current \spadfunFrom{precision}{FloatingPointSystem} precision by \spad{n} decimal digits.');
INSERT INTO olibdb VALUES('o','deductions',1,'n','(List(%))->List(%)','dILogic',NULL,'assumes \spad{ln} contains a list of factors which must be \spad{true} for the whole to be \spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','deductions',1,'n','(List(%))->List(%)','dLatticeJoinOfMeets',NULL,'assumes \spad{ln} contains a list of factors which must be \spad{true} for the whole to be \spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','deductions',1,'n','(List(%))->List(%)','dLatticeMeetOfJoins',NULL,'assumes \spad{ln} contains a list of factors which must be \spad{true} for the whole to be \spad{true} (such as the list produced by factor). From this deductions attempts to produce a list of other proposition that must also be \spad{true} by using modus ponens. This is used to determine the returned type when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','deepCopy',1,'n','(%)->%','dSubSpace(n,R)',NULL,'\spad{deepCopy(x)} \undocumented');
INSERT INTO olibdb VALUES('o','deepDiagramSvg',3,'n','(String,A,Boolean)->Void','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deepDiagramSvg',3,'n','(String,%,Boolean)->Void','cFiniteGraph(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deepestInitial',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deepestInitial',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{deepestInitial(p)} returns an error if \spad{p} belongs to \spad{R},{} otherwise returns the last term of \spad{iteratedInitials(p)}.');
INSERT INTO olibdb VALUES('o','deepestTail',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deepestTail',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{deepestTail(p)} returns \spad{0} if \spad{p} belongs to \spad{R},{} otherwise returns tail(\spad{p}),{} if \spad{tail(p)} belongs to \spad{R} or \spad{mvar(tail(p)) < mvar(p)},{} otherwise returns \spad{deepestTail(tail(p))}.');
INSERT INTO olibdb VALUES('o','deepExpand',1,'x','(%)->OutputForm','dFreeNilpotentLie(n,class,R)',NULL,'\spad{deepExpand(x)} rewrites all terms of \spad{x} as commutators of generators.');
INSERT INTO olibdb VALUES('o','defaultEpilogue',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{defaultEpilogue(label)} returns a box that is used at the end of every format.');
INSERT INTO olibdb VALUES('o','defaultPrologue',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{defaultPrologue(label)} returns a box that is used at the beginning of every format.');
INSERT INTO olibdb VALUES('o','defineProperty',3,'n','(%,List(NonNegativeInteger),SubSpaceComponentProperty)->%','dSubSpace(n,R)',NULL,'\spad{defineProperty(s,{} \spad{li},{} p)} defines the component property in the 3 dimensional subspace,{} \spad{s},{} to be that of \spad{p},{} where \spad{p} is of the domain \spadtype{SubSpaceComponentProperty}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose property is being defined. The subspace,{} \spad{s},{} is returned with the component property definition.');
INSERT INTO olibdb VALUES('o','definingEquations',1,'n','(%)->List(Dpoly)','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{definingEquations(s)} returns a list of defining polynomials for equations,{} that is,{} for the Zariski closed part of \spad{s}.');
INSERT INTO olibdb VALUES('o','definingInequation',1,'n','(%)->Dpoly','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{definingInequation(s)} returns a single defining polynomial for the inequation,{} that is,{} the Zariski open part of \spad{s}.');
INSERT INTO olibdb VALUES('o','definingPolynomial',0,'n','()->SparseUnivariatePolynomial(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','definingPolynomial',0,'x','()->SparseUnivariatePolynomial(F)','cFiniteAlgebraicExtensionField(F)',NULL,'\spad{definingPolynomial()} returns the polynomial used to define the field extension.');
INSERT INTO olibdb VALUES('o','definingPolynomial',0,'x','()->UP','cMonogenicAlgebra(R,UP)',NULL,'\spad{definingPolynomial()} returns the minimal polynomial which \spad{generator()} satisfies.');
INSERT INTO olibdb VALUES('o','definingPolynomial',1,'n','(F)->F','pAlgebraicFunction(R,F)','has(R,RetractableTo(Integer))','\spad{definingPolynomial(f)} returns the defining polynomial of \spad{f} as an element of \spad{F}. Error: if \spad{f} is not a kernel.');
INSERT INTO olibdb VALUES('o','definingPolynomial',1,'x','(%)->%','cExpressionSpace2(K)','has(%,Ring)','\spad{definingPolynomial(x)} returns an expression \spad{p} such that \spad{p(x) = 0}.');
INSERT INTO olibdb VALUES('o','definingPolynomial',1,'x','(%)->ThePols','cRealRootCharacterizationCategory(TheField,ThePols)',NULL,'\spad{definingPolynomial(aRoot)} gives a polynomial such that \spad{definingPolynomial(aRoot).aRoot = 0}');
INSERT INTO olibdb VALUES('o','degree',1,'n','(A)->E','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(%)->Expon','cSolvableSkewPolynomialCategory(R,Expon)',NULL,'\spad{degree(p)} returns the maximum of the exponents of the terms of \spad{p}.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(%)->Integer','dLaurentPolynomial(R,UP)',NULL,'\spad{degree(x)} \undocumented');
INSERT INTO olibdb VALUES('o','degree',1,'n','(MPT)->Integer','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{degree(x)} gives degree of \spad{x}.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(%)->NonNegativeInteger','dAntiSymm(R,lVar)',NULL,'\spad{degree(p)} returns the homogeneous degree of \spad{p}.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(%)->NonNegativeInteger','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{degree(df)} returns the homogeneous degree of differential form \spad{df}.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(%)->NonNegativeInteger','dExtAlgBasis',NULL,'\spad{degree(x)} gives the numbers of 1\spad{''s} in \spad{x},{} \spadignore{i.e.} the number of non-zero exponents in the basis element that \spad{x} represents.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(PA)->Integer','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{degree(pol)} returns degree of the polynomial \spad{pol}.');
INSERT INTO olibdb VALUES('o','degree',1,'n','(PrimitiveArray(K))->Integer','pVectorPolynomialOperationsF(K)',NULL,'\spad{degree(v)} is degree of \spad{v} treated as polynomial');
INSERT INTO olibdb VALUES('o','degree',1,'n','(PrimitiveArray(PrimeField(p)))->Integer','pVectorPolynomialOperationsP(p)',NULL,'\spad{degree(v)} is degree of \spad{v} treated as polynomial');
INSERT INTO olibdb VALUES('o','degree',1,'n','(S)->Expon','xUnivariatePowerSeriesCategory&(S,Coef,Expon)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(S)->NonNegativeInteger','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(S)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(S)->OnePointCompletion(PositiveInteger)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(S)->PositiveInteger','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',1,'n','(U32Vector)->Integer','pU32VectorPolynomialOperations',NULL,'\spad{degree(v)} is degree of \spad{v} treated as polynomial');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->E','cAbelianMonoidRing(R,E)',NULL,'\spad{degree(p)} returns the maximum of the exponents of the terms of \spad{p}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->E','cGradedModule(R,E)',NULL,'\spad{degree(g)} names the degree of \spad{g}. The set of all elements of a given degree form an \spad{R}-module.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->Expon','cPowerSeriesCategory(Coef,Expon,Var)',NULL,'\spad{degree(f)} returns the exponent of the lowest order term of \spad{f}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->Fraction(Integer)','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \spad{f(x)},{} which may have zero as a coefficient.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->Integer','cUnivariateLaurentSeriesConstructorCategory(Coef,UTS)',NULL,'\spad{degree(f(x))} returns the degree of the lowest order term of \spad{f(x)},{} which may have zero as a coefficient.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->NonNegativeInteger','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{degree(x)} returns the greatest length of a word in the support of \spad{x}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->NonNegativeInteger','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{degree(ts)} returns the product of main degrees of the members of \spad{ts}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->NonNegativeInteger','cXPolynomialsCat(vl,R)',NULL,'\spad{degree(p)} returns the degree of \spad{p}. \indented{1}{Note that the degree of a word is its length.}');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->NonNegativeInteger','dPermutationGroup(S)',NULL,'\spad{degree(gp)} returns the number of points moved by all permutations of the group {\em gp}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->NonNegativeInteger','dPermutation(S)',NULL,'\spad{degree(p)} returns the number of points moved by the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->OnePointCompletion(PositiveInteger)','cExtensionField(F)',NULL,'\spad{degree(a)} returns the degree of minimal polynomial of an element \spad{a} if \spad{a} is algebraic with respect to the ground field \spad{F},{} and \spad{infinity} otherwise.');
INSERT INTO olibdb VALUES('o','degree',1,'x','(%)->PositiveInteger','cFiniteAlgebraicExtensionField(F)',NULL,'\spad{degree(a)} returns the degree of the minimal polynomial of an element \spad{a} over the ground field \spad{F}.');
INSERT INTO olibdb VALUES('o','degree',2,'n','(A,List(V))->List(NonNegativeInteger)','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(A,S)->NonNegativeInteger','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(A,V)->NonNegativeInteger','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(%,List(VarSet))->List(NonNegativeInteger)','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{degree(p,{} lv)} gives the list of degrees of polynomial \spad{p} with respect to each of the variables in the list \spad{lv}.');
INSERT INTO olibdb VALUES('o','degree',2,'n','(MP,Symbol)->NonNegativeInteger','cModularEvaluationCategory(PT,MP)',NULL,'\spad{degree(p,{} v)} computes degree of \spad{p} with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','degree',2,'n','(S,List(SingletonAsOrderedSet))->List(NonNegativeInteger)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(SparseUnivariatePolynomial(P),List(OV))->List(NonNegativeInteger)','pFactoringUtilities(E,OV,R,P)',NULL,'\spad{degree(upoly,{} lvar)} returns a list containing the maximum degree for each variable in lvar.');
INSERT INTO olibdb VALUES('o','degree',2,'n','(S,SingletonAsOrderedSet)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(%,Symbol)->NonNegativeInteger','dFakePolynomial',NULL,NULL);
INSERT INTO olibdb VALUES('o','degree',2,'n','(%,VarSet)->NonNegativeInteger','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{degree(p,{} v)} gives the degree of polynomial \spad{p} with respect to the variable \spad{v}.');
INSERT INTO olibdb VALUES('o','degree',2,'x','(%,S)->NonNegativeInteger','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{degree(p,{} s)} returns the maximum degree of the differential polynomial \spad{p} viewed as a differential polynomial in the differential indeterminate \spad{s} alone.');
INSERT INTO olibdb VALUES('o','degreePartition',1,'n','(Factored(UP))->Multiset(NonNegativeInteger)','pGaloisGroupPolynomialUtilities(R,UP)',NULL,'\spad{degreePartition(f)} returns the degree partition (\spadignore{i.e.} the multiset of the degrees of the irreducible factors) of the polynomial \spad{f}.');
INSERT INTO olibdb VALUES('o','degreePartition',1,'n','(List(Record(factor:UP,degree:Integer)))->Multiset(NonNegativeInteger)','pGaloisGroupFactorizer(UP)',NULL,'\spad{degreePartition(ddfactorization)} returns the degree partition of the polynomial \spad{f} modulo \spad{p} where \spad{ddfactorization} is the distinct degree factorization of \spad{f} computed by \spad{ddfact} from modular factorization package for some prime \spad{p}.');
INSERT INTO olibdb VALUES('o','degreeSubResultant',3,'n','(polR,polR,NonNegativeInteger)->polR','pPseudoRemainderSequence(R,polR)',NULL,'\spad{degreeSubResultant(P,{} Q,{} d)} computes a subresultant of degree \spad{d}.');
INSERT INTO olibdb VALUES('o','degreeSubResultantEuclidean',3,'n','(polR,polR,NonNegativeInteger)->Record(coef1:polR,coef2:polR,subResultant:polR)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{degreeSubResultantEuclidean(P,{} Q,{} d)} returns a subresultant \spad{S_i} of degree \spad{d} and carries out the equality \spad{coef1*P + coef2*Q = S_i}.');
INSERT INTO olibdb VALUES('o','dehomogenize',1,'n','(List(Record(ratpart:F,coeffs:Vector(F))))->Record(particular:Union(Record(ratpart:F,coeffs:Vector(F)),failed),basis:List(Record(ratpart:F,coeffs:Vector(F))))','pLinearCombinationUtilities(F,UP)',NULL,'\spad{dehomogenize(ls)} converts list of solutions (a,{} [\spad{c0},{} \spad{c1},{} ...,{} \spad{cn}]) to homogeneous equation \spad{L}(a) + \spad{c0} \spad{f} + \spad{c1} \spad{g1} + ... + \spad{cn} \spad{gn} = 0 into list of solutions of inhomogeneous equation \spad{L}(a) + \spad{f} + \spad{c1} \spad{g1} + ... + \spad{cn} \spad{gn} = 0. This transformation works the same for all equations,{} so we only need list of solutions as argument');
INSERT INTO olibdb VALUES('o','delay',1,'x','(()->%)->%','dStream(S)',NULL,'\spad{delay(f)} creates a stream with a lazy evaluation defined by function \spad{f}. Caution: This function can only be called in compiled code.');
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,Integer)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,Integer)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete!',2,'n','(A,Integer)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,Integer)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,UniversalSegment(Integer))->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,UniversalSegment(Integer))->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete!',2,'n','(A,UniversalSegment(Integer))->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete',2,'n','(A,UniversalSegment(Integer))->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','delete!',2,'x','(%,Integer)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{delete!(u,{} i)} destructively deletes the \spad{i}th element of \spad{u}.');
INSERT INTO olibdb VALUES('o','delete',2,'x','(%,Integer)->%','cLinearAggregate(S)',NULL,'\spad{delete(u,{} i)} returns a copy of \spad{u} with the \spad{i}th element deleted. Note: \spad{delete(u,{} i) = concat(u(minIndex(u)..i - 1),{} u(i + 1..))}.');
INSERT INTO olibdb VALUES('o','delete!',2,'x','(%,UniversalSegment(Integer))->%','cExtensibleLinearAggregate(S)',NULL,'\spad{delete!(u,{} i..j)} destructively deletes elements \spad{u}.\spad{i} through \spad{u}.\spad{j}.');
INSERT INTO olibdb VALUES('o','delete',2,'x','(%,UniversalSegment(Integer))->%','cLinearAggregate(S)',NULL,'\spad{delete(u,{} i..j)} returns a copy of \spad{u} with the \spad{i}th through \spad{j}th element deleted. Note: \spad{delete(u,{} i..j) = concat(u(minIndex(u)..i-1),{} u(j+1..))}.');
INSERT INTO olibdb VALUES('o','deleteProperty!',2,'x','(%,Symbol)->%','dBasicOperator',NULL,'\spad{deleteProperty!(op,{} s)} unattaches property \spad{s} from \spad{op}. Argument \spad{op} is modified in place,{} \spadignore{i.e.} no copy is made.');
INSERT INTO olibdb VALUES('o','deleteRow!',2,'n','(%,Integer)->Void','dSparseEchelonMatrix(C,D)',NULL,'\spad{deleteRow(A,{} i)} deletes the \spad{i}\spad{-}th row of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','Delta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Delta()} returns symbol for capital greek letter delta.');
INSERT INTO olibdb VALUES('o','delta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{delta()} returns symbol for small greek letter delta.');
INSERT INTO olibdb VALUES('o','Delta',1,'n','(Symbol)->%','dSparseMultivariateSkewPolynomial(R,Var,sigma,delta)','has(Var,SIGNATURE(variable,Var(Symbol)))','\spad{Delta(s)} returns operator corresponding to derivative with respect to \spad{s} in \spad{R}.');
INSERT INTO olibdb VALUES('o','delta',3,'n','(%,PositiveInteger,PositiveInteger)->NonNegativeInteger','dSetOfMIntegersInOneToN(m,n)',NULL,'\spad{delta(S,{} k,{} p)} returns the number of elements of \spad{S} which are strictly between \spad{p} and the \spad{k^}{th} element of \spad{S}.');
INSERT INTO olibdb VALUES('o','deltaComplex',1,'n','(FiniteCubicalComplex(VS))->%','dDeltaComplex(VS)',NULL,'construct from FiniteCubicalComplex. This builds indexes of edges,{} squares and so on.');
INSERT INTO olibdb VALUES('o','deltaComplex',1,'n','(FiniteSimplicialComplex(VS))->%','dDeltaComplex(VS)',NULL,'construct from FiniteSimplicialComplex. This builds indexes of edges,{} triangles and so on.');
INSERT INTO olibdb VALUES('o','deltaComplex',2,'n','(FiniteSimplicialComplex(VS),Boolean)->%','dDeltaComplex(VS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deltaComplex',3,'n','(List(VS),NonNegativeInteger,List(List(List(Integer))))->%','dDeltaComplex(VS)',NULL,'constructor where the simplices are supplied');
INSERT INTO olibdb VALUES('o','delta_deriv',1,'n','(R)->R','pLinearOrdinaryDifferentialOperator3Aux(Coeff,A,R)',NULL,'\spad{delta_deriv(f)} is x*f'' where \spad{x} is variable in A');
INSERT INTO olibdb VALUES('o','denom',1,'n','(%)->R','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{denom(1/d * (f1,{} ...,{} fn))} returns \spad{d}.');
INSERT INTO olibdb VALUES('o','denom',1,'n','(%)->R','dLocalAlgebra(A,R)',NULL,'\spad{denom x} returns the denominator of \spad{x}.');
INSERT INTO olibdb VALUES('o','denom',1,'n','(%)->R','dLocalize(M,R)',NULL,'\spad{denom x} returns the denominator of \spad{x}.');
INSERT INTO olibdb VALUES('o','denom',1,'x','(%)->S','cQuotientFieldCategory(S)',NULL,'\spad{denom(x)} returns the denominator of the fraction \spad{x}.');
INSERT INTO olibdb VALUES('o','denom',1,'x','(%)->SparseMultivariatePolynomial(Integer,Kernel(%))','dAlgebraicNumber',NULL,'\spad{denom(f)} returns the denominator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.');
INSERT INTO olibdb VALUES('o','denom',1,'x','(%)->SparseMultivariatePolynomial(R,K)','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{denom(f)} returns the denominator of \spad{f} viewed as a polynomial in the kernels over \spad{R}.');
INSERT INTO olibdb VALUES('o','denominator',1,'n','(A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','denominator',1,'n','(%)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{denominator(f)} yields the denominator of \spad{f}.');
INSERT INTO olibdb VALUES('o','denominator',1,'n','(S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','denominator',1,'x','(%)->%','cFunctionSpace2(R,K)','has(R,IntegralDomain)','\spad{denominator(f)} returns the denominator of \spad{f} converted to \%.');
INSERT INTO olibdb VALUES('o','denominator',1,'x','(%)->%','cQuotientFieldCategory(S)',NULL,'\spad{denominator(x)} is the denominator of the fraction \spad{x} converted to \%.');
INSERT INTO olibdb VALUES('o','denominators',1,'x','(%)->Stream(R)','dContinuedFraction(R)',NULL,'\spad{denominators(x)} returns the stream of denominators of the approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.');
INSERT INTO olibdb VALUES('o','denomLODE',2,'n','(L,Fraction(UP))->Union(UP,failed)','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{denomLODE(op,{} g)} returns a polynomial \spad{d} such that any rational solution of \spad{op y = g} is of the form \spad{p/d} for some polynomial \spad{p},{} and failed,{} if the equation has no rational solution.');
INSERT INTO olibdb VALUES('o','denomLODE',2,'n','(L,List(Fraction(UP)))->UP','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{denomLODE(op,{} [g1,{} ...,{} gm])} returns a polynomial \spad{d} such that any rational solution of \spad{op y = c1 g1 + ... + cm gm} is of the form \spad{p/d} for some polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','denomRicDE',1,'n','(L)->UP','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{denomRicDE(op)} returns a polynomial \spad{d} such that any rational solution of the associated Riccati equation of \spad{op y = 0} is of the form \spad{p/d + q''/q + r} for some polynomials \spad{p} and \spad{q} and a reduced \spad{r}. Also,{} \spad{deg(p) < deg(d)} and {\spad{gcd}(\spad{d},{} \spad{q}) = 1}.');
INSERT INTO olibdb VALUES('o','depth',1,'n','(%)->NonNegativeInteger','dOutputBox',NULL,'\spad{depth(box)} returns the height of the \spad{box} below the baseline.');
INSERT INTO olibdb VALUES('o','depth',1,'n','(%)->NonNegativeInteger','dPattern(R)',NULL,'\spad{depth(p)} returns the nesting level of \spad{p}.');
INSERT INTO olibdb VALUES('o','dequeue',1,'x','(List(S))->%','dDequeue(S)',NULL,'\spad{dequeue([x,{} y,{} ...,{} z])} creates a dequeue with first (top or front) element \spad{x},{} second element \spad{y},{} ...,{} and last (bottom or back) element \spad{z}.');
INSERT INTO olibdb VALUES('o','dequeue!',1,'x','(%)->S','cQueueAggregate(S)',NULL,'\spad{dequeue!(q)} destructively extracts the first (top) element from queue \spad{q}. The element previously second in the queue becomes the first element. Error: if \spad{q} is empty.');
INSERT INTO olibdb VALUES('o','deref',1,'n','(%)->S','dReference(S)',NULL,'\spad{deref(n)} is equivalent to \spad{elt(n)}.');
INSERT INTO olibdb VALUES('o','deriv',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{deriv(a)} returns the derivative of the power series with respect to the power series variable. Thus \spad{deriv([a0,{} a1,{} a2,{} ...])} returns \spad{[a1,{} 2 a2,{} 3 a3,{} ...]}.');
INSERT INTO olibdb VALUES('o','deriv',1,'n','(Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{deriv(f)} is the derivative,{} which simply coincides with left shift');
INSERT INTO olibdb VALUES('o','derivationCoordinates',2,'n','(Vector(S),(R)->R)->Matrix(R)','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','derivationCoordinates',2,'x','(Vector(%),(R)->R)->Matrix(R)','cMonogenicAlgebra(R,UP)','has(R,Field)','\spad{derivationCoordinates(b,{} '')} returns \spad{M} such that \spad{b'' = M b}.');
INSERT INTO olibdb VALUES('o','derivative',1,'x','(BasicOperator)->Union(List((List(A))->A),failed)','pBasicOperatorFunctions1(A)',NULL,'\spad{derivative(op)} returns the value of the \%diff property of \spad{op} if it has one,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','derivative',2,'x','(BasicOperator,(A)->A)->BasicOperator','pBasicOperatorFunctions1(A)',NULL,'\spad{derivative(op,{} foo)} attaches foo as the \%diff property of \spad{op}. If \spad{op} has an \%diff property \spad{f},{} then applying a derivation \spad{D} to \spad{op}(a) returns \spad{f(a) * D(a)}. Argument \spad{op} must be unary.');
INSERT INTO olibdb VALUES('o','derivative',2,'x','(BasicOperator,List((List(A))->A))->BasicOperator','pBasicOperatorFunctions1(A)',NULL,'\spad{derivative(op,{} [foo1,{} ...,{} foon])} attaches [\spad{foo1},{} ...,{} foon] as the \%diff property of \spad{op}. If \spad{op} has an \%diff property \spad{[f1,{} ...,{} fn]} then applying a derivation \spad{D} to \spad{op(a1,{} ...,{} an)} returns \spad{f1(a1,{} ...,{} an) * D(a1) + ... + fn(a1,{} ...,{} an) * D(an)}.');
INSERT INTO olibdb VALUES('o','derivativeOf?',2,'n','(%,%)->List(NonNegativeInteger)','cJetBundleCategory',NULL,'\spad{derivativeOf?(jv1,{} jv2)} checks whether \spad{jv1} is a derivative of \spad{jv2}. In this case,{} the difference of their multi-indices is returned. Otherwise,{} an empty list is returned.');
INSERT INTO olibdb VALUES('o','derivativeOf?',2,'n','(S,S)->List(NonNegativeInteger)','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','deserialize',1,'n','(None)->None','pFileSerialization',NULL,'\spad{deserialize(d)} reconstructs \spad{o} from \spad{d := serialize(o)}.');
INSERT INTO olibdb VALUES('o','destruct',1,'n','(%)->List(Record(key:Symbol,entry:S))','dPatternMatchResult(R,S)',NULL,'\spad{destruct(r)} returns the list of matches (var,{} expr) in \spad{r}. Error: if \spad{r} is a failed match.');
INSERT INTO olibdb VALUES('o','destruct',1,'x','(%)->List(%)','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{destruct((a1,{} ...,{} an))} returns the list [\spad{a1},{} ...,{} an].');
INSERT INTO olibdb VALUES('o','determinant',1,'n','(M)->R','pInnerMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,Field)','\spad{determinant(m)} returns the determinant of the matrix \spad{m}. an error message is returned if the matrix is not square.');
INSERT INTO olibdb VALUES('o','determinant',1,'x','(M)->R','pMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{determinant(m)} returns the determinant of the matrix \spad{m}. an error message is returned if the matrix is not square.');
INSERT INTO olibdb VALUES('o','determinant',1,'x','(%)->R','cMatrixCategory(R,Row,Col)','has(R,CommutativeRing)','\spad{determinant(m)} returns the determinant of the matrix \spad{m}. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','determinant',1,'x','(%)->R','cSquareMatrixCategory(ndim,R,Row,Col)','has(R,CommutativeRing)','\spad{determinant(m)} returns the determinant of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','detSys',1,'n','(List(JetBundleExpression(JB1)))->List(JetBundleExpression(JetBundleSymAna(JB1,xi,eta)))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{detSys(sys)} computes the determining system for symmetry generators of the system \spad{sys}. It is assumed that each equation can be solved for its leading derivative.');
INSERT INTO olibdb VALUES('o','detSys',2,'n','(List(JetBundleExpression(JB1)),JetVectorField(JB1,JetBundleExpression(JB1)))->List(JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{detSys(sys,{} vf)} computes the determining system for symmetry generators of the system \spad{sys} with a given ansatz for the generators. It is assumed that each equation can be solved for its leading derivative.');
INSERT INTO olibdb VALUES('o','detSys',3,'n','(List(JetBundleExpression(JB1)),List(JB1),JetVectorField(JB1,JetBundleExpression(JB1)))->List(JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{detSys(sys,{} sjb,{} vf)} computes the determining system for symmetry generators of the system \spad{sys} with a given ansatz for the generators. \spad{sjb} contains jet variables for which the individual equations can be solved.');
INSERT INTO olibdb VALUES('o','detSysNS',1,'n','(List(JetBundleExpression(JB1)))->List(JetBundleExpression(JetBundleSymAna(JB1,xi,eta)))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{detSysNS(sys,{} vf)} computes the determining system for symmetry generators without assuming solvability of the equations for some derivatives.');
INSERT INTO olibdb VALUES('o','detSysNS',2,'n','(List(JetBundleExpression(JB1)),JetVectorField(JB1,JetBundleExpression(JB1)))->List(JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{detSysNS(sys,{} vf)} computes the determining system for symmetry generators without assuming solvability of the equations for some derivatives.');
INSERT INTO olibdb VALUES('o','det_via_common_denominator',1,'n','(Matrix(Fraction(R)))->Fraction(R)','pCharacteristicPolynomial3(R)','has(R,GcdDomain)','\spad{det_via_common_denominator(m)} computes determinant of \spad{m}.');
INSERT INTO olibdb VALUES('o','diag',1,'x','((A,A)->C)->(A)->C','pMappingPackage2(A,C)',NULL,'\spad{diag(f)} is the function \spad{g} \indented{1}{such that \spad{g a = f(a,{} a)}.}');
INSERT INTO olibdb VALUES('o','diagonal?',1,'n','(S)->Boolean','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonal?',1,'n','(S)->Boolean','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonal',1,'n','(S)->Row','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonal?',1,'x','(%)->Boolean','cMatrixCategory(R,Row,Col)',NULL,'\spad{diagonal?(m)} returns \spad{true} if the matrix \spad{m} is square and diagonal (\spadignore{i.e.} all entries of \spad{m} not on the diagonal are zero) and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','diagonal?',1,'x','(%)->Boolean','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{diagonal?(m)} returns \spad{true} if the matrix \spad{m} is square and diagonal (\spadignore{i.e.} all entries of \spad{m} not on the diagonal are zero) and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','diagonal',1,'x','(%)->Row','cSquareMatrixCategory(ndim,R,Row,Col)',NULL,'\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','diagonal?',2,'n','(%,NonNegativeInteger)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{diagonal?(p,{} l)} is the matrix \spad{l} diagonal?');
INSERT INTO olibdb VALUES('o','diagonal',2,'n','(%,NonNegativeInteger)->List(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{diagonal(p,{} l)} returns the entries along the diagonal in a list.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'n','(List(R))->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'n','(List(S))->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'n','(M)->M','pMatrixManipulation(R,Row,Col,M)','has(R,AbelianMonoid)','\spad{diagonalMatrix} returns the main diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'x','(List(%))->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{diagonalMatrix([m1,{} ...,{} mk])} creates a block diagonal matrix \spad{M} with block matrices {\em m1},{} ...,{} {\em mk} down the diagonal,{} with 0 block matrices elsewhere. More precisely: if \spad{\spad{ri} := nrows \spad{mi}},{} \spad{\spad{ci} := ncols \spad{mi}},{} then \spad{m} is an (\spad{r1+}..\spad{+rk}) by (\spad{c1+}..\spad{+ck}) - matrix with entries \spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))},{} if \spad{(r1+..+r(l-1)) < i <= r1+..+rl} and \spad{(c1+..+c(l-1)) < i <= c1+..+cl},{} \spad{m.i.j} = 0 otherwise.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'x','(List(R))->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \spad{l} on the diagonal.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'x','(List(R))->%','cSquareMatrixCategory(ndim,R,Row,Col)',NULL,'\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \spad{l} on the diagonal.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',1,'x','(Vector(R))->%','dMatrix(R)',NULL,'\spad{diagonalMatrix(v)} returns a diagonal matrix where the elements of \spad{v} appear on the diagonal.');
INSERT INTO olibdb VALUES('o','diagonalMatrix',2,'n','(M,Integer)->M','pMatrixManipulation(R,Row,Col,M)','has(R,AbelianMonoid)','\spad{diagonalMatrix} returns a diagonal out of a matrix. The diagonal is put into a matrix of same shape as the original one. Positive integer arguments select upper off-diagonals,{} negative ones lower off-diagonals.');
INSERT INTO olibdb VALUES('o','diagonalProduct',1,'n','(Matrix(R))->R','pIntegralBasisTools(R,UP,F)',NULL,'\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \spad{m}');
INSERT INTO olibdb VALUES('o','diagonalProduct',1,'n','(S)->R','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagonalProduct',1,'x','(%)->R','cSquareMatrixCategory(ndim,R,Row,Col)',NULL,'\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','diagonals',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{diagonals(v,{} s)} displays the diagonals of the polygon outline showing a triangularized surface instead of a quadrilateral surface outline,{} for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is on,{} or does not display the diagonals if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','diagramHeight',1,'n','(A)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagramHeight',1,'n','(%)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{diagramHeight(s)} returns the height of the diagram that will be generated by diagramSvg. This is the maximum posY of all vertices in graph \spad{s}');
INSERT INTO olibdb VALUES('o','diagramsSvg',3,'n','(String,List(A),Boolean)->Void','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagramsSvg',3,'n','(String,List(%),Boolean)->Void','cFiniteGraph(S)',NULL,'creates \spad{SVG} diagram containing multiple graphs fileName: String is the name of the \spad{SVG} file that will be created \spad{ln:} List \% is list of graphs that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow');
INSERT INTO olibdb VALUES('o','diagramSvg2',3,'n','(String,%,Boolean)->Void','dUndirectedGraph(S)',NULL,'diagramSvg(fileName,{} \spad{n},{} dispArrowName) creates an \spad{SVG} diagram. This is an alternative version which does not shorten lines. fileName: String is the name of the \spad{SVG} file that will be created \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow');
INSERT INTO olibdb VALUES('o','diagramSvg',3,'n','(String,A,Boolean)->Void','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagramSvg',3,'n','(String,%,Boolean)->Void','cFiniteGraph(S)',NULL,'\spad{diagramSvg(fileName,{} n,{} dispArrowName)} creates an \spad{SVG} diagram fileName: String is the name of the \spad{SVG} file that will be created \spad{n:} \% is the graph that will be written dispArrowName: Boolean is \spad{true} to include the name of each arrow');
INSERT INTO olibdb VALUES('o','diagramWidth',1,'n','(A)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diagramWidth',1,'n','(%)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{diagramWidth(s)} returns the width of the diagram that will be generated by diagramSvg. This is the maximum posX of all vertices in graph \spad{s}');
INSERT INTO olibdb VALUES('o','dictionary',0,'n','()->A','xDictionary&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dictionary',0,'n','()->A','xDictionaryOperations&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dictionary',0,'x','()->%','cDictionaryOperations(S)',NULL,'\spad{dictionary()}\$\spad{D} creates an empty dictionary of type \spad{D}.');
INSERT INTO olibdb VALUES('o','dictionary',1,'n','(List(S))->A','xDictionary&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dictionary',1,'n','(List(S))->A','xDictionaryOperations&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dictionary',1,'x','(List(S))->%','cDictionaryOperations(S)',NULL,'\spad{dictionary([x,{} y,{} ...,{} z])} creates a dictionary consisting of entries \spad{x,{} y,{} ...,{} z}.');
INSERT INTO olibdb VALUES('o','diff',1,'n','(JB)->%','dJetVectorField(JB,D)',NULL,'\spad{diff(jb)} returns the base vector field in direction \spad{jb}.');
INSERT INTO olibdb VALUES('o','diff',1,'n','(Symbol)->(F)->F','pODEIntegration(R,F)',NULL,'\spad{diff(x)} returns the derivation with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','DiffAction',3,'n','(NonNegativeInteger,NonNegativeInteger,V)->D','pFractionFreeFastGaussian(D,V)',NULL,'\spad{DiffAction(k,{} l,{} g)} gives the coefficient of \spad{x^k} in \spad{z^l} \spad{g}(\spad{x}),{} where \spad{z*}(a+b*x+c*x^2+d*x^3+...) = (a*x+b*x^2+c*x^3+...),{} \spadignore{i.e.} multiplication with \spad{x}.');
INSERT INTO olibdb VALUES('o','DiffC',1,'n','(NonNegativeInteger)->List(D)','pFractionFreeFastGaussian(D,V)',NULL,'\spad{DiffC} gives the coefficients \spad{c_}{\spad{k},{} \spad{k}} in the expansion <x^k> \spad{z} \spad{g}(\spad{x}) = sum_{\spad{i=0}}\spad{^k} \spad{c_}{\spad{k},{} \spad{i}} <x^i> \spad{g}(\spad{x}),{} where \spad{z} acts on \spad{g}(\spad{x}) by shifting. In fact,{} the result is [0,{} 0,{} 0,{} ...]');
INSERT INTO olibdb VALUES('o','difference',2,'n','(A,A)->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','difference',2,'n','(A,A)->A','xSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','difference',2,'n','(A,S)->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','difference',2,'n','(A,S)->A','xSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','difference',2,'x','(%,%)->%','cSetAggregate(S)',NULL,'\spad{difference(u,{} v)} returns the set aggregate \spad{w} consisting of elements in set aggregate \spad{u} but not in set aggregate \spad{v}. If \spad{u} and \spad{v} have no elements in common,{} \spad{difference(u,{} v)} returns a copy of \spad{u}. Note: equivalent to the notation (not currently supported) \spad{[x for x in u | not member?(x,{} v)]}.');
INSERT INTO olibdb VALUES('o','difference',2,'x','(%,S)->%','cSetAggregate(S)',NULL,'\spad{difference(u,{} x)} returns the set aggregate \spad{u} with element \spad{x} removed. If \spad{u} does not contain \spad{x},{} a copy of \spad{u} is returned. Note: \spad{difference(s,{} x) = difference(s,{} set [x])}.');
INSERT INTO olibdb VALUES('o','differentials',1,'n','(%)->List(JB)','dJetDifferential(JB,D)',NULL,'\spad{directions(om)} yields the differentials where \spad{om} has non-vanishing coefficients.');
INSERT INTO olibdb VALUES('o','differentialVariables',1,'n','(A)->List(S)','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentialVariables',1,'x','(%)->List(S)','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(A)->A','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xDifferentialRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'n','(S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',1,'x','(%)->%','cDifferentialRing',NULL,'\spad{differentiate(x)} returns the derivative of \spad{x}. This function is a simple differential operator where no variable needs to be specified.');
INSERT INTO olibdb VALUES('o','differentiate',1,'x','(%)->%','cDifferentialVariableCategory(S)',NULL,'\spad{differentiate(v)} returns the derivative of \spad{v}.');
INSERT INTO olibdb VALUES('o','differentiate',1,'x','(%)->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{differentiate(f)} returns the derivative of \spad{f}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,List(S))->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,List(Symbol))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,List(Symbol))->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,List(V))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,NonNegativeInteger)->A','xDifferentialVariableCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,NonNegativeInteger)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,(R)->R)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,S)->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,(S)->S)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,Symbol)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,Symbol)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(A,V)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,(F)->F)->F','dIntegrationResult(F)',NULL,'\spad{differentiate(ir,{} D)} differentiates \spad{ir} with respect to the derivation \spad{D}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,JB)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{differentiate(f,{} jv)} differentiates the function \spad{f} \spad{wrt} the jet variable \spad{jv}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,NonNegativeInteger)->%','dOutputForm',NULL,'\spad{differentiate(f,{} n)} creates a form for the \spad{n}th derivative of \spad{f},{} \spadignore{e.g.} \spad{f''},{} \spad{f''''},{} \spad{f''''''},{} \spad{f} super \spad{iv}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,PositiveInteger)->Union(%,0)','cJetBundleCategory',NULL,'\spad{differentiate(jv,{} i)} differentiates \spad{jv} \spad{wrt} the \spad{i}\spad{-}th independent variable.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(Fraction(UP))->Fraction(UP))->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(SingletonAsOrderedSet))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,List(Symbol))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xDifferentialRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,PositiveInteger)->Union(S,0)','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(R)->R)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,SingletonAsOrderedSet)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,Symbol)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(S,(UP)->UP)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Symbol)->F','dIntegrationResult(F)','has(F,PartialDifferentialRing(Symbol))','\spad{differentiate(ir,{} x)} differentiates \spad{ir} with respect to \spad{x}');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(U32Vector,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'Polynomial differentiation.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dSparseUnivariateLaurentSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dSparseUnivariatePuiseuxSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dSparseUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} computes the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dUnivariateLaurentSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dUnivariatePuiseuxSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(var))->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} computes the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'n','(%,Variable(''x))->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,List(S))->%','cPartialDifferentialRing(S)',NULL,'\spad{differentiate(x,{} [s1,{} ...sn])} computes successive partial derivatives,{} \spadignore{i.e.} \spad{differentiate(...differentiate(x,{} s1)...,{} sn)}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,NonNegativeInteger)->%','cDifferentialRing',NULL,'\spad{differentiate(x,{} n)} returns the \spad{n}-th derivative of \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,NonNegativeInteger)->%','cDifferentialVariableCategory(S)',NULL,'\spad{differentiate(v,{} n)} returns the \spad{n}-th derivative of \spad{v}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,NonNegativeInteger)->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{differentiate(f,{} n)} returns the \spad{n}-th derivative of \spad{f}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,(R)->R)->%','cDifferentialExtension(R)',NULL,'\spad{differentiate(x,{} deriv)} differentiates \spad{x} extending the derivation deriv on \spad{R}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,S)->%','cPartialDifferentialRing(S)',NULL,'\spad{differentiate(x,{} v)} computes the partial derivative of \spad{x} with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,(UP)->UP)->%','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{differentiate(x,{} d)} extends the derivation \spad{d} from UP to \$ and applies it to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',2,'x','(%,Variable(var))->%','dGeneralUnivariatePowerSeries(Coef,var,cen)',NULL,'\spad{differentiate(f(x),{} x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,List(S),List(NonNegativeInteger))->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,List(Symbol),List(NonNegativeInteger))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,List(Symbol),List(NonNegativeInteger))->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,List(V),List(NonNegativeInteger))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,(R)->R,NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,S,NonNegativeInteger)->A','xPartialDifferentialRing&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,(S)->S,NonNegativeInteger)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,Symbol,NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,Symbol,NonNegativeInteger)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(A,V,NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(Fraction(UP))->Fraction(UP),NonNegativeInteger)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(SingletonAsOrderedSet),List(NonNegativeInteger))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,List(Symbol),List(NonNegativeInteger))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,(R)->R,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,SingletonAsOrderedSet,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xDifferentialExtension&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xSquareMatrixCategory&(S,ndim,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(S,Symbol,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','differentiate',3,'n','(U32Vector,NonNegativeInteger,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'Polynomial differentiation.');
INSERT INTO olibdb VALUES('o','differentiate',3,'x','(%,List(S),List(NonNegativeInteger))->%','cPartialDifferentialRing(S)',NULL,'\spad{differentiate(x,{} [s1,{} ...,{} sn],{} [n1,{} ...,{} nn])} computes multiple partial derivatives,{} \spadignore{i.e.}');
INSERT INTO olibdb VALUES('o','differentiate',3,'x','(%,(R)->R,%)->%','cUnivariatePolynomialCategory(R)','has(R,Ring)','\spad{differentiate(p,{} d,{} x'')} extends the \spad{R}-derivation \spad{d} to an extension \spad{D} in \spad{R[x]} where \spad{Dx} is given by \spad{x''},{} and returns \spad{Dp}.');
INSERT INTO olibdb VALUES('o','differentiate',3,'x','(%,(R)->R,NonNegativeInteger)->%','cDifferentialExtension(R)',NULL,'\spad{differentiate(x,{} deriv,{} n)} differentiate \spad{x} \spad{n} times using a derivation which extends \spad{deriv} on \spad{R}.');
INSERT INTO olibdb VALUES('o','differentiate',3,'x','(%,S,NonNegativeInteger)->%','cPartialDifferentialRing(S)',NULL,'\spad{differentiate(x,{} s,{} n)} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{n}-th derivative of \spad{x} with respect to \spad{s}.');
INSERT INTO olibdb VALUES('o','diffextint',3,'n','((List(UP))->List(Record(ratpart:F,coeffs:Vector(F))),(Matrix(F))->List(Vector(F)),List(Fraction(UP)))->List(Record(ratpart:F,coeffs:Vector(F)))','pParametricTranscendentalIntegration(F,UP)',NULL,'\spad{diffextint(ext,{} csolve,{} [g1,{} ...,{} gn])} is like primextint and expextint but for differentialy transcendental extensions.');
INSERT INTO olibdb VALUES('o','diffHP',1,'n','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(AlgebraicNumber))->Stream(UnivariateFormalPowerSeries(AlgebraicNumber)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(AlgebraicNumber))->AlgebraicNumber,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(AlgebraicNumber))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'n','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(AlgebraicNumber))->Stream(UnivariateFormalPowerSeries(AlgebraicNumber)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(AlgebraicNumber))->AlgebraicNumber,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger)))->SparseMultivariatePolynomial(AlgebraicNumber,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(AlgebraicNumber))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Integer)))->Stream(UnivariateFormalPowerSeries(Fraction(Integer))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Integer))->Integer,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(Integer)))->Polynomial(Integer),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(Integer)))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(R))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(R)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(R)))->Polynomial(R),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(R)))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(F))->F,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(F))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(EXPRR,Symbol)->Stream(EXPRR),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(S))->S,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,EXPRR)->EXPRR,C:(NonNegativeInteger)->List(S))','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{diffHP options} returns a specification for Hermite-Pade approximation with the differential operator');
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Integer)))->Stream(UnivariateFormalPowerSeries(Fraction(Integer))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Integer))->Integer,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Integer),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(Integer)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(Integer)))->Polynomial(Integer),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(Integer)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(Integer)))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(Fraction(Polynomial(R))))->Stream(UnivariateFormalPowerSeries(Fraction(Polynomial(R)))),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(Polynomial(R)))->Polynomial(R),AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger)))->SparseMultivariatePolynomial(Fraction(Polynomial(R)),NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(Polynomial(R)))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(Expression(Integer),Symbol)->Stream(Expression(Integer)),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(F))->F,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,Expression(Integer))->Expression(Integer),C:(NonNegativeInteger)->List(F))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','diffHP',1,'x','(Symbol)->(List(GuessOption))->Record(degreeStream:Stream(NonNegativeInteger),guessStream:(UnivariateFormalPowerSeries(F))->Stream(UnivariateFormalPowerSeries(F)),guessModGen:(NonNegativeInteger)->(List(U32Vector),Integer,Integer)->Vector(U32Vector),testGen:(List(PositiveInteger))->(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->Vector(UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger))),exprStream:(EXPRR,Symbol)->Stream(EXPRR),kind:Symbol,qvar:Symbol,A:(NonNegativeInteger,NonNegativeInteger,SparseUnivariatePolynomial(S))->S,AF:(NonNegativeInteger,NonNegativeInteger,UnivariateFormalPowerSeries(SparseMultivariatePolynomial(F,NonNegativeInteger)))->SparseMultivariatePolynomial(F,NonNegativeInteger),AX:(NonNegativeInteger,Symbol,EXPRR)->EXPRR,C:(NonNegativeInteger)->List(S))','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{diffHP options} returns a specification for Hermite-Pade approximation with the \$\spad{q}\$-dilation operator');
INSERT INTO olibdb VALUES('o','diff_map',1,'n','(Var)->(R)->R','pPartialDifferentialOperatorHelper(R,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','diffP',2,'n','(PositiveInteger,List(NonNegativeInteger))->%','dJetVectorField(JB,D)',NULL,'\spad{diffP(i,{} mu)} returns the base vector field in direction \spad{P(i,{} mu)}.');
INSERT INTO olibdb VALUES('o','diffU',1,'n','(PositiveInteger)->%','dJetVectorField(JB,D)',NULL,'\spad{diffU(i)} returns the base vector field in direction \spad{U(i)}.');
INSERT INTO olibdb VALUES('o','diffX',1,'n','(PositiveInteger)->%','dJetVectorField(JB,D)',NULL,'\spad{diffX(i)} returns the base vector field in direction \spad{X(i)}.');
INSERT INTO olibdb VALUES('o','digamma',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{digamma(x)} returns the digamma function applied to \spad{x}.');
INSERT INTO olibdb VALUES('o','digamma',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','digamma',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{digamma(z)} is the logarithmic derivative of \spad{Gamma(x)}.');
INSERT INTO olibdb VALUES('o','digamma',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{digamma(x)} is the logarithmic derivative of \spad{Gamma(x)} (often written \spad{psi(x)} in the literature).');
INSERT INTO olibdb VALUES('o','digamma',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','digamma',1,'x','(Float)->Float','pFloatSpecialFunctions',NULL,'\spad{digamma(z)} is the logarithmic derivative of \spad{Gamma(x)}.');
INSERT INTO olibdb VALUES('o','digit',0,'x','()->%','dCharacterClass',NULL,'\spad{digit()} returns the class of all characters for which \spadfunFrom{digit?}{Character} is \spad{true}.');
INSERT INTO olibdb VALUES('o','digit?',1,'x','(%)->Boolean','dCharacter',NULL,'\spad{digit?(c)} tests if \spad{c} is a digit character,{} \spadignore{i.e.} one of 0..9.');
INSERT INTO olibdb VALUES('o','digits',0,'n','()->PositiveInteger','xFloatingPointSystem&(S)',NULL,'\spad{digits()} returns ceiling\spad{''s} precision in decimal digits.');
INSERT INTO olibdb VALUES('o','digits',0,'x','()->PositiveInteger','cFloatingPointSystem',NULL,'\spad{digits()} returns ceiling\spad{''s} precision in decimal digits.');
INSERT INTO olibdb VALUES('o','digits',1,'n','(PositiveInteger)->PositiveInteger','xFloatingPointSystem&(S)',NULL,'\spad{digits(d)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{d} digits.');
INSERT INTO olibdb VALUES('o','digits',1,'x','(PositiveInteger)->PositiveInteger','cFloatingPointSystem','has(%,arbitraryPrecision)','\spad{digits(d)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{d} digits.');
INSERT INTO olibdb VALUES('o','digits',1,'x','(%)->Stream(Integer)','cPAdicIntegerCategory(p)',NULL,'\spad{digits(x)} returns a stream of \spad{p}-adic digits of \spad{x}.');
INSERT INTO olibdb VALUES('o','dihedral',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{dihedral n} is the cycle index of the \indented{1}{dihedral group of degree \spad{n}.}');
INSERT INTO olibdb VALUES('o','dihedralGroup',1,'n','(PositiveInteger)->%','dGroupPresentation',NULL,'\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,{} ...,{} \spad{N}.');
INSERT INTO olibdb VALUES('o','dihedralGroup',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{dihedralGroup([i1,{} ...,{} ik])} constructs the dihedral group of order 2k acting on the integers out of {\em i1},{} ...,{} {\em ik}. Note: duplicates in the list will be removed.');
INSERT INTO olibdb VALUES('o','dihedralGroup',1,'x','(PositiveInteger)->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,{} ...,{} \spad{N}.');
INSERT INTO olibdb VALUES('o','dilate',2,'n','(R,%)->%','cSequenceCategory(R)',NULL,'\spad{dilate(a,{} x)} returns the sequence \$a^n \spad{x_n}\$ (starting at \$\spad{n=1}\$)');
INSERT INTO olibdb VALUES('o','dilog',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{dilog(f)} denotes the dilogarithm');
INSERT INTO olibdb VALUES('o','dilog',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{dilog(x)} returns the dilogarithm of \spad{x},{} \spadignore{i.e.} the integral of \spad{log(x) / (1 - x) dx}.');
INSERT INTO olibdb VALUES('o','dilog',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{dilog(z)} is the dilogarithm');
INSERT INTO olibdb VALUES('o','dim',1,'x','(Color)->%','dPalette',NULL,'\spad{dim(c)} sets the shade of a hue,{} \spad{c},{} above dark,{} but below bright.');
INSERT INTO olibdb VALUES('o','dimension',0,'x','()->NonNegativeInteger','dFreeNilpotentLie(n,class,R)',NULL,'\spad{dimension()} is the rank of this Lie algebra');
INSERT INTO olibdb VALUES('o','dimension',1,'n','(%)->NonNegativeInteger','dCell(TheField)',NULL,'\spad{dimension(c)} returns dimension of \spad{c}');
INSERT INTO olibdb VALUES('o','dimension',1,'n','(%)->NonNegativeInteger','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{dimension(f)} returns the dimension of the ALS.');
INSERT INTO olibdb VALUES('o','dimension',1,'n','(%)->PositiveInteger','cSPointCategory',NULL,'\spad{dimension(p)} returns the number of dimensions that make up the point category \spad{p}.');
INSERT INTO olibdb VALUES('o','dimension',1,'x','(%)->Integer','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{dimension(I)} gives the dimension of the ideal \spad{I}. in the ring \spad{F[lvar]},{} where lvar are the variables appearing in \spad{I}');
INSERT INTO olibdb VALUES('o','dimension',1,'x','(%)->PositiveInteger','cPointCategory(R)',NULL,'\spad{dimension(s)} returns the dimension of the point category \spad{s}.');
INSERT INTO olibdb VALUES('o','dimension',2,'n','(%,NonNegativeInteger)->NonNegativeInteger','dJetDifferentialEquation(JB,D)',NULL,'\spad{dimension(de,{} q)} computes the dimension of the differential equation \spad{de} as a submanifold of the \spad{q}\spad{-}th order jet bundle. The result is correct only,{} if \spad{de} is simplified.');
INSERT INTO olibdb VALUES('o','dimension',2,'x','(%,List(VarSet))->Integer','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{dimension(I,{} lvar)} gives the dimension of the ideal \spad{I},{} in the ring \spad{F[lvar]}');
INSERT INTO olibdb VALUES('o','dimension',3,'n','(List(%),SparseEchelonMatrix(JB,%),NonNegativeInteger)->NonNegativeInteger','cJetBundleFunctionCategory(JB)',NULL,'\spad{dimension(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \spad{sys} with Jacobi matrix \spad{jm} in the jet bundle of order \spad{q}.');
INSERT INTO olibdb VALUES('o','dimension',3,'n','(List(S),SparseEchelonMatrix(JB,S),NonNegativeInteger)->NonNegativeInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dimensionOfIrreducibleRepresentation',1,'x','(List(Integer))->NonNegativeInteger','pIrrRepSymNatPackage',NULL,'\spad{dimensionOfIrreducibleRepresentation(lambda)} is the dimension of the ordinary irreducible representation of the symmetric group corresponding to {\em lambda}. Note: the Robinson-Thrall hook formula is implemented.');
INSERT INTO olibdb VALUES('o','dimensions',5,'n','(%,NonNegativeInteger,NonNegativeInteger,PositiveInteger,PositiveInteger)->Void','dTwoDimensionalViewport',NULL,'\spad{dimensions(v,{} x,{} y,{} width,{} height)} sets the position of the upper left-hand corner of the two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} to the window coordinate \spad{x},{} \spad{y},{} and sets the dimensions of the window to that of \spad{width},{} \spad{height}. The new dimensions are not displayed until the function \spadfun{makeViewport2D} is executed again for \spad{v}.');
INSERT INTO olibdb VALUES('o','dimensions',5,'x','(%,NonNegativeInteger,NonNegativeInteger,PositiveInteger,PositiveInteger)->Void','dThreeDimensionalViewport',NULL,'\spad{dimensions(v,{} x,{} y,{} width,{} height)} sets the position of the upper left-hand corner of the three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} to the window coordinate \spad{x},{} \spad{y},{} and sets the dimensions of the window to that of \spad{width},{} \spad{height}. The new dimensions are not displayed until the function \spadfun{makeViewport3D} is executed again for \spad{v}.');
INSERT INTO olibdb VALUES('o','dimensionsOf',1,'n','(%)->List(Polynomial(Integer))','dFortranType',NULL,'\spad{dimensionsOf(t)} returns the dimensions of \spad{t}');
INSERT INTO olibdb VALUES('o','dimJ',1,'n','(NonNegativeInteger)->NonNegativeInteger','cJetBundleCategory',NULL,'\spad{dimJ(q)} computes the (fibre) dimension of the \spad{q}\spad{-}th order jet bundle.');
INSERT INTO olibdb VALUES('o','dimJ',1,'n','(NonNegativeInteger)->NonNegativeInteger','xJetBundleCategory&(S)',NULL,'\spad{dimJ(q)} computes the (fibre) dimension of the \spad{q}\spad{-}th order jet bundle.');
INSERT INTO olibdb VALUES('o','dimS',1,'n','(NonNegativeInteger)->NonNegativeInteger','cJetBundleCategory',NULL,'\spad{dimS(q)} computes dimension of \spad{SqT} \spad{x} VE (= number of derivatives of order \spad{q}).');
INSERT INTO olibdb VALUES('o','dimS',1,'n','(NonNegativeInteger)->NonNegativeInteger','xJetBundleCategory&(S)',NULL,'\spad{dimS(q)} computes dimension of \spad{SqT} \spad{x} VE (= number of derivatives of order \spad{q}).');
INSERT INTO olibdb VALUES('o','diophantineSystem',2,'x','(M,Col)->Record(particular:Union(Col,failed),basis:List(Col))','pSmithNormalForm(R,Row,Col,M)',NULL,'\spad{diophantineSystem(A,{} B)} returns a particular integer solution and an integer basis of the equation \spad{A X = B}.');
INSERT INTO olibdb VALUES('o','dioSolve',1,'x','(Equation(Polynomial(Integer)))->Record(varOrder:List(Symbol),inhom:Union(List(Vector(NonNegativeInteger)),failed),hom:List(Vector(NonNegativeInteger)))','pDiophantineSolutionPackage',NULL,'\spad{dioSolve(u)} computes a basis of all minimal solutions for linear homogeneous Diophantine equation \spad{u},{} then all minimal solutions of inhomogeneous equation');
INSERT INTO olibdb VALUES('o','diracDelta',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{diracDelta(x)} is unit mass at zeros of \spad{x}.');
INSERT INTO olibdb VALUES('o','diracDelta',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{diracDelta(x)} is unit mass at zeros of \spad{x}.');
INSERT INTO olibdb VALUES('o','directedGraph',1,'n','(FinitePoset(S))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(poset)} constructs graph from a partially ordered set. This will be a graph with,{} at most,{} one arrow between any two nodes.');
INSERT INTO olibdb VALUES('o','directedGraph',1,'n','(List(Permutation(S)))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(perms)} constructs graph from a list of permutations: \spad{perms}.');
INSERT INTO olibdb VALUES('o','directedGraph',1,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(ob)} is a constructor for graph with given objects \spad{ob},{} more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','directedGraph',1,'n','(List(S))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(ob)} is a constructor for graph with given list of object names and no arrows. Use this version of the constructor if you don\spad{''t} want to create specific \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','directedGraph',2,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(ob,{} ar)} constructs graph with objects \spad{ob} and arrows ar,{} more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','directedGraph',2,'n','(List(S),List(List(NonNegativeInteger)))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(ob,{} am)} constructs graph with objects \spad{ob} and adjacency matrix am.');
INSERT INTO olibdb VALUES('o','directedGraph',2,'n','(List(S),List(Record(fromOb:NonNegativeInteger,toOb:NonNegativeInteger)))->%','dDirectedGraph(S)',NULL,'\spad{directedGraph(obs,{} ars)} constructs graph with objects \spad{obs} and arrows ars. This constructor just has pure abstract graph information without decoration information.');
INSERT INTO olibdb VALUES('o','direction',1,'n','(String)->Integer','pToolsForSign(R)',NULL,'\spad{direction(s)} \undocumented');
INSERT INTO olibdb VALUES('o','directions',1,'n','(%)->List(JB)','dJetVectorField(JB,D)',NULL,'\spad{directions(v)} yields the directions of the base vectors where \spad{v} has non-vanishing coefficients.');
INSERT INTO olibdb VALUES('o','directory',1,'x','(%)->String','cFileNameCategory',NULL,'\spad{directory(f)} returns the directory part of the file name.');
INSERT INTO olibdb VALUES('o','directProduct',1,'x','(Vector(R))->%','cDirectProductCategory(dim,R)',NULL,'\spad{directProduct(v)} converts the vector \spad{v} to a direct product. Error: if the length of \spad{v} is different from dim.');
INSERT INTO olibdb VALUES('o','directProduct',2,'n','(%,%)->%','dGroupPresentation',NULL,'\spad{directProduct of} two groups');
INSERT INTO olibdb VALUES('o','directSum',2,'x','(%,%)->%','cLinearOrdinaryDifferentialOperatorCategory(A)','has(A,Field)','\spad{directSum(a,{} b)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the sums of a solution of \spad{a} by a solution of \spad{b}.');
INSERT INTO olibdb VALUES('o','directSum',3,'n','(L,L,(A)->A)->L','pLinearOrdinaryDifferentialOperatorsOps(A,L)',NULL,'\spad{directSum(a,{} b,{} D)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the sums of a solution of \spad{a} by a solution of \spad{b}. \spad{D} is the derivation to use.');
INSERT INTO olibdb VALUES('o','disableAlternativeOutput',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{disableAlternativeOutput(f)} disable output as rational expression.');
INSERT INTO olibdb VALUES('o','disableDebugOutput',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{disableDebugOutput(f)} disable displaying the ALS.');
INSERT INTO olibdb VALUES('o','discreteLog',1,'n','(S)->NonNegativeInteger','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discreteLog',1,'x','(%)->NonNegativeInteger','cFiniteFieldCategory',NULL,'\spad{discreteLog(a)} computes the discrete logarithm of \spad{a} with respect to \spad{primitiveElement()} of the field.');
INSERT INTO olibdb VALUES('o','discreteLog',2,'n','(S,S)->Union(NonNegativeInteger,failed)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discreteLog',2,'x','(%,%)->Union(NonNegativeInteger,failed)','cFieldOfPrimeCharacteristic',NULL,'\spad{discreteLog(b,{} a)} computes \spad{s} with \spad{b^s = a} if such an \spad{s} exists.');
INSERT INTO olibdb VALUES('o','discriminant',0,'n','()->Integer','pNumberFieldIntegralBasis(UP,F)',NULL,'\spad{discriminant()} returns the discriminant of the integral closure of \spad{Z} in the quotient field of the framed algebra \spad{F}.');
INSERT INTO olibdb VALUES('o','discriminant',0,'n','()->R','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discriminant',0,'n','()->R','xFramedAlgebra&(S,R,UP)',NULL,'\spad{discriminant()} = determinant(traceMatrix()).');
INSERT INTO olibdb VALUES('o','discriminant',0,'x','()->R','cFramedAlgebra(R,UP)',NULL,'\spad{discriminant()} = determinant(traceMatrix()).');
INSERT INTO olibdb VALUES('o','discriminant',1,'n','(polR)->R','pPseudoRemainderSequence(R,polR)',NULL,'\spad{discriminant(P)} returns the discriminant of \spad{P}.');
INSERT INTO olibdb VALUES('o','discriminant',1,'n','(Vector(S))->R','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discriminant',1,'n','(Vector(S))->R','xFiniteRankAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discriminant',1,'n','(Vector(S))->R','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discriminant',1,'x','(%)->R','cUnivariatePolynomialCategory(R)','has(R,CommutativeRing)','\spad{discriminant(p)} returns the discriminant of the polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','discriminant',1,'x','(Vector(%))->R','cFiniteRankAlgebra(R,UP)',NULL,'\spad{discriminant([v1,{} ..,{} vn])} returns \spad{determinant(traceMatrix([v1,{} ..,{} vn]))}.');
INSERT INTO olibdb VALUES('o','discriminant',2,'n','(S,VarSet)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','discriminant',2,'x','(%,VarSet)->%','cPolynomialCategory(R,E,VarSet)','has(R,CommutativeRing)','\spad{discriminant(p,{} v)} returns the disriminant of the polynomial \spad{p} with respect to the variable \spad{v}.');
INSERT INTO olibdb VALUES('o','discriminantEuclidean',1,'n','(polR)->Record(coef1:polR,coef2:polR,discriminant:R)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{discriminantEuclidean(P)} carries out the equality \spad{coef1 * P + coef2 * D(P) = discriminant(P)}.');
INSERT INTO olibdb VALUES('o','discriminantSet',1,'n','(List(SparseUnivariatePolynomial(Polynomial(TheField))))->List(Polynomial(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dispGenerators',1,'n','(%)->OutputForm','dHomology',NULL,'more detailed output with generators');
INSERT INTO olibdb VALUES('o','display',1,'n','(Record(rows:List(FreeMonoid(VAR)),cols:List(FreeMonoid(VAR)),H:Matrix(F)))->OutputForm','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{display(sys)} prints the Hankel matrix in an extended form with row-indices as column 0 and column-indices as row 0.');
INSERT INTO olibdb VALUES('o','display',1,'n','(String)->Void','dHTMLFormat',NULL,'\spad{display(o)} prints the string returned by coerce.');
INSERT INTO olibdb VALUES('o','display',1,'n','(String)->Void','dMathMLFormat',NULL,'prints the string returned by coerce,{} adding <math ...> tags.');
INSERT INTO olibdb VALUES('o','display',1,'n','(String)->Void','dTexmacsFormat',NULL,'prints the string returned by coerce,{} adding <math ...> tags.');
INSERT INTO olibdb VALUES('o','display',1,'n','(%)->Void','cOutputFormatterCategory',NULL,'\spad{display(t)} outputs the formatted code');
INSERT INTO olibdb VALUES('o','display',1,'n','(%)->Void','dJetDifferentialEquation(JB,D)',NULL,'\spad{display(de)} prints all information stored about the differential equation \spad{de}. This comprises the system ordered by the order of the equations,{} the Jacobi matrices separately for each order and the index of the independent variable with respect to which the equation was lastly differentiated (1 for not prolonged equations).');
INSERT INTO olibdb VALUES('o','display',1,'n','(%)->Void','dTexFormat',NULL,'\spad{display(t)} outputs the TeX formatted code \spad{t} so that each line has length less than or equal to the value set by the system command \spadsys{)set output length}.');
INSERT INTO olibdb VALUES('o','display',1,'x','(%)->Union((List(OutputForm))->OutputForm,failed)','dBasicOperator',NULL,'\spad{display(op)} returns the \%display property of \spad{op} if it has one attached,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','display',1,'x','(%)->Void','dDatabase(S)',NULL,'\spad{display(db)} prints a summary line for each entry in \spad{db}.');
INSERT INTO olibdb VALUES('o','display',1,'x','(%)->Void','dIndexCard',NULL,'\spad{display(ic)} prints a summary of the information contained in \spad{ic}.');
INSERT INTO olibdb VALUES('o','display',2,'n','(%,Integer)->Void','dTexFormat',NULL,'\spad{display(t,{} width)} outputs the TeX formatted code \spad{t} so that each line has length less than or equal to \spadvar{width}.');
INSERT INTO olibdb VALUES('o','display',2,'n','(%,List(Symbol))->OutputForm','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{display(f,{}[s])} prints the element \spad{f} as A*(\spad{s_1},{}\spad{s_2},{}...,{}\spad{s_n})'' = \spad{v}.');
INSERT INTO olibdb VALUES('o','display',2,'n','(%,OutputForm)->OutputForm','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{display(f,{}sol)} prints the element \spad{f} as A*sol = \spad{v}.');
INSERT INTO olibdb VALUES('o','display',2,'x','(%,(List(OutputForm))->OutputForm)->%','dBasicOperator',NULL,'\spad{display(op,{} foo)} attaches foo as the \%display property of \spad{op}. If \spad{op} has a \%display property \spad{f},{} then \spad{op(a1,{}...,{}an)} gets converted to OutputForm as \spad{f(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','display',2,'x','(%,(OutputForm)->OutputForm)->%','dBasicOperator',NULL,'\spad{display(op,{} foo)} attaches foo as the \%display property of \spad{op}. If \spad{op} has a \%display property \spad{f},{} then \spad{op(a)} gets converted to OutputForm as \spad{f(a)}. Argument \spad{op} must be unary.');
INSERT INTO olibdb VALUES('o','displayKind',1,'n','(List(GuessOption))->Symbol','dGuessOptionFunctions0',NULL,'\spad{displayKind(d)} specifies kind of the result: generating function,{} recurrence or equation. This option should not be set by the user,{} but rather by the \spad{HP}-specification.');
INSERT INTO olibdb VALUES('o','displayKind',1,'x','(Symbol)->%','dGuessOption',NULL,'\spad{displayKind(d)} specifies kind of the result: generating function,{} recurrence or equation. This option should not be set by the user,{} but rather by the \spad{HP}-specification.');
INSERT INTO olibdb VALUES('o','displayLines',1,'n','(List(String))->Void','pFortranCodeTools',NULL,'\spad{displayLines(l)}');
INSERT INTO olibdb VALUES('o','dispStatement',1,'n','(OutputForm)->Void','pFortranCodeTools',NULL,'\spad{dispStatement(of)}');
INSERT INTO olibdb VALUES('o','distance',2,'n','(A,A)->Integer','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distance',2,'n','(A,A)->Integer','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distance',2,'n','(%,%)->DoubleFloat','cSPointCategory',NULL,'\spad{distance(p1,{} p2)} returns the distance between the points \spad{p1} is the first point. \spad{p2} is the second point. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space.');
INSERT INTO olibdb VALUES('o','distance',2,'n','(S,S)->DoubleFloat','xSPointCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distance',2,'x','(%,%)->Integer','cRecursiveAggregate(S)',NULL,'\spad{distance(u,{} v)} returns the path length (an integer) from node \spad{u} to \spad{v}.');
INSERT INTO olibdb VALUES('o','distance',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Integer','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distance',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Integer','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distance',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Integer','cFiniteGraph(S)',NULL,'\spad{distance(s,{} a,{} b)} gives the shortest distance between nodes ''a'' and \spad{''b''} as a number of hops. 0 if ''a'' = \spad{''b''},{} \spad{-1} if it is not possible to go from ''a'' to \spad{''b''}');
INSERT INTO olibdb VALUES('o','distanceMatrix',1,'n','(A)->Matrix(Integer)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distanceMatrix',1,'n','(%)->Matrix(Integer)','cFiniteGraph(S)',NULL,'\spad{distanceMatrix(s)} gives matrix of distances between vertices. Element a_{\spad{i},{} \spad{j}} is the distance from \spad{i} to \spad{j}. Distance matrices are related to adjacency matrices,{} with the differences that: a. the latter only provides the information which vertices are connected \indented{3}{but does not tell about costs or distances between the vertices} \spad{b}. adjacency matrix only tells us about directly connected \indented{3}{vertices while distance matrix also considers indirect connections.}');
INSERT INTO olibdb VALUES('o','distanceSquared',2,'n','(%,%)->DoubleFloat','cSPointCategory',NULL,'\spad{distanceSquared(p1,{} p2)} returns the distance between the points \spad{p1} and \spad{p2}. There are 2 metrics associated with any SPointCategory the underlying space and the space that it is embedded in this is the distance in the underlying space.');
INSERT INTO olibdb VALUES('o','distanceWeighted',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Union(W,disjoint)','dWeightedGraph(S,W)',NULL,'the shortest distance between ''a'' and \spad{''b''} in terms of weight.');
INSERT INTO olibdb VALUES('o','distFact',6,'n','(Z,List(SparseUnivariatePolynomial(Z)),Record(contp:Z,factors:List(Record(irr:P,pow:NonNegativeInteger))),List(Z),List(OV),List(Z))->Union(Record(polfac:List(P),correct:Z,corrfact:List(SparseUnivariatePolynomial(Z))),failed)','pLeadingCoefDetermination(OV,E,Z,P)',NULL,'\spad{distFact(contm,{} unilist,{} plead,{} vl,{} lvar,{} lval)},{} where \spad{contm} is the content of the evaluated polynomial,{} \spad{unilist} is the list of factors of the evaluated polynomial,{} \spad{plead} is the complete factorization of the leading coefficient,{} \spad{vl} is the list of factors of the leading coefficient evaluated,{} \spad{lvar} is the list of variables,{} lval is the list of values,{} returns a record giving the list of leading coefficients to impose on the univariate factors,{}');
INSERT INTO olibdb VALUES('o','distinct_partition',1,'x','(I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{distinct_partition(n)} returns the number of partitions of the integer \spad{n} with distinct members. This is the number of ways that \spad{n} can be written as a sum of distinct positive integers. For \spad{n > 0} this is the same as number of ways that \spad{n} can be written as a sum of odd positive integers.');
INSERT INTO olibdb VALUES('o','distinct_partitions',1,'x','(Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{distinct_partitions(n)} is the stream of all partitions \indented{1}{of \spad{n} into distinct numbers.}');
INSERT INTO olibdb VALUES('o','distinct_partitions',3,'x','(Integer,Integer,Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{distinct_partitions(p,{} l,{} n)} is the stream of partitions \indented{1}{of \spad{n} into distinct numbers whose number of parts is no greater than \spad{p}} \indented{1}{and whose largest part is no greater than \spad{l}.}');
INSERT INTO olibdb VALUES('o','distribute',1,'n','(S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distribute',1,'x','(%)->%','cExpressionSpace2(K)',NULL,'\spad{distribute(f)} expands all the kernels in \spad{f} that are formally enclosed by a \spadfunFrom{box}{ExpressionSpace} or \spadfunFrom{paren}{ExpressionSpace} expression.');
INSERT INTO olibdb VALUES('o','distribute',2,'n','(S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','distribute',2,'x','(%,%)->%','cExpressionSpace2(K)',NULL,'\spad{distribute(f,{} g)} expands all the kernels in \spad{f} that contain \spad{g} in their arguments and that are formally enclosed by a \spadfunFrom{box}{ExpressionSpace} or a \spadfunFrom{paren}{ExpressionSpace} expression.');
INSERT INTO olibdb VALUES('o','distributionByBooleanCumulants',1,'x','(Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByBooleanCumulants(bb)} initiates a distribution with given Boolean cumulants \spad{bb}.');
INSERT INTO olibdb VALUES('o','distributionByBooleanCumulants',1,'x','(Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByBooleanCumulants(bb)} initiates a distribution with given Boolean cumulants \spad{bb}.');
INSERT INTO olibdb VALUES('o','distributionByClassicalCumulants',1,'x','(Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByEvenMoments(kk)} initiates a distribution with given classical cumulants \spad{kk}.');
INSERT INTO olibdb VALUES('o','distributionByClassicalCumulants',1,'x','(Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByEvenMoments(kk)} initiates a distribution with given classical cumulants \spad{kk}.');
INSERT INTO olibdb VALUES('o','distributionByEvenMoments',1,'x','(Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByEvenMoments(mm)} initiates a distribution with given even moments \spad{mm} and odd moments zero.');
INSERT INTO olibdb VALUES('o','distributionByEvenMoments',1,'x','(Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByEvenMoments(mm)} initiates a distribution with given even moments \spad{mm} and odd moments zero.');
INSERT INTO olibdb VALUES('o','distributionByFreeCumulants',1,'x','(Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByFreeCumulants(cc)} initiates a distribution with given free cumulants \spad{cc}.');
INSERT INTO olibdb VALUES('o','distributionByFreeCumulants',1,'x','(Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByFreeCumulants(cc)} initiates a distribution with given free cumulants \spad{cc}.');
INSERT INTO olibdb VALUES('o','distributionByJacobiParameters',2,'x','(Sequence(R),Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByJacobiParameters(aa,{} bb)} initiates a distribution with given Jacobi parameters \spad{[aa,{} bb]}.');
INSERT INTO olibdb VALUES('o','distributionByJacobiParameters',2,'x','(Stream(R),Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByJacobiParameters(aa,{} bb)} initiates a distribution with given Jacobi parameters \spad{[aa,{} bb]}.');
INSERT INTO olibdb VALUES('o','distributionByMoments',1,'x','(Sequence(R))->%','dDistribution(R)',NULL,'\spad{distributionByMoments(mm)} initiates a distribution with given moments \spad{mm}.');
INSERT INTO olibdb VALUES('o','distributionByMoments',1,'x','(Stream(R))->%','dDistribution(R)',NULL,'\spad{distributionByMoments(mm)} initiates a distribution with given moments \spad{mm}.');
INSERT INTO olibdb VALUES('o','distributionByMonotoneCumulants',1,'x','(Sequence(R))->%','dDistribution(R)','has(R,Algebra(Fraction(Integer)))','\spad{distributionByMonotoneCumulants(hh)} initiates a distribution with given monotone cumulants \spad{hh}.');
INSERT INTO olibdb VALUES('o','distributionByMonotoneCumulants',1,'x','(Stream(R))->%','dDistribution(R)','has(R,Algebra(Fraction(Integer)))','\spad{distributionByMonotoneCumulants(hh)} initiates a distribution with given monotone cumulants \spad{hh}.');
INSERT INTO olibdb VALUES('o','distributionBySTransform',1,'x','(Record(puiseux:Fraction(Integer),laurent:Fraction(Integer),coef:Sequence(R)))->%','dDistribution(R)','has(R,Algebra(Fraction(Integer)))','\spad{distributionBySTransform(series)} initiates a distribution with given \spad{S}-transform \spad{series}.');
INSERT INTO olibdb VALUES('o','distributionBySTransform',1,'x','(UPSR)->Distribution(R)','pSTransformPackage(R,UTSR,ULSR,UPSR)',NULL,'\spad{distributionBySTransform(x)} returns the distribution with \spad{S}-transform \spad{x}.');
INSERT INTO olibdb VALUES('o','distributionBySTransform',3,'x','(Fraction(Integer),Fraction(Integer),Sequence(R))->%','dDistribution(R)','has(R,Algebra(Fraction(Integer)))','\spad{distributionBySTransform(series)} initiates a distribution with given \spad{S}-transform \spad{series}.');
INSERT INTO olibdb VALUES('o','divergence',2,'n','(FLAF,FLAS)->F','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{divergence(vf,{} xlist)} computes the divergence of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in xlist.');
INSERT INTO olibdb VALUES('o','divide',2,'n','(polR,polR)->Record(quotient:polR,remainder:polR)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{divide(F,{} G)} computes quotient and rest of the exact euclidean division of \spad{F} by \spad{G}.');
INSERT INTO olibdb VALUES('o','divide',2,'n','(S,S)->Record(quotient:S,remainder:S)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divide',2,'n','(S,S)->Record(quotient:S,remainder:S)','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divide',2,'n','(S,S)->Record(quotient:S,remainder:S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divide',2,'n','(%,%)->Union(Record(lm:%,rm:%),failed)','dFreeMonoid(S)',NULL,'\spad{divide(x,{} y)} returns the left and right exact quotients of \spad{x} by \spad{y},{} \spadignore{i.e.} \spad{[l,{} r]} such that \spad{x = l * y * r},{} failed if \spad{x} is not of the form \spad{l * y * r}.');
INSERT INTO olibdb VALUES('o','divide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cEuclideanDomain',NULL,'\spad{divide(x,{} y)} divides \spad{x} by \spad{y} producing a record containing a \spad{quotient} and \spad{remainder},{} where the remainder is smaller (see \spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \spad{y}.');
INSERT INTO olibdb VALUES('o','divide',2,'x','(%,%)->Record(quotient:%,remainder:%)','dNonNegativeInteger',NULL,'\spad{divide(a,{} b)} returns a record containing both remainder and quotient.');
INSERT INTO olibdb VALUES('o','divide!',3,'n','(PA,PA,MD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{divide!(pol1,{} pol2,{} md)} performs division with remainder of \spad{pol1} by \spad{pol2}. \spad{pol1} is modified in place to contain remainder. Quotient is return value.');
INSERT INTO olibdb VALUES('o','divide!',4,'n','(U32Vector,U32Vector,U32Vector,Integer)->Void','pU32VectorPolynomialOperations',NULL,'Polynomial division.');
INSERT INTO olibdb VALUES('o','divideExponents',2,'x','(%,NonNegativeInteger)->Union(%,failed)','cUnivariatePolynomialCategory(R)',NULL,'\spad{divideExponents(p,{} n)} returns a new polynomial resulting from dividing all exponents of the polynomial \spad{p} by the non negative integer \spad{n},{} or failed if some exponent is not exactly divisible by \spad{n}.');
INSERT INTO olibdb VALUES('o','divideIfCan',2,'n','(UP,UP)->Union(Record(quotient:UP,remainder:UP),failed)','pUnivariatePolynomialDivisionPackage(R,UP)',NULL,'\spad{divideIfCan(f,{} g)} returns quotient and remainder of the division of \spad{f} by \spad{g} or failed if it has not succeeded.');
INSERT INTO olibdb VALUES('o','divideIfCan!',4,'n','(Matrix(R),Matrix(R),R,Integer)->R','pIntegralBasisTools(R,UP,F)',NULL,'\spad{divideIfCan!(matrix,{} matrixOut,{} prime,{} n)} attempts to divide the entries of \spad{matrix} by \spad{prime} and store the result in \spad{matrixOut}. If it is successful,{} 1 is returned and if not,{} \spad{prime} is returned. Here both \spad{matrix} and \spad{matrixOut} are \spad{n}-by-\spad{n} upper triangular matrices.');
INSERT INTO olibdb VALUES('o','divisor',1,'n','(FractionalIdeal(UP,Fraction(UP),UPUP,R))->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',1,'n','(R)->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',1,'x','(FractionalIdeal(UP,Fraction(UP),UPUP,R))->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(I)} makes a divisor \spad{D} from an ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','divisor',1,'x','(R)->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(g)} returns the divisor of the function \spad{g}.');
INSERT INTO olibdb VALUES('o','divisor',2,'n','(F,F)->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',2,'x','(F,F)->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(a,{} b)} makes the divisor \spad{P:} \spad{(x = a,{} y = b)}. Error: if \spad{P} is singular.');
INSERT INTO olibdb VALUES('o','divisor',3,'n','(F,F,Integer)->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',3,'n','(R,UP,UP)->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',3,'x','(F,F,Integer)->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(a,{} b,{} n)} makes the divisor \spad{nP} where \spad{P:} \spad{(x = a,{} y = b)}. \spad{P} is allowed to be singular if \spad{n} is a multiple of the rank.');
INSERT INTO olibdb VALUES('o','divisor',3,'x','(R,UP,UP)->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(h,{} d,{} g)} returns \spad{gcd} of divisor of zeros of \spad{h} and divisor of zeros of \spad{d}. \spad{d} must be squarefree. All ramified zeros of \spad{d} must be contained in zeros of \spad{g}.');
INSERT INTO olibdb VALUES('o','divisor',5,'n','(R,UP,UP,UP,F)->S','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','divisor',5,'x','(R,UP,UP,UP,F)->%','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{divisor(h,{} d,{} d'',{} g,{} r)} returns the sum of all the finite points where \spad{h/d} has residue \spad{r}. \spad{h} must be integral. \spad{d} must be squarefree. \spad{d''} is some derivative of \spad{d} (not necessarily dd/dx). \spad{g = gcd(d,{} discriminant)} contains the ramified zeros of \spad{d}');
INSERT INTO olibdb VALUES('o','divisorCascade',2,'n','(UP,UP)->List(Record(factors:List(UP),error:R))','pComplexRootFindingPackage(R,UP)',NULL,'\spad{divisorCascade(p,{} tp)} assumes that degree of polynomial {\em tp} is smaller than degree of polynomial \spad{p},{} both monic. A sequence of divisions is calculated using the remainder,{} made monic,{} as divisor for the the next division. The result contains also the error of the factorizations,{} \spadignore{i.e.} the norm of the remainder polynomial.');
INSERT INTO olibdb VALUES('o','divisorCascade',3,'n','(UP,UP,Boolean)->List(Record(factors:List(UP),error:R))','pComplexRootFindingPackage(R,UP)',NULL,'\spad{divisorCascade(p,{} tp)} assumes that degree of polynomial {\em tp} is smaller than degree of polynomial \spad{p},{} both monic. A sequence of divisions are calculated using the remainder,{} made monic,{} as divisor for the next division. The result contains also the error of the factorizations,{} \spadignore{i.e.} the norm of the remainder polynomial. If {\em info} is {\em true},{} then information messages are issued.');
INSERT INTO olibdb VALUES('o','divisors',1,'x','(Integer)->List(Integer)','pIntegerNumberTheoryFunctions',NULL,'\spad{divisors(n)} returns a list of the divisors of \spad{n}.');
INSERT INTO olibdb VALUES('o','dmp2rfi',1,'n','(GR)->Fraction(Polynomial(R))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{dmp2rfi(p)} converts \spad{p} to target domain');
INSERT INTO olibdb VALUES('o','dmp2rfi',1,'n','(List(GR))->List(Fraction(Polynomial(R)))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{dmp2rfi(l)} converts \spad{l} to target domain');
INSERT INTO olibdb VALUES('o','dmp2rfi',1,'n','(Matrix(GR))->Matrix(Fraction(Polynomial(R)))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{dmp2rfi(m)} converts \spad{m} to target domain');
INSERT INTO olibdb VALUES('o','dmpToHdmp',1,'n','(DistributedMultivariatePolynomial(lv,R))->HomogeneousDistributedMultivariatePolynomial(lv,R)','pPolToPol(lv,R)',NULL,'\spad{dmpToHdmp(p)} converts \spad{p} from a \spadtype{DMP} to a \spadtype{HDMP}.');
INSERT INTO olibdb VALUES('o','dmpToP',1,'n','(DistributedMultivariatePolynomial(lv,R))->Polynomial(R)','pPolToPol(lv,R)',NULL,'\spad{dmpToP(p)} converts \spad{p} from a \spadtype{DMP} to a \spadtype{POLY}.');
INSERT INTO olibdb VALUES('o','doFactor',3,'n','(SparseUnivariatePolynomial(SparseUnivariatePolynomial(F)),Integer,Boolean)->Factored(SparseUnivariatePolynomial(SparseUnivariatePolynomial(F)))','pTwoFactorize(F)',NULL,'\spad{doFactor(p,{} n,{} ext?)} returns the factorisation of polynomial \spad{p},{} \spad{p} is assumed to be primitive and squarefree,{} \spad{n} is degree in auxiliary variable,{} ext? if \spad{false} inhibits use of extension field.');
INSERT INTO olibdb VALUES('o','do_liou',2,'n','(BasicOperator,List(Complex(F)))->Complex(F)','pInnerTrigonometricManipulations(R,F,FG)',NULL,'\spad{do_liou(op,{} lf)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','dom',1,'x','(%)->SExpression','dAny',NULL,'\spad{dom(a)} returns a \spadgloss{LISP} form of the type of the original object that was converted to \spadtype{Any}.');
INSERT INTO olibdb VALUES('o','domainOf',1,'x','(%)->OutputForm','dAny',NULL,'\spad{domainOf(a)} returns a printable form of the type of the original object that was converted to \spadtype{Any}.');
INSERT INTO olibdb VALUES('o','dominantTerm',1,'n','(%)->Union(Record(%term:Record(%coef:UnivariatePuiseuxSeries(FE,var,cen),%expon:ExponentialOfUnivariatePuiseuxSeries(FE,var,cen),%expTerms:List(Record(k:Fraction(Integer),c:FE))),%type:String),failed)','dUnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,var,cen)',NULL,'\spad{dominantTerm(f(var))} returns the term that dominates the limiting behavior of \spad{f(var)} as \spad{var -> cen+} together with a \spadtype{String} which briefly describes that behavior. The value of the \spadtype{String} will be \spad{zero} (resp. \spad{infinity}) if the term tends to zero (resp. infinity) exponentially and will \spad{series} if the term is a Puiseux series.');
INSERT INTO olibdb VALUES('o','do_modular_solve',6,'n','(Vector(U32Vector),Vector(Integer),NonNegativeInteger,U32Vector,Integer,Symbol)->Union(Record(basis:TwoDimensionalArray(U32Vector),defects:Vector(Integer),cinds:Vector(Integer)),no_solution)','pInnerModularHermitePade',NULL,NULL);
INSERT INTO olibdb VALUES('o','do_param_RDE',5,'n','(F,F,List(F),Symbol,List(Kernel(F)))->Union(Record(ratpart:F,coeffs:Vector(F)),failed)','pElementaryRischDEX2(R,F)',NULL,'\spad{do_param_RDE(f,{} h,{} lg,{} x,{} lk)} solves parametric Risch differential equation,{} that is returns \spad{[y,{} [c1,{} ...,{} ck]]} such that dy/dx + \spad{n} df/dx \spad{y} + \spad{c1} \spad{g1} + ... \spad{cn} \spad{gn} = \spad{h} where \spad{y} is in the is in field generated by \spad{lk} and \spad{ci} are constants or failed if there is no solution.');
INSERT INTO olibdb VALUES('o','do_poly_integer',8,'n','(List(Symbol),List(PrimitiveArray(Fraction(Polynomial(Integer)))),Vector(Integer),NonNegativeInteger,U32Vector,Symbol,Symbol,(List(U32Vector),Integer,Integer)->Vector(U32Vector))->Union(Record(defects:Vector(Integer),cinds:Vector(Integer),rowlen:Integer,offsetdata:Vector(Integer),expdata:SortedExponentVector,coeffdata:PrimitiveArray(Integer)),no_solution)','pInnerModularHermitePade',NULL,NULL);
INSERT INTO olibdb VALUES('o','do_quo',2,'n','(PS,PS)->Union(PS,failed)','dElementaryFunctionsGeneralizedUnivariatePowerSeries(Coef,Expon,PS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','do_risch_DE',4,'n','(F,F,Symbol,List(Kernel(F)))->Record(ans:F,right:F,primpart:F,sol?:Boolean)','pElementaryRischDEX2(R,F)',NULL,'\spad{do_risch_DE(f,{} g,{} x,{} lk)} returns \spad{[y,{} h,{} 0,{} b]} such that \spad{dy/dx + df/dx y = h} and \spad{b := h = g}. The equation \spad{dy/dx + df/dx y = g} has no solution in the field generated by \spad{lk} if \spad{h \~~= g} (\spad{y} is a partial solution in that case).');
INSERT INTO olibdb VALUES('o','dot',1,'n','(%)->%','dOutputForm',NULL,'\spad{dot(f)} creates the form with one dot overhead.');
INSERT INTO olibdb VALUES('o','dot',2,'n','(%,NonNegativeInteger)->%','dOutputForm',NULL,'\spad{dot(f,{} n)} creates the form \spad{f} with \spad{n} dots overhead.');
INSERT INTO olibdb VALUES('o','dot',2,'n','(Point(DoubleFloat),Point(DoubleFloat))->DoubleFloat','pTubePlotTools',NULL,'\spad{dot(p,{} q)} computes the dot product of the two points \spad{p} and \spad{q} using only the first three coordinates,{} and returns the resulting \spadtype{DoubleFloat}.');
INSERT INTO olibdb VALUES('o','dot',2,'n','(S,S)->R','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dot',2,'x','(%,%)->R','cDirectProductCategory(dim,R)','AND(has(R,AbelianMonoid),has(R,SemiRng))','\spad{dot(x,{} y)} computes the inner product of the vectors \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','dot',2,'x','(%,%)->R','cVectorCategory(R)','AND(has(R,AbelianMonoid),has(R,SemiRng))','\spad{dot(x,{} y)} computes the inner product of the two vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.');
INSERT INTO olibdb VALUES('o','double?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{double?(t)} tests whether \spad{t} is equivalent to the FORTRAN type DOUBLE PRECISION');
INSERT INTO olibdb VALUES('o','double',2,'n','(PositiveInteger,S)->S','pRepeatedDoubling(S)',NULL,'\spad{double(i,{} r)} multiplies \spad{r} by \spad{i} using repeated doubling.');
INSERT INTO olibdb VALUES('o','doubleComplex?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{doubleComplex?(t)} tests whether \spad{t} is equivalent to the (non-standard) FORTRAN type DOUBLE COMPLEX.');
INSERT INTO olibdb VALUES('o','doubleDisc',1,'n','(UPUP)->Integer','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{doubleDisc(u)} \undocumented');
INSERT INTO olibdb VALUES('o','doubleFloatFormat',1,'x','(String)->String','dDoubleFloat',NULL,'change the output format for doublefloats using lisp format strings');
INSERT INTO olibdb VALUES('o','doubleRank',1,'x','(A)->NonNegativeInteger','pAlgebraPackage(R,A)',NULL,'\spad{doubleRank(x)} determines the number of linearly independent elements in \spad{b1*x},{} ...,{} \spad{x*bn},{} where \spad{b=[b1,{} ...,{} bn]} is a basis.');
INSERT INTO olibdb VALUES('o','doubleResultant',2,'n','(R,(UP)->UP)->UP','pDoubleResultantPackage(F,UP,UPUP,R)',NULL,'\spad{doubleResultant(f,{} '')} returns \spad{p}(\spad{x}) whose roots are rational multiples of the residues of \spad{f} at all its finite poles. Argument '' is the derivation to use.');
INSERT INTO olibdb VALUES('o','doublyTransitive?',1,'x','(UP)->Boolean','pAlgFactor(UP)',NULL,'\spad{doublyTransitive?(p)} is \spad{true} if \spad{p} is irreducible over over the field \spad{K} generated by its coefficients,{} and if \spad{p(X) / (X - a)} is irreducible over \spad{K(a)} where \spad{p(a) = 0}.');
INSERT INTO olibdb VALUES('o','do_with_error_env1',1,'n','(()->List(String))->List(String)','pFortranCodeTools',NULL,'\spad{do_with_error_env1(f)}');
INSERT INTO olibdb VALUES('o','do_with_error_env2',2,'n','(Boolean,()->List(String))->List(String)','pFortranCodeTools',NULL,'\spad{do_with_error_env2(int_to_floats?,{} f)}');
INSERT INTO olibdb VALUES('o','do_with_error_env3',2,'n','(Boolean,()->List(String))->List(String)','pFortranCodeTools',NULL,'\spad{do_with_error_env3(int_to_floats?,{} f)}');
INSERT INTO olibdb VALUES('o','dP',2,'n','(PositiveInteger,List(NonNegativeInteger))->%','dJetDifferential(JB,D)',NULL,'\spad{dP(i,{} mu)} returns the differential of \spad{P(i,{} mu)}.');
INSERT INTO olibdb VALUES('o','draw',1,'x','(List(Point(DoubleFloat)))->TwoDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lp)} plots the curve constructed from the list of points \spad{lp}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','((DoubleFloat)->DoubleFloat,Segment(Float))->TwoDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','((DoubleFloat)->Point(DoubleFloat),Segment(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} l)} draws the graph of the parametric curve \spad{f} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(Ex,SegmentBinding(Float))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(f(x),{} x = a..b)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{f(x)} appears in the title bar.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(List(DoubleFloat),List(DoubleFloat))->TwoDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lx,{} ly)} plots the curve constructed of points (\spad{x},{} \spad{y}) for \spad{x} in \spad{lx} for \spad{y} in \spad{ly}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(List(Point(DoubleFloat)),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lp,{} l)} plots the curve constructed from the list of points \spad{lp}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(ParametricComplexCurve(Ex),SegmentBinding(Float))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(c,{} b)} is like version for plane curves,{} but uses complex curve.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(Float))->TwoDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(curve(f,{} g),{} a..b)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(ParametricPlaneCurve(Ex),SegmentBinding(Float))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(curve(f(t),{} g(t)),{} t = a..b)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{(f(t),{} g(t))} appears in the title bar.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(curve(f,{} g,{} h),{} a..b,{} l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','draw',2,'x','(ParametricSpaceCurve(Ex),SegmentBinding(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(curve(f(t),{} g(t),{} h(t)),{} t = a..b)} draws the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{h(t)} is the default title.');
INSERT INTO olibdb VALUES('o','draw',3,'x','((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(Float),Segment(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} c..d)} draws the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}.');
INSERT INTO olibdb VALUES('o','draw',3,'x','((DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(Float),Segment(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} c..d)} draws the graph of the parametric surface \spad{f(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)} The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','((DoubleFloat)->DoubleFloat,Segment(Float),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} l)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','((DoubleFloat)->Point(DoubleFloat),Segment(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} l)} draws the graph of the parametric curve \spad{f} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(Ex,SegmentBinding(Float),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(f(x),{} x = a..b,{} l)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{f(x)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(Ex,SegmentBinding(Float),SegmentBinding(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(f(x,{} y),{} x = a..b,{} y = c..d)} draws the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{f(x,{} y)} appears in the title bar.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(List(DoubleFloat),List(DoubleFloat),List(DoubleFloat))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lx,{} ly,{} lz)} draws the surface constructed by projecting the values in the \spad{lz} list onto the rectangular grid formed by the \spad{lx X ly}.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(List(DoubleFloat),List(DoubleFloat),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lx,{} ly,{} l)} plots the curve constructed of points (\spad{x},{} \spad{y}) for \spad{x} in \spad{lx} for \spad{y} in \spad{ly}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricComplexCurve(Ex),SegmentBinding(Float),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(c,{} b,{} l)} is like version for plane curves,{} but uses complex curve.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(Float),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(curve(f,{} g),{} a..b,{} l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricPlaneCurve(Ex),SegmentBinding(Float),List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(curve(f(t),{} g(t)),{} t = a..b,{} l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{(f(t),{} g(t))} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(curve(f,{} g,{} h),{} a..b,{} l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricSpaceCurve(Ex),SegmentBinding(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(curve(f(t),{} g(t),{} h(t)),{} t = a..b,{} l)} draws the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(Float),Segment(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(surface(f,{} g,{} h),{} a..b,{} c..d)} draws the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}.');
INSERT INTO olibdb VALUES('o','draw',3,'x','(ParametricSurface(Ex),SegmentBinding(Float),SegmentBinding(Float))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d)} draws the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{h(t)} is the default title.');
INSERT INTO olibdb VALUES('o','draw',4,'x','((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(Float),Segment(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} c..d,{} l)} draws the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}. and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',4,'x','((DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(Float),Segment(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(f,{} a..b,{} c..d)} draws the graph of the parametric surface \spad{f(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',4,'x','(Equation(Ex),Symbol,Symbol,List(DrawOption))->TwoDimensionalViewport','pTopLevelDrawFunctionsForAlgebraicCurves(R,Ex)',NULL,'\spad{draw(f(x,{} y) = g(x,{} y),{} x,{} y,{} l)} draws the graph of a polynomial equation. The list \spad{l} of draw options must specify a region in the plane in which the curve is to sketched.');
INSERT INTO olibdb VALUES('o','draw',4,'x','(Ex,SegmentBinding(Float),SegmentBinding(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(f(x,{} y),{} x = a..b,{} y = c..d,{} l)} draws the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{f(x,{} y)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',4,'x','(List(DoubleFloat),List(DoubleFloat),List(DoubleFloat),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForPoints',NULL,'\spad{draw(lx,{} ly,{} lz,{} l)} draws the surface constructed by projecting the values in the \spad{lz} list onto the rectangular grid formed by the The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',4,'x','(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(Float),Segment(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{draw(surface(f,{} g,{} h),{} a..b,{} c..d)} draws the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','draw',4,'x','(ParametricSurface(Ex),SegmentBinding(Float),SegmentBinding(Float),List(DrawOption))->ThreeDimensionalViewport','pTopLevelDrawFunctions(Ex)',NULL,'\spad{draw(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d,{} l)} draws the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','drawComplex',4,'x','((Complex(DoubleFloat))->Complex(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Boolean)->ThreeDimensionalViewport','pDrawComplex',NULL,'\spad{drawComplex(f,{} rRange,{} iRange,{} arrows?)} draws a complex function as a height field. It uses the complex norm as the height and the complex argument as the color. It will optionally draw arrows on the surface indicating the direction of the complex value.\newline Sample call: \indented{2}{\spad{f z == exp(1/z)}} \indented{2}{\spad{drawComplex(f,{} 0.3..3,{} 0..2*\%\spad{pi},{} false)}} Parameter descriptions: \indented{2}{\spad{f:}\space{2}the function to draw} \indented{2}{\spad{rRange} : the range of the real values} \indented{2}{\spad{iRange} : the range of imaginary values} \indented{2}{arrows? : a flag indicating whether to draw the phase arrows for \spad{f}} Call the functions \spadfunFrom{setRealSteps}{DrawComplex} and \spadfunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction.');
INSERT INTO olibdb VALUES('o','drawComplexVectorField',3,'x','((Complex(DoubleFloat))->Complex(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->ThreeDimensionalViewport','pDrawComplex',NULL,'\spad{drawComplexVectorField(f,{} rRange,{} iRange)} draws a complex vector field using arrows on the \spad{x--y} plane. These vector fields should be viewed from the top by pressing the XY translate button on the 3-\spad{d} viewport control panel.\newline Sample call: \indented{3}{\spad{f z == sin z}} \indented{3}{\spad{drawComplexVectorField(f,{} -2..2,{} -2..2)}} Parameter descriptions: \indented{2}{\spad{f} : the function to draw} \indented{2}{\spad{rRange} : the range of the real values} \indented{2}{iRange : the range of the imaginary values} Call the functions \spadfunFrom{setRealSteps}{DrawComplex} and \spadfunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction.');
INSERT INTO olibdb VALUES('o','drawCurves',2,'n','(List(List(Point(DoubleFloat))),List(DrawOption))->TwoDimensionalViewport','pViewportPackage',NULL,'\spad{drawCurves([[p0],{} [p1],{} ...,{} [pn]],{} [options])} creates a \spadtype{TwoDimensionalViewport} from the list of lists of points,{} \spad{p0} through \spad{pn},{} using the options specified in the list \spad{options}.');
INSERT INTO olibdb VALUES('o','drawCurves',5,'n','(List(List(Point(DoubleFloat))),Palette,Palette,PositiveInteger,List(DrawOption))->TwoDimensionalViewport','pViewportPackage',NULL,'\spad{drawCurves([[p0],{} [p1],{} ...,{} [pn]],{} ptColor,{} lineColor,{} ptSize,{} [options])} creates a \spadtype{TwoDimensionalViewport} from the list of lists of points,{} \spad{p0} through \spad{pn},{} using the options specified in the list \spad{options}. The point color is specified by \spad{ptColor},{} the line color is specified by \spad{lineColor},{} and the point size is specified by \spad{ptSize}.');
INSERT INTO olibdb VALUES('o','drawStyle',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{drawStyle(v,{} s)} displays the surface for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport} in the style of drawing indicated by \spad{s}. If \spad{s} is not a valid drawing style the style is wireframe by default. Possible styles are \spad{shade},{} \spad{solid} or \spad{opaque},{} \spad{smooth},{} and \spad{wireMesh}.');
INSERT INTO olibdb VALUES('o','drawToScale',0,'x','()->Boolean','pGraphicsDefaults',NULL,'\spad{drawToScale()} determines whether or not plots are to be drawn to scale.');
INSERT INTO olibdb VALUES('o','drawToScale',1,'x','(Boolean)->Boolean','pGraphicsDefaults',NULL,'\spad{drawToScale(true)} causes plots to be drawn to scale. \spad{drawToScale(false)} causes plots to be drawn so that they fill up the viewport window. The default setting is \spad{false}.');
INSERT INTO olibdb VALUES('o','droot',1,'n','(List(F))->OutputForm','pAlgebraicFunction(R,F)',NULL,'\spad{droot(l)} should be a non-exported function.');
INSERT INTO olibdb VALUES('o','dSubst',3,'n','(%,JB,%)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{dSubst(f,{} jv,{} exp)} is like \spad{subst(f,{} jv,{} exp)}. But additionally for all derivatives of \spad{jv} the corresponding substitutions are performed.');
INSERT INTO olibdb VALUES('o','dSubst',3,'n','(S,JB,S)->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','dU',1,'n','(PositiveInteger)->%','dJetDifferential(JB,D)',NULL,'\spad{dU(i)} returns the differential of \spad{U(i)}.');
INSERT INTO olibdb VALUES('o','dunceHat',0,'n','()->DeltaComplex(VS)','pDeltaComplexFactory(VS)',NULL,'generate a minimal dunceHat from 3 edges.');
INSERT INTO olibdb VALUES('o','dunceHat',0,'n','()->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'Generate a minimal triangulation of dunce hat.');
INSERT INTO olibdb VALUES('o','duplicates?',1,'n','(%)->Boolean','dListMultiDictionary(S)',NULL,'\spad{duplicates?(d)} tests if dictionary \spad{d} has duplicate entries.');
INSERT INTO olibdb VALUES('o','duplicates',1,'x','(%)->List(Record(entry:S,count:NonNegativeInteger))','cMultiDictionary(S)',NULL,'\spad{duplicates(d)} returns a list of values which have duplicates in \spad{d}');
INSERT INTO olibdb VALUES('o','dX',1,'n','(PositiveInteger)->%','dJetDifferential(JB,D)',NULL,'\spad{dX(i)} returns the differential of \spad{X(i)}.');
INSERT INTO olibdb VALUES('o','e',1,'x','(PositiveInteger)->%','dCliffordAlgebra(n,K,bLin)',NULL,'\spad{e(n)} produces phi(e_i) where e_i is \spad{i}-th basis vector in \spad{K^n} and phi is canonical embedding of \spad{K^n} into Clifford algebra.');
INSERT INTO olibdb VALUES('o','ee',1,'x','(List(PositiveInteger))->%','dCliffordAlgebra(n,K,bLin)',NULL,'to allow entries like: ee[1,{} 2]');
INSERT INTO olibdb VALUES('o','eFromBinaryMap',1,'x','(NonNegativeInteger)->%','dCliffordAlgebra(n,K,bLin)',NULL,'\spad{eFromBinaryMap(n)} sets the appropriate Grassmann basis,{} for example: eFromBinaryMap(0) = 1 (scalar) eFromBinaryMap(1) = \spad{e1} eFromBinaryMap(2) = \spad{e2} eFromBinaryMap(3) = e1/\e2');
INSERT INTO olibdb VALUES('o','Ei',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{\spad{Ei}(f)} denotes the exponential integral');
INSERT INTO olibdb VALUES('o','Ei',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{\spad{Ei}(x)} returns the exponential integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{exp(x)/x dx}.');
INSERT INTO olibdb VALUES('o','Ei',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{\spad{Ei}(f)} denotes the exponential integral');
INSERT INTO olibdb VALUES('o','Ei',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Ei',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{\spad{Ei}(f)} denotes the exponential integral');
INSERT INTO olibdb VALUES('o','eigenMatrix',1,'x','(Matrix(Fraction(Polynomial(Integer))))->Union(Matrix(Expression(Integer)),failed)','pRadicalEigenPackage',NULL,'\spad{eigenMatrix(m)} returns the matrix \spad{b} such that \spad{b*m*(inverse b)} is diagonal,{} or failed if no such \spad{b} exists.');
INSERT INTO olibdb VALUES('o','eigenvalues',1,'n','(Matrix(F))->List(Union(F,SparseUnivariatePolynomial(F)))','pInnerEigenPackage(F)','has(F,PolynomialFactorizationExplicit)','\spad{eigenvalues(m)} returns the eigenvalues of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','eigenvalues',1,'x','(Matrix(Fraction(Polynomial(R))))->List(Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))))','pEigenPackage(R)','has(R,PolynomialFactorizationExplicit)','\spad{eigenvalues(m)} returns the eigenvalues of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','eigenvalues',2,'n','(Matrix(F),(SparseUnivariatePolynomial(F))->Factored(SparseUnivariatePolynomial(F)))->List(Union(F,SparseUnivariatePolynomial(F)))','pInnerEigenPackage(F)',NULL,'\spad{eigenvalues(m,{} fac)} returns the eigenvalues of the matrix \spad{m}. Eigenvalues in base field are given explicitly,{} other are represented by minimal polynomial. fac is a factorizer for polynomials over \spad{F}.');
INSERT INTO olibdb VALUES('o','eigenvector',2,'n','(Union(F,SparseUnivariatePolynomial(F)),Matrix(F))->List(Vector(SparseUnivariatePolynomial(F)))','pInnerEigenPackage(F)',NULL,'\spad{eigenvector(eigval,{} m)} returns the eigenvectors belonging to the eigenvalue \spad{eigval} for the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','eigenvector',2,'x','(Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))),Matrix(Fraction(Polynomial(R))))->List(Matrix(Fraction(Polynomial(R))))','pEigenPackage(R)',NULL,'\spad{eigenvector(eigval,{} m)} returns the eigenvectors belonging to the eigenvalue \spad{eigval} for the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','eigenvectors',1,'n','(Matrix(F))->List(Record(eigval:Union(F,SparseUnivariatePolynomial(F)),eigmult:NonNegativeInteger,eigvec:List(Vector(SparseUnivariatePolynomial(F)))))','pInnerEigenPackage(F)','has(F,PolynomialFactorizationExplicit)','\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \spad{m}. The eigenvalues in base field and corresponding eigenvectors are explicitly computed,{} while the non rational ones are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a generic root of such a polynomial.');
INSERT INTO olibdb VALUES('o','eigenvectors',1,'x','(Matrix(Fraction(Polynomial(R))))->List(Record(eigval:Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))),eigmult:NonNegativeInteger,eigvec:List(Matrix(Fraction(Polynomial(R))))))','pEigenPackage(R)','has(R,PolynomialFactorizationExplicit)','\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \spad{m}. The eigenvalues in base field and the corresponding eigenvectors are explicitly computed,{} while the other ones are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a generic root of such a polynomial.');
INSERT INTO olibdb VALUES('o','eigenvectors',2,'n','(Matrix(F),(SparseUnivariatePolynomial(F))->Factored(SparseUnivariatePolynomial(F)))->List(Record(eigval:Union(F,SparseUnivariatePolynomial(F)),eigmult:NonNegativeInteger,eigvec:List(Vector(SparseUnivariatePolynomial(F)))))','pInnerEigenPackage(F)',NULL,'\spad{eigenvectors(m,{} fac)} returns the eigenvalues and eigenvectors for the matrix \spad{m}. The eigenvalues in base field and corresponding eigenvectors are explicitly computed,{} while the other eigenvalues are given via their minimal polynomial and the corresponding eigenvectors are expressed in terms of a generic root of such a polynomial. fac is a factorizer for polynomials over \spad{F}.');
INSERT INTO olibdb VALUES('o','ei_int',4,'n','(Integer,F,F,Symbol)->Record(ans:F,right:F,primpart:F,sol?:Boolean)','pElementaryRischDEX(R,F)',NULL,'\spad{ei_int(n,{} f,{} g,{} x)} returns \spad{[h,{} u,{} t,{} s]} such that \spad{u*exp(n*f) = (h*exp(n*f))'' + t''} where \spad{t} involves special functions. When \spad{s} is \spad{true} then \spad{g = u},{} otherwise ei_int returns partial answer,{}');
INSERT INTO olibdb VALUES('o','eisensteinIrreducible?',1,'n','(UP)->Boolean','pGaloisGroupFactorizer(UP)',NULL,'\spad{eisensteinIrreducible?(p)} returns \spad{true} if \spad{p} can be shown to be irreducible by Eisenstein\spad{''s} criterion,{} \spad{false} is inconclusive.');
INSERT INTO olibdb VALUES('o','elColumn2!',4,'x','(M,R,Integer,Integer)->M','pMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{elColumn2!(m,{} a,{} i,{} j)} adds to column \spad{i} a*column(\spad{m},{} \spad{j}) : elementary operation of second kind. (\spad{i} \spad{~=j})');
INSERT INTO olibdb VALUES('o','elem?',1,'n','(%)->Boolean','dIntegrationResult(F)',NULL,'\spad{elem?(ir)} tests if an integration result is elementary over \spad{F?}');
INSERT INTO olibdb VALUES('o','element?',2,'x','(DPoly,%)->Boolean','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{element?(f,{} I)} tests whether the polynomial \spad{f} belongs to the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','element',3,'n','(M,Integer,Integer)->M','pMatrixManipulation(R,Row,Col,M)',NULL,'\spad{element} returns a single element out of a matrix. The element is put into a one by one matrix.');
INSERT INTO olibdb VALUES('o','elementary',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{elementary n} is the \spad{n} th elementary symmetric \indented{1}{function expressed in terms of power sums.}');
INSERT INTO olibdb VALUES('o','elements',1,'n','(%)->List(PositiveInteger)','dSetOfMIntegersInOneToN(m,n)',NULL,'\spad{elements(S)} returns the list of the elements of \spad{S} in increasing order.');
INSERT INTO olibdb VALUES('o','eliminationEquations',11,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Matrix(Polynomial(R)))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} returns a list of matrices with equations to eliminate the entries in rows/columns rdst/cdst,{} \spad{rex1/cex1} and \spad{rex2/cex2}.');
INSERT INTO olibdb VALUES('o','eliminationEquations',11,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Polynomial(R))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} returns a list of equations with equations to eliminate the entries in rows/columns rdst/cdst,{} \spad{rex1/cex1} and \spad{rex2/cex2},{} including det(\spad{P})\spad{-1} and det(\spad{Q})\spad{-1}.');
INSERT INTO olibdb VALUES('o','eliminationEquations',7,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Matrix(Polynomial(R)))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationEquations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst)} returns a list of matrices with equations to eliminate the entries in rows/columns rdst/cdst.');
INSERT INTO olibdb VALUES('o','eliminationGroebner',11,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Polynomial(R))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationGroebner(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} rdst,{} cdst,{} rex1,{} cex1,{} rex2,{} cex2)} computes a Groebner--Shirshov basis for the ideal generated by the equations from eliminationEquations(...) using the domain DistributedMultivariatePolynomial.');
INSERT INTO olibdb VALUES('o','eliminationSolve',1,'n','(List(Polynomial(R)))->List(List(Equation(Polynomial(R))))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationSolve(lst_eqn)} calls eliminationSolve(\spad{lst_eqn},{} [0,{}1],{} []).');
INSERT INTO olibdb VALUES('o','eliminationSolve',2,'n','(Polynomial(R),List(R))->List(List(Equation(Polynomial(R))))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationSolve(eqn,{} lst_val)} computes all solutions of equation \spad{eqn} by trying the values of lst_val for undetermined variables.');
INSERT INTO olibdb VALUES('o','eliminationSolve',3,'n','(List(Polynomial(R)),List(R),List(List(Equation(Polynomial(R)))))->List(List(Equation(Polynomial(R))))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationSolve(lst_eqn,{} lst_val,{} lst_sub)} computes all solutions of the first equation of \spad{lst_eqn} by trying the values of \spad{lst_val} for undetermined variables with respect to given subsolutions lst_sub and return those which fulfill all other equations in \spad{lst_eqn}.');
INSERT INTO olibdb VALUES('o','eliminationSolve',3,'n','(Polynomial(R),List(R),List(Equation(Polynomial(R))))->List(List(Equation(Polynomial(R))))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationSolve(eqn,{} lst_val,{} sub)} computes all solutions of equation \spad{eqn} by trying the values of \spad{lst_val} for undetermined variables with respect to given subsolution sub.');
INSERT INTO olibdb VALUES('o','eliminationSolve',3,'n','(Polynomial(R),List(R),List(List(Equation(Polynomial(R)))))->List(List(Equation(Polynomial(R))))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationSolve(eqn,{} lst_val,{} lst_sub)} computes all solutions of equation \spad{eqn} by trying the values of \spad{lst_val} for undetermined variables with respect to given subsolutions lst_sub.');
INSERT INTO olibdb VALUES('o','eliminationTransformations',5,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger))->List(Matrix(Polynomial(R)))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationTransformations(p,{} row_P,{} col_P,{} row_Q,{} col_Q)} returns a pair of transformation matrices with commutative variables ''a[\spad{i}] in rows/columns row_P/col_P respectively \spad{''b}[\spad{i}] in rows/columns row_Q/col_Q.');
INSERT INTO olibdb VALUES('o','eliminationTransformations',6,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(NonNegativeInteger),List(Equation(Polynomial(R))))->List(Matrix(R))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationTransformations(p,{} row_P,{} col_P,{} row_Q,{} col_Q,{} sol)} Uses eval to set the values in sol into the variables in the transformation matrices.');
INSERT INTO olibdb VALUES('o','eliminationTransformations',7,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger),Symbol,List(NonNegativeInteger),List(NonNegativeInteger),Symbol)->List(Matrix(Polynomial(R)))','dLinearMultivariateMatrixPencil(R)','has(R,Field)','\spad{eliminationTransformations(p,{} row_P,{} col_P,{} sym_P,{} row_Q,{} col_Q,{} sym_Q)} returns a pair of transformation matrices with commutative variables \spad{sym_P}[\spad{i}] in rows/columns row_P/col_P respectively sym_Q[\spad{i}] in rows/columns row_Q/col_Q.');
INSERT INTO olibdb VALUES('o','elimZeroCols!',1,'n','(%)->Void','dSparseEchelonMatrix(C,D)',NULL,'\spad{elimZeroCols!(A)} removes columns which contain only zeros. This affects basically only the value of \spad{allIndices(A)}.');
INSERT INTO olibdb VALUES('o','ellipseBoundary',2,'n','(PT,PT)->%','dSBoundary(PT)',NULL,'\spad{ellipseBoundary(c1,{} c2)} constructs an ellipse boundary \spad{n}-dimensional axis-aligned ellipoid with given parameters \spad{c1:} \spad{PT} holds centre point \spad{c2:} \spad{PT} holds extent (radius for each coordinate)');
INSERT INTO olibdb VALUES('o','elliptic',0,'n','()->Union(UP,failed)','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{elliptic()} returns \spad{p(x)} if the curve is the elliptic defined by \spad{y^2 = p(x)},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','elliptic',0,'x','()->Union(UP,failed)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{elliptic()} returns \spad{p(x)} if the curve is the elliptic defined by \spad{y^2 = p(x)},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','elliptic',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{elliptic(a)} transforms from elliptic coordinates to Cartesian coordinates: \spad{elliptic(a)} is a function which will map the point \spad{(u,{} v)} to \spad{x = a*cosh(u)*cos(v)},{} \spad{y = a*sinh(u)*sin(v)}.');
INSERT INTO olibdb VALUES('o','ellipticCylindrical',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{ellipticCylindrical(a)} transforms from elliptic cylindrical coordinates to Cartesian coordinates: \spad{ellipticCylindrical(a)} is a function which will map the point \spad{(u,{} v,{} z)} to \spad{x = a*cosh(u)*cos(v)},{} \spad{y = a*sinh(u)*sin(v)},{} \spad{z}.');
INSERT INTO olibdb VALUES('o','ellipticE',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind: \spad{ellipticE(m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..1)}.');
INSERT INTO olibdb VALUES('o','ellipticE',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind');
INSERT INTO olibdb VALUES('o','ellipticE',1,'x','(Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticE',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind: \spad{ellipticE(m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..1)}.');
INSERT INTO olibdb VALUES('o','ellipticE',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind');
INSERT INTO olibdb VALUES('o','ellipticE',1,'x','(Float)->Float','pFloatEllipticFunctions',NULL,'\spad{ellipticE(m)} is the complete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind: \spad{ellipticE(z,{} m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'n','(UTS,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)','has(Coef,Algebra(Fraction(Integer)))','\spad{ellipticE(z,{} m)} expands the elliptic integral \spad{E} as a Taylor series in \spad{z}.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind: \spad{ellipticE(z,{} m) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticE',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{ellipticE(z,{} m)} is the incomplete elliptic integral of the second kind.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind : \spad{ellipticF(z,{} m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'n','(UTS,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)','has(Coef,Algebra(Fraction(Integer)))','\spad{ellipticF(z,{} m)} expands the elliptic integral \spad{F} as a Taylor series in \spad{z}.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind : \spad{ellipticF(z,{} m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticF',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{ellipticF(z,{} m)} is the incomplete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ellipticK(m)} is the complete elliptic integral of the first kind: \spad{ellipticK(m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..1)}.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticK(z,{} m)} is the incomplete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'x','(Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{ellipticK(m)} is the complete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{ellipticK(m)} is the complete elliptic integral of the first kind: \spad{ellipticK(m) = integrate(1/sqrt((1-t^2)*(1-m*t^2)),{} t = 0..1)}.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticK(z,{} m)} is the complete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticK',1,'x','(Float)->Float','pFloatEllipticFunctions',NULL,'\spad{ellipticK(m)} is the complete elliptic integral of the first kind.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind: \spad{ellipticPi(z,{} n,{} m) = integrate(1/((1-n*t^2)*sqrt((1-t^2)*(1-m*t^2))),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'n','(UTS,Coef,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)','has(Coef,Algebra(Fraction(Integer)))','\spad{ellipticPi(z,{} n,{} m)} expands the elliptic integral \spad{Pi} as a Taylor series in \spad{z}.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'x','(Complex(DoubleFloat),Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'x','(Complex(Float),Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind: \spad{ellipticPi(z,{} n,{} m) = integrate(1/((1-n*t^2)*sqrt((1-t^2)*(1-m*t^2))),{} t = 0..z)}.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'x','(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.');
INSERT INTO olibdb VALUES('o','ellipticPi',3,'x','(Float,Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{ellipticPi(z,{} n,{} m)} is the incomplete elliptic integral of the third kind.');
INSERT INTO olibdb VALUES('o','ellipticRC',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRC(x,{} y)} computes integral from 0 to infinity of \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRC',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRC(x,{} y)} computes integral from 0 to infinity of \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRD',3,'x','(Complex(DoubleFloat),Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRD(x,{} y,{} z)} computes integral from 0 to infinity of \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRD',3,'x','(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRD(x,{} y,{} z)} computes integral from 0 to infinity of \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-3/2)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRF',3,'x','(Complex(DoubleFloat),Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRF(x,{} y,{} z)} computes integral from 0 to infinity of \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRF',3,'x','(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRF(x,{} y,{} z)} computes integral from 0 to infinity of \spad{(1/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRJ',4,'x','(Complex(DoubleFloat),Complex(DoubleFloat),Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatEllipticIntegrals',NULL,'ellipticRF(\spad{x},{} \spad{y},{} \spad{z},{} \spad{p}) computes integral from 0 to infinity of \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}.');
INSERT INTO olibdb VALUES('o','ellipticRJ',4,'x','(DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatEllipticIntegrals',NULL,'\spad{ellipticRJ(x,{} y,{} z,{} p)} computes integral from 0 to infinity of \spad{(3/2)*(t+x)^(-1/2)*(t+y)^(-1/2)*(t+Z)^(-1/2)*(t+p)^(-1)dt}.');
INSERT INTO olibdb VALUES('o','elRow1!',3,'x','(M,Integer,Integer)->M','pMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{elRow1!(m,{} i,{} j)} swaps rows \spad{i} and \spad{j} of matrix \spad{m} : elementary operation of first kind');
INSERT INTO olibdb VALUES('o','elRow2!',4,'x','(M,R,Integer,Integer)->M','pMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{elRow2!(m,{} a,{} i,{} j)} adds to row \spad{i} a*row(\spad{m},{} \spad{j}) : elementary operation of second kind. (\spad{i} \spad{~=j})');
INSERT INTO olibdb VALUES('o','elt',10,'n','(BasicOperator,S,S,S,S,S,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',10,'n','(BasicOperator,S,S,S,S,S,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',10,'x','(BasicOperator,%,%,%,%,%,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p,{} o)} applies the 9-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z},{} \spad{t},{} \spad{s},{} \spad{r},{} \spad{q},{} \spad{p} and \spad{o}');
INSERT INTO olibdb VALUES('o','elt',1,'n','(%)->S','dReference(S)',NULL,'\spad{elt(n)} returns the object \spad{n}.');
INSERT INTO olibdb VALUES('o','elt',1,'x','(%)->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t)} gives the component of a rank 0 tensor.');
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,first)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,first)->S','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,first)->S','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,first)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,Integer)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,Integer)->S','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,Integer)->S','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,Integer)->S','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,last)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,last)->S','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,last)->S','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,last)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,left)->A','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,rest)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,rest)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,rest)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,rest)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,right)->A','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,UniversalSegment(Integer))->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,UniversalSegment(Integer))->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,UniversalSegment(Integer))->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,UniversalSegment(Integer))->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(A,value)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(BasicOperator,List(%))->%','dPattern(R)',NULL,'\spad{elt(op,{} [a1,{} ...,{} an])} returns \spad{op(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','elt',2,'n','(BasicOperator,List(S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(BasicOperator,List(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(BasicOperator,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(BasicOperator,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(Fraction(S),Fraction(S))->Fraction(S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(Fraction(S),R)->R','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(%,Integer)->R','cSequenceCategory(R)',NULL,'\spad{elt(mm,{} n)} returns the \spad{n}th element of a sequence.');
INSERT INTO olibdb VALUES('o','elt',2,'n','(%,List(%))->%','dOutputForm',NULL,'\spad{elt(op,{} l)} creates a form for application of \spad{op} to list of arguments \spad{l}.');
INSERT INTO olibdb VALUES('o','elt',2,'n','(%,NonNegativeInteger)->F','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{elt(f,{} i)} returns \spad{v}(\spad{i}) from the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','elt',2,'n','(%,R)->R','dEuclideanModularRing(S,R,Mod,reduction,merge,exactQuo)',NULL,'\spad{elt(x,{} r)} or \spad{x}.\spad{r} \undocumented');
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,Fraction(S))->Fraction(S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,Index)->Entry','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,Integer)->Character','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,Key)->Entry','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,R)->R','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,R)->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,S)->S','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'n','(S,UniversalSegment(Integer))->S','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',2,'x','(BasicOperator,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x)} or \spad{op}(\spad{x}) applies the unary operator \spad{op} to \spad{x}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(BasicOperator,List(%))->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} [x1,{} ...,{} xn])} or \spad{op}([\spad{x1},{} ...,{} \spad{xn}]) applies the \spad{n}-ary operator \spad{op} to \spad{x1},{} ...,{} \spad{xn}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,count)->NonNegativeInteger','dDataList(S)',NULL,'\spad{l.count} returns the number of elements in \spad{l}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,%)->%','cStringAggregate',NULL,'\spad{elt(s,{} t)} returns the concatenation of \spad{s} and \spad{t}. It is provided to allow juxtaposition of strings to work as concatenation. For example,{} \spad{smoo shed} returns \spad{smooshed}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,D)->I','cEltable(D,I)',NULL,'\spad{elt(u,{} i)} (also written: \spad{u}.\spad{i}) returns the element of \spad{u} indexed by \spad{i}. Error: if \spad{i} is not an index of \spad{u}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,DirectProduct(n,K))->K','dQuadraticForm(n,K)',NULL,'\spad{elt(qf,{} v)} evaluates the quadratic form \spad{qf} on the vector \spad{v},{} producing a scalar.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Expon)->Coef','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{elt(f(x),{} r)} returns the coefficient of the term of degree \spad{r} in \spad{f(x)}. This is the same as the function \spadfun{coefficient}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,first)->S','cUnaryRecursiveAggregate(S)',NULL,'\spad{elt(u,{} first)} (also written: \spad{u.first}) is equivalent to first(\spad{u}).');
INSERT INTO olibdb VALUES('o','elt',2,'x','(Fraction(%),Fraction(%))->Fraction(%)','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{elt(a,{} b)} evaluates the fraction of univariate polynomials \spad{a} with the distinguished variable replaced by \spad{b}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(Fraction(%),R)->R','cUnivariatePolynomialCategory(R)','has(R,Field)','\spad{elt(a,{} r)} evaluates the fraction of univariate polynomials \spad{a} with the distinguished variable replaced by the constant \spad{r}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Integer)->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{elt((a1,{} ...,{} an),{} i)} returns \spad{\spad{ai}}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Integer)->R','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{elt(a,{} i)} returns the \spad{i}-th coefficient of \spad{a} with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Integer)->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t,{} i)} gives a component of a rank 1 tensor.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,last)->S','cUnaryRecursiveAggregate(S)',NULL,'\spad{elt(u,{} last)} (also written: \spad{u.last}) is equivalent to last(\spad{u}).');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,left)->%','cBinaryRecursiveAggregate(S)',NULL,'\spad{elt(a,{} left)} (also written: \spad{a.left}) is equivalent to \spad{left(a)}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,List(Integer))->%','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{elt(s,{} [i1,{} ...,{} im])} recursively selects subexpression,{} that is elt(\spad{s},{} []) is just \spad{s} and elt(\spad{s},{} [\spad{i1},{} ...,{} im]) is the same as elt(elt(\spad{s},{} \spad{i1}),{} [\spad{i2},{} ...,{} im]).');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,List(Integer))->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t,{} [i1,{} ...,{} iN])} gives a component of a rank \spad{N} tensor.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,List(OutputForm))->%','dSymbol',NULL,'\spad{elt(s,{} [a1,{} ...,{} an])} or \spad{s}([\spad{a1},{} ...,{} an]) returns \spad{s} subscripted by \spad{[a1,{} ...,{} an]}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,NonNegativeInteger)->Permutation(S)','dPermutationGroup(S)',NULL,'\spad{elt(gp,{} i)} returns the \spad{i}-th generator of the group {\em gp}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,QueryEquation)->%','dDatabase(S)',NULL,'\spad{elt(db,{} q)} returns all elements of \spad{db} which satisfy \spad{q}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,rest)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{elt(\%,{} rest)} (also written: \spad{u.rest}) is equivalent to \spad{rest u}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,right)->%','cBinaryRecursiveAggregate(S)',NULL,'\spad{elt(a,{} right)} (also written: \spad{a.right}) is equivalent to \spad{right(a)}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,sort)->%','dDataList(S)',NULL,'\spad{l.sort} returns \spad{l} with elements sorted. Note: \spad{l.sort = sort(l)}');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,S)->S','cPermutationCategory(S)',NULL,'\spad{elt(p,{} el)} returns the image of {\em el} under the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Symbol)->Any','dLibrary',NULL,'\spad{elt(lib,{} k)} or \spad{lib}.\spad{k} extracts the value corresponding to the key \spad{k} from the library \spad{lib}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Symbol)->DataList(String)','dDatabase(S)',NULL,'\spad{elt(db,{} s)} returns the \spad{s} field of each element of \spad{db}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,Symbol)->String','dIndexCard',NULL,'\spad{elt(ic,{} s)} selects a particular field from \spad{ic}. Valid fields are \spad{name,{} nargs,{} exposed,{} type,{} abbreviation,{} kind,{} origin,{} params,{} condition,{} doc}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,unique)->%','dDataList(S)',NULL,'\spad{l.unique} returns \spad{l} with duplicates removed. Note: \spad{l.unique = removeDuplicates(l)}.');
INSERT INTO olibdb VALUES('o','elt',2,'x','(%,value)->S','cRecursiveAggregate(S)',NULL,'\spad{elt(u,{} value)} (also written: \spad{u.value}) is equivalent to \spad{value(u)}.');
INSERT INTO olibdb VALUES('o','elt',3,'n','(A,Integer,S)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(A,Integer,S)->S','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(A,Integer,S)->S','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(A,Integer,S)->S','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(BasicOperator,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(BasicOperator,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(%,Integer,C)->D','dSparseEchelonMatrix(C,D)',NULL,'\spad{elt(A,{} i,{} c)} returns the entry of the matrix \spad{A} in row \spad{i} and in the column with index \spad{c}.');
INSERT INTO olibdb VALUES('o','elt',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{elt(p,{} i,{} j)} returns the elements (\spad{i},{}\spad{j}) from the linear pencil \spad{p} as a list.');
INSERT INTO olibdb VALUES('o','elt',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->XDistributedPolynomial(VAR,F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{elt(f,{} i,{} j)} returns A(\spad{i},{}\spad{j}) from the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,F,F)->F','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Index,Entry)->Entry','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Integer,Character)->Character','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Integer,Integer)->R','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Integer,List(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Integer,List(Segment(Integer)))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Key,Entry)->Entry','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Integer),Integer)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Integer),List(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Integer),Segment(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Segment(Integer)),Integer)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Segment(Integer)),List(Segment(Integer)))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,List(Segment(Integer)),Segment(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Segment(Integer),List(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Segment(Integer),List(Segment(Integer)))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'n','(S,Segment(Integer),Segment(Integer))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',3,'x','(BasicOperator,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y)} or \spad{op}(\spad{x},{} \spad{y}) applies the binary operator \spad{op} to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Dom,Im)->Im','cEltableAggregate(Dom,Im)',NULL,'\spad{elt(u,{} x,{} y)} applies \spad{u} to \spad{x} if \spad{x} is in the domain of \spad{u},{} and returns \spad{y} otherwise.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,F,F)->F','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{elt(f,{} a,{} b)} or \spad{f}(a,{} \spad{b}) returns the value of \spad{f} at the point \spad{(x = a,{} y = b)} if it is not singular.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,F,PositiveInteger)->F','dRewriteRule(Base,R,F)',NULL,'\spad{elt(r,{} f,{} n)} or \spad{r}(\spad{f},{} \spad{n}) applies the rule \spad{r} to \spad{f} at most \spad{n} times.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,F,PositiveInteger)->F','dRuleset(Base,R,F)',NULL,'\spad{elt(r,{} f,{} n)} or \spad{r}(\spad{f},{} \spad{n}) applies all the rules of \spad{r} to \spad{f} at most \spad{n} times.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Integer,Integer)->R','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{elt(m,{} i,{} j)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m}. Error: if indices are outside the proper ranges.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Integer,Integer)->R','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(m,{} i,{} j)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m} error check to determine if indices are in proper ranges');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Integer,Integer)->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t,{} i,{} j)} gives a component of a rank 2 tensor.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Integer,List(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} row,{} colList)} returns an 1-by-\spad{n} array consisting of elements of \spad{x},{} where \spad{n = \# colList}. If \spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \spad{(k,{} l)}th entry of \spad{elt(x,{} row,{} colList)} is \spad{x(row,{} j<l>)}.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Integer,List(Segment(Integer)))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} row,{} ls2)} is equivalent to \spad{elt(x,{} row,{} l2)} where \spad{l2} is obtained appending expansions of elements of \spad{ls2},{} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Integer),Integer)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} rowList,{} col)} returns an \spad{m}-by-1 array consisting of elements of \spad{x},{} where \spad{m = \# rowList}. If \spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]},{} then the \spad{(k,{} l)}th entry of \spad{elt(x,{} rowList,{} col)} is \spad{x(i<k>,{} col)}.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Integer),List(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} rowList,{} colList)} returns an \spad{m}-by-\spad{n} array consisting of elements of \spad{x},{} where \spad{m = \# rowList} and \spad{n = \# colList}. If \spad{rowList = [i<1>,{} i<2>,{} ...,{} i<m>]} and \spad{colList = [j<1>,{} j<2>,{} ...,{} j<n>]},{} then the \spad{(k,{} l)}th entry of \spad{elt(x,{} rowList,{} colList)} is \spad{x(i<k>,{} j<l>)}.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Integer),Segment(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} rowList,{} s)} is equivalent to \spad{elt(x,{} rowList,{} expand(s))} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Segment(Integer)),Integer)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} ls1,{} col)} is equivalent to \spad{elt(x,{} l1,{} col)} where \spad{l1} is obtained appending expansions of elements of \spad{ls1},{} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Segment(Integer)),List(Segment(Integer)))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} ls1,{} ls2)} is equivalent to \spad{elt(x,{} l1,{} l2)} where \spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,List(Segment(Integer)),Segment(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} ls1,{} s2)} is equivalent to \spad{elt(x,{} l1,{} l2)} where \spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Segment(Integer),List(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} s,{} colList)} is equivalent to \spad{elt(x,{} expand(s),{} colList)} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Segment(Integer),List(Segment(Integer)))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} s1,{} ls2)} is equivalent to \spad{elt(x,{} l1,{} l2)} where \spad{li} is obtained appending expansions of elements of lsi,{} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',3,'x','(%,Segment(Integer),Segment(Integer))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(x,{} s1,{} s2)} is equivalent to \spad{elt(x,{} expand(s1),{} expand(s2))} but should be more convenient and more efficient.');
INSERT INTO olibdb VALUES('o','elt',4,'n','(BasicOperator,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',4,'n','(BasicOperator,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->R','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{elt(p,{} i,{} j,{} l)} returns the element (\spad{i},{}\spad{j}) in matrix \spad{l} of the linear pencil \spad{p}.');
INSERT INTO olibdb VALUES('o','elt',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->R','dThreeDimensionalMatrix(R)',NULL,'\spad{elt(x,{} i,{} j,{} k)} extract an element from the matrix \spad{x}');
INSERT INTO olibdb VALUES('o','elt',4,'n','(S,Integer,Integer,R)->R','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',4,'x','(BasicOperator,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z)} or \spad{op}(\spad{x},{} \spad{y},{} \spad{z}) applies the ternary operator \spad{op} to \spad{x},{} \spad{y} and \spad{z}.');
INSERT INTO olibdb VALUES('o','elt',4,'x','(%,Integer,Integer,Integer)->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t,{} i,{} j,{} k)} gives a component of a rank 3 tensor.');
INSERT INTO olibdb VALUES('o','elt',4,'x','(%,Integer,Integer,R)->R','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{elt(m,{} i,{} j,{} r)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m},{} if \spad{m} has an \spad{i}th row and a \spad{j}th column,{} and returns \spad{r} otherwise.');
INSERT INTO olibdb VALUES('o','elt',4,'x','(%,Integer,Integer,R)->R','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{elt(m,{} i,{} j,{} r)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m},{} if \spad{m} has an \spad{i}th row and a \spad{j}th column,{} and returns \spad{r} otherwise');
INSERT INTO olibdb VALUES('o','elt',5,'n','(BasicOperator,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',5,'n','(BasicOperator,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',5,'x','(BasicOperator,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t)} or \spad{op}(\spad{x},{} \spad{y},{} \spad{z},{} \spad{t}) applies the 4-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z} and \spad{t}.');
INSERT INTO olibdb VALUES('o','elt',5,'x','(%,Integer,Integer,Integer,Integer)->R','dCartesianTensor(minix,dim,R)',NULL,'\spad{elt(t,{} i,{} j,{} k,{} l)} gives a component of a rank 4 tensor.');
INSERT INTO olibdb VALUES('o','elt',6,'n','(BasicOperator,S,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',6,'n','(BasicOperator,S,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',6,'x','(BasicOperator,%,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t,{} s)} applies the 5-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z},{} \spad{t} and \spad{s}');
INSERT INTO olibdb VALUES('o','elt',7,'n','(BasicOperator,S,S,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',7,'n','(BasicOperator,S,S,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',7,'x','(BasicOperator,%,%,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r)} applies the 6-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z},{} \spad{t},{} \spad{s} and \spad{r}');
INSERT INTO olibdb VALUES('o','elt',8,'n','(BasicOperator,S,S,S,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',8,'n','(BasicOperator,S,S,S,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',8,'x','(BasicOperator,%,%,%,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q)} applies the 7-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z},{} \spad{t},{} \spad{s},{} \spad{r} and \spad{q}');
INSERT INTO olibdb VALUES('o','elt',9,'n','(BasicOperator,S,S,S,S,S,S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',9,'n','(BasicOperator,S,S,S,S,S,S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','elt',9,'x','(BasicOperator,%,%,%,%,%,%,%,%)->%','cExpressionSpace2(K)',NULL,'\spad{elt(op,{} x,{} y,{} z,{} t,{} s,{} r,{} q,{} p)} applies the 8-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z},{} \spad{t},{} \spad{s},{} \spad{r},{} \spad{q} and \spad{p}');
INSERT INTO olibdb VALUES('o','eltable?',1,'n','(F)->Boolean','pRecurrenceOperator(R,F)',NULL,'\spad{eltable? r} returns whether the operator determines (most likely) the sequence completely.');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dOutputBox',NULL,'Create an empty box of size 0.');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dOutputForm',NULL,'\spad{empty()} creates an empty form.');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{empty()} returns the empty quasi-algebraic set');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dSplittingNode(V,C)',NULL,'\spad{empty()} returns the same as \spad{[empty()\$V,{} empty()\$C,{} false]\$\%}');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dSymbolTable',NULL,'\spad{empty()} returns a new,{} empty symbol table');
INSERT INTO olibdb VALUES('o','empty',0,'n','()->%','dTheSymbolTable',NULL,'\spad{empty()} creates a new,{} empty symbol table.');
INSERT INTO olibdb VALUES('o','empty',0,'x','()->%','cAggregate',NULL,'\spad{empty()}\$\spad{D} creates an aggregate of type \spad{D} with 0 elements. Note: The {\em \$D} can be dropped if understood by context,{} \spadignore{e.g.} \spad{u: D := empty()}.');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','cFacetCategory',NULL,'is empty if it contains no vertices or if multiplier is zero');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dLatticeJoinOfMeets',NULL,'\spad{true} if empty');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dLatticeMeetOfJoins',NULL,'\spad{true} if empty');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dOutputBox',NULL,'\spad{empty?(b)} returns \spad{true} of the box has height and depth equal to 0.');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{empty?(s)} returns \spad{true} if the quasialgebraic set \spad{s} has no points,{} and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dSplittingNode(V,C)',NULL,'\spad{empty?(n)} returns \spad{true} iff the node \spad{n} is \spad{empty()\$\%}.');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(%)->Boolean','dXmlElement',NULL,'\spad{empty?(el)} returns \spad{true} is this element does not contain anything');
INSERT INTO olibdb VALUES('o','empty',1,'n','(Integer)->%','dVectorIntegerReconstructor',NULL,'\spad{empty(n)} produces reconstructor with \spad{n} slots');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(OutputForm)->Boolean','pOutputFormTools',NULL,'\spad{empty?(f)} checks if form \spad{f} is empty.');
INSERT INTO olibdb VALUES('o','empty?',1,'n','(S)->Boolean','xAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','empty?',1,'n','(S)->Boolean','xFacetCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','empty?',1,'x','(%)->Boolean','cAggregate',NULL,'\spad{empty?(u)} tests if \spad{u} has 0 elements.');
INSERT INTO olibdb VALUES('o','empty',2,'n','(Integer,Integer)->%','dVectorModularReconstructor',NULL,'\spad{empty(n,{} p)} initializes reconstructor with \spad{n} slots working modulo \spad{p}');
INSERT INTO olibdb VALUES('o','emptyLattice',0,'n','()->%','dLatticeJoinOfMeets',NULL,'construct an empty lattice');
INSERT INTO olibdb VALUES('o','emptyLattice',0,'n','()->%','dLatticeMeetOfJoins',NULL,'construct an empty lattice');
INSERT INTO olibdb VALUES('o','empty_mat',0,'n','()->MMT','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{empty_mat()} returns empty (that is of dimensions 0) matrix.');
INSERT INTO olibdb VALUES('o','empty_mat?',1,'n','(MMT)->Boolean','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{empty_mat?(mat)} returns \spad{true} if matrix is empty,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','empty_poly',0,'n','()->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{empty_poly()} returns empty (that is 0) polynomial.');
INSERT INTO olibdb VALUES('o','enableAlternativeOutput',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{enableAlternativeOutput(f)} enable output as rational expression.');
INSERT INTO olibdb VALUES('o','enableDebugOutput',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{enableDebugOutput(f)} enable displaying the ALS.');
INSERT INTO olibdb VALUES('o','endOfFile?',1,'x','(%)->Boolean','dTextFile',NULL,'\spad{endOfFile?(f)} tests whether the file \spad{f} is positioned after the end of all text. If the file is open for output,{} then this test is always \spad{true}.');
INSERT INTO olibdb VALUES('o','endSubProgram',0,'n','()->Symbol','dTheSymbolTable',NULL,'\spad{endSubProgram()} asserts that we are no longer processing the current subprogram.');
INSERT INTO olibdb VALUES('o','enqueue!',2,'x','(S,%)->S','cQueueAggregate(S)',NULL,'\spad{enqueue!(x,{} q)} inserts \spad{x} into the queue \spad{q} at the back end.');
INSERT INTO olibdb VALUES('o','enterInCache',2,'n','(S,(S)->Boolean)->S','pSortedCache(S)',NULL,'\spad{enterInCache(x,{} f)} enters \spad{x} in the cache,{} calling \spad{f(y)} to determine whether \spad{x} is equal to \spad{y}. It returns \spad{x} with an integer associated with it.');
INSERT INTO olibdb VALUES('o','enterInCache',2,'n','(S,(S,S)->Integer)->S','pSortedCache(S)',NULL,'\spad{enterInCache(x,{} f)} enters \spad{x} in the cache,{} calling \spad{f(x,{} y)} to determine whether \spad{x < y (f(x,{} y) < 0),{} x = y (f(x,{} y) = 0)},{} or \spad{x > y (f(x,{} y) > 0)}. It returns \spad{x} with an integer associated with it.');
INSERT INTO olibdb VALUES('o','enterPointData',2,'x','(%,List(Point(R)))->NonNegativeInteger','cThreeSpaceCategory(R)',NULL,'\spad{enterPointData(s,{} [p0,{} p1,{} ...,{} pn])} adds a list of points from \spad{p0} through \spad{pn} to the \spadtype{ThreeSpace},{} \spad{s},{} and returns the index,{} to the starting point of the list.');
INSERT INTO olibdb VALUES('o','entries',1,'n','(A)->List(S)','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','entries',1,'n','(%)->List(NonNegativeInteger)','dLoop',NULL,'\spad{entries(lp)} returns list of indexes that make this loop');
INSERT INTO olibdb VALUES('o','entries',1,'n','(S)->List(Entry)','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','entries',1,'n','(S)->List(Entry)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','entries',1,'x','(%)->List(Entry)','cIndexedAggregate(Index,Entry)',NULL,'\spad{entries(u)} returns a list of all the entries of aggregate \spad{u} in no assumed order.');
INSERT INTO olibdb VALUES('o','entry?',2,'n','(Entry,S)->Boolean','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','entry?',2,'x','(Entry,%)->Boolean','cIndexedAggregate(Index,Entry)','AND(has(%,finiteAggregate),has(Entry,BasicType))','\spad{entry?(x,{} u)} tests if \spad{x} equals \spad{u . i} for some index \spad{i}.');
INSERT INTO olibdb VALUES('o','enumerate',0,'n','()->List(S)','xFinite&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','enumerate',0,'n','()->Vector(%)','dSetOfMIntegersInOneToN(m,n)',NULL,'\spad{enumerate()} returns a vector of all the sets of \spad{M} integers in \spad{1..n}.');
INSERT INTO olibdb VALUES('o','enumerate',0,'x','()->List(%)','cFinite',NULL,'\spad{enumerate()} returns list of elements of the set.');
INSERT INTO olibdb VALUES('o','environment',4,'n','(String,String,String,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','dFormatLaTeX',NULL,'\spad{environmnt(env,{} x,{} sep)} returns a handler that typesets its arguments (without parentheses) in a \LaTeX{} environment with name \spad{env}. The string \spad{x} is put right after the start of the environment. The arguments are separated by the string \spad{sep}.');
INSERT INTO olibdb VALUES('o','environment',4,'n','(String,String,String,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','dFormatMathJax',NULL,'\spad{environmnt(env,{} x,{} sep)} returns a handler that typesets its arguments (without parentheses) in a \LaTeX{} environment with name \spad{env}. The string \spad{x} is put right after the start of the environment. The arguments are separated by the string \spad{sep}.');
INSERT INTO olibdb VALUES('o','epilogue',1,'n','(%)->List(String)','dTexFormat',NULL,'\spad{epilogue(t)} extracts the epilogue section of a TeX form \spad{t}.');
INSERT INTO olibdb VALUES('o','epilogue',1,'n','(%)->OutputBox','dFormatter(F)',NULL,'\spad{epilogue(t)} extracts the epilogue section of the form \spad{t}. This is a function \spad{f} such that \spad{f}(\spad{l}) returns a box with label \spad{l}.');
INSERT INTO olibdb VALUES('o','ePseudoscalar',0,'x','()->%','dCliffordAlgebra(n,K,bLin)',NULL,'unit pseudoscalar');
INSERT INTO olibdb VALUES('o','Epsilon',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Epsilon()} returns symbol for capital greek letter epsilon.');
INSERT INTO olibdb VALUES('o','epsilon',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{epsilon()} returns symbol for small greek letter epsilon.');
INSERT INTO olibdb VALUES('o','eq?',2,'n','(S,S)->Boolean','xAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','EQ',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{EQ(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x = y}.');
INSERT INTO olibdb VALUES('o','eq?',2,'x','(%,%)->Boolean','cAggregate',NULL,'\spad{eq?(u,{} v)} tests if \spad{u} and \spad{v} are same objects.');
INSERT INTO olibdb VALUES('o','eq',2,'x','(%,%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{eq(s,{} t)} is \spad{true} if EQ(\spad{s},{} \spad{t}) is \spad{true} in Lisp.');
INSERT INTO olibdb VALUES('o','eqRep?',2,'n','(%,%)->Boolean','dJetLazyFunction(JB,D)',NULL,'\spad{eqRep?(x,{} y)} compares the representations of \spad{x} and \spad{y} without any evaluation. Thus it is much weaker than \spad{=} and cannot decide equality of the evaluated expressions.');
INSERT INTO olibdb VALUES('o','equal?',4,'n','(%,List(NonNegativeInteger),%,List(NonNegativeInteger))->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{equal?(p,{} pos_p,{} q,{} pos_q)} checks,{} if the matrices \spad{pos_p} in \spad{p} are equal to the pos_q in \spad{q}. Not specified matrices have to be zero.');
INSERT INTO olibdb VALUES('o','equality',2,'x','(%,(%,%)->Boolean)->%','dBasicOperator',NULL,'\spad{equality(op,{} foo?)} attaches foo? as the \%equal? property to \spad{op}. If \spad{op1} and \spad{op2} have the same name,{} and one of them has an \%equal? property \spad{f},{} then \spad{f(op1,{} op2)} is called to decide whether \spad{op1} and \spad{op2} should be considered equal.');
INSERT INTO olibdb VALUES('o','equation',2,'x','(S,S)->%','dEquation(S)',NULL,'\spad{equation(a,{} b)} creates an equation.');
INSERT INTO olibdb VALUES('o','equation',2,'x','(Symbol,Segment(S))->%','dSegmentBinding(S)',NULL,'\spad{equation(v,{} a..b)} creates a segment binding value with variable \spad{v} and segment \spad{a..b}. Note that the interpreter parses \spad{v=a..b} to this form.');
INSERT INTO olibdb VALUES('o','equation',2,'x','(Symbol,String)->%','dQueryEquation',NULL,'\spad{equation(s,{}a)} creates a new equation.');
INSERT INTO olibdb VALUES('o','erf',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{erf(f)} denotes the error function');
INSERT INTO olibdb VALUES('o','erf',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{erf(x)} returns the error function of \spad{x},{} \spadignore{i.e.} \spad{2 / sqrt(\%\spad{pi})} times the integral of \spad{exp(-x^2) dx}.');
INSERT INTO olibdb VALUES('o','erf',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{erf(f)} denotes the error function');
INSERT INTO olibdb VALUES('o','erf',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','erf',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{erf(f)} denotes the error function');
INSERT INTO olibdb VALUES('o','erfi',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{erfi(f)} denotes \spad{-\%i*erf(\%i*z)}');
INSERT INTO olibdb VALUES('o','erfi',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{erfi(x)} denotes \spad{-\%i*erf(\%i*x)}');
INSERT INTO olibdb VALUES('o','erfi',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{erfi(f)} denotes \spad{-\%i*erf(\%i*f)}');
INSERT INTO olibdb VALUES('o','erfi',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','erfi',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{erfi(f)} denotes \spad{-\%i*erf(\%i*f)}');
INSERT INTO olibdb VALUES('o','error',1,'x','(List(String))->Exit','pErrorFunctions',NULL,'\spad{error(lmsg)} displays error message \spad{lmsg} and terminates.');
INSERT INTO olibdb VALUES('o','error',1,'x','(String)->Exit','pErrorFunctions',NULL,'\spad{error(msg)} displays error message \spad{msg} and terminates.');
INSERT INTO olibdb VALUES('o','error',2,'x','(String,List(String))->Exit','pErrorFunctions',NULL,'\spad{error(nam,{} lmsg)} displays error messages lmsg preceded by a message containing the name \spad{nam} of the function in which the error is contained.');
INSERT INTO olibdb VALUES('o','error',2,'x','(String,String)->Exit','pErrorFunctions',NULL,'\spad{error(nam,{} msg)} displays error message \spad{msg} preceded by a message containing the name \spad{nam} of the function in which the error is contained.');
INSERT INTO olibdb VALUES('o','errorInfo',1,'x','(%)->List(Symbol)','dOpenMathError',NULL,'\spad{errorInfo(u)} returns information about the error \spad{u}.');
INSERT INTO olibdb VALUES('o','errorKind',1,'x','(%)->OpenMathErrorKind','dOpenMathError',NULL,'\spad{errorKind(u)} returns the type of error which \spad{u} represents.');
INSERT INTO olibdb VALUES('o','Eta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Eta()} returns symbol for capital greek letter eta.');
INSERT INTO olibdb VALUES('o','eta',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{eta()} returns symbol for small greek letter eta.');
INSERT INTO olibdb VALUES('o','euclideanGroebner',1,'x','(List(Dpol))->List(Dpol)','pEuclideanGroebnerBasisPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{euclideanGroebner(lp)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','euclideanGroebner',2,'x','(List(Dpol),String)->List(Dpol)','pEuclideanGroebnerBasisPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{euclideanGroebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \spad{lp}. During computation,{} additional information is printed out if infoflag is given as either info (for summary information) or redcrit (for reduced critical pairs)');
INSERT INTO olibdb VALUES('o','euclideanGroebner',3,'x','(List(Dpol),String,String)->List(Dpol)','pEuclideanGroebnerBasisPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{euclideanGroebner(lp,{} info,{} redcrit)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}. If the second argument is \spad{info},{} a summary is given of the critical pairs. If the third argument is redcrit,{} critical pairs are printed.');
INSERT INTO olibdb VALUES('o','euclideanNormalForm',2,'x','(Dpol,List(Dpol))->Dpol','pEuclideanGroebnerBasisPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{euclideanNormalForm(poly,{} gb)} reduces the polynomial \spad{poly} modulo the precomputed groebner basis \spad{gb} giving a canonical representative of the residue class.');
INSERT INTO olibdb VALUES('o','euclideanSize',1,'n','(S)->NonNegativeInteger','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','euclideanSize',1,'n','(S)->NonNegativeInteger','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','euclideanSize',1,'n','(S)->NonNegativeInteger','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','euclideanSize',1,'n','(S)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','euclideanSize',1,'x','(%)->NonNegativeInteger','cEuclideanDomain',NULL,'\spad{euclideanSize(x)} returns the euclidean size of the element \spad{x}. Error: if \spad{x} is zero.');
INSERT INTO olibdb VALUES('o','euler',1,'n','(Integer)->SparseUnivariatePolynomial(Fraction(Integer))','pPolynomialNumberTheoryFunctions',NULL,'\spad{euler(n)} returns the \spad{n}th Euler polynomial \spad{E[n](x)}. Note: Euler polynomials denoted \spad{E(n,{} x)} are computed by solving the differential equation \spad{differentiate(E(n,{} x),{} x) = n E(n-1,{} x)} where \spad{E(0,{} x) = 1} and initial condition comes from \spad{E(n) = 2^n E(n,{} 1/2)}.');
INSERT INTO olibdb VALUES('o','euler',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{euler(n)} returns the \spad{n}th Euler number. This is \spad{2^n E(n,{} 1/2)},{} where \spad{E(n,{} x)} is the \spad{n}th Euler polynomial.');
INSERT INTO olibdb VALUES('o','eulerE',2,'x','(NonNegativeInteger,R)->R','pNumberTheoreticPolynomialFunctions(R)','has(R,Algebra(Fraction(Integer)))','\spad{eulerE(n,{} r)} returns value of the \spad{n}th Euler polynomial at \spad{r}.');
INSERT INTO olibdb VALUES('o','eulerPhi',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{eulerPhi(n)} returns the number of integers between 1 and \spad{n} (including 1) which are relatively prime to \spad{n}. This is the Euler phi function \spad{phi(n)} is also called the totient function.');
INSERT INTO olibdb VALUES('o','eval1',1,'n','(%)->%','dJetLazyFunction(JB,D)',NULL,'\spad{eval1(exp)} explicitly evaluates the next term in \spad{exp}. \spad{exp} is destructively altered.');
INSERT INTO olibdb VALUES('o','eval1',4,'n','(MP,Symbol,Integer,Record(prime:Integer,eval1coeffbuf:U32Vector,eval1expbuf:SortedExponentVector))->Union(MP,failed)','cModularEvaluationCategory(PT,MP)',NULL,'\spad{eval1(p,{} v,{} r,{} pss)} evaluates \spad{p} with respect to single variable \spad{v} at \spad{r}. \spad{pss} is global state.');
INSERT INTO olibdb VALUES('o','eval1',4,'n','(Polynomial(Integer),Symbol,Integer,Record(prime:Integer,eval1coeffbuf:U32Vector,eval1expbuf:SortedExponentVector))->Polynomial(Integer)','pPolynomialEvaluationUtilities',NULL,'\spad{eval1(pol,{} v,{} pt,{} pss)} evaluates \spad{pol} in variable \spad{v} at \spad{pt},{} using global state form \spad{pss}. Computations are done modulo a prime contained in \spad{pss}.');
INSERT INTO olibdb VALUES('o','eval1',4,'n','(Record(numer:Polynomial(Integer),denom:Polynomial(Integer)),Symbol,Integer,Record(prime:Integer,eval1coeffbuf:U32Vector,eval1expbuf:SortedExponentVector))->Union(Record(numer:Polynomial(Integer),denom:Polynomial(Integer)),failed)','pPolynomialEvaluationUtilities',NULL,'\spad{eval1(pq,{} v,{} pt,{} pss)} evaluates fraction of polynomial \spad{pq} in variable \spad{v} at \spad{pt},{} using global state form \spad{pss}. Computations are done modulo a prime contained in \spad{pss}.');
INSERT INTO olibdb VALUES('o','eval1a',3,'n','(Polynomial(Integer),Integer,Record(prime:Integer,eval1coeffbuf:U32Vector,eval1expbuf:SortedExponentVector))->Integer','pPolynomialEvaluationUtilities',NULL,'\spad{eval1a(pol,{} pt,{} pss)} evaluates polynomial \spad{pol} at point \spad{pt} using global state form \spad{pss}. Computations are done modulo a prime contained in \spad{pss}. Note: \spad{pol} must have at most one variable.');
INSERT INTO olibdb VALUES('o','eval',1,'n','(%)->%','dJetLazyFunction(JB,D)',NULL,'\spad{eval(exp)} explicitly evaluates all terms in \spad{exp}. \spad{exp} is destructively altered.');
INSERT INTO olibdb VALUES('o','eval',1,'x','(SymmetricPolynomial(Fraction(Integer)))->Fraction(Integer)','pCycleIndicators',NULL,'\spad{eval s} is the sum of the coefficients of a cycle index.');
INSERT INTO olibdb VALUES('o','eval',2,'n','(A,Equation(A))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(A,Equation(S))->A','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(A,List(Equation(A)))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(A,List(Equation(S)))->A','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(%,D)->D','dJetVectorField(JB,D)',NULL,'\spad{eval(v,{} f)} applies the vector field \spad{v} to the function \spad{f}.');
INSERT INTO olibdb VALUES('o','eval',2,'n','(%,F)->F','dMoebiusTransform(F)',NULL,'\spad{eval(m,{} x)} returns \spad{(a*x + b)/(c*x + d)} where \spad{m = moebius(a,{} b,{} c,{} d)} (see \spadfunFrom{moebius}{MoebiusTransform}).');
INSERT INTO olibdb VALUES('o','eval',2,'n','((Integer)->F,SymmetricPolynomial(Fraction(Integer)))->F','pEvaluateCycleIndicators(F)',NULL,'\spad{eval(f,{} s)} evaluates the cycle index \spad{s} by applying \indented{1}{the function \spad{f} to each integer in a monomial partition,{}} \indented{1}{forms their product and sums the results over all monomials.}');
INSERT INTO olibdb VALUES('o','eval',2,'n','(%,JetVectorField(JB,D))->D','dJetDifferential(JB,D)',NULL,'\spad{eval(om,{} v)} applies the differential \spad{om} to the vector field \spad{v}.');
INSERT INTO olibdb VALUES('o','eval',2,'n','(%,OnePointCompletion(F))->OnePointCompletion(F)','dMoebiusTransform(F)',NULL,'\spad{eval(m,{} x)} returns \spad{(a*x + b)/(c*x + d)} where \spad{m = moebius(a,{} b,{} c,{} d)} (see \spadfunFrom{moebius}{MoebiusTransform}).');
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(R))->S','xEvalable&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(R))->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(S))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,Equation(S))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(R)))->S','xEvalable&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(R)))->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(S)))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(S)))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(S)))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(S,List(Equation(S)))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',2,'n','(Stream(A),A)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{eval(a,{} r)} returns a stream of partial sums of the power series \spad{a} evaluated at the power series variable equal to \spad{r}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,Coef)->Stream(Coef)','cUnivariatePowerSeriesCategory(Coef,Expon)','has(Coef,SIGNATURE(^,Coef(Coef,Expon)))','\spad{eval(f,{} a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,%)->%','dEquation(S)','AND(has(S,Evalable(S)),has(S,SetCategory))','\spad{eval(eqn,{} x=f)} replaces \spad{x} by \spad{f} in equation \spad{eqn}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(Distribution(R),UPS)->S','pDistributionPolynomialPackage(R,S,UPS)',NULL,'\spad{eval(d,{} p)} evaluates the distribution \spad{d} as a linear functional on the polynomial \spad{p}. Same as \spad{integrate(p,{} d)}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,Equation(R))->%','cEvalable(R)',NULL,'\spad{eval(f,{} x = v)} replaces \spad{x} by \spad{v} in \spad{f}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(Fraction(Polynomial(R)),Equation(Fraction(Polynomial(R))))->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{eval(f,{} v = g)} returns \spad{f} with \spad{v} replaced by \spad{g}. Error: if \spad{v} is not a symbol.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(Fraction(Polynomial(R)),List(Equation(Fraction(Polynomial(R)))))->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{eval(f,{} [v1 = g1,{} ...,{} vn = gn])} returns \spad{f} with each \spad{vi} replaced by \spad{gi} in parallel,{} \spadignore{i.e.} \spad{vi}\spad{''s} appearing inside the \spad{gi}\spad{''s} are not replaced. Error: if any \spad{vi} is not a symbol.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,List(%))->%','dEquation(S)','AND(has(S,Evalable(S)),has(S,SetCategory))','\spad{eval(eqn,{} [x1=v1,{} ... xn=vn])} replaces \spad{xi} by \spad{vi} in equation \spad{eqn}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,List(Equation(R)))->%','cEvalable(R)',NULL,'\spad{eval(f,{} [x1 = v1,{} ...,{} xn = vn])} replaces \spad{xi} by \spad{vi} in \spad{f}.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(MxN,(M,N)->S)->S','cTensorProductProperty(R,M,N,MxN,S)',NULL,'\spad{eval(x,{} f)} evaluates the bivariate function \spad{f} linearly on the tensor product.');
INSERT INTO olibdb VALUES('o','eval',2,'x','(%,S)->S','cPermutationCategory(S)',NULL,'\spad{eval(p,{} el)} returns the image of {\em el} under the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,A,A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(A),List(A))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(S),List(A))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(S),List(R))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(S),List(S))->A','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(V),List(A))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,List(V),List(R))->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,S,A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,S,R)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,S,S)->A','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,V,A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(A,V,R)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,A,B)->S','xInnerEvalable&(S,A,B)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,BasicOperator,(List(S))->S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,BasicOperator,(List(S))->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,BasicOperator,(S)->S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,BasicOperator,(S)->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,K,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,K,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(A),List(B))->S','xInnerEvalable&(S,A,B)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(BasicOperator),List((List(S))->S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(BasicOperator),List((List(S))->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(BasicOperator),List((S)->S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(BasicOperator),List((S)->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(K),List(S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(K),List(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(R),List(R))->S','xEvalable&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(R),List(R))->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(SingletonAsOrderedSet),List(R))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(SingletonAsOrderedSet),List(S))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(S),List(S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(S),List(S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(S),List(S))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(S),List(S))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(Symbol),List((List(S))->S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(Symbol),List((List(S))->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(Symbol),List(R))->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(Symbol),List((S)->S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(Symbol),List((S)->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(VarSet),List(R))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,List(VarSet),List(S))->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,R,R)->S','xEvalable&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,R,R)->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,SingletonAsOrderedSet,R)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,SingletonAsOrderedSet,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,S,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,S,S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,S,S)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,S,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,Symbol,(List(S))->S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,Symbol,(List(S))->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,Symbol,R)->S','xFullyEvalableOver&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,Symbol,(S)->S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,Symbol,(S)->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,VarSet,R)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(S,VarSet,S)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',3,'n','(UPUP,Fraction(UP),Fraction(UP))->UPUP','pChangeOfVariable(F,UP,UPUP)',NULL,'\spad{eval(p(x,{} y),{} f(x),{} g(x))} returns \spad{p(f(x),{} y * g(x))}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,A,B)->%','cInnerEvalable(A,B)',NULL,'\spad{eval(f,{} x,{} v)} replaces \spad{x} by \spad{v} in \spad{f}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,BasicOperator,(%)->%)->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} s,{} f)} replaces every \spad{s(a)} in \spad{x} by \spad{f(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,BasicOperator,(List(%))->%)->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} s,{} f)} replaces every \spad{s(a1,{} ..,{} am)} in \spad{x} by \spad{f(a1,{} ..,{} am)} for any \spad{a1},{} ...,{} \spad{am}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(Fraction(Polynomial(R)),List(Symbol),List(Fraction(Polynomial(R))))->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{eval(f,{} [v1,{} ...,{} vn],{} [g1,{} ...,{} gn])} returns \spad{f} with each \spad{vi} replaced by \spad{gi} in parallel,{} \spadignore{i.e.} \spad{vi}\spad{''s} appearing inside the \spad{gi}\spad{''s} are not replaced.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(Fraction(Polynomial(R)),Symbol,Fraction(Polynomial(R)))->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{eval(f,{} v,{} g)} returns \spad{f} with \spad{v} replaced by \spad{g}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(A),List(B))->%','cInnerEvalable(A,B)',NULL,'\spad{eval(f,{} [x1,{} ...,{} xn],{} [v1,{} ...,{} vn])} replaces \spad{xi} by \spad{vi} in \spad{f}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(BasicOperator),List((%)->%))->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(BasicOperator),List((List(%))->%))->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a1,{} ...,{} an)} in \spad{x} by \spad{\spad{fi}(a1,{} ...,{} an)} for any \spad{a1},{} ...,{} \spad{an}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(Symbol),List((%)->%))->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(Symbol),List((List(%))->%))->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a1,{} ...,{} an)} in \spad{x} by \spad{\spad{fi}(a1,{} ...,{} an)} for any \spad{a1},{} ...,{} \spad{an}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,List(VarSet),List(%))->%','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{eval(p,{} [x1,{} ...,{} xn],{} [v1,{} ...,{} vn])} replaces \spad{\spad{xi}} by \spad{\spad{vi}} in \spad{p}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,Symbol,(%)->%)->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} s,{} f)} replaces every \spad{s(a)} in \spad{x} by \spad{f(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,Symbol,(List(%))->%)->%','cExpressionSpace2(K)',NULL,'\spad{eval(x,{} s,{} f)} replaces every \spad{s(a1,{} ..,{} am)} in \spad{x} by \spad{f(a1,{} ..,{} am)} for any \spad{a1},{} ...,{} \spad{am}.');
INSERT INTO olibdb VALUES('o','eval',3,'x','(%,VarSet,%)->%','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{eval(p,{} x,{} v)} replaces \spad{x} by \spad{v} in \spad{p}.');
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,BasicOperator,S,Symbol)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,List(BasicOperator),List(S),Symbol)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,List(Symbol),List(NonNegativeInteger),List((List(S))->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,List(Symbol),List(NonNegativeInteger),List((S)->S))->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,Symbol,NonNegativeInteger,(List(S))->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'n','(S,Symbol,NonNegativeInteger,(S)->S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,BasicOperator,%,Symbol)->%','cFunctionSpace2(R,K)','has(R,ConvertibleTo(InputForm))','\spad{eval(x,{} s,{} f,{} y)} replaces every \spad{s(a)} in \spad{x} by \spad{f(y)} with \spad{y} replaced by \spad{a} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,List(BasicOperator),List(%),Symbol)->%','cFunctionSpace2(R,K)','has(R,ConvertibleTo(InputForm))','\spad{eval(x,{} [s1,{} ...,{} sm],{} [f1,{} ...,{} fm],{} y)} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(y)} with \spad{y} replaced by \spad{a} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,List(Symbol),List(NonNegativeInteger),List((%)->%))->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a)^ni} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,List(Symbol),List(NonNegativeInteger),List((List(%))->%))->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{eval(x,{} [s1,{} ...,{} sm],{} [n1,{} ...,{} nm],{} [f1,{} ...,{} fm])} replaces every \spad{\spad{si}(a1,{} ...,{} an)^ni} in \spad{x} by \spad{\spad{fi}(a1,{} ...,{} an)} for any \spad{a1},{} ...,{} am.');
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,Symbol,NonNegativeInteger,(%)->%)->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{eval(x,{} s,{} n,{} f)} replaces every \spad{s(a)^n} in \spad{x} by \spad{f(a)} for any \spad{a}.');
INSERT INTO olibdb VALUES('o','eval',4,'x','(%,Symbol,NonNegativeInteger,(List(%))->%)->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{eval(x,{} s,{} n,{} f)} replaces every \spad{s(a1,{} ...,{} am)^n} in \spad{x} by \spad{f(a1,{} ...,{} am)} for any \spad{a1},{} ...,{} am.');
INSERT INTO olibdb VALUES('o','eval_at',4,'n','(U32Vector,Integer,Integer,Integer)->Integer','pU32VectorPolynomialOperations',NULL,'\spad{eval_at(v,{} deg,{} pt,{} p)} treats \spad{v} as coefficients of polynomial of degree \spad{deg} and evaluates the polynomial at point \spad{pt} modulo \spad{p}');
INSERT INTO olibdb VALUES('o','evaluate',1,'x','(BasicOperator)->Union((List(A))->A,failed)','pBasicOperatorFunctions1(A)',NULL,'\spad{evaluate(op)} returns the value of the \%eval property of \spad{op} if it has one,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','evaluate',2,'n','(%,(R)->R)->%','dOperator(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','evaluate',2,'x','(BasicOperator,(A)->A)->BasicOperator','pBasicOperatorFunctions1(A)',NULL,'\spad{evaluate(op,{} foo)} attaches foo as the \%eval property of \spad{op}. If \spad{op} has an \%eval property \spad{f},{} then applying \spad{op} to a returns the result of \spad{f(a)}. Argument \spad{op} must be unary.');
INSERT INTO olibdb VALUES('o','evaluate',2,'x','(BasicOperator,(List(A))->A)->BasicOperator','pBasicOperatorFunctions1(A)',NULL,'\spad{evaluate(op,{} foo)} attaches foo as the \%eval property of \spad{op}. If \spad{op} has an \%eval property \spad{f},{} then applying \spad{op} to \spad{(a1,{} ...,{} an)} returns the result of \spad{f(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','evaluate',2,'x','(BasicOperator,List(A))->Union(A,failed)','pBasicOperatorFunctions1(A)',NULL,'\spad{evaluate(op,{} [a1,{}...,{}an])} checks if \spad{op} has an \%eval property \spad{f}. If it has,{} then \spad{f(a1,{} ...,{} an)} is returned,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','evaluate',2,'x','(%,(M)->M)->%','dModuleOperator(R,M)',NULL,'\spad{evaluate(f,{} u +-> g u)} attaches the map \spad{g} to \spad{f}. \spad{f} must be a basic operator \spad{g} MUST be additive,{} \spadignore{i.e.} \spad{g(a + b) = g(a) + g(b)} for any \spad{a},{} \spad{b} in \spad{M}. This implies that \spad{g(n a) = n g(a)} for any \spad{a} in \spad{M} and integer \spad{n > 0}.');
INSERT INTO olibdb VALUES('o','evaluateInverse',2,'n','(%,(R)->R)->%','dOperator(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','evaluateInverse',2,'x','(%,(M)->M)->%','dModuleOperator(R,M)',NULL,'\spad{evaluateInverse(x,{} f)} \undocumented');
INSERT INTO olibdb VALUES('o','eval_with_timeout',2,'n','(()->S,Integer)->Union(S,failed)','pTimeoutPackage(S)',NULL,'\spad{eval_with_timeout(f,{} t)} calls \spad{f} with timeout of \spad{t} seconds. Returns value computed by \spad{f} or failed if \spad{f} did not finish within \spad{t} seconds.');
INSERT INTO olibdb VALUES('o','even?',1,'n','(S)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','even?',1,'n','(S)->Boolean','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','even?',1,'x','(%)->Boolean','cExpressionSpace2(K)','has(%,RetractableTo(Integer))','\spad{even? x} is \spad{true} if \spad{x} is an even integer.');
INSERT INTO olibdb VALUES('o','even?',1,'x','(%)->Boolean','cIntegerNumberSystem',NULL,'\spad{even?(n)} returns \spad{true} if and only if \spad{n} is even.');
INSERT INTO olibdb VALUES('o','even?',1,'x','(%)->Boolean','dPermutation(S)',NULL,'\spad{even?(p)} returns \spad{true} if and only if \spad{p} is an even permutation,{} \spadignore{i.e.} {\em sign(p)} is 1.');
INSERT INTO olibdb VALUES('o','evenInfiniteProduct',1,'x','(UTS)->UTS','pInfiniteLambertProduct(Coef,UTS)',NULL,'\spad{evenInfiniteProduct(f(x))} computes \spad{product(n=2,{} 4,{} 6...,{} f(x^n))}. The series \spad{f(x)} should have constant coefficient 1.');
INSERT INTO olibdb VALUES('o','evenlambert',1,'n','(%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','evenlambert',1,'n','(%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{evenlambert(f(x))} returns \spad{f(x^2) + f(x^4) + f(x^6) + ...}. \indented{1}{\spad{f(x)} should have a zero constant coefficient.} \indented{1}{This function is used for computing infinite products.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n=1..infinity,{} f(x^(2*n))) = exp(evenlambert(log(f(x))))}.}');
INSERT INTO olibdb VALUES('o','evenlambert',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{evenlambert(st)} computes \spad{f(x^2) + f(x^4) + f(x^6) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f(x)} is a power series with constant coefficient 1,{} then \spad{prod(f(x^(2*n)),{} n=1..infinity) = exp(evenlambert(log(f(x))))}.');
INSERT INTO olibdb VALUES('o','every?',2,'n','((Entry)->Boolean,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'n','((R)->Boolean,S)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'n','((Record(key:Key,entry:Entry))->Boolean,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'n','((S)->Boolean,A)->Boolean','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'n','((S)->Boolean,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'n','((S)->Boolean,A)->Boolean','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','every?',2,'x','((S)->Boolean,%)->Boolean','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{every?(p,{} u)} tests if \spad{p}(\spad{x}) is \spad{true} for all elements \spad{x} of \spad{u}. Note: for collections,{} \spad{every?(p,{} u) = reduce(and,{} map(p,{} u),{} true,{} false)}. However,{} \spad{every?(p,{} u)} returns as soon as it finds an element for which \spad{p} gives \spad{false}.');
INSERT INTO olibdb VALUES('o','exactQuotient!',2,'n','(S,R)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exactQuotient',2,'n','(S,R)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exactQuotient!',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exactQuotient',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exactQuotient',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{exactQuotient(a,{} b)} computes the exact quotient of \spad{a} by \spad{b},{} which is assumed to be a divisor of \spad{a}. No error is returned if this exact quotient fails!');
INSERT INTO olibdb VALUES('o','exactQuotient!',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{exactQuotient!(a,{} b)} replaces \spad{a} by \spad{exactQuotient(a,{} b)}');
INSERT INTO olibdb VALUES('o','exactQuotient',2,'x','(%,R)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{exactQuotient(p,{} r)} computes the exact quotient of \spad{p} by \spad{r},{} which is assumed to be a divisor of \spad{p}. No error is returned if this exact quotient fails!');
INSERT INTO olibdb VALUES('o','exactQuotient!',2,'x','(%,R)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{exactQuotient!(p,{} r)} replaces \spad{p} by \spad{exactQuotient(p,{} r)}.');
INSERT INTO olibdb VALUES('o','exists?',1,'x','(%)->Boolean','cFileNameCategory',NULL,'\spad{exists?(f)} tests if the file exists in the file system.');
INSERT INTO olibdb VALUES('o','exp0',1,'n','(Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{exp0(f)} returns the exponential of the power series represented by cons(0,{} \spad{f}),{} \spadignore{i.e.} assuming zero constant term and therefore transcendentality is not involved.');
INSERT INTO olibdb VALUES('o','exp1',0,'x','()->%','dDoubleFloat',NULL,'\spad{exp1()} returns the natural log base \spad{2.718281828...}.');
INSERT INTO olibdb VALUES('o','exp1',0,'x','()->%','dFloat',NULL,'\spad{exp1()} returns exp 1: \spad{2.7182818284...}.');
INSERT INTO olibdb VALUES('o','exp1',1,'n','(PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{exp1(b)} computes approximation to exp(1) accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','exp',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{exp(x)} represents the Fortran intrinsic function EXP');
INSERT INTO olibdb VALUES('o','exp',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{exp(x)} applies the exponential operator to \spad{x}');
INSERT INTO olibdb VALUES('o','exp',1,'n','(LiePolynomial(VarSet,R))->%','dLieExponentials(VarSet,R,Order)',NULL,'\spad{exp(p)} returns the exponential of \spad{p}.');
INSERT INTO olibdb VALUES('o','exp',1,'n','(List(Integer))->%','dAntiSymm(R,lVar)',NULL,'\spad{exp([i1,{} ...in])} returns \spad{u_1\^{i_1} ... u_n\^{i_n}}');
INSERT INTO olibdb VALUES('o','exp',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exp',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exp',1,'n','(Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesTranscendentalFunctions(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exp',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{exp(st)} computes the exponential of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','exp',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{exp(st)} computes the exponential of a power series \spad{st}.');
INSERT INTO olibdb VALUES('o','exp',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{exp(z)} returns the exponential of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','exp',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{exp(z)} returns the exponential of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','exp',1,'x','(%)->%','cElementaryFunctionCategory',NULL,'\spad{exp(x)} returns \%\spad{e} to the power \spad{x}.');
INSERT INTO olibdb VALUES('o','exp',2,'n','(%,NonNegativeInteger)->%','dXPBWPolynomial(VarSet,R)','has(R,Module(Fraction(Integer)))','\spad{exp(p,{} n)} returns the exponential of \spad{p} (truncated up to order \spad{n}).');
INSERT INTO olibdb VALUES('o','exp',2,'n','(Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{exp(x,{} b)} computes approximation to exp(\spad{x}) accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','exp',2,'n','(XPOLY,NonNegativeInteger)->XPOLY','pXExponentialPackage(R,VarSet,XPOLY)',NULL,'\spad{exp(p,{} n)} returns the exponential of \spad{p} truncated at order \spad{n}.');
INSERT INTO olibdb VALUES('o','expa',1,'n','(%)->IntegerMod(n)','dDihedralGroup(n,a,b)',NULL,'\spad{expa(x)} returns the exponent of the rotation a in the normal form of \spad{x}');
INSERT INTO olibdb VALUES('o','expand',1,'n','(%)->XDistributedPolynomial(Symbol,R)','dXPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','expand',1,'n','(%)->XDistributedPolynomial(VarSet,R)','dXRecursivePolynomial(VarSet,R)',NULL,'\spad{expand(p)} returns \spad{p} in distributed form.');
INSERT INTO olibdb VALUES('o','expand',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{expand(f)} performs the following expansions on \spad{f:} \begin{items} \item 1. logs of products are expanded into sums of logs. \item 2. trigonometric and hyperbolic trigonometric functions of sums are expanded into sums of products of trigonometric and hyperbolic trigonometric functions. \item 3. formal powers of the form \spad{(a/b)^c} are expanded into \spad{a^c * b^(-c)}. \end{items}');
INSERT INTO olibdb VALUES('o','expand',1,'x','(%)->L','cSegmentExpansionCategory(S,L)',NULL,'\spad{expand(l..h by k)} creates value of type \spad{L} with elements \spad{l,{} l+k,{} ... lN} where \spad{lN <= h < lN+k}. For example,{} \spad{expand(1..5 by 2) = [1,{} 3,{} 5]}.');
INSERT INTO olibdb VALUES('o','expand',1,'x','(List(%))->L','cSegmentExpansionCategory(S,L)',NULL,'\spad{expand(l)} creates a new value of type \spad{L} in which each segment \spad{l..h by k} is replaced with \spad{l,{} l+k,{} ... lN},{} where \spad{lN <= h < lN+k}. For example,{} \spad{expand [1..4,{} 7..9] = [1,{} 2,{} 3,{} 4,{} 7,{} 8,{} 9]}.');
INSERT INTO olibdb VALUES('o','expand',1,'x','(%)->R','dFactored(R)',NULL,'\spad{expand(f)} multiplies the unit and factors together,{} yielding an unfactored object. Note: this is purposely not called \spadfun{coerce} which would cause the interpreter to do this automatically.');
INSERT INTO olibdb VALUES('o','expand',2,'n','(Expression(R2),PositiveInteger)->List(Expression(R2))','pDegreeReductionPackage(R1,R2)',NULL,'\spad{expand(f,{} n)} returns list of all solutions \spad{y} to equation \spad{y^n} = \spad{f}');
INSERT INTO olibdb VALUES('o','expand',2,'x','(IntegrationResult(Fraction(Polynomial(R))),Symbol)->List(Expression(R))','pIntegrationResultRFToFunction(R)',NULL,'\spad{expand(i,{} x)} returns the list of possible real functions of \spad{x} corresponding to \spad{i}.');
INSERT INTO olibdb VALUES('o','expand',2,'x','(IntegrationResult(F),Symbol)->List(F)','pIntegrationResultToFunction(R,F)',NULL,'\spad{expand(i,{} x)} returns the list of possible real functions of \spad{x} corresponding to \spad{i}.');
INSERT INTO olibdb VALUES('o','expandLog',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{expandLog(f)} converts every \spad{log(a/b)} appearing in \spad{f} into \spad{log(a) - log(b)},{} and every \spad{log(a*b)} into \spad{log(a) + log(b)}.');
INSERT INTO olibdb VALUES('o','expandPower',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{expandPower(f)} converts every power \spad{(a/b)^c} appearing in \spad{f} into \spad{a^c * b^(-c)}.');
INSERT INTO olibdb VALUES('o','expandTrigProducts',1,'x','(F)->F','pTranscendentalManipulations(R,F)','AND(has(R,ConvertibleTo(Pattern(R))),has(R,PatternMatchable(R)),has(F,ConvertibleTo(Pattern(R))),has(F,PatternMatchable(R)))','\spad{expandTrigProducts(e)} replaces \spad{sin(x)*sin(y)} by \spad{(cos(x-y)-cos(x+y))/2},{} \spad{cos(x)*cos(y)} by \spad{(cos(x-y)+cos(x+y))/2},{} and \spad{sin(x)*cos(y)} by \spad{(sin(x-y)+sin(x+y))/2}. Note: this operation uses pattern matcher,{} so it is relatively expensive. To avoid getting into an infinite loop the transformations are applied at most ten times.');
INSERT INTO olibdb VALUES('o','expb',1,'n','(%)->IntegerMod(2)','dDihedralGroup(n,a,b)',NULL,'\spad{expa(x)} returns the exponent of the reflection \spad{b} in the normal form of \spad{x}');
INSERT INTO olibdb VALUES('o','expextint',4,'n','((UP)->UP,(Integer,List(F))->List(Record(ratpart:F,coeffs:Vector(F))),(Matrix(F))->List(Vector(F)),List(Fraction(UP)))->List(Record(ratpart:Fraction(UP),coeffs:Vector(F)))','pParametricTranscendentalIntegration(F,UP)',NULL,'\spad{expextint('',{} rde,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solution of the homogeneous system \spad{h'' + c1*g1 + ... + cn*gn = 0} Argument foo is an parametric \spad{rde} solver on \spad{F}. \spad{csolve} is solver over constants.');
INSERT INTO olibdb VALUES('o','exp_frac',3,'n','(Integer,Integer,PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,NULL);
INSERT INTO olibdb VALUES('o','expIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{expIfCan(z)} returns exp(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','expint',2,'n','(F,Symbol)->F','pODEIntegration(R,F)',NULL,'\spad{expint(f,{} x)} returns e^{the integral of \spad{f} with respect to \spad{x}}.');
INSERT INTO olibdb VALUES('o','expintegrate',4,'n','(Fraction(UP),(UP)->UP,(Fraction(UP))->Record(answer:Fraction(UP),logpart:Fraction(UP),ir:IntegrationResult(Fraction(UP))),(Integer,F)->Record(ans:F,right:F,primpart:F,sol?:Boolean))->Record(answer:IntegrationResult(Fraction(UP)),a0:F)','pTranscendentalIntegration(F,UP)',NULL,'\spad{expintegrate(f,{} '',{} foo)} returns \spad{[g,{} a]} such that \spad{f = g'' + a},{} and \spad{a = 0} or \spad{a} has no integral in \spad{F}; Argument foo is a Risch differential equation solver on \spad{F}.');
INSERT INTO olibdb VALUES('o','explicitEntries?',1,'x','(%)->Boolean','cLazyStreamAggregate(S)',NULL,'\spad{explicitEntries?(s)} returns \spad{true} if the stream \spad{s} has explicitly computed entries,{} and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','explicitlyEmpty?',1,'x','(%)->Boolean','cLazyStreamAggregate(S)',NULL,'\spad{explicitlyEmpty?(s)} returns \spad{true} if the stream is an (explicitly) empty stream. Note: this is a null test which will not cause lazy evaluation.');
INSERT INTO olibdb VALUES('o','explicitlyFinite?',1,'n','(A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','explicitlyFinite?',1,'n','(A)->Boolean','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','explicitlyFinite?',1,'x','(%)->Boolean','cStreamAggregate(S)',NULL,'\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements,{} and \spad{false} otherwise. Note: for many datatypes,{} \spad{explicitlyFinite?(s) = not possiblyInfinite?(s)}.');
INSERT INTO olibdb VALUES('o','explogs2trigs',1,'n','(FG)->Complex(F)','pInnerTrigonometricManipulations(R,F,FG)',NULL,'\spad{explogs2trigs(f)} rewrites all the complex logs and exponentials appearing in \spad{f} in terms of trigonometric functions.');
INSERT INTO olibdb VALUES('o','exp_lower_bound',7,'n','(SparseUnivariatePolynomial(F),LaurentPolynomial(F,SparseUnivariatePolynomial(F)),Integer,Integer,List(Kernel(F)),F,(List(Kernel(F)),List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer)))))->Integer','pParametricRischDE(R,F)',NULL,'\spad{exp_lower_bound(a,{} b,{} ob,{} nc0,{} lk,{} eta,{} logi)} computes lower degree bound for solution of \spad{a*D(y) + b*y = c} in exponential case. \spad{ob} is order of \spad{b},{} \spad{nc0} is lower bound on order of \spad{c},{} \spad{eta} is derivative of the argument of exponential.');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->E','dModuleMonomial(IS,E,ff)',NULL,'\spad{exponent(x)} \undocumented');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->Integer','dCyclicGroup(n,g)',NULL,'\spad{exponent(g^k)} returns the representative integer \$\spad{k}\$.');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->Integer','dInfiniteCyclicGroup(g)',NULL,'\spad{exponent(g^k)} returns the representative integer \$\spad{k}\$.');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->Integer','dMachineFloat',NULL,'\spad{exponent(u)} returns the exponent of \spad{u}');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->NonNegativeInteger','dIntegerLocalizedAtPrime(p)',NULL,'Each element \spad{x} can be written as x=p^n*a/b with \spad{gcd}(\spad{p},{}a)=gcd(\spad{p},{}\spad{b})\spad{=1}. exponent(\spad{x}) returns \spad{n}.');
INSERT INTO olibdb VALUES('o','exponent',1,'n','(%)->UnivariatePuiseuxSeries(FE,var,cen)','dExponentialOfUnivariatePuiseuxSeries(FE,var,cen)',NULL,'\spad{exponent(exp(f(x)))} returns \spad{f(x)}');
INSERT INTO olibdb VALUES('o','exponent',1,'x','(%)->Integer','cFloatingPointSystem',NULL,'\spad{exponent(x)} returns the \spadfunFrom{exponent}{FloatingPointSystem} part of \spad{x}.');
INSERT INTO olibdb VALUES('o','exponenta',1,'n','(%)->Integer','dDihedralGroup(n,a,b)',NULL,'\spad{exponenta(x)} returns the exponent of the rotation a in the normal form of \spad{x} as integer');
INSERT INTO olibdb VALUES('o','exponentb',1,'n','(%)->Integer','dDihedralGroup(n,a,b)',NULL,'\spad{exponentb(x)} returns the exponent of the reflection \spad{b} in the normal form of \spad{x} as integer');
INSERT INTO olibdb VALUES('o','exponential1',0,'n','()->Float','pRandomFloatDistributions',NULL,'\spad{exponential1()} \undocumented');
INSERT INTO olibdb VALUES('o','exponential',1,'n','(Float)->()->Float','pRandomFloatDistributions',NULL,'\spad{exponential(f)} \undocumented');
INSERT INTO olibdb VALUES('o','exponential',1,'n','(UnivariatePuiseuxSeries(FE,var,cen))->%','dExponentialOfUnivariatePuiseuxSeries(FE,var,cen)',NULL,'\spad{exponential(f(x))} returns \spad{exp(f(x))}. Note: the function does NOT check that \spad{f(x)} has no non-negative terms.');
INSERT INTO olibdb VALUES('o','exponentialOrder',1,'n','(%)->Fraction(Integer)','dExponentialOfUnivariatePuiseuxSeries(FE,var,cen)',NULL,'\spad{exponentialOrder(exp(c * x ^(-n) + ...))} returns \spad{-n}. exponentialOrder(0) returns \spad{0}.');
INSERT INTO olibdb VALUES('o','exponents',1,'n','(%)->List(Integer)','dExtAlgBasis',NULL,'\spad{exponents(x)} converts a domain element into a list of zeros and ones corresponding to the exponents in the basis element that \spad{x} represents.');
INSERT INTO olibdb VALUES('o','expPot',3,'n','(Vector(GF),SingleInteger,SingleInteger)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{expPot(v,{} e,{} d)} returns the sum from \spad{i = 0} to \spad{e - 1} of \spad{v^(q^i*d)},{} interpreting \spad{v} as an element of a normal basis field and where \spad{q} is the size of the ground field. Note: for a description of the algorithm,{} see \spad{T}.Itoh and \spad{S}.Tsujii,{} A fast algorithm for computing multiplicative inverses in \spad{GF}(2^m) using normal bases,{} Information and Computation 78,{} \spad{pp}.171-177,{} 1988.');
INSERT INTO olibdb VALUES('o','expressIdealMember',2,'n','(List(S),S)->Union(List(S),failed)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','expressIdealMember',2,'x','(List(%),%)->Union(List(%),failed)','cPrincipalIdealDomain',NULL,'\spad{expressIdealMember([f1,{} ...,{} fn],{} h)} returns a representation of \spad{h} as a linear combination of the \spad{fi} or failed if \spad{h} is not in the ideal generated by the \spad{fi}.');
INSERT INTO olibdb VALUES('o','expression2Fortran1',3,'n','(()->Symbol,OutputForm,Boolean)->List(String)','pFortranCodeTools',NULL,'\spad{expression2Fortran1(nf,{} of,{} int_to_floats?)}');
INSERT INTO olibdb VALUES('o','expression2Fortran',1,'n','(OutputForm)->List(String)','pFortranCodeTools',NULL,'\spad{expression2Fortran(of)}');
INSERT INTO olibdb VALUES('o','exprex',1,'n','(OutputForm)->String','dHTMLFormat',NULL,'\spad{exprex(o)} converts \spadtype{OutputForm} to \spadtype{String}');
INSERT INTO olibdb VALUES('o','EXPRR2F',1,'n','(Expression(Integer))->F','pGuessFiniteFunctions(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','EXPRR2F',1,'n','(Expression(Integer))->Fraction(Polynomial(R))','pGuessPolynomialFunctions(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exprToGenUPS',3,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it))->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{exprToGenUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \spad{fcn} to a generalized power series. If \spad{posCheck?} is \spad{true},{} log\spad{''s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag} determines how the case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{complex},{} \spad{real: two sides},{} \spad{real: left side},{} \spad{real: right side},{} and \spad{just do it}. If \spad{atanFlag} is \spad{complex},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{just do it}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for values to the right. If \spad{atanFlag} is \spad{real: two sides},{} no series expansion will be computed. If \spad{atanFlag} is \spad{real: left side} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{real: right side} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.');
INSERT INTO olibdb VALUES('o','exprToGenUPS',3,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it))->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,UTS,TEXP,x)',NULL,'\spad{exprToGenUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \spad{fcn} to a generalized power series. If \spad{posCheck?} is \spad{true},{} log\spad{''s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag} determines how the case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{complex},{} \spad{real: two sides},{} \spad{real: left side},{} \spad{real: right side},{} and \spad{just do it}. If \spad{atanFlag} is \spad{complex},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{just do it}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for values to the right. If \spad{atanFlag} is \spad{real: two sides},{} no series expansion will be computed. If \spad{atanFlag} is \spad{real: left side} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{real: right side} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} we return a record containing the name of the function that caused the problem and a brief description of the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.');
INSERT INTO olibdb VALUES('o','exprToPS',5,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it),Boolean,FE)->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{exprToPS(fcn,{} posCheck?,{} atanFlag,{} log_flag,{} log_val)} is like exprToUPS,{} but if \spad{log_flag} is \spad{true} it replaces logarithms of expansion variable by \spad{log_val}');
INSERT INTO olibdb VALUES('o','exprToPS',5,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it),Boolean,FE)->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,UTS,TEXP,x)',NULL,'\spad{exprToPS(fcn,{} posCheck?,{} atanFlag,{} log_flag,{} log_val)} is like exprToUPS,{} but if \spad{log_flag} is \spad{true} it replaces logarithms of expansion variable by \spad{log_val}');
INSERT INTO olibdb VALUES('o','exprToPS',8,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it),Boolean,FE,(FE)->Boolean,(FE)->Boolean,(FE)->Boolean)->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'exprToPS(\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val,{} coef_chk,{} inv_chk,{} zero_chk) is like exprToPS(\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val),{} but fails if \spad{coef_chk} is \spad{false} for some coefficient of \spad{fcn} or if expansion process needs to invert element of \spad{FE} for which \spad{inv_chk} is \spad{false}');
INSERT INTO olibdb VALUES('o','exprToPS',8,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it),Boolean,FE,(FE)->Boolean,(FE)->Boolean,(FE)->Boolean)->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,UTS,TEXP,x)',NULL,'exprToPS(\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val,{} coef_chk,{} inv_chk,{} zero_chk) is like exprToPS(\spad{fcn},{} posCheck?,{} atanFlag,{} log_flag,{} log_val),{} but fails if \spad{coef_chk} is \spad{false} for some coefficient of \spad{fcn} or if expansion process needs to invert element of \spad{FE} for which \spad{inv_chk} is \spad{false}');
INSERT INTO olibdb VALUES('o','expr_to_series',3,'n','(Expression(Integer),Kernel(Expression(Integer)),Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(Record(degree:OrderedExpression,coeff:Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{expr_to_series computes} degree and leading coefficinet of series expansion.');
INSERT INTO olibdb VALUES('o','exprToUPS',3,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it))->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{exprToUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \spad{fcn} to a power series. If \spad{posCheck?} is \spad{true},{} log\spad{''s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag} determines how the case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{complex},{} \spad{real: two sides},{} \spad{real: left side},{} \spad{real: right side},{} and \spad{just do it}. If \spad{atanFlag} is \spad{complex},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{just do it}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for values to the right. If \spad{atanFlag} is \spad{real: two sides},{} no series expansion will be computed. If \spad{atanFlag} is \spad{real: left side} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{real: right side} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.');
INSERT INTO olibdb VALUES('o','exprToUPS',3,'n','(FE,Boolean,Union(complex,real: two sides,real: left side,real: right side,just do it))->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,UTS,TEXP,x)',NULL,'\spad{exprToUPS(fcn,{} posCheck?,{} atanFlag)} converts the expression \spad{fcn} to a power series. If \spad{posCheck?} is \spad{true},{} log\spad{''s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag} determines how the case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{complex},{} \spad{real: two sides},{} \spad{real: left side},{} \spad{real: right side},{} and \spad{just do it}. If \spad{atanFlag} is \spad{complex},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the series expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{just do it}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for values to the right. If \spad{atanFlag} is \spad{real: two sides},{} no series expansion will be computed. If \spad{atanFlag} is \spad{real: left side} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{real: right side} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} a record containing the name of the function that caused the problem and a brief description of the problem is returned. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.');
INSERT INTO olibdb VALUES('o','exprToXXP',2,'n','(FE,Boolean)->Union(%expansion:ExponentialExpansion(R,FE,x,cen),%problem:Record(func:String,prob:String))','pFunctionSpaceToExponentialExpansion(R,FE,x,cen)',NULL,'\spad{exprToXXP(fcn,{} posCheck?)} converts the expression \spad{fcn} to an exponential expansion. If \spad{posCheck?} is \spad{true},{} log\spad{''s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed.');
INSERT INTO olibdb VALUES('o','exp_series',2,'n','(Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,NULL);
INSERT INTO olibdb VALUES('o','expt',2,'n','(S,PositiveInteger)->S','pRepeatedSquaring(S)',NULL,'\spad{expt(r,{} i)} computes r^i by repeated squaring');
INSERT INTO olibdb VALUES('o','exquo',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{exquo(f,{} g)} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,R)->Union(S,failed)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,R)->Union(S,failed)','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,R)->Union(S,failed)','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,R)->Union(S,failed)','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,S)->Union(S,failed)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,S)->Union(S,failed)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,S)->Union(S,failed)','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,S)->Union(S,failed)','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(S,S)->Union(S,failed)','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','exquo',2,'n','(Stream(A),Stream(A))->Union(Stream(A),failed)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{exquo(a,{} b)} returns the power series quotient of \spad{a} by \spad{b},{} if the quotient exists,{} and failed otherwise');
INSERT INTO olibdb VALUES('o','exQuo',2,'n','(%,%)->Union(%,failed)','dEuclideanModularRing(S,R,Mod,reduction,merge,exactQuo)',NULL,'\spad{exQuo(x,{} y)} \undocumented');
INSERT INTO olibdb VALUES('o','exQuo',2,'n','(%,%)->Union(%,failed)','dModularField(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{exQuo(x,{} y)} \undocumented');
INSERT INTO olibdb VALUES('o','exQuo',2,'n','(%,%)->Union(%,failed)','dModularRing(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{exQuo(x,{} y)} \undocumented');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,R)->Union(%,failed)','cComplexCategory(R)','has(R,IntegralDomain)','\spad{exquo(x,{} r)} returns the exact quotient of \spad{x} by \spad{r},{} or failed if \spad{r} does not divide \spad{x} exactly.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,R)->Union(%,failed)','cFiniteAbelianMonoidRing(R,E)','has(R,EntireRing)','\spad{exquo(p,{}r)} returns the exact quotient of polynomial \spad{p} by \spad{r},{} or failed if none exists.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,R)->Union(%,failed)','cMatrixCategory(R,Row,Col)','has(R,IntegralDomain)','\spad{exquo(m,{} r)} computes the exact quotient of the elements of \spad{m} by \spad{r},{} returning \spad{failed} if this is not possible.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,R)->Union(%,failed)','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,IntegralDomain)','\spad{exquo(m,{} r)} computes the exact quotient of the elements of \spad{m} by \spad{r},{} returning \spad{failed} if this is not possible.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,R)->Union(%,failed)','cUnivariateSkewPolynomialCategory(R)','has(R,IntegralDomain)','\spad{exquo(l,{} a)} returns the exact quotient of \spad{l} by a,{} returning \spad{failed} if this is not possible.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,%)->Union(%,failed)','cEntireRing',NULL,'\spad{exquo(a,{} b)} either returns an element \spad{c} such that \spad{c*b=a} or failed if no such element can be found.');
INSERT INTO olibdb VALUES('o','exquo',2,'x','(%,%)->Union(%,failed)','dNonNegativeInteger',NULL,'\spad{exquo(a,{}b)} returns the quotient of \spad{a} and \spad{b},{} or failed if \spad{b} is zero or \spad{a} rem \spad{b} is zero.');
INSERT INTO olibdb VALUES('o','extend',2,'n','(A,Integer)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(List(P),List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(List(P),S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(P,List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(P,S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(S,P)->S','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'n','(S,P)->S','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,Expon)->%','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{extend(f,{} n)} causes all terms of \spad{f} of degree \spad{<=} \spad{n} to be computed.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,Integer)->%','cLazyStreamAggregate(S)',NULL,'\spad{extend(st,{} n)} causes entries to be computed,{} if necessary,{} so that ''st'' will have at least \spad{''n''} explicit entries or so that all entries of ''st'' will be computed if ''st'' is finite with length \spad{<=} \spad{n}.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,Integer)->%','cPAdicIntegerCategory(p)',NULL,'\spad{extend(x,{} n)} forces the computation of digits up to order \spad{n}.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,Integer)->%','dContinuedFraction(R)',NULL,'\spad{extend(x,{} n)} causes the first \spadvar{\spad{n}} entries in the continued fraction \spadvar{\spad{x}} to be computed. Normally entries are only computed as needed.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(List(P),%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{extend(lp,{} ts)} returns \spad{ts} if \spad{empty? lp} \spad{extend(p,{} ts)} if \spad{lp = [p]} else \spad{extend(first lp,{} extend(rest lp,{} ts))}');
INSERT INTO olibdb VALUES('o','extend',2,'x','(List(P),List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{extend(lp,{} lts)} returns the same as \spad{concat([extend(lp,{} ts) for ts in lts])|}');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,List(R))->%','cPointCategory(R)',NULL,'\spad{extend(x,{} l,{} r)} \undocumented');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,NonNegativeInteger)->%','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{extend(f,{} n)} causes all terms of \spad{f} of degree \spad{<= n} to be computed.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(%,P)->%','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{extend(ts,{} p)} returns a triangular set which encodes the simple extension by \spad{p} of the extension of the base field defined by \spad{ts},{} according to the properties of triangular sets of the current category If the required properties do not hold an error is returned.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(P,%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{extend(p,{} ts)} assumes that \spad{p} is a non-constant polynomial whose main variable is greater than any variable of \spad{ts}. Then it returns a split of Kalkbrener of \spad{ts+p}. This may not be \spad{ts+p} itself,{} if for instance \spad{ts+p} is not a regular triangular set.');
INSERT INTO olibdb VALUES('o','extend',2,'x','(P,List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{extend(p,{} lts)} returns the same as \spad{concat([extend(p,{} ts) for ts in lts])|}');
INSERT INTO olibdb VALUES('o','extendedALS',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{extendedALS(f)} returns an extended ALS for \spad{f},{} that is,{} 1*f (with a scalar first row).');
INSERT INTO olibdb VALUES('o','extendedCoords',1,'n','(%)->List(DoubleFloat)','cSPointCategory',NULL,'\spad{extendedCoords(pt)} returns extended coordinates as a list.');
INSERT INTO olibdb VALUES('o','extendedEuclidean',2,'n','(S,S)->Record(coef1:S,coef2:S,generator:S)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extendedEuclidean',2,'x','(%,%)->Record(coef1:%,coef2:%,generator:%)','cEuclideanDomain',NULL,'\spad{extendedEuclidean(x,{} y)} returns a record rec where \spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \spad{gcd} of \spad{x} and \spad{y}. The \spad{gcd} is unique only up to associates if \spadtype{canonicalUnitNormal} is not asserted. \spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments.');
INSERT INTO olibdb VALUES('o','extendedEuclidean',3,'n','(S,S,S)->Union(Record(coef1:S,coef2:S),failed)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extendedEuclidean',3,'x','(%,%,%)->Union(Record(coef1:%,coef2:%),failed)','cEuclideanDomain',NULL,'\spad{extendedEuclidean(x,{} y,{} z)} either returns a record rec where \spad{rec.coef1*x+rec.coef2*y=z} or returns failed if \spad{z} cannot be expressed as a linear combination of \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','extended_gcd',3,'n','(U32Vector,U32Vector,Integer)->List(U32Vector)','pU32VectorPolynomialOperations',NULL,'\spad{extended_gcd(v1,{} v2,{} p)} gives [\spad{g},{} \spad{c1},{} \spad{c2}] such that \spad{g} is \spad{gcd(v1,{} v2,{} p)},{} \spad{g = c1*v1 + c2*v2} and degree(\spad{c1}) < max(degree(\spad{v2}) - degree(\spad{g}),{} 0) and degree(\spad{c2}) < max(degree(\spad{v1}) - degree(\spad{g}),{} 1)');
INSERT INTO olibdb VALUES('o','extendedint',3,'n','(F,Symbol,List(F))->Record(particular:Union(Record(ratpart:F,coeffs:Vector(F)),failed),basis:List(Record(ratpart:F,coeffs:Vector(F))))','pParametricIntegration(R,F)',NULL,'\spad{extendedint(f,{} x,{} [g1,{} ...,{} gn])} returns solution of the system \spad{f = dh/dx + c1*g1 + ... + cn*gn} and and a basis of the associated homogeneous system \spad{dh/dx + c1*g1 + ... + cn*gn = 0}. Solutions are in the field generated by kernels of \spad{f} and \spad{g1},{} ...,{} \spad{gn}.');
INSERT INTO olibdb VALUES('o','extendedint',3,'n','(Symbol,List(Kernel(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F)))','pParametricIntegration(R,F)',NULL,'\spad{extendedint(x,{} [k1,{} ...,{} kn],{} [g1,{} ...,{} gn])} returns a basis of the homogeneous system \spad{dh/dx + c1*g1 + ... + cn*gn = 0}. Solutions are in the field generated by \spad{k1},{} ...,{} \spad{kn}.');
INSERT INTO olibdb VALUES('o','extendedint',4,'n','(F,Symbol,List(Kernel(F)),List(F))->Record(particular:Union(Record(ratpart:F,coeffs:Vector(F)),failed),basis:List(Record(ratpart:F,coeffs:Vector(F))))','pParametricIntegration(R,F)',NULL,'\spad{extendedint(f,{} x,{} [k1,{} ...,{} kn],{} [g1,{} ...,{} gn])} is like extendedint(\spad{f},{} [\spad{k1},{} ...,{} \spad{kn}],{} [\spad{g1},{} ...,{} \spad{gn}]) but looks for solutions in the field generated by \spad{k1},{} ...,{} \spad{kn}.');
INSERT INTO olibdb VALUES('o','extendedLLL',1,'n','(Matrix(Integer))->Record(lll:Matrix(Integer),trf:Matrix(Integer))','pLLLReduction',NULL,'\spad{extendedLLL(m)} returns the \spad{LLL} reductions of \spad{m} together with the transformation matrix,{} \spadignore{i.e.} if [\spad{l},{} \spad{t}] is returned then it holds \spad{l} = \spad{t*m}.');
INSERT INTO olibdb VALUES('o','extendedLLL!',2,'n','(Matrix(Integer),NonNegativeInteger)->Matrix(Integer)','pLLLReduction',NULL,'\spad{extendedLLL!(m,{} n)} with 1 \spad{<=} \spad{n} \spad{<=} ncols(\spad{m}) performs the \spad{LLL} reduction of \spad{m} where only the first \spad{n} columns are considered significant. All matrix transformations,{} however,{} will be executed on the full matrix. \spad{m} is destructively modified and will be lost after this call.');
INSERT INTO olibdb VALUES('o','extendedResultant',2,'n','(%,%)->Record(resultant:R,coef1:%,coef2:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{extendedResultant(a,{} b)} returns \spad{[r,{} ca,{} cb]} such that \spad{r} is the resultant of \spad{a} and \spad{b} and \spad{r = ca * a + cb * b}');
INSERT INTO olibdb VALUES('o','extendedSubResultantGcd',2,'n','(%,%)->Record(gcd:%,coef1:%,coef2:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]} such that \spad{g} is a \spad{gcd} of \spad{a} and \spad{b} in \spad{R^(-1) P} and \spad{g = ca * a + cb * b}');
INSERT INTO olibdb VALUES('o','extendedSubResultantGcd',2,'x','(%,%)->Record(gcd:%,coef1:%,coef2:%)','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]} such that \spad{g} is \spad{subResultantGcd(a,{} b)} and we have \spad{ca * a + cb * cb = g}.');
INSERT INTO olibdb VALUES('o','extendIfCan',2,'x','(%,P)->Union(%,failed)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{extendIfCan(ts,{} p)} returns a triangular set which encodes the simple extension by \spad{p} of the extension of the base field defined by \spad{ts},{} according to the properties of triangular sets of the current domain. If the required properties do not hold then failed is returned. This operation encodes in some sense the properties of the triangular sets of the current category. Is is used to implement the \spad{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties.');
INSERT INTO olibdb VALUES('o','extendToPoint',2,'n','(%,PT)->%','dSBoundary(PT)',NULL,'\spad{extendToPoint(n,{} p)} creates a boundary that is the union \indented{2}{of a boundary and a point.} \spad{n} is the boundary \spad{p} is the point');
INSERT INTO olibdb VALUES('o','extension',1,'x','(%)->String','cFileNameCategory',NULL,'\spad{extension(f)} returns the type part of the file name.');
INSERT INTO olibdb VALUES('o','extensionDegree',0,'n','()->OnePointCompletion(PositiveInteger)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extensionDegree',0,'n','()->PositiveInteger','xFiniteAlgebraicExtensionField&(S,F)',NULL,'\spad{extensionDegree()} returns the degree of field extension.');
INSERT INTO olibdb VALUES('o','extensionDegree',0,'x','()->OnePointCompletion(PositiveInteger)','cExtensionField(F)',NULL,'\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic,{} and \spad{infinity} if it is not.');
INSERT INTO olibdb VALUES('o','extensionDegree',0,'x','()->PositiveInteger','cFiniteAlgebraicExtensionField(F)',NULL,'\spad{extensionDegree()} returns the degree of field extension.');
INSERT INTO olibdb VALUES('o','exteriorDifferential',1,'n','(%)->%','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{exteriorDifferential(df)} returns the exterior derivative (gradient,{} curl,{} divergence,{} ...) of the differential form \spad{df}.');
INSERT INTO olibdb VALUES('o','external?',1,'n','(%)->Boolean','dFortranType',NULL,'\spad{external?(u)} returns \spad{true} if \spad{u} is declared to be EXTERNAL');
INSERT INTO olibdb VALUES('o','externalList',1,'n','(%)->List(Symbol)','dSymbolTable',NULL,'\spad{externalList(tab)} returns a list of all the external symbols in \spad{tab}');
INSERT INTO olibdb VALUES('o','extract!',1,'n','(S)->Record(key:Key,entry:Entry)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extract!',1,'x','(%)->S','cBagAggregate(S)',NULL,'\spad{extract!(u)} destructively removes a (random) item from bag \spad{u}.');
INSERT INTO olibdb VALUES('o','extract',3,'n','(%,Integer,Integer)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{extract(A,{} i1,{} i2)} extracts the rows \spad{i1} to \spad{i2} and returns them as a new matrix.');
INSERT INTO olibdb VALUES('o','extractBottom!',1,'x','(%)->S','cDequeueAggregate(S)',NULL,'\spad{extractBottom!(d)} destructively extracts the bottom (back) element from the dequeue \spad{d}. Error: if \spad{d} is empty.');
INSERT INTO olibdb VALUES('o','extractClosed',1,'n','(%)->Boolean','dSubSpace(n,R)',NULL,'\spad{extractClosed(s)} returns the \spadtype{Boolean} value of the closed property for the indicated 3 dimensional subspace \spad{s}. If the property is closed,{} \spad{True} is returned,{} otherwise \spad{False} is returned.');
INSERT INTO olibdb VALUES('o','extractIfCan',1,'n','(Key)->Union(Entry,failed)','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{extractIfCan(x)} searches the item whose key is \spad{x}.');
INSERT INTO olibdb VALUES('o','extractIndex',1,'n','(%)->NonNegativeInteger','dSubSpace(n,R)',NULL,'\spad{extractIndex(s)} returns a non negative integer which is the current index of the 3 dimensional subspace \spad{s}.');
INSERT INTO olibdb VALUES('o','extractPoint',1,'n','(%)->Point(R)','dSubSpace(n,R)',NULL,'\spad{extractPoint(s)} returns the point which is given by the current index location into the point data field of the 3 dimensional subspace \spad{s}.');
INSERT INTO olibdb VALUES('o','extractProperty',1,'n','(%)->SubSpaceComponentProperty','dSubSpace(n,R)',NULL,'\spad{extractProperty(s)} returns the property of domain \spadtype{SubSpaceComponentProperty} of the indicated 3 dimensional subspace \spad{s}.');
INSERT INTO olibdb VALUES('o','extractSplittingLeaf',1,'n','(%)->Union(%,failed)','dSplittingTree(V,C)',NULL,'\spad{extractSplittingLeaf(a)} returns the left most leaf (as a tree) whose status is \spad{false} if any,{} else failed is returned.');
INSERT INTO olibdb VALUES('o','extractSymbol',1,'n','(SparseEchelonMatrix(JB,%))->SparseEchelonMatrix(JB,%)','cJetBundleFunctionCategory(JB)',NULL,'\spad{extractSymbol(jm)} extracts the highest order part of the Jacobi matrix.');
INSERT INTO olibdb VALUES('o','extractSymbol',1,'n','(SparseEchelonMatrix(JB,S))->SparseEchelonMatrix(JB,S)','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','extractSymbol',2,'n','(%,Boolean)->SparseEchelonMatrix(JB,D)','dJetDifferentialEquation(JB,D)',NULL,'\spad{extractSymbol(de,{} solved?)} computes the symbol of the differential equation \spad{de}. If \spad{solved?} is \spad{true},{} the row echelon form of the symbol is computed at once.');
INSERT INTO olibdb VALUES('o','extractTop!',1,'x','(%)->S','cDequeueAggregate(S)',NULL,'\spad{extractTop!(d)} destructively extracts the top (front) element from the dequeue \spad{d}. Error: if \spad{d} is empty.');
INSERT INTO olibdb VALUES('o','eyeDistance',2,'x','(%,Float)->Void','dThreeDimensionalViewport',NULL,'\spad{eyeDistance(v,{} d)} sets the distance of the observer from the center of the graph to \spad{d},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','F2EXPRR',1,'n','(F)->Expression(Integer)','pGuessFiniteFunctions(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','F2EXPRR',1,'n','(Fraction(Polynomial(R)))->Expression(Integer)','pGuessPolynomialFunctions(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','F2FG',1,'n','(F)->FG','pInnerTrigonometricManipulations(R,F,FG)',NULL,'\spad{F2FG(a + sqrt(-1) b)} returns \spad{a + i b}.');
INSERT INTO olibdb VALUES('o','F',2,'n','(NonNegativeInteger,NonNegativeInteger)->()->Float','pRandomFloatDistributions',NULL,'\spad{F(n,{} m)} \undocumented');
INSERT INTO olibdb VALUES('o','faceMap',2,'n','(%,NonNegativeInteger)->List(List(Integer))','dDeltaComplex(VS)',NULL,'returns an individual face map specified by \spad{n}. Where \spad{''n''} is the dimension required,{} so \spad{n=1} returns one dimensional faces (edges),{} \spad{n=2} returns two dimensional faces (triamgles),{} and so on. used by fundamentalGroup.');
INSERT INTO olibdb VALUES('o','factor1',1,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UP)))->List(LinearOrdinaryDifferentialOperator1(Fraction(UP)))','pLinearOrdinaryDifferentialOperatorFactorizer(F,UP)','has(F,AlgebraicallyClosedField)','\spad{factor1(a)} returns the factorisation of a,{} assuming that a has no first-order right factor.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(FreeMonoid(VarSet))->List(%)','dLyndonWord(VarSet)',NULL,'\spad{factor(x)} returns the decreasing factorization into Lyndon words.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(I)->Factored(I)','pIntegerFactorizationPackage(I)',NULL,'\spad{factor(n)} returns the full factorization of integer \spad{n}');
INSERT INTO olibdb VALUES('o','factor',1,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UP)))->List(LinearOrdinaryDifferentialOperator1(Fraction(UP)))','pLinearOrdinaryDifferentialOperatorFactorizer(F,UP)','has(F,AlgebraicallyClosedField)','\spad{factor(a)} returns the factorisation of a.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(%)->List(%)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factor(f)} factorizes \spad{f} in f=f_1*f_2*...*f_k with atoms (irreducible elements) f_i. Notice that this factorization is unique only with respect to similarity.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(%)->List(%)','dILogic',NULL,'splits \spad{n} into a list of factors which must be \spad{true} for the whole to be \spad{true}. This assumes that the top level is already a set of factors separated by \spad{/\} otherwise the result will just be a list with one entry: \spad{''n''}. This is used when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(%)->List(%)','dLatticeJoinOfMeets',NULL,'splits \spad{n} into a list of factors which must be \spad{true} for the whole to be \spad{true}. This assumes that the top level is already a set of factors separated by \spad{/\} otherwise the result will just be a list with one entry: \spad{''n''}. This is used when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(%)->List(%)','dLatticeMeetOfJoins',NULL,'splits \spad{n} into a list of factors which must be \spad{true} for the whole to be \spad{true}. This assumes that the top level is already a set of factors separated by \spad{/\} otherwise the result will just be a list with one entry: \spad{''n''}. This is used when converting ILogic to types by using the Curry-Howard isomorphism.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(P)->Factored(P)','pGeneralizedMultivariateFactorize(OV,E,S,R,P)',NULL,'\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain');
INSERT INTO olibdb VALUES('o','factor',1,'n','(P)->Factored(P)','pMRationalFactorize(E,OV,R,P)',NULL,'\spad{factor(p)} factors the multivariate polynomial \spad{p} with coefficients which are fractions of elements of \spad{R}.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(PPR)->Factored(PPR)','pMPolyCatPolyFactorizer(E,OV,R,PPR)',NULL,'\spad{factor(p)} factors a polynomial with polynomial coefficients.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(RP)->Factored(RP)','pRationalFactorize(RP)',NULL,'\spad{factor(p)} factors an extended polynomial \spad{p} over the rational numbers.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(S)->Factored(S)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factor',1,'n','(S)->Factored(S)','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factor',1,'n','(S)->Factored(S)','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factor',1,'n','(S)->Factored(S)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factor',1,'n','(S)->Factored(S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factor',1,'n','(UP)->Factored(UP)','pComplexRootFindingPackage(R,UP)',NULL,'\spad{factor(p)} tries to factor \spad{p} into linear factors with error at most {\em globalEps},{} the internal error bound,{} which can be set by {\em setErrorBound}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(UP)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factor(p)} returns the factorization of \spad{p} over the integers.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(UP)->Factored(UP)','pUnivariateFiniteFieldFactorize(F,UP)',NULL,'\spad{factor(p)} factorizes \spad{p} into prime factors.');
INSERT INTO olibdb VALUES('o','factor',1,'n','(XDistributedPolynomial(vl,F))->List(XDistributedPolynomial(vl,F))','pXPolynomialFactor(vl,F)','has(F,PolynomialFactorizationExplicit)','\spad{factor(p)} returns a factorization of \spad{p} into irreducible factors. Note: in general there are finitely many nonequivalent factorizations into irreducible factors,{} this routine returns only one.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(Complex(Integer))->Factored(Complex(Integer))','pGaussianFactorizationPackage',NULL,'\spad{factor(\spad{zi})} produces the complete factorization of the complex integer \spad{zi}.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(%)->Factored(%)','cUniqueFactorizationDomain',NULL,'\spad{factor(x)} returns the factorization of \spad{x} into irreducibles.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(P)->Factored(P)','pMultivariateFactorize(OV,E,R,P)',NULL,'\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain');
INSERT INTO olibdb VALUES('o','factor',1,'x','(PG)->Factored(PG)','pMultFiniteFactorize(OV,E,F,PG)',NULL,'\spad{factor(p)} produces the complete factorization of the multivariate polynomial \spad{p} over a finite field.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(PRF)->Factored(PRF)','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{factor(prf)} factors a polynomial with rational function coefficients.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(SparseUnivariatePolynomial(P))->Factored(SparseUnivariatePolynomial(P))','pMultivariateFactorize(OV,E,R,P)',NULL,'\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain where \spad{p} is represented as a univariate polynomial with multivariate coefficients');
INSERT INTO olibdb VALUES('o','factor',1,'x','(SparseUnivariatePolynomial(PG))->Factored(SparseUnivariatePolynomial(PG))','pMultFiniteFactorize(OV,E,F,PG)',NULL,'\spad{factor(p)} produces the complete factorization of the multivariate polynomial \spad{p} over a finite field. \spad{p} is represented as a univariate polynomial with multivariate coefficients over a finite field.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(UP)->Factored(UP)','pAlgFactor(UP)',NULL,'\spad{factor(p)} returns a prime factorisation of \spad{p} over the field generated by its coefficients.');
INSERT INTO olibdb VALUES('o','factor',1,'x','(UP)->Factored(UP)','pRationalFunctionFactor(UP)',NULL,'\spad{factor(p)} returns a prime factorisation of \spad{p}.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(AlPol,(UP)->Factored(UP))->Factored(AlPol)','pInnerAlgFactor(F,UP,AlExt,AlPol)',NULL,'\spad{factor(p,{} f)} returns a prime factorisation of \spad{p}; \spad{f} is a factorisation map for elements of UP.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UP)),(UP)->List(F))->List(LinearOrdinaryDifferentialOperator1(Fraction(UP)))','pLinearOrdinaryDifferentialOperatorFactorizer(F,UP)',NULL,'\spad{factor(a,{} zeros)} returns the factorisation of a. \spad{zeros} is a zero finder in \spad{UP}.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(P,(SparseUnivariatePolynomial(R))->Factored(SparseUnivariatePolynomial(R)))->Factored(P)','pInnerMultFact(OV,E,R,P)',NULL,'\spad{factor(p,{} ufact)} factors the multivariate polynomial \spad{p} by specializing variables and calling the univariate factorizer ufact.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(SparseUnivariatePolynomial(F),List(F))->Factored(SparseUnivariatePolynomial(F))','pExpressionFactorPolynomial(R,F)',NULL,'\spad{factor(p,{} [k1,{} ...,{} kn])} factors \spad{p} into irreducible factors over field generated by its coefficients and \spad{k1},{} ...,{} \spad{kn}.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(SparseUnivariatePolynomial(P),(SparseUnivariatePolynomial(R))->Factored(SparseUnivariatePolynomial(R)))->Factored(SparseUnivariatePolynomial(P))','pInnerMultFact(OV,E,R,P)',NULL,'\spad{factor(p,{} ufact)} factors the multivariate polynomial \spad{p} by specializing variables and calling the univariate factorizer ufact. \spad{p} is represented as a univariate polynomial with multivariate coefficients.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(UP,List(NonNegativeInteger))->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factor(p,{} listOfDegrees)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has for possible splitting of its degree listOfDegrees.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(UP,NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factor(p,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has at least \spad{r} factors.');
INSERT INTO olibdb VALUES('o','factor',2,'n','(UP,R)->Factored(UP)','pComplexRootFindingPackage(R,UP)',NULL,'\spad{factor(p,{} eps)} tries to factor \spad{p} into linear factors with error at most {\em eps}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization.');
INSERT INTO olibdb VALUES('o','factor',2,'x','(P,List(AlgebraicNumber))->Factored(P)','pAlgebraicMultFact(OV,E,P)',NULL,'\spad{factor(p,{} lan)} factors the polynomial \spad{p} over the extension generated by the algebraic numbers given by the list lan.');
INSERT INTO olibdb VALUES('o','factor',2,'x','(SparseUnivariatePolynomial(P),List(AlgebraicNumber))->Factored(SparseUnivariatePolynomial(P))','pAlgebraicMultFact(OV,E,P)',NULL,'\spad{factor(p,{} lan)} factors the polynomial \spad{p} over the extension generated by the algebraic numbers given by the list lan. \spad{p} is presented as a univariate polynomial with multivariate coefficients.');
INSERT INTO olibdb VALUES('o','factor',2,'x','(UP,List(AlgebraicNumber))->Factored(UP)','pAlgFactor(UP)',NULL,'\spad{factor(p,{} [a1,{} ...,{} an])} returns a prime factorisation of \spad{p} over the field generated by its coefficients and \spad{a1},{} ...,{} an.');
INSERT INTO olibdb VALUES('o','factor',3,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UnivariatePolynomial(var,Expression(Integer)))),(SparseUnivariatePolynomial(Expression(Integer)),List(Expression(Integer)))->Factored(SparseUnivariatePolynomial(Expression(Integer))),List(Expression(Integer)))->List(LinearOrdinaryDifferentialOperator1(Fraction(UnivariatePolynomial(var,Expression(Integer)))))','pLinearOrdinaryDifferentialOperatorFactorizer2(var,cen)',NULL,'to be documented later.');
INSERT INTO olibdb VALUES('o','factor',3,'n','(UP,List(NonNegativeInteger),NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factor(p,{} listOfDegrees,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees} and that \spad{p} has at least \spad{r} factors.');
INSERT INTO olibdb VALUES('o','factor',3,'n','(UP,NonNegativeInteger,NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factor(p,{} d,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{d} divides the degree of all factors of \spad{p} and that \spad{p} has at least \spad{r} factors.');
INSERT INTO olibdb VALUES('o','factor',3,'n','(UP,R,Boolean)->Factored(UP)','pComplexRootFindingPackage(R,UP)',NULL,'\spad{factor(p,{} eps,{} info)} tries to factor \spad{p} into linear factors with error at most {\em eps}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization. If {\em info} is {\em true},{} then information messages are given.');
INSERT INTO olibdb VALUES('o','factorAndSplit',1,'x','(%)->List(%)','dEquation(S)','has(S,IntegralDomain)','\spad{factorAndSplit(eq)} make the right hand side 0 and factors the new left hand side. Each factor is equated to 0 and put into the resulting list without repetitions.');
INSERT INTO olibdb VALUES('o','factorByRecursion',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','pPolynomialFactorizationByRecursion(R,E,VarSet,S)',NULL,'\spad{factorByRecursion(p)} factors polynomial \spad{p}. This function performs the recursion step for factorPolynomial,{} as defined in \spadtype{PolynomialFactorizationExplicit} category (see \spadfun{factorPolynomial})');
INSERT INTO olibdb VALUES('o','factorFraction',1,'x','(%)->Fraction(Factored(S))','dFraction(S)','has(S,UniqueFactorizationDomain)','\spad{factorFraction(r)} factors the numerator and the denominator of the fraction \spad{r}.');
INSERT INTO olibdb VALUES('o','factorGroebnerBasis',1,'x','(List(Dpol))->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{factorGroebnerBasis(basis)} checks whether the \spad{basis} contains reducible polynomials and uses these to split the \spad{basis}.');
INSERT INTO olibdb VALUES('o','factorGroebnerBasis',2,'x','(List(Dpol),Boolean)->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{factorGroebnerBasis(basis,{} info)} checks whether the \spad{basis} contains reducible polynomials and uses these to split the \spad{basis}. If argument {\em info} is \spad{true},{} information is printed about partial results.');
INSERT INTO olibdb VALUES('o','factorial',1,'n','(F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{factorial(n)} returns the factorial of \spad{n},{} \spadignore{i.e.} \spad{n!}.');
INSERT INTO olibdb VALUES('o','factorial',1,'n','(S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorial',1,'x','(%)->%','cCombinatorialFunctionCategory',NULL,'\spad{factorial(n)} computes the factorial of \spad{n} (denoted in the literature by \spad{n!}) Note: \spad{n! = n (n-1)! when n > 0}; also,{} \spad{0! = 1}.');
INSERT INTO olibdb VALUES('o','factorial',1,'x','(I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{factorial(n)} returns \spad{n!}. this is the product of all integers between 1 and \spad{n} (inclusive). Note: \spad{0!} is defined to be 1.');
INSERT INTO olibdb VALUES('o','factorials',1,'n','(F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{factorials(f)} rewrites the permutations and binomials in \spad{f} in terms of factorials.');
INSERT INTO olibdb VALUES('o','factorials',1,'x','(%)->%','cCombinatorialOpsCategory',NULL,'\spad{factorials(f)} rewrites the permutations and binomials in \spad{f} in terms of factorials.');
INSERT INTO olibdb VALUES('o','factorials',2,'n','(F,Symbol)->F','pCombinatorialFunction(R,F)',NULL,'\spad{factorials(f,{} x)} rewrites the permutations and binomials in \spad{f} involving \spad{x} in terms of factorials.');
INSERT INTO olibdb VALUES('o','factorials',2,'x','(%,Symbol)->%','cCombinatorialOpsCategory',NULL,'\spad{factorials(f,{} x)} rewrites the permutations and binomials in \spad{f} involving \spad{x} in terms of factorials.');
INSERT INTO olibdb VALUES('o','factorizationEquations',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(Polynomial(F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factorizationEquations(f,{}k_rows,{}k_cols)} for debugging purposes (interface LINPEN)');
INSERT INTO olibdb VALUES('o','factorizationGroebner',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(Polynomial(F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factorizationGroebner(f,{}k_rows,{}k_cols)} for debugging purposes (interface LINPEN)');
INSERT INTO olibdb VALUES('o','factorizationSolve',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(List(Equation(Polynomial(F))))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factorizationSolve(f,{}k_rows,{}k_cols)} returns a (possible empty) list of solutions for an admissible transformation to create an upper right block of zeros of size \spad{k_rows} times \spad{k_cols}.');
INSERT INTO olibdb VALUES('o','factorizationTransformations',4,'n','(%,NonNegativeInteger,NonNegativeInteger,List(Equation(Polynomial(F))))->List(Matrix(F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factorizationTransformations(f,{}k_rows,{}k_cols,{}sol)} for debugging purposes (interface LINPEN)');
INSERT INTO olibdb VALUES('o','factorize',2,'n','(%,NonNegativeInteger)->List(%)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factorize(f,{}k)} factorizes \spad{f} in f=g*h with rank(\spad{g})\spad{=k} if possible (if necessary by using non-linear techniques).');
INSERT INTO olibdb VALUES('o','factorList',1,'x','(%)->List(Record(flag:Union(nil,sqfr,irred,prime),factor:R,exponent:NonNegativeInteger))','dFactored(R)',NULL,'\spad{factorList(u)} returns the list of factors with flags (for use by factoring code).');
INSERT INTO olibdb VALUES('o','factorList',4,'n','(K,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->List(SparseUnivariatePolynomial(K))','pChineseRemainderToolsForIntegralBases(K,R,UP)',NULL,'\spad{factorList(k,{} n,{} m,{} j)} \undocumented');
INSERT INTO olibdb VALUES('o','factorOfDegree',2,'n','(PositiveInteger,Factored(UP))->UP','pGaloisGroupPolynomialUtilities(R,UP)',NULL,'\spad{factorOfDegree(d,{} f)} returns a factor of degree \spad{d} of the factored polynomial \spad{f}. Such a factor shall exist.');
INSERT INTO olibdb VALUES('o','factorOfDegree',2,'n','(PositiveInteger,UP)->Union(UP,failed)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorOfDegree(d,{} p)} returns a factor of \spad{p} of degree \spad{d}.');
INSERT INTO olibdb VALUES('o','factorOfDegree',3,'n','(PositiveInteger,UP,List(NonNegativeInteger))->Union(UP,failed)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorOfDegree(d,{} p,{} listOfDegrees)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree listOfDegrees.');
INSERT INTO olibdb VALUES('o','factorOfDegree',3,'n','(PositiveInteger,UP,NonNegativeInteger)->Union(UP,failed)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorOfDegree(d,{} p,{} r)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has at least \spad{r} factors.');
INSERT INTO olibdb VALUES('o','factorOfDegree',4,'n','(PositiveInteger,UP,List(NonNegativeInteger),NonNegativeInteger)->Union(UP,failed)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorOfDegree(d,{} p,{} listOfDegrees,{} r)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees},{} and that \spad{p} has at least \spad{r} factors.');
INSERT INTO olibdb VALUES('o','factorOfDegree',5,'n','(PositiveInteger,UP,List(NonNegativeInteger),NonNegativeInteger,Boolean)->Union(UP,failed)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorOfDegree(d,{} p,{} listOfDegrees,{} r,{} sqf)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees},{} and that \spad{p} has at least \spad{r} factors. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors).');
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'n','(SparseUnivariatePolynomial(F))->Factored(SparseUnivariatePolynomial(F))','pExpressionFactorPolynomial(R,F)',NULL,'\spad{factorPolynomial(p)} factors \spad{p} into irreducible factors over field generated by its coefficients.');
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorPolynomial',1,'x','(SparseUnivariatePolynomial(%))->Factored(SparseUnivariatePolynomial(%))','cPolynomialFactorizationExplicit',NULL,'\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','factors',1,'n','(%)->List(%)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{factors(f)} analysis the block structure of the system matrix of the ALS of \spad{f} to split \spad{f} into factors.');
INSERT INTO olibdb VALUES('o','factors',1,'n','(%)->List(Record(gen:S,exp:Integer))','dFreeGroup(S)',NULL,'\spad{factors(a1\^e1,{} ...,{} an\^en)} returns \spad{[[a1,{} e1],{} ...,{} [an,{} en]]}.');
INSERT INTO olibdb VALUES('o','factors',1,'n','(%)->List(Record(gen:S,exp:NonNegativeInteger))','dFreeMonoid(S)',NULL,'\spad{factors(a1\^e1,{} ...,{} an\^en)} returns \spad{[[a1,{} e1],{} ...,{} [an,{} en]]}.');
INSERT INTO olibdb VALUES('o','factors',1,'x','(%)->List(Record(factor:R,exponent:NonNegativeInteger))','dFactored(R)',NULL,'\spad{factors(u)} returns a list of the factors in a form suitable for iteration. That is,{} it returns a list where each element is a record containing a base and exponent. The original object is the product of all the factors and the unit (which can be extracted by \spad{unit(u)}).');
INSERT INTO olibdb VALUES('o','factorset',1,'n','(GR)->List(GR)','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{factorset(p)} returns the set of irreducible factors of \spad{p}.');
INSERT INTO olibdb VALUES('o','factorsOfCyclicGroupSize',0,'x','()->List(Record(factor:Integer,exponent:NonNegativeInteger))','cFiniteFieldCategory',NULL,'\spad{factorsOfCyclicGroupSize()} returns the factorization of size()\spad{-1}');
INSERT INTO olibdb VALUES('o','factorsOfDegree',2,'n','(PositiveInteger,Factored(UP))->List(UP)','pGaloisGroupPolynomialUtilities(R,UP)',NULL,'\spad{factorsOfDegree(d,{} f)} returns the factors of degree \spad{d} of the factored polynomial \spad{f}.');
INSERT INTO olibdb VALUES('o','factorSquareFree',1,'n','(RP)->Factored(RP)','pRationalFactorize(RP)',NULL,'\spad{factorSquareFree(p)} factors an extended squareFree polynomial \spad{p} over the rational numbers.');
INSERT INTO olibdb VALUES('o','factorSquareFree',1,'n','(UP)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorSquareFree(p)} returns the factorization of \spad{p} which is supposed not having any repeated factor (this is not checked).');
INSERT INTO olibdb VALUES('o','factorSquareFree',1,'n','(UP)->Factored(UP)','pUnivariateFiniteFieldFactorize(F,UP)',NULL,'\spad{factorSquareFree(p)} factorizes \spad{p} into prime factors. \spad{p} must be square free.');
INSERT INTO olibdb VALUES('o','factorSquareFree',2,'n','(UP,List(NonNegativeInteger))->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorSquareFree(p,{} listOfDegrees)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has for possible splitting of its degree listOfDegrees. \spad{p} is supposed not having any repeated factor (this is not checked).');
INSERT INTO olibdb VALUES('o','factorSquareFree',2,'n','(UP,NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorSquareFree(p,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has at least \spad{r} factors. \spad{p} is supposed not having any repeated factor (this is not checked).');
INSERT INTO olibdb VALUES('o','factorSquareFree',3,'n','(UP,List(NonNegativeInteger),NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorSquareFree(p,{} listOfDegrees,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees} and that \spad{p} has at least \spad{r} factors. \spad{p} is supposed not having any repeated factor (this is not checked).');
INSERT INTO olibdb VALUES('o','factorSquareFree',3,'n','(UP,NonNegativeInteger,NonNegativeInteger)->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{factorSquareFree(p,{} d,{} r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{d} divides the degree of all factors of \spad{p} and that \spad{p} has at least \spad{r} factors. \spad{p} is supposed not having any repeated factor (this is not checked).');
INSERT INTO olibdb VALUES('o','factorSquareFreeByRecursion',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','pPolynomialFactorizationByRecursion(R,E,VarSet,S)',NULL,'\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \spad{p}. This functions performs the recursion step for factorSquareFreePolynomial,{} as defined in \spadtype{PolynomialFactorizationExplicit} category (see \spadfun{factorSquareFreePolynomial}).');
INSERT INTO olibdb VALUES('o','factorSquareFreePolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorSquareFreePolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorSquareFreePolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorSquareFreePolynomial',1,'n','(SparseUnivariatePolynomial(S))->Factored(SparseUnivariatePolynomial(S))','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','factorSquareFreePolynomial',1,'x','(SparseUnivariatePolynomial(%))->Factored(SparseUnivariatePolynomial(%))','cPolynomialFactorizationExplicit',NULL,'\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \spad{p} into irreducibles where \spad{p} is known to be square free and primitive with respect to its main variable.');
INSERT INTO olibdb VALUES('o','failed',0,'n','()->%','dPatternMatchListResult(R,S,L)',NULL,'\spad{failed()} returns a failed match.');
INSERT INTO olibdb VALUES('o','failed',0,'n','()->%','dPatternMatchResult(R,S)',NULL,'\spad{failed()} returns a failed match.');
INSERT INTO olibdb VALUES('o','failed?',1,'n','(%)->Boolean','dPatternMatchListResult(R,S,L)',NULL,'\spad{failed?(r)} tests if \spad{r} is a failed match.');
INSERT INTO olibdb VALUES('o','failed?',1,'n','(%)->Boolean','dPatternMatchResult(R,S)',NULL,'\spad{failed?(r)} tests if \spad{r} is a failed match.');
INSERT INTO olibdb VALUES('o','false',0,'x','()->%','cLogic',NULL,'\spad{false} is a logical constant.');
INSERT INTO olibdb VALUES('o','fffg',3,'n','(List(D),(NonNegativeInteger,Vector(SparseUnivariatePolynomial(D)))->D,List(NonNegativeInteger))->Matrix(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{fffg(C,{} c,{} eta)} is version of fffg which uses sum of eta as order');
INSERT INTO olibdb VALUES('o','fffg',4,'n','(List(D),(NonNegativeInteger,Vector(SparseUnivariatePolynomial(D)))->D,Vector(Integer),NonNegativeInteger)->Matrix(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{fffg(C,{} c,{} vd,{} K)} is the general algorithm as proposed by Beckermann and Labahn. \blankline The first argument is the list of \spad{c_}{\spad{i},{} \spad{i}}. These are the only values of \spad{C} explicitly needed in \spad{fffg}. \blankline The second argument \spad{c},{} computes \spad{c_k}(\spad{M}),{} \spadignore{i.e.} \spad{c_k}(.) is the dual basis of the vector space \spad{V},{} but also knows about the special multiplication rule as described in Equation (2). Note that the information about \spad{f} is therefore encoded in \spad{c}. \blankline \spad{vd} is modified by the routine,{} on input it is the vector of degree bounds \spad{n},{} as introduced in Definition 2.1. On output it is vector of defects (degree bound minus degree of solution). \blankline \spad{K} is requested order of solution.');
INSERT INTO olibdb VALUES('o','FG2F',1,'n','(FG)->F','pInnerTrigonometricManipulations(R,F,FG)',NULL,'\spad{FG2F(a + i b)} returns \spad{a + sqrt(-1) b}.');
INSERT INTO olibdb VALUES('o','fglmIfCan',1,'n','(List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls))))->Union(List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls))),failed)','pLexTriangularPackage(R,ls)',NULL,'\spad{fglmIfCan(lp)} returns the lexicographical Groebner basis of \spad{lp} by using the {\em FGLM} strategy,{} if \spad{zeroDimensional?(lp)} holds .');
INSERT INTO olibdb VALUES('o','fglmIfCan',1,'n','(List(Polynomial(R)))->Union(List(Polynomial(R)),failed)','pFGLMIfCanPackage(R,ls)',NULL,'\spad{fglmIfCan(lq1)} returns the lexicographical Groebner basis of \spad{lq1} by using the {\em FGLM} strategy,{} if \spad{zeroDimensional?(lq1)} holds.');
INSERT INTO olibdb VALUES('o','fibonacci',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{fibonacci(n)} returns the \spad{n}th Fibonacci number,{} \spad{F[n]}. The Fibonacci numbers are defined by \spad{F[0] = 0},{} \spad{F[1] = 1} and \spad{F[n] = F[n-1] + F[n-2]}. The algorithm has running time \spad{O(log(n)^3)}. Reference: Knuth,{} The Art of Computer Programming Vol 2,{} Semi-Numerical Algorithms.');
INSERT INTO olibdb VALUES('o','filename',3,'x','(String,String,String)->%','cFileNameCategory',NULL,'\spad{filename(d,{} n,{} e)} creates a file name with \spad{d} as its directory,{} \spad{n} as its name and \spad{e} as its extension. This is a portable way to create file names. When \spad{d} or \spad{t} is the empty string,{} a default is used.');
INSERT INTO olibdb VALUES('o','fill!',2,'n','(A,S)->A','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fill!',2,'n','(S,Entry)->S','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fill!',2,'n','(S,R)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fill!',2,'x','(%,Entry)->%','cIndexedAggregate(Index,Entry)','has(%,shallowlyMutable)','\spad{fill!(u,{} x)} replaces each entry in aggregate \spad{u} by \spad{x}. The modified \spad{u} is returned as value.');
INSERT INTO olibdb VALUES('o','fill!',2,'x','(%,R)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{fill!(m,{} r)} fills \spad{m} with \spad{r}\spad{''s}');
INSERT INTO olibdb VALUES('o','fillPascalTriangle',0,'n','()->Void','pGaloisGroupUtilities(R)',NULL,'\spad{fillPascalTriangle()} fills the stored table.');
INSERT INTO olibdb VALUES('o','filterUntil',2,'x','((S)->Boolean,%)->%','dInfiniteTuple(S)',NULL,'\spad{filterUntil(p,{} t)} returns \spad{[x for x in t while not p(x)]}.');
INSERT INTO olibdb VALUES('o','filterUntil',2,'x','((S)->Boolean,%)->%','dStream(S)',NULL,'\spad{filterUntil(p,{} s)} returns \spad{[x0,{} x1,{} ...,{} x(n)]} where \spad{s = [x0,{} x1,{} x2,{} ..]} and \spad{n} is the smallest index such that \spad{p(xn) = true}.');
INSERT INTO olibdb VALUES('o','filterWhile',2,'x','((S)->Boolean,%)->%','dInfiniteTuple(S)',NULL,'\spad{filterWhile(p,{} t)} returns \spad{[x for x in t while p(x)]}.');
INSERT INTO olibdb VALUES('o','filterWhile',2,'x','((S)->Boolean,%)->%','dStream(S)',NULL,'\spad{filterWhile(p,{} s)} returns \spad{[x0,{} x1,{} ...,{} x(n-1)]} where \spad{s = [x0,{} x1,{} x2,{} ..]} and \spad{n} is the smallest index such that \spad{p(xn) = false}.');
INSERT INTO olibdb VALUES('o','find',2,'n','((Record(key:Key,entry:Entry))->Boolean,S)->Union(Record(key:Key,entry:Entry),failed)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','find',2,'n','((S)->Boolean,A)->Union(S,failed)','xCollection&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','find',2,'n','((S)->Boolean,A)->Union(S,failed)','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','find',2,'n','((S)->Boolean,A)->Union(S,failed)','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','find',2,'x','((S)->Boolean,%)->Union(S,failed)','cCollection(S)',NULL,'\spad{find(p,{} u)} returns the first \spad{x} in \spad{u} such that \spad{p(x)} is \spad{true},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','findCycle',2,'x','(NonNegativeInteger,%)->Record(cycle?:Boolean,prefix:NonNegativeInteger,period:NonNegativeInteger)','dStream(S)',NULL,'\spad{findCycle(n,{} st)} determines if st is periodic within \spad{n}.');
INSERT INTO olibdb VALUES('o','findNode',2,'n','(%,String)->Scene(PT)','dSceneNamedPoints(PT)',NULL,'\spad{findNode(n,{} ptName)} finds a scene node');
INSERT INTO olibdb VALUES('o','findNonZeroEntry',3,'n','(Matrix(F),NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{findNonZeroEntry(A,{}i,{}j)} returns the indices [\spad{k},{}\spad{l}] with i<=k<=m and j<=l<=n such that A(\spad{k},{}\spad{l}) is non-zero and [0,{}0] otherwise. A is of size \spad{m} \spad{x} \spad{n}.');
INSERT INTO olibdb VALUES('o','findPoint',2,'n','(%,String)->PT','dSceneNamedPoints(PT)',NULL,'\spad{findPoint(n,{} ptName)} find the point associated with a given string.');
INSERT INTO olibdb VALUES('o','find_relation',2,'n','(List(Float),NonNegativeInteger)->List(Integer)','pLLLReduction',NULL,'\spad{find_relation(lf,{} k)} finds short integer relation between elements of \spad{lf} rounded to \spad{k} decimal places.');
INSERT INTO olibdb VALUES('o','finite?',1,'x','(%)->Boolean','dCardinalNumber',NULL,'\spad{finite?(\spad{a})} determines whether \spad{a} is a finite cardinal,{} \spadignore{i.e.} an integer.');
INSERT INTO olibdb VALUES('o','finite?',1,'x','(%)->Boolean','dOnePointCompletion(R)',NULL,'\spad{finite?(x)} tests if \spad{x} is finite.');
INSERT INTO olibdb VALUES('o','finite?',1,'x','(%)->Boolean','dOrderedCompletion(R)',NULL,'\spad{finite?(x)} tests if \spad{x} is finite.');
INSERT INTO olibdb VALUES('o','finiteBasis',1,'n','(%)->Vector(R)','dFiniteDivisor(F,UP,UPUP,R)',NULL,'\spad{finiteBasis(d)} returns a basis for \spad{d} as a module over {\em K[x]}.');
INSERT INTO olibdb VALUES('o','finiteLattice',1,'n','(NonNegativeInteger)->%','dFiniteLattice(S,p)',NULL,'construct finite lattice element from index');
INSERT INTO olibdb VALUES('o','finiteLattice',1,'n','(S)->%','dFiniteLattice(S,p)',NULL,'construct finite lattice element from object');
INSERT INTO olibdb VALUES('o','finitePoset',2,'n','(List(S),List(List(Boolean)))->%','cPoset(S)',NULL,'\spad{finitePoset(c,{} s)} constructs a finite poset where the set and structure is supplied.');
INSERT INTO olibdb VALUES('o','finitePoset',2,'n','(List(S),(S,S)->Boolean)->%','cPoset(S)',NULL,'\spad{finitePoset(c,{} p)} constructs a finite poset where the set and structure is supplied. The structure is supplied as a predicate function.');
INSERT INTO olibdb VALUES('o','fintegrate',3,'n','(()->%,Var,Coef)->%','dSparseMultivariateTaylorSeries(Coef,Var,SMP)','has(Coef,Algebra(Fraction(Integer)))','\spad{fintegrate(f,{} v,{} c)} is the integral of \spad{f()} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.} \indented{1}{The evaluation of \spad{f()} is delayed.}');
INSERT INTO olibdb VALUES('o','fintegrate',3,'x','(()->%,Symbol,Coef)->%','dTaylorSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{fintegrate(f,{} v,{} c)} is the integral of \spad{f()} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.} \indented{1}{The evaluation of \spad{f()} is delayed.}');
INSERT INTO olibdb VALUES('o','first',1,'n','(%)->A','dProduct(A,B)',NULL,'\spad{first(x)} selects first component of the product');
INSERT INTO olibdb VALUES('o','first',1,'n','(A)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',1,'n','(A)->S','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',1,'n','(A)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',1,'n','(%)->LyndonWord(VarSet)','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,'\spad{first([l1]*[l2]*...[ln])} returns the Lyndon word \spad{l1}.');
INSERT INTO olibdb VALUES('o','first',1,'n','(%)->S','dFreeMonoid(S)',NULL,'\spad{first(x)} returns the first letter of \spad{x}.');
INSERT INTO olibdb VALUES('o','first',1,'n','(S)->Entry','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',1,'n','(S)->Union(P,failed)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',1,'n','(%)->VarSet','dFreeMagma(VarSet)',NULL,'\spad{first(x)} returns the first entry of the tree \spad{x}.');
INSERT INTO olibdb VALUES('o','first',1,'x','(%)->Entry','cIndexedAggregate(Index,Entry)','has(Index,OrderedSet)','\spad{first(u)} returns the first element \spad{x} of \spad{u}. Note: for collections,{} \spad{first([x,{} y,{} ...,{} z]) = x}. Error: if \spad{u} is empty.');
INSERT INTO olibdb VALUES('o','first',1,'x','(%)->S','cUnaryRecursiveAggregate(S)',NULL,'\spad{first(u)} returns the first element of \spad{u} (equivalently,{} the value at the current node).');
INSERT INTO olibdb VALUES('o','first',1,'x','(%)->Union(P,failed)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{first(ts)} returns the polynomial of \spad{ts} with greatest main variable if \spad{ts} is not empty,{} otherwise returns \spad{failed}.');
INSERT INTO olibdb VALUES('o','first',2,'n','(A,NonNegativeInteger)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',2,'n','(A,NonNegativeInteger)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',2,'n','(A,NonNegativeInteger)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','first',2,'n','(%,NonNegativeInteger)->%','cSequenceCategory(R)',NULL,'\spad{first(x,{} n)} returns the sequence of the first \spad{n} entries');
INSERT INTO olibdb VALUES('o','first',2,'x','(%,NonNegativeInteger)->%','cLinearAggregate(S)',NULL,'\spad{first(u,{} n)} returns a copy of the first \spad{n} elements of \spad{u}. Error: if \spad{u} has less than \spad{n} elements.');
INSERT INTO olibdb VALUES('o','first',2,'x','(%,NonNegativeInteger)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{first(u,{} n)} returns a copy of the first \spad{n} elements of \spad{u}.');
INSERT INTO olibdb VALUES('o','firstn',2,'n','(%,NonNegativeInteger)->List(R)','cSequenceCategory(R)',NULL,'\spad{firstn(x,{} n)} returns a list of the first \spad{n} entries');
INSERT INTO olibdb VALUES('o','firstSubsetGray',1,'n','(PositiveInteger)->Vector(Vector(Integer))','pGrayCode',NULL,'\spad{firstSubsetGray(n)} creates the first vector {\em ww} to start a loop using {\em nextSubsetGray(ww,{} n)}');
INSERT INTO olibdb VALUES('o','firstUncouplingMatrix',2,'n','(L,PositiveInteger)->Union(Matrix(R),failed)','pPrecomputedAssociatedEquations(R,L)',NULL,'\spad{firstUncouplingMatrix(op,{} m)} returns the matrix A such that \spad{A w = (W'',{} W'''',{} ...,{} W^N)} in the corresponding associated equations for right-factors of order \spad{m} of \spad{op}. Returns failed if the matrix A has not been precomputed for the particular combination \spad{degree(L),{} m}.');
INSERT INTO olibdb VALUES('o','fixedDivisor',1,'n','(SparseUnivariatePolynomial(Integer))->Integer','pPolynomialNumberTheoryFunctions',NULL,'\spad{fixedDivisor(a)} for \spad{a(x)} in \spad{Z[x]} is the largest integer \spad{f} such that \spad{f} divides \spad{a(x=k)} for all integers \spad{k}. Note: fixed divisor of \spad{a} is \spad{reduce(gcd,{} [a(x=k) for k in 0..degree(a)])}.');
INSERT INTO olibdb VALUES('o','fixed_mr',3,'n','(Record(mantissa:Integer,exponent:Integer),Integer,Record(default?:Boolean,trim_trailing_zeros?:Boolean,out_mode:String,spacing:Integer,separator:Character))->String','pFloatingPointConvertion',NULL,NULL);
INSERT INTO olibdb VALUES('o','fixedPointExquo',2,'n','(UTS,UTS)->UTS','pUnivariateTaylorSeriesODESolver(Coef,UTS)',NULL,'\spad{fixedPointExquo(f,{} g)} computes the exact quotient of \spad{f} and \spad{g} using a fixed point computation.');
INSERT INTO olibdb VALUES('o','fixedPoints',1,'x','(%)->Set(S)','dPermutation(S)','has(S,Finite)','\spad{fixedPoints(p)} returns the points fixed by the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','fixPredicate',1,'n','((B)->Boolean)->(A)->Boolean','pPatternMatchPushDown(S,A,B)',NULL,'\spad{fixPredicate(f)} returns \spad{g} defined by \spad{g}(a) = \spad{f}(a::B).');
INSERT INTO olibdb VALUES('o','flagFactor',3,'x','(R,NonNegativeInteger,Union(nil,sqfr,irred,prime))->%','dFactored(R)',NULL,'\spad{flagFactor(base,{} exponent,{} flag)} creates a factored object with a single factor whose \spad{base} is asserted to be properly described by the information flag.');
INSERT INTO olibdb VALUES('o','flatten',1,'n','(%)->%','dInputForm',NULL,'\spad{flatten(s)} returns an input form corresponding to \spad{s} with all the nested operations flattened to triples using new local variables. If \spad{s} is a piece of code,{} this speeds up the compilation tremendously later on.');
INSERT INTO olibdb VALUES('o','flatten',1,'n','(DirectedGraph(A))->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','flatten',1,'n','(DirectedGraph(%))->%','cFiniteGraph(S)',NULL,'\spad{flatten(n)} takes a second order graph,{} that is a graph whose elements are themselves graphs and create a first order graph whose vertices are the vertices of the inner graphs.');
INSERT INTO olibdb VALUES('o','flexible?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{flexible?()} tests if \spad{2*associator(a,{} b,{} a) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','flexible?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{flexible?()} tests if \spad{2*associator(a,{} b,{} a) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','flexibleArray',1,'n','(List(S))->%','dIndexedFlexibleArray(S,mn)',NULL,'\spad{flexibleArray(l)} creates a flexible array from the list of elements \spad{l}');
INSERT INTO olibdb VALUES('o','flexibleArray',1,'x','(List(S))->%','dFlexibleArray(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','float?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{float?(s)} is \spad{true} if \spad{s} is an atom and belong to \spad{Flt}.');
INSERT INTO olibdb VALUES('o','float',1,'x','(%)->Flt','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{float(s)} returns \spad{s} as an element of \spad{Flt}; Error: if \spad{s} is not an atom that also belongs to \spad{Flt}.');
INSERT INTO olibdb VALUES('o','float',2,'n','(Integer,Integer)->S','xFloatingPointSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','float',2,'x','(Integer,Integer)->%','cFloatingPointSystem',NULL,'\spad{float(a,{} e)} returns \spad{a * base() ^ e}.');
INSERT INTO olibdb VALUES('o','float',3,'n','(Integer,Integer,PositiveInteger)->S','xFloatingPointSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','float',3,'x','(Integer,Integer,PositiveInteger)->%','cFloatingPointSystem',NULL,'\spad{float(a,{} e,{} b)} returns \spad{a * b ^ e}.');
INSERT INTO olibdb VALUES('o','floating_mr',3,'n','(Record(mantissa:Integer,exponent:Integer),Integer,Record(default?:Boolean,trim_trailing_zeros?:Boolean,out_mode:String,spacing:Integer,separator:Character))->String','pFloatingPointConvertion',NULL,NULL);
INSERT INTO olibdb VALUES('o','floor',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{floor(x)} returns the largest integer below or equal \spad{x}.');
INSERT INTO olibdb VALUES('o','floor',1,'n','(S)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','floor',1,'x','(%)->%','cRealNumberSystem',NULL,'\spad{floor x} returns the largest integer \spad{<= x}.');
INSERT INTO olibdb VALUES('o','floor',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{floor(x)} returns the largest integer below or equal \spad{x}.');
INSERT INTO olibdb VALUES('o','floor',1,'x','(%)->S','cQuotientFieldCategory(S)','has(S,IntegerNumberSystem)','\spad{floor(x)} returns the largest integral element below \spad{x}.');
INSERT INTO olibdb VALUES('o','flush',1,'n','(%)->Void','dBasicFile',NULL,'\spad{flush passes} all buffered data to the operating system.');
INSERT INTO olibdb VALUES('o','flush',1,'x','(%)->Void','cFileCategory(Name,S)',NULL,'\spad{flush(f)} make sure that buffered data in written out to the operating system.');
INSERT INTO olibdb VALUES('o','fmecg',4,'n','(S,E,R,S)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fmecg',4,'x','(%,E,R,%)->%','cFiniteAbelianMonoidRing(R,E)','has(R,Ring)','\spad{fmecg(p1,{} e,{} r,{} p2)} returns \spad{p1 - monomial(r,{} e) * p2}.');
INSERT INTO olibdb VALUES('o','forLoop',2,'n','(SegmentBinding(Polynomial(Integer)),%)->%','dFortranCode',NULL,'\spad{forLoop(i=1..10,{} c)} creates a representation of a FORTRAN DO loop with \spad{i} ranging over the values 1 to 10.');
INSERT INTO olibdb VALUES('o','forLoop',3,'n','(SegmentBinding(Polynomial(Integer)),Polynomial(Integer),%)->%','dFortranCode',NULL,'\spad{forLoop(i=1..10,{} n,{} c)} creates a representation of a FORTRAN DO loop with \spad{i} ranging over the values 1 to 10 by \spad{n}.');
INSERT INTO olibdb VALUES('o','formalDiff2',3,'n','(List(%),PositiveInteger,SparseEchelonMatrix(JB,%))->Record(DSys:List(%),JVars:List(List(JB)))','cJetBundleFunctionCategory(JB)',NULL,'\spad{formalDiff2(sys,{} i,{} jm)} is like the other \spadfun{\spad{formalDiff2}} but for systems.');
INSERT INTO olibdb VALUES('o','formalDiff2',3,'n','(List(S),PositiveInteger,SparseEchelonMatrix(JB,S))->Record(DSys:List(S),JVars:List(List(JB)))','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','formalDiff2',3,'n','(%,PositiveInteger,SparseEchelonMatrix(JB,%))->Record(DPhi:%,JVars:List(JB))','cJetBundleFunctionCategory(JB)',NULL,'\spad{formalDiff2(f,{} i,{} jm)} formally differentiates the function \spad{f} with the Jacobi matrix \spad{jm} \spad{wrt} the \spad{i}\spad{-}th independent variable. \spad{JVars} is a list of the jet variables effectively in the result \spad{DPhi} (might be too large).');
INSERT INTO olibdb VALUES('o','formalDiff2',3,'n','(S,PositiveInteger,SparseEchelonMatrix(JB,S))->Record(DPhi:S,JVars:List(JB))','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(%,List(NonNegativeInteger))->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{formalDiff(f,{} mu)} formally differentiates \spad{f} as indicated by the multi-index \spad{mu}.');
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(List(%),PositiveInteger)->List(%)','cJetBundleFunctionCategory(JB)',NULL,'\spad{formalDiff(sys,{} i)} formally differentiates a family \spad{sys} of functions \spad{wrt} the \spad{i}\spad{-}th independent variable.');
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(List(S),PositiveInteger)->List(S)','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(%,PositiveInteger)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{formalDiff(f,{} i)} formally (totally) differentiates \spad{f} \spad{wrt} the \spad{i}\spad{-}th independent variable.');
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(S,List(NonNegativeInteger))->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','formalDiff',2,'n','(S,PositiveInteger)->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','format',1,'n','(%)->OutputBox','dFormatter(F)',NULL,'\spad{format(t)} extracts the \spad{fmt} section of a 2D-form \spad{t}.');
INSERT INTO olibdb VALUES('o','format',1,'n','(OutputForm)->%','dFormatter(F)',NULL,'\spad{format(o)} creates a formatted form of the \spad{OutputForm} \spad{o}.');
INSERT INTO olibdb VALUES('o','FormatArabic',1,'n','(PositiveInteger)->String','pNumberFormats',NULL,'\spad{FormatArabic(n)} forms an Arabic numeral string from an integer \spad{n}.');
INSERT INTO olibdb VALUES('o','formatConstant',1,'n','(String)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{formatConstant(op)} is a handler to format constant operators.');
INSERT INTO olibdb VALUES('o','formatConstant',1,'n','(String)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatConstant(op)} is a handler to format constant operators.');
INSERT INTO olibdb VALUES('o','formatExpression',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{formatExpression(p)} returns a handler \spad{h} that \spad{h(prec,{} args)} returns \spad{formatExpression(first args,{} p)}. This handler is used to change the precedence context in which the argument is formatted.');
INSERT INTO olibdb VALUES('o','formatExpression',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatExpression(p)} returns a handler \spad{h} that \spad{h(prec,{} args)} returns \spad{formatExpression(first args,{} p)}. This handler is used to change the precedence context in which the argument is formatted.');
INSERT INTO olibdb VALUES('o','formatExpression',1,'n','(OutputForm)->OutputBox','cFormatterCategory',NULL,'\spad{formatExpression(o)} returns \spad{formatExpression(o,{} minPrecedence())}.');
INSERT INTO olibdb VALUES('o','formatExpression',1,'n','(OutputForm)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatExpression(o)} returns \spad{formatExpression(o,{} minPrecedence())}.');
INSERT INTO olibdb VALUES('o','formatExpression',2,'n','(OutputForm,Integer)->OutputBox','cFormatterCategory',NULL,'\spad{formatExpression(o,{} p)} returns an \spadtype{OutputBox} that represent the expression \spad{o} in the respective format when considered in a context with outer precedence \spad{p}. This function is the main dispatcher function. It first checks whether \spad{o} is an integer or a string and treats these cases. Then,{} if the number \spad{n} of arguments is less than 3,{} it tries to find a handler for the top-level operator of \spad{o}. If none is found,{} it checks for a handler of an \spad{n}-ary operator. If no handler is found,{} the operator is treated as a function symbol and formatted as such.');
INSERT INTO olibdb VALUES('o','formatExpression',2,'n','(OutputForm,Integer)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatExpression(o,{} p)} returns an \spadtype{OutputBox} that represent the expression \spad{o} in the respective format when considered in a context with outer precedence \spad{p}. This function is the main dispatcher function. It first checks whether \spad{o} is an integer or a string and treats these cases. Then,{} if the number \spad{n} of arguments is less than 3,{} it tries to find a handler for the top-level operator of \spad{o}. If none is found,{} it checks for a handler of an \spad{n}-ary operator. If no handler is found,{} the operator is treated as a function symbol and formatted as such.');
INSERT INTO olibdb VALUES('o','formatFloat',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{formatFloat(s)} formats a floating point number from it string representation in \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','formatFloat',1,'n','(String)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatFloat(s)} formats a floating point number from it string representation in \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','formatFunction',2,'n','(OutputBox,List(OutputBox))->OutputBox','cFormatterCategory',NULL,'\spad{formatFunction(b,{} args)} is supposed to create a box for \spad{b}(args),{} \spadignore{i.e.} format the list of arguments given by args an put it into a format that represents a function application.');
INSERT INTO olibdb VALUES('o','formatFunction',2,'n','(OutputBox,List(OutputBox))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatFunction(b,{} args)} is supposed to create a box for \spad{b}(args),{} \spadignore{i.e.} format the list of arguments given by args an put it into a format that represents a function application.');
INSERT INTO olibdb VALUES('o','formatFunctionSymbol',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{formatFunctionSymbol(s)} formats an otherwise unknown function symbol.');
INSERT INTO olibdb VALUES('o','formatFunctionSymbol',1,'n','(String)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatFunctionSymbol(s)} formats an otherwise unknown function symbol.');
INSERT INTO olibdb VALUES('o','formatInteger',1,'n','(Integer)->OutputBox','cFormatterCategory',NULL,'\spad{formatInteger(n)} formats an integer.');
INSERT INTO olibdb VALUES('o','formatInteger',1,'n','(Integer)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatInteger(n)} formats an integer.');
INSERT INTO olibdb VALUES('o','FormatRadix',2,'n','(Integer,Integer)->String','pNumberFormats',NULL,'\spad{FormatRadix(n,{} r)} forms a string from an integer \spad{n} in radix \spad{r}.');
INSERT INTO olibdb VALUES('o','FormatRoman',1,'n','(PositiveInteger)->String','pNumberFormats',NULL,'\spad{FormatRoman(n)} forms a Roman numeral string from an integer \spad{n}.');
INSERT INTO olibdb VALUES('o','formatStep',2,'n','(OutputForm,Integer)->%','dFormatter(F)',NULL,'\spad{format(o,{} n)} creates a formatted form of the \spad{OutputForm} \spad{o} with step number \spad{n}.');
INSERT INTO olibdb VALUES('o','formatString',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{formatString(s)} formats a string.');
INSERT INTO olibdb VALUES('o','formatString',1,'n','(String)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatString(s)} formats a string.');
INSERT INTO olibdb VALUES('o','formatSymbol',1,'n','(String)->OutputBox','cFormatterCategory',NULL,'\spad{formatSymbol(s)} formats a symbol.');
INSERT INTO olibdb VALUES('o','formatSymbol',1,'n','(String)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{formatSymbol(s)} formats a symbol.');
INSERT INTO olibdb VALUES('o','fort_clean_lines',1,'n','(List(String))->List(String)','pFortranCodeTools',NULL,NULL);
INSERT INTO olibdb VALUES('o','fortFormatHead',3,'n','(Symbol,Union(fst:FortranScalarType,void:void),List(Symbol))->Void','pFortranCodeTools',NULL,'\spad{fortFormatHead(name,{} returnType,{} args)}');
INSERT INTO olibdb VALUES('o','fortFormatTypeLines',2,'n','(String,List(String))->Void','pFortranCodeTools',NULL,'\spad{fortFormatTypeLines(typeName,{} l)}');
INSERT INTO olibdb VALUES('o','fort_format_types',2,'n','(String,List(OutputForm))->Void','pFortranCodeTools',NULL,'\spad{fort_format_types(typeName,{} names)}');
INSERT INTO olibdb VALUES('o','fortran',3,'n','(Symbol,FortranScalarType,FS)->%','dSimpleFortranProgram(R,FS)',NULL,'\spad{fortran(fname,{} ftype,{} body)} builds an object of type \spadtype{FortranProgramCategory}. The three arguments specify the name,{} the type and the body of the program.');
INSERT INTO olibdb VALUES('o','fortranCarriageReturn',0,'n','()->Void','dFortranTemplate',NULL,'\spad{fortranCarriageReturn()} produces a carriage return on the current Fortran output stream');
INSERT INTO olibdb VALUES('o','fortranCharacter',0,'n','()->%','dFortranType',NULL,'\spad{fortranCharacter()} returns CHARACTER,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranComplex',0,'n','()->%','dFortranType',NULL,'\spad{fortranComplex()} returns COMPLEX,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranDouble',0,'n','()->%','dFortranType',NULL,'\spad{fortranDouble()} returns DOUBLE PRECISION,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranDoubleComplex',0,'n','()->%','dFortranType',NULL,'\spad{fortranDoubleComplex()} returns DOUBLE COMPLEX,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranInteger',0,'n','()->%','dFortranType',NULL,'\spad{fortranInteger()} returns INTEGER,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranLiteral',1,'n','(String)->Void','dFortranTemplate',NULL,'\spad{fortranLiteral(s)} writes \spad{s} to the current Fortran output stream');
INSERT INTO olibdb VALUES('o','fortranLiteralLine',1,'n','(String)->Void','dFortranTemplate',NULL,'\spad{fortranLiteralLine(s)} writes \spad{s} to the current Fortran output stream,{} followed by a carriage return');
INSERT INTO olibdb VALUES('o','fortranLogical',0,'n','()->%','dFortranType',NULL,'\spad{fortranLogical()} returns LOGICAL,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranReal',0,'n','()->%','dFortranType',NULL,'\spad{fortranReal()} returns REAL,{} an element of FortranType');
INSERT INTO olibdb VALUES('o','fortranTypeOf',2,'n','(Symbol,%)->FortranType','dSymbolTable',NULL,'\spad{fortranTypeOf(u,{} tab)} returns the type of \spad{u} in tab');
INSERT INTO olibdb VALUES('o','fprindINFO',7,'n','(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol),Dpol,Dpol,Integer,Integer,Integer,Integer)->Integer','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{fprindINFO }\undocumented');
INSERT INTO olibdb VALUES('o','fracPart',1,'x','(%)->List(Record(exponent:NonNegativeInteger,center:UP,num:UP))','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{fracPart(f)} returns the list of summands of the fractional part of \spad{f}.');
INSERT INTO olibdb VALUES('o','fraction',3,'n','(Integer,(Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'Format a fraction. \spad{fraction(p,{} h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument by \spad{h1} and the second argument by \spad{h2}. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','fractionalTerms',1,'x','(%)->List(Record(num:R,d_fact:R,d_exp:NonNegativeInteger))','dPartialFraction(R)',NULL,'\spad{fractionalTerms(p)} extracts the fractional part of \spad{p} to a list of Record(num : \spad{R},{} den : Factored \spad{R}). This returns [] if there is no fractional part.');
INSERT INTO olibdb VALUES('o','fractionFreeGauss!',1,'x','(M)->M','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,IntegralDomain)','\spad{fractionFreeGauss(m)} performs the fraction free gaussian elimination on the matrix \spad{m},{} also known as Bareiss algorithm.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'n','(A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fractionPart',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{fractionPart(x)} returns the fractional part of \spad{x}.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'n','(S)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->%','cQuotientFieldCategory(S)','has(S,EuclideanDomain)','\spad{fractionPart(x)} returns the fractional part of \spad{x}. \spad{x} = wholePart(\spad{x}) + fractionPart(\spad{x})');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->%','cRealNumberSystem',NULL,'\spad{fractionPart x} returns the fractional part of \spad{x}.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{fractionPart(x)} returns the fractional part of \spad{x}. Note: fractionPart(\spad{x}) = \spad{x} - floor(\spad{x}).');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->Fraction(Integer)','dBinaryExpansion',NULL,'\spad{fractionPart(b)} returns the fractional part of a binary expansion.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->Fraction(Integer)','dDecimalExpansion',NULL,'\spad{fractionPart(d)} returns the fractional part of a decimal expansion.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->Fraction(Integer)','dHexadecimalExpansion',NULL,'\spad{fractionPart(h)} returns the fractional part of a hexadecimal expansion.');
INSERT INTO olibdb VALUES('o','fractionPart',1,'x','(%)->Fraction(Integer)','dRadixExpansion(bb)',NULL,'\spad{fractionPart(rx)} returns the fractional part of a radix expansion.');
INSERT INTO olibdb VALUES('o','fractRadix',2,'x','(List(Integer),List(Integer))->%','dRadixExpansion(bb)',NULL,'\spad{fractRadix(pre,{} cyc)} creates a fractional radix expansion from a list of prefix ragits and a list of cyclic ragits. For example,{} \spad{fractRadix([1],{} [6])} will return \spad{0.16666666...}.');
INSERT INTO olibdb VALUES('o','fractRagits',1,'x','(%)->Stream(Integer)','dRadixExpansion(bb)',NULL,'\spad{fractRagits(rx)} returns the ragits of the fractional part of a radix expansion.');
INSERT INTO olibdb VALUES('o','free?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'if this is a lambda term then is it free,{} that is does its variable appear in its expression');
INSERT INTO olibdb VALUES('o','freeConvolution',2,'n','(%,%)->%','cDistributionCategory(R)',NULL,'\spad{freeConvolution(x,{} y)} returns the free convolution of the distributions \spad{x} and \spad{y}');
INSERT INTO olibdb VALUES('o','freeCumulant2moment',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{freeCumulant2moment(cc)} computes the sequence of moments from the sequence of free cumulants \spad{cc}');
INSERT INTO olibdb VALUES('o','freeCumulant',2,'n','(%,PositiveInteger)->R','cDistributionCategory(R)',NULL,'\spad{freeCumulant(x,{} n)} returns the \spad{n}-th free cumulant of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','freeCumulants',1,'n','(%)->Sequence(R)','cDistributionCategory(R)',NULL,'\spad{freeCumulants(x)} returns the sequence of free cumulants of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','freeMultiplicativeConvolution',2,'x','(%,%)->%','dDistribution(R)','has(R,Algebra(Fraction(Integer)))','\spad{freeMultiplicativeConvolution(mu,{} nu)} computes the free multiplicative convolution of the distributions \spad{mu} and \spad{nu}.');
INSERT INTO olibdb VALUES('o','freeOf?',2,'n','(%,JB)->Boolean','cJetBundleFunctionCategory(JB)',NULL,'\spad{freeOf?(fun,{} jv)} checks whether \spad{fun} contains the jet variable \spad{jv}.');
INSERT INTO olibdb VALUES('o','freeOf?',2,'n','(S,JB)->Boolean','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','freeOf?',2,'n','(S,S)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','freeOf?',2,'n','(S,Symbol)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','freeOf?',2,'x','(%,%)->Boolean','cExpressionSpace2(K)',NULL,'\spad{freeOf?(x,{} y)} tests if \spad{x} does not contain any occurrence of \spad{y},{} where \spad{y} is a single kernel.');
INSERT INTO olibdb VALUES('o','freeOf?',2,'x','(%,Symbol)->Boolean','cExpressionSpace2(K)',NULL,'\spad{freeOf?(x,{} s)} tests if \spad{x} does not contain any operator whose name is \spad{s}.');
INSERT INTO olibdb VALUES('o','freePoissonDistribution',1,'x','(R)->Distribution(R)','pDistributionPackage(R)',NULL,'\spad{freePoissonDistribution(a)} produces a free Poisson distribution of variance \spad{a}.');
INSERT INTO olibdb VALUES('o','freeVariable?',2,'n','(%,UT)->Boolean','dSKICombinators(UT)',NULL,'the variable indicated by \spad{''s''} is free if it does not appear in node \spad{''n''} or any of its subnodes.');
INSERT INTO olibdb VALUES('o','fresnelC',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{fresnelC(f)} denotes the Fresnel integral \spad{C}');
INSERT INTO olibdb VALUES('o','fresnelC',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{fresnelC(x)} is the Fresnel integral \spad{C},{} defined by \spad{C(x) = integrate(cos(\%pi*t^2/2),{} t=0..x)}');
INSERT INTO olibdb VALUES('o','fresnelC',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{fresnelC(f)} denotes the Fresnel integral \spad{C}');
INSERT INTO olibdb VALUES('o','fresnelC',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','fresnelC',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{fresnelC(f)} denotes the Fresnel integral \spad{C}');
INSERT INTO olibdb VALUES('o','fresnelS',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{fresnelS(f)} denotes the Fresnel integral \spad{S}');
INSERT INTO olibdb VALUES('o','fresnelS',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{fresnelS(x)} is the Fresnel integral \spad{S},{} defined by \spad{S(x) = integrate(sin(\%pi*t^2/2),{} t=0..x)}');
INSERT INTO olibdb VALUES('o','fresnelS',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{fresnelS(f)} denotes the Fresnel integral \spad{S}');
INSERT INTO olibdb VALUES('o','fresnelS',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','fresnelS',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{fresnelS(f)} denotes the Fresnel integral \spad{S}');
INSERT INTO olibdb VALUES('o','frobenius',1,'n','(%)->%','dModMonic(R,Rep)','has(R,FiniteFieldCategory)','\spad{frobenius(x)} computes \spad{x^q} where \spad{q} is the size of \spad{R}.');
INSERT INTO olibdb VALUES('o','Frobenius',1,'n','(ExtP)->ExtP','pNormRetractPackage(F,ExtF,SUEx,ExtP,n)',NULL,'\spad{Frobenius(x)} \undocumented');
INSERT INTO olibdb VALUES('o','Frobenius',1,'n','(S)->S','xExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','Frobenius',1,'x','(%)->%','cExtensionField(F)','has(F,Finite)','\spad{Frobenius(a)} returns \spad{a ^ q} where \spad{q} is the \spad{size()\$F}.');
INSERT INTO olibdb VALUES('o','Frobenius',2,'n','(S,NonNegativeInteger)->S','xExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','Frobenius',2,'x','(%,NonNegativeInteger)->%','cExtensionField(F)','has(F,Finite)','\spad{Frobenius(a,{} s)} returns \spad{a^(q^s)} where \spad{q} is the size()\$\spad{F}.');
INSERT INTO olibdb VALUES('o','front',1,'x','(%)->S','cQueueAggregate(S)',NULL,'\spad{front(q)} returns the element at the front of the queue. The queue \spad{q} is unchanged by this operation. Error: if \spad{q} is empty.');
INSERT INTO olibdb VALUES('o','froot',2,'n','(F,NonNegativeInteger)->Record(exponent:NonNegativeInteger,coef:F,radicand:F)','pPolynomialRoots(E,V,R,P,F)','has(R,GcdDomain)','\spad{froot(f,{} n)} returns \spad{[m,{} c,{} r]} such that \spad{f^(1/n) = c * r^(1/m)}.');
INSERT INTO olibdb VALUES('o','frst',1,'x','(%)->S','cLazyStreamAggregate(S)',NULL,'\spad{frst(s)} returns the first element of stream \spad{s}. Caution: this function should only be called after a \spad{empty?} test has been made since there is no error check.');
INSERT INTO olibdb VALUES('o','fsqrt',1,'n','(F)->F','pGenerateEllipticIntegrals(F,UP,UPUP,R)',NULL,'\spad{fsqrt(f)} should be local but conditional');
INSERT INTO olibdb VALUES('o','fullDisplay',1,'x','(%)->Void','dDatabase(S)',NULL,'\spad{fullDisplay(db)} prints full details of each entry in \spad{db}.');
INSERT INTO olibdb VALUES('o','fullDisplay',1,'x','(%)->Void','dIndexCard',NULL,'\spad{fullDisplay(ic)} prints all of the information contained in \spad{ic}.');
INSERT INTO olibdb VALUES('o','fullDisplay',3,'x','(%,PositiveInteger,PositiveInteger)->Void','dDatabase(S)',NULL,'\spad{fullDisplay(db,{} start,{} end )} prints full details of entries in the range \spad{start..end} in \spad{db}.');
INSERT INTO olibdb VALUES('o','fullPartialFraction',1,'x','(Fraction(UP))->%','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{fullPartialFraction(f)} returns \spad{[p,{} [[j,{} Dj,{} Hj]...]]} such that \spad{f = p(x) + \sum_{[j,{} Dj,{} Hj] in l} \sum_{Dj(a)=0} Hj(a)/(x - a)\^j}.');
INSERT INTO olibdb VALUES('o','function',2,'n','(Symbol,List(%))->%','dJetBundleXExpression(JB)',NULL,'\spad{function(f,{} arg)} generates a function with name \spad{f} and arguments \spad{arg}.');
INSERT INTO olibdb VALUES('o','function',2,'x','(S,Symbol)->Symbol','pMakeFunction(S)',NULL,'\spad{function(e,{} foo)} creates a function \spad{foo() == e}.');
INSERT INTO olibdb VALUES('o','function',3,'n','(%,List(Symbol),Symbol)->%','dInputForm',NULL,'\spad{function(code,{} [x1,{} ...,{} xn],{} f)} returns the input form corresponding to \spad{f(x1,{} ...,{} xn) == code}.');
INSERT INTO olibdb VALUES('o','function',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{function(s,{} p,{} hh)} is meant to typeset function applications. It defaults to prefix(\spad{s},{}\spad{p},{}bracket((,{}),{}\spad{hh})).');
INSERT INTO olibdb VALUES('o','function',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{function(s,{} p,{} hh)} is meant to typeset function applications. It defaults to prefix(\spad{s},{}\spad{p},{}bracket((,{}),{}\spad{hh})).');
INSERT INTO olibdb VALUES('o','function',3,'n','(Symbol,List(%),NonNegativeInteger)->%','dJetBundleExpression(JB)',NULL,'\spad{function(f,{} arg,{} show)} generates a function with name \spad{f} and arguments \spad{arg}. In the output only the first \spad{show} arguments are shown.');
INSERT INTO olibdb VALUES('o','function',3,'x','(S,Symbol,List(Symbol))->Symbol','pMakeFunction(S)',NULL,'\spad{function(e,{} foo,{} [x1,{} ...,{} xn])} creates a function \spad{foo(x1,{} ...,{} xn) == e}.');
INSERT INTO olibdb VALUES('o','function',3,'x','(S,Symbol,Symbol)->Symbol','pMakeFunction(S)',NULL,'\spad{function(e,{} foo,{} x)} creates a function \spad{foo(x) == e}.');
INSERT INTO olibdb VALUES('o','function',4,'x','(S,Symbol,Symbol,Symbol)->Symbol','pMakeFunction(S)',NULL,'\spad{function(e,{} foo,{} x,{} y)} creates a function \spad{foo(x,{} y) = e}.');
INSERT INTO olibdb VALUES('o','functionGraph',1,'n','(List(Permutation(S)))->%','dFunctionGraph(S)',NULL,'construct graph from a list of permutations.');
INSERT INTO olibdb VALUES('o','functionGraph',1,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,next:NonNegativeInteger,map:List(NonNegativeInteger))))->%','dFunctionGraph(S)',NULL,'constructor for graph with given objects more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','functionGraph',1,'n','(List(S))->%','dFunctionGraph(S)',NULL,'constructor for graph with given list of object names. Use this version of the constructor if you don\spad{''t} intend to create diagrams and therefore don\spad{''t} care about \spad{x},{} \spad{y} coordinates. more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','functionGraph',2,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->%','dFunctionGraph(S)',NULL,'constructor for graph with given objects and arrows more objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','functionName',1,'n','(List(GuessOption))->Symbol','dGuessOptionFunctions0',NULL,'\spad{functionName returns} the name of the function given by the algebraic differential equation,{} default being \spad{f}');
INSERT INTO olibdb VALUES('o','functionName',1,'x','(Symbol)->%','dGuessOption',NULL,'\spad{functionName(d)} specifies the name of the function given by the algebraic differential equation or recurrence. This option is expressed in the form \spad{functionName == d}.');
INSERT INTO olibdb VALUES('o','functionNames',1,'n','(List(GuessOption))->List(Symbol)','dGuessOptionFunctions0',NULL,'\spad{functionNames returns} the names for the function in the algebraic dependence,{} default being \%\spad{f1},{} \%\spad{f2},{} ...');
INSERT INTO olibdb VALUES('o','functionNames',1,'x','(List(Symbol))->%','dGuessOption',NULL,'\spad{functionNames(d)} specifies the names for the function in algebraic dependence. This option is expressed in the form \spad{functionNames == d}.');
INSERT INTO olibdb VALUES('o','fundamentalGroup',1,'n','(%)->GroupPresentation','dDeltaComplex(VS)',NULL,'Generates fundamental group from this simplicial complex.');
INSERT INTO olibdb VALUES('o','fundamentalGroup',1,'n','(%)->GroupPresentation','dFiniteCubicalComplex(VS)',NULL,'Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\spad{''t} want this use alternative function of same name. TODO write a faster implementation which only generates edge and square faceMaps.');
INSERT INTO olibdb VALUES('o','fundamentalGroup',1,'n','(%)->GroupPresentation','dFiniteSimplicialComplex(VS)',NULL,'Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This will attempt to simplify the group presentation,{} if you don\spad{''t} want this use alternative function of same name. For more information: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','fundamentalGroup',3,'n','(%,Boolean,Boolean)->GroupPresentation','dDeltaComplex(VS)',NULL,'Generates fundamental group from this simplicial complex.');
INSERT INTO olibdb VALUES('o','fundamentalGroup',3,'n','(%,Boolean,Boolean)->GroupPresentation','dFiniteCubicalComplex(VS)',NULL,'Generates fundamental group from this cubical complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. TODO write a faster implementation which only generates edge and square faceMaps. This version has options to: simplify - if \spad{true} attempts to simplify the group presentation trace - if \spad{true} outputs trace of simplification rules used.');
INSERT INTO olibdb VALUES('o','fundamentalGroup',3,'n','(%,Boolean,Boolean)->GroupPresentation','dFiniteSimplicialComplex(VS)',NULL,'Generates fundamental group from this simplicial complex. This works by converting to a DeltaComplex and then generating the fundamentalGroup from that. This is not the most efficient method because the conversion generates lots of higher order faceMaps which are not used. This version has options to: simplify - if \spad{true} attempts to simplify the group presentation trace - if \spad{true} outputs trace of simplification rules used. For more information: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homotopy/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','Gamma',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Gamma()} returns symbol for capital greek letter gamma.');
INSERT INTO olibdb VALUES('o','gamma',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{gamma()} returns symbol for small greek letter gamma.');
INSERT INTO olibdb VALUES('o','gamma',0,'x','()->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{gamma()} is the Euler constant');
INSERT INTO olibdb VALUES('o','Gamma',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{Gamma(f)} returns the formal Gamma function applied to \spad{f}.');
INSERT INTO olibdb VALUES('o','Gamma',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Gamma',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{Gamma(x)} is the Euler Gamma function.');
INSERT INTO olibdb VALUES('o','Gamma',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{Gamma(x)} is the Euler Gamma function.');
INSERT INTO olibdb VALUES('o','Gamma',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','Gamma',1,'x','(Float)->Float','pFloatSpecialFunctions',NULL,'\spad{Gamma(x)} is the Euler Gamma function.');
INSERT INTO olibdb VALUES('o','Gamma',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{Gamma(a,{} x)} returns the incomplete Gamma function applied to a and \spad{x}.');
INSERT INTO olibdb VALUES('o','Gamma',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{Gamma(a,{} x)} is the incomplete Gamma function.');
INSERT INTO olibdb VALUES('o','gauge',3,'n','(NonNegativeInteger,Integer,List(NonNegativeInteger))->List(Integer)','pCartanKuranishi(JB,D)',NULL,'\spad{gauge(q,{} j,{} gamma)} computes the gauge corrections to the number of arbitrary functions of differentiation order \spad{j} for a system of order \spad{q} with \spad{gamma} gauge functions.');
INSERT INTO olibdb VALUES('o','gaugeHilbert',2,'n','(NonNegativeInteger,List(NonNegativeInteger))->SparseUnivariatePolynomial(Fraction(Integer))','pCartanKuranishi(JB,D)',NULL,'\spad{gaugeHilbert(q,{} gamma)} computes the gauge correction to the Hilbert polynomial for a system of order \spad{q} with \spad{gamma} gauge functions.');
INSERT INTO olibdb VALUES('o','gaussianDistribution',1,'x','(R)->Distribution(R)','pDistributionPackage(R)',NULL,'\spad{gaussianDistribution(a)} produces a gaussian distribution of variance \spad{a}.');
INSERT INTO olibdb VALUES('o','gbasis',3,'n','(List(Dpol),Integer,Integer)->List(Dpol)','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{gbasis(pols,{} f1,{} f2)} computes a Groebner basis of \spad{pols}.');
INSERT INTO olibdb VALUES('o','gbasisExtend',4,'n','(List(Dpol),List(Dpol),Integer,Integer)->List(Dpol)','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{gbasisExtend(pols,{} gb,{} f1,{} f2)} computes a Groebner basis of concat(\spad{pols},{} \spad{gb}) where \spad{gb} is assumed to be already a Groebner basis,{} \spadignore{i.e.} no \spad{S}-polynomials among elements of \spad{gb} will ever be considered.');
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(BP))->BP','pHeuGcd(BP)',NULL,'\spad{gcd([f1,{} ..,{} fk])} = \spad{gcd} of the polynomials \spad{fi}.');
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(P))->P','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcd(lp)} computes the \spad{gcd} of the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(SparseUnivariatePolynomial(P)))->SparseUnivariatePolynomial(P)','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcd(lp)} computes the \spad{gcd} of the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(S))->S','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(S))->S','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(S))->S','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(S))->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',1,'n','(List(S))->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',1,'x','(List(%))->%','cGcdDomain',NULL,'\spad{gcd(l)} returns the common \spad{gcd} of the elements in the list \spad{l}.');
INSERT INTO olibdb VALUES('o','gcd',2,'n','(polR,polR)->polR','pPseudoRemainderSequence(R,polR)','has(R,GcdDomain)','\spad{gcd(P,{} Q)} returns the \spad{gcd} of \spad{P} and \spad{Q}.');
INSERT INTO olibdb VALUES('o','gcd',2,'n','(P,P)->P','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcd(p,{} q)} computes the \spad{gcd} of the two polynomials \spad{p} and \spad{q}.');
INSERT INTO olibdb VALUES('o','gcd',2,'n','(R,S)->R','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'n','(SparseUnivariatePolynomial(P),SparseUnivariatePolynomial(P))->SparseUnivariatePolynomial(P)','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcd(p,{} q)} computes the \spad{gcd} of the two polynomials \spad{p} and \spad{q}.');
INSERT INTO olibdb VALUES('o','gcd',2,'n','(S,S)->S','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'n','(S,S)->S','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'n','(S,S)->S','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'n','(S,S)->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcd',2,'x','(%,%)->%','cGcdDomain',NULL,'\spad{gcd(x,{} y)} returns the greatest common divisor of \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','gcd',2,'x','(%,%)->%','dNonNegativeInteger',NULL,'\spad{gcd(a,{} b)} computes the greatest common divisor of two non negative integers \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','gcd',2,'x','(%,%)->%','dPositiveInteger',NULL,'\spad{gcd(a,{} b)} computes the greatest common divisor of two positive integers \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','gcd',2,'x','(R,%)->R','cRecursivePolynomialCategory(R,E,V)','has(R,GcdDomain)','\spad{gcd(r,{} p)} returns the \spad{gcd} of \spad{r} and the content of \spad{p}.');
INSERT INTO olibdb VALUES('o','gcd',3,'n','(PA,PA,MD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{gcd(pol1,{} pol2,{} md)} computes \spad{gcd} of \spad{pol1} and \spad{pol2}.');
INSERT INTO olibdb VALUES('o','gcd',3,'n','(U32Vector,U32Vector,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'\spad{gcd(v1,{} v2,{} p)} computes monic \spad{gcd} of \spad{v1} and \spad{v2} modulo \spad{p}.');
INSERT INTO olibdb VALUES('o','gcd',4,'n','(PrimitiveArray(U32Vector),Integer,Integer,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'\spad{gcd(a,{} lo,{} \spad{hi},{} p)} computes \spad{gcd} of elements a(\spad{lo}),{} a(\spad{lo+1}),{} ...,{} a(\spad{hi}).');
INSERT INTO olibdb VALUES('o','gcdBasis',1,'n','(List(P))->List(P)','pCylindricalAlgebraicDecompositionUtilities(R,P)',NULL,'\spad{gcdBasis(lp)} computes \spad{gcd} basis of \spad{lp}');
INSERT INTO olibdb VALUES('o','gcdBasis',1,'n','(Vector(R))->Vector(R)','pGcdBasis(R)',NULL,'\spad{gcdBasis(v)} returns basis part of \spad{gcdDecomposition(v)}.');
INSERT INTO olibdb VALUES('o','gcdcofact',1,'n','(List(BP))->List(BP)','pHeuGcd(BP)',NULL,'\spad{gcdcofact([f1,{} ..fk])} = \spad{gcd} and cofactors of \spad{k} univariate polynomials.');
INSERT INTO olibdb VALUES('o','gcdcofactprim',1,'n','(List(BP))->List(BP)','pHeuGcd(BP)',NULL,'\spad{gcdcofactprim([f1,{} ..fk])} = \spad{gcd} and cofactors of \spad{k} primitive polynomials.');
INSERT INTO olibdb VALUES('o','gcdDecomposition',1,'n','(Vector(Fraction(R)))->Record(basis:Vector(R),transform:Matrix(Integer))','pGcdBasis(R)',NULL,'\spad{gcdDecomposition(v)} returns \spad{[b,{} t]} such that elements of \spad{b} are relatively prime and that \spad{v(i) = product(b(j)^(t(j,{} i)),{} j=1..n)}');
INSERT INTO olibdb VALUES('o','gcdDecomposition',1,'n','(Vector(R))->Record(basis:Vector(R),transform:Matrix(Integer))','pGcdBasis(R)',NULL,'\spad{gcdDecomposition(v)} returns \spad{[b,{} t]} such that elements of \spad{b} are relatively prime and that \spad{v(i) = product(b(j)^(t(j,{} i)),{} j=1..n)}');
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'n','(SparseUnivariatePolynomial(P),SparseUnivariatePolynomial(P))->SparseUnivariatePolynomial(P)','pGeneralPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcdPolynomial(p,{} q)} returns the \spad{GCD} of \spad{p} and \spad{q}');
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'n','(SparseUnivariatePolynomial(S),SparseUnivariatePolynomial(S))->SparseUnivariatePolynomial(S)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'n','(SparseUnivariatePolynomial(S),SparseUnivariatePolynomial(S))->SparseUnivariatePolynomial(S)','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'n','(SparseUnivariatePolynomial(S),SparseUnivariatePolynomial(S))->SparseUnivariatePolynomial(S)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'n','(SparseUnivariatePolynomial(S),SparseUnivariatePolynomial(S))->SparseUnivariatePolynomial(S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'x','(SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%))->SparseUnivariatePolynomial(%)','cGcdDomain',NULL,'\spad{gcdPolynomial(p,{} q)} returns the greatest common divisor (\spad{gcd}) of univariate polynomials over the domain');
INSERT INTO olibdb VALUES('o','gcdPolynomial',2,'x','(SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%))->SparseUnivariatePolynomial(%)','cPolynomialFactorizationExplicit',NULL,'\spad{gcdPolynomial(p,{} q)} returns the \spad{gcd} of the univariate polynomials \spad{p} \spad{qnd} \spad{q}.');
INSERT INTO olibdb VALUES('o','gcdprim',1,'n','(List(BP))->BP','pHeuGcd(BP)',NULL,'\spad{gcdprim([f1,{} ..,{} fk])} = \spad{gcd} of \spad{k} PRIMITIVE univariate polynomials');
INSERT INTO olibdb VALUES('o','gcdPrimitive',1,'n','(List(P))->P','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcdPrimitive lp} computes the \spad{gcd} of the list of primitive polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','gcdPrimitive',2,'n','(P,P)->P','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcdPrimitive(p,{} q)} computes the \spad{gcd} of the primitive polynomials \spad{p} and \spad{q}.');
INSERT INTO olibdb VALUES('o','gcdPrimitive',2,'n','(SparseUnivariatePolynomial(P),SparseUnivariatePolynomial(P))->SparseUnivariatePolynomial(P)','pPolynomialGcdPackage(E,OV,R,P)',NULL,'\spad{gcdPrimitive(p,{} q)} computes the \spad{gcd} of the primitive polynomials \spad{p} and \spad{q}.');
INSERT INTO olibdb VALUES('o','gderiv',2,'n','((Integer)->A,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{gderiv(f,{} [a0,{} a1,{} a2,{} ..])} returns \spad{[f(0)*a0,{} f(1)*a1,{} f(2)*a2,{} ..]}.');
INSERT INTO olibdb VALUES('o','GE',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{GE(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x>=y}.');
INSERT INTO olibdb VALUES('o','ge_minimal',3,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UnivariatePolynomial(var,Expression(Integer)))),(SparseUnivariatePolynomial(Expression(Integer)))->Factored(SparseUnivariatePolynomial(Expression(Integer))),String)->List(Record(singularity:Record(point:Union(Expression(Integer),infinity),lpf:LinearOrdinaryDifferentialOperator3(Expression(Integer),UnivariateTaylorSeries(Expression(Integer),var,cen),UnivariateLaurentSeries(Expression(Integer),var,cen)),dxt:PositiveInteger),fos:List(Record(op:LinearOrdinaryDifferentialOperator3(Expression(Integer),UnivariateTaylorSeries(Expression(Integer),var,cen),UnivariateLaurentSeries(Expression(Integer),var,cen)),ram:UnivariatePolynomial(var,Expression(Integer)),expart:UnivariateLaurentSeries(Expression(Integer),var,cen))),mge:List(UnivariateLaurentSeries(Expression(Integer),var,cen))))','pLinearOrdinaryDifferentialOperatorFactorizer2(var,cen)',NULL,'to be documented later.');
INSERT INTO olibdb VALUES('o','gen_ef',4,'n','(F,UP,R,R)->Union(Record(result1:Fraction(UP),result2:F),failed)','pGenerateEllipticIntegrals(F,UP,UPUP,R)',NULL,'\spad{gen_ef(f_var,{} f_pol,{} cfr,{} cer)} produces linear combination');
INSERT INTO olibdb VALUES('o','generalCoefficient',4,'n','((NonNegativeInteger,NonNegativeInteger,V)->D,Vector(V),NonNegativeInteger,Vector(SparseUnivariatePolynomial(D)))->D','pFractionFreeFastGaussian(D,V)',NULL,'\spad{generalCoefficient(action,{} f,{} k,{} p)} gives the coefficient of \spad{x^k} in \spad{p}(\spad{z})\dot \spad{f}(\spad{x}),{} where the \spad{action} of \spad{z^l} on a polynomial in \spad{x} is given by \spad{action},{} \spadignore{i.e.} \spad{action}(\spad{k},{} \spad{l},{} \spad{f}) should return the coefficient of \spad{x^k} in \spad{z^l} \spad{f}(\spad{x}).');
INSERT INTO olibdb VALUES('o','generalInfiniteProduct',3,'x','(UTS,Integer,Integer)->UTS','pInfiniteLambertProduct(Coef,UTS)',NULL,'\spad{generalInfiniteProduct(f(x),{} a,{} d)} computes \spad{product(n=a,{} a+d,{} a+2*d,{} ...,{} f(x^n))}. The series \spad{f(x)} should have constant coefficient 1.');
INSERT INTO olibdb VALUES('o','generalInterpolation',4,'n','(List(D),(NonNegativeInteger,NonNegativeInteger,V)->D,Vector(VF),List(NonNegativeInteger))->Matrix(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussianFractions(D,V,VF)',NULL,'\spad{generalInterpolation(l,{} CA,{} f,{} eta)} performs Hermite-Pade approximation using the given action \spad{CA} of polynomials on the elements of \spad{f}. The result is guaranteed to be correct up to order |eta|-1. Given that eta is a normal point,{} the degrees on the diagonal are given by eta. The degrees of column \spad{i} are in this case eta + \spad{e}.\spad{i} - [1,{} 1,{} ...,{} 1],{} where the degree of zero is \spad{-1}.');
INSERT INTO olibdb VALUES('o','generalInterpolation',4,'n','(List(D),(NonNegativeInteger,NonNegativeInteger,V)->D,Vector(V),List(NonNegativeInteger))->Matrix(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{generalInterpolation(C,{} CA,{} f,{} eta)} performs Hermite-Pade approximation using the given action \spad{CA} of polynomials on the elements of \spad{f}. The result is guaranteed to be correct up to order |eta|-1. Given that eta is a normal point,{} the degrees on the diagonal are given by eta. The degrees of column \spad{i} are in this case eta + \spad{e}.\spad{i} - [1,{} 1,{} ...,{} 1],{} where the degree of zero is \spad{-1}. \blankline The first argument \spad{C} is the list of coefficients \spad{c_}{\spad{k},{} \spad{k}} in the expansion <x^k> \spad{z} \spad{g}(\spad{x}) = sum_{\spad{i=0}}\spad{^k} \spad{c_}{\spad{k},{} \spad{i}} <x^i> \spad{g}(\spad{x}). \blankline The second argument,{} \spad{CA}(\spad{k},{} \spad{l},{} \spad{f}),{} should return the coefficient of \spad{x^k} in \spad{z^l} \spad{f}(\spad{x}).');
INSERT INTO olibdb VALUES('o','generalInterpolation',5,'n','(List(D),(NonNegativeInteger,NonNegativeInteger,V)->D,Vector(V),Vector(Integer),NonNegativeInteger)->Matrix(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{generalInterpolation(C,{} CA,{} f,{} vd,{} K)} is like \spad{generalInterpolation(C,{} CA,{} f,{} eta)} but solves up to order \spad{K} and modifies \spad{vd} to return defects of solutions');
INSERT INTO olibdb VALUES('o','generalizedContinuumHypothesisAssumed?',0,'x','()->Boolean','dCardinalNumber',NULL,'\spad{generalizedContinuumHypothesisAssumed?()} tests if the hypothesis is currently assumed.');
INSERT INTO olibdb VALUES('o','generalizedContinuumHypothesisAssumed',1,'x','(Boolean)->Boolean','dCardinalNumber',NULL,'\spad{generalizedContinuumHypothesisAssumed(bool)} is used to dictate whether the hypothesis is to be assumed.');
INSERT INTO olibdb VALUES('o','generalizedEigenvector',2,'n','(Record(eigval:Union(F,SparseUnivariatePolynomial(F)),eigmult:NonNegativeInteger,eigvec:List(Vector(SparseUnivariatePolynomial(F)))),Matrix(F))->List(Vector(SparseUnivariatePolynomial(F)))','pInnerEigenPackage(F)',NULL,'\spad{generalizedEigenvector(eigen,{} m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{eigen},{} as returned by the function eigenvectors.');
INSERT INTO olibdb VALUES('o','generalizedEigenvector',2,'x','(Record(eigval:Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))),eigmult:NonNegativeInteger,eigvec:List(Matrix(Fraction(Polynomial(R))))),Matrix(Fraction(Polynomial(R))))->List(Matrix(Fraction(Polynomial(R))))','pEigenPackage(R)',NULL,'\spad{generalizedEigenvector(eigen,{} m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{eigen},{} as returned by the function eigenvectors.');
INSERT INTO olibdb VALUES('o','generalizedEigenvector',4,'n','(Union(F,SparseUnivariatePolynomial(F)),Matrix(F),NonNegativeInteger,NonNegativeInteger)->List(Vector(SparseUnivariatePolynomial(F)))','pInnerEigenPackage(F)',NULL,'\spad{generalizedEigenvector(alpha,{} m,{} k,{} g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{alpha}. The integers \spad{k} and \spad{g} are respectively the algebraic and the geometric multiplicity of the eigenvalue \spad{alpha}.');
INSERT INTO olibdb VALUES('o','generalizedEigenvector',4,'x','(Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))),Matrix(Fraction(Polynomial(R))),NonNegativeInteger,NonNegativeInteger)->List(Matrix(Fraction(Polynomial(R))))','pEigenPackage(R)',NULL,'\spad{generalizedEigenvector(alpha,{} m,{} k,{} g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{alpha}. The integers \spad{k} and \spad{g} are respectively the algebraic and the geometric multiplicity of the eigenvalue \spad{alpha}.');
INSERT INTO olibdb VALUES('o','generalizedEigenvectors',1,'n','(Matrix(F))->List(Record(eigval:Union(F,SparseUnivariatePolynomial(F)),geneigvec:List(Vector(SparseUnivariatePolynomial(F)))))','pInnerEigenPackage(F)','has(F,PolynomialFactorizationExplicit)','\spad{generalizedEigenvectors(m)} returns the generalized eigenvectors of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','generalizedEigenvectors',1,'x','(Matrix(Fraction(Polynomial(R))))->List(Record(eigval:Union(Fraction(Polynomial(R)),SuchThat(Symbol,Polynomial(R))),geneigvec:List(Matrix(Fraction(Polynomial(R))))))','pEigenPackage(R)','has(R,PolynomialFactorizationExplicit)','\spad{generalizedEigenvectors(m)} returns the generalized returns the generalized eigenvectors of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','generalizedEigenvectors',2,'n','(Matrix(F),(SparseUnivariatePolynomial(F))->Factored(SparseUnivariatePolynomial(F)))->List(Record(eigval:Union(F,SparseUnivariatePolynomial(F)),geneigvec:List(Vector(SparseUnivariatePolynomial(F)))))','pInnerEigenPackage(F)',NULL,'\spad{generalizedEigenvectors(m,{} fac)} returns the generalized eigenvectors of the matrix \spad{m}. fac is a factorizer for polynomials over \spad{F}.');
INSERT INTO olibdb VALUES('o','generalizedInverse',1,'n','(M)->M','pInnerMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,Field)','\spad{generalizedInverse(m)} returns the generalized (Moore--Penrose) inverse of the matrix \spad{m},{} \spadignore{i.e.} the matrix \spad{h} such that m*h*m=h,{} h*m*h=m,{} \spad{m*h} and \spad{h*m} are both symmetric matrices.');
INSERT INTO olibdb VALUES('o','generalizedMoebiusFunction',2,'n','(List(P),(P,P)->R)->%','dGeneralizedFiniteMoebiusFunction(P,R)',NULL,'\spad{generalizedMoebiusFunction(pp,{} zeta)} inverts the given zeta function');
INSERT INTO olibdb VALUES('o','generalLambert',3,'n','(%,Integer,Integer)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','generalLambert',3,'n','(%,Integer,Integer)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{generalLambert(f(x),{} a,{} d)} returns \spad{f(x^a) + f(x^(a + d)) + \indented{1}{f(x^(a + 2 d)) + ... }. \spad{f(x)} should have zero constant} \indented{1}{coefficient and \spad{a} and \spad{d} should be positive.}');
INSERT INTO olibdb VALUES('o','generalLambert',3,'n','(Stream(A),Integer,Integer)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{generalLambert(f(x),{} a,{} d)} returns \spad{f(x^a) + f(x^(a + d)) + f(x^(a + 2 d)) + ...}. \spad{f(x)} should have zero constant coefficient and \spad{a} and \spad{d} should be positive.');
INSERT INTO olibdb VALUES('o','general_Lambert_product',3,'n','(Stream(A),Integer,Integer)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{general_Lambert_product(f(x),{} a,{} d)} returns \spad{f(x^a)*f(x^(a + d))*f(x^(a + 2 d))* ...}. \spad{f(x)} should have constant coefficient equal to one and \spad{a} and \spad{d} should be positive.');
INSERT INTO olibdb VALUES('o','general_mr',3,'n','(Record(mantissa:Integer,exponent:Integer),Integer,Record(default?:Boolean,trim_trailing_zeros?:Boolean,out_mode:String,spacing:Integer,separator:Character))->String','pFloatingPointConvertion',NULL,NULL);
INSERT INTO olibdb VALUES('o','generalPosition',2,'x','(%,List(VarSet))->Record(mval:Matrix(F),invmval:Matrix(F),genIdeal:%)','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{generalPosition(I,{} listvar)} perform a random linear transformation on the variables in listvar and returns the transformed ideal along with the change of basis matrix.');
INSERT INTO olibdb VALUES('o','generalTwoFactor',1,'n','(SparseUnivariatePolynomial(SparseUnivariatePolynomial(F)))->Factored(SparseUnivariatePolynomial(SparseUnivariatePolynomial(F)))','pTwoFactorize(F)',NULL,'\spad{generalTwoFactor(p)} returns the factorisation of polynomial \spad{p},{} a sparse univariate polynomial (sup) over a sup over \spad{F}.');
INSERT INTO olibdb VALUES('o','generator',0,'n','()->%','dCyclicGroup(n,g)',NULL,'\spad{generator()} returns the generator.');
INSERT INTO olibdb VALUES('o','generator',0,'n','()->%','dInfiniteCyclicGroup(g)',NULL,'\spad{generator()} returns the generator.');
INSERT INTO olibdb VALUES('o','generator',0,'n','()->S','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','generator',0,'x','()->%','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field.');
INSERT INTO olibdb VALUES('o','generator',0,'x','()->%','cMonogenicAlgebra(R,UP)',NULL,'\spad{generator()} returns the generator for this domain.');
INSERT INTO olibdb VALUES('o','generator',1,'n','(NonNegativeInteger)->%','dAntiSymm(R,lVar)',NULL,'\spad{generator(n)} returns the \spad{n}th multiplicative generator,{} a basis term.');
INSERT INTO olibdb VALUES('o','generator',1,'n','(NonNegativeInteger)->%','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{generator(n)} returns the \spad{n}th basis term for a differential form.');
INSERT INTO olibdb VALUES('o','generator',1,'x','(NonNegativeInteger)->%','dFreeNilpotentLie(n,class,R)',NULL,'\spad{generator(i)} is the \spad{i}th Hall Basis element');
INSERT INTO olibdb VALUES('o','generator',1,'x','(%)->Union(R,failed)','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{generator(d)} returns \spad{f} if \spad{(f) = d},{} failed if \spad{d} is not principal. \spad{d} is assumed to be of degree 0.');
INSERT INTO olibdb VALUES('o','generator',3,'x','(%,Integer,List(UP))->Union(R,failed)','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{generator(d,{} k,{} lp)} returns \spad{f} if \spad{(f) = d},{} failed if \spad{d} is not principal. \spad{k} is sum of orders of \spad{d} at special places. Special places are places over infinity and over zeros of polynomials in \spad{lp}. Elements of \spad{lp} are assumed to be relatively prime.');
INSERT INTO olibdb VALUES('o','generators',0,'n','()->List(%)','cFinitelyGenerated',NULL,'\spad{generators()} returns the list of generators.');
INSERT INTO olibdb VALUES('o','generators',1,'x','(%)->List(DPoly)','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{generators(I)} returns a list of generators for the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','generators',1,'x','(%)->List(Permutation(S))','dPermutationGroup(S)',NULL,'\spad{generators(gp)} returns the generators of the group {\em gp}.');
INSERT INTO olibdb VALUES('o','generic',0,'n','()->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic()} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{\%x1,{} \%x2,{} ..}');
INSERT INTO olibdb VALUES('o','generic?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{generic?(p)} tests if \spad{p} is a single matching variable.');
INSERT INTO olibdb VALUES('o','generic',1,'n','(Symbol)->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic(s)} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{s1,{} s2,{} ..}');
INSERT INTO olibdb VALUES('o','generic',1,'n','(Vector(%))->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic(ve)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{ve} basis with the symbolic coefficients \spad{\%x1,{} \%x2,{} ..}');
INSERT INTO olibdb VALUES('o','generic',1,'n','(Vector(Symbol))->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic(vs)} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{vs}; error,{} if the vector of symbols is too short');
INSERT INTO olibdb VALUES('o','generic',2,'n','(Symbol,Vector(%))->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic(s,{} v)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{v} with the symbolic coefficients \spad{s1,{} s2,{} ..}');
INSERT INTO olibdb VALUES('o','generic',2,'n','(Vector(Symbol),Vector(%))->%','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{generic(vs,{} ve)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{ve} with the symbolic coefficients \spad{vs} error,{} if the vector of symbols is shorter than the vector of elements');
INSERT INTO olibdb VALUES('o','genericLeftDiscriminant',0,'n','()->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericLeftDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable');
INSERT INTO olibdb VALUES('o','genericLeftMinimalPolynomial',1,'n','(%)->SparseUnivariatePolynomial(Fraction(Polynomial(R)))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericLeftMinimalPolynomial(a)} substitutes the coefficients of {em a} for the generic coefficients in \spad{leftRankPolynomial()}');
INSERT INTO olibdb VALUES('o','genericLeftNorm',1,'n','(%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericLeftNorm(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the constant term in \spadfun{leftRankPolynomial} and changes the sign if the degree of this polynomial is odd. This is a form of degree \spad{k}');
INSERT INTO olibdb VALUES('o','genericLeftTrace',1,'n','(%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericLeftTrace(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the second highest term in \spadfun{leftRankPolynomial} and changes the sign. \indented{1}{This is a linear form}');
INSERT INTO olibdb VALUES('o','genericLeftTraceForm',2,'n','(%,%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericLeftTraceForm (a,{} b)} is defined to be \spad{genericLeftTrace (a*b)},{} this defines a symmetric bilinear form on the algebra');
INSERT INTO olibdb VALUES('o','genericPosition',2,'n','(List(DistributedMultivariatePolynomial(lv,F)),List(OrderedVariableList(lv)))->Record(dpolys:List(DistributedMultivariatePolynomial(lv,F)),coords:List(Integer))','pGroebnerSolve(lv,F,R)',NULL,'\spad{genericPosition(lp,{} lv)} puts a radical zero dimensional ideal in general position,{} for system \spad{lp} in variables \spad{lv}.');
INSERT INTO olibdb VALUES('o','genericRightDiscriminant',0,'n','()->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericRightDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable');
INSERT INTO olibdb VALUES('o','genericRightMinimalPolynomial',1,'n','(%)->SparseUnivariatePolynomial(Fraction(Polynomial(R)))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericRightMinimalPolynomial(a)} substitutes the coefficients of \spad{a} for the generic coefficients in \spadfun{rightRankPolynomial}');
INSERT INTO olibdb VALUES('o','genericRightNorm',1,'n','(%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericRightNorm(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the constant term in \spadfun{rightRankPolynomial} and changes the sign if the degree of this polynomial is odd');
INSERT INTO olibdb VALUES('o','genericRightTrace',1,'n','(%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericRightTrace(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the second highest term in \spadfun{rightRankPolynomial} and changes the sign');
INSERT INTO olibdb VALUES('o','genericRightTraceForm',2,'n','(%,%)->Fraction(Polynomial(R))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{genericRightTraceForm (a,{} b)} is defined to be \spadfun{genericRightTrace (a*b)},{} this defines a symmetric bilinear form on the algebra');
INSERT INTO olibdb VALUES('o','gen_exp',4,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UnivariatePolynomial(var,Expression(Integer)))),Union(Expression(Integer),infinity),(SparseUnivariatePolynomial(Expression(Integer)),List(Expression(Integer)))->Factored(SparseUnivariatePolynomial(Expression(Integer))),List(Expression(Integer)))->List(Record(ecs:List(UnivariateLaurentSeries(Expression(Integer),var,cen)),ecr:UnivariatePolynomial(var,Expression(Integer)),ect:Fraction(UnivariatePolynomial(var,Expression(Integer)))))','pLinearOrdinaryDifferentialOperatorFactorizer2(var,cen)',NULL,'to be documented later.');
INSERT INTO olibdb VALUES('o','gen_Monte_Carlo_check',6,'n','((List(SparseUnivariatePolynomial(S)))->Union(good,reject,no_solution),List(List(F)),Symbol,Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector))->(List(SparseUnivariatePolynomial(S)))->Union(good,reject,no_solution)','pModularHermitePadeSolver(F,S)',NULL,'\spad{gen_Monte_Carlo_check(check,{} l,{} kind,{} qvar,{} sigma,{} gen)} returns Monte Carlo \spad{check} for solutions to guessing problem. If Monte Carlo \spad{check} is unavailable returns \spad{check}.');
INSERT INTO olibdb VALUES('o','genus',0,'n','()->NonNegativeInteger','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{genus()} returns the genus of one absolutely irreducible component');
INSERT INTO olibdb VALUES('o','genus',0,'x','()->NonNegativeInteger','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{genus()} returns the genus of one absolutely irreducible component');
INSERT INTO olibdb VALUES('o','genVectorStream2',3,'n','(NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->Stream(List(NonNegativeInteger))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{genVectorStream2} is like genVectorStream,{} but skips every second vector.');
INSERT INTO olibdb VALUES('o','genVectorStream',3,'n','(NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->Stream(List(NonNegativeInteger))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{genVectorStream(sumEta,{} maxEta,{} k)} generates stream of all possible non-increasing lists \spad{eta} with maximal entry \spad{maxEta} and sum of entries at most \spad{sumEta}.');
INSERT INTO olibdb VALUES('o','geometric',1,'n','(Fraction(Integer))->()->Integer','pRandomIntegerDistributions',NULL,'\spad{geometric(f)} \undocumented');
INSERT INTO olibdb VALUES('o','getArr',1,'n','(%)->List(List(Boolean))','cPoset(S)',NULL,'\spad{getArr(s)} returns a list of all the arrows (or edges) Note: different from getArrows(\spad{s}) which is inherited from FiniteGraph(\spad{S})');
INSERT INTO olibdb VALUES('o','getArrowIndex',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getArrowIndex',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getArrowIndex',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{getArrowIndex(s,{} a,{} b)} retrieves arrow index of the arrow form a to \spad{b}');
INSERT INTO olibdb VALUES('o','getArrows',1,'n','(A)->List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getArrows',1,'n','(%)->List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger)))','cFiniteGraph(S)',NULL,'\spad{getArrows(s)} returns a list of all the arrows (or edges)');
INSERT INTO olibdb VALUES('o','getBadValues',1,'n','(%)->List(Any)','dPattern(R)',NULL,'\spad{getBadValues(p)} returns the list of bad values for \spad{p}. Note: \spad{p} is not allowed to match any of its bad values.');
INSERT INTO olibdb VALUES('o','getBoundValue',1,'n','(%)->NonNegativeInteger','dLambda(UT)',NULL,'introspection: returns deBruijn index of bound variable in bound leaf node');
INSERT INTO olibdb VALUES('o','getCentre',1,'n','(%)->PT','dSBoundary(PT)',NULL,'\spad{getCentre(n)} returns centre coordinate of the boundary. \spad{n:} \% is the boundary');
INSERT INTO olibdb VALUES('o','get_char',1,'n','(MD)->Integer','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{get_char(md)} returns characteristic of the field described by info \spad{md}.');
INSERT INTO olibdb VALUES('o','getChildren',1,'n','(%)->List(%)','dILogic',NULL,'returns child nodes if this is a compound term otherwise returns []');
INSERT INTO olibdb VALUES('o','getChildren',1,'n','(%)->List(%)','dLambda(UT)',NULL,'returns 2 child nodes if this is a compound term returns 1 child node if this is a lambda term otherwise returns []');
INSERT INTO olibdb VALUES('o','getChildren',1,'n','(%)->List(%)','dLatticeJoinOfMeets',NULL,'returns child nodes if this is a compound term otherwise returns []');
INSERT INTO olibdb VALUES('o','getChildren',1,'n','(%)->List(%)','dLatticeMeetOfJoins',NULL,'returns child nodes if this is a compound term otherwise returns []');
INSERT INTO olibdb VALUES('o','getChildren',1,'n','(%)->List(%)','dSKICombinators(UT)',NULL,'returns child nodes if this is a compound term otherwise returns []');
INSERT INTO olibdb VALUES('o','getCode',1,'n','(%)->List(String)','dFortranCode',NULL,'\spad{getCode(f)} returns a list of strings representing \spad{f} in Fortran notation. This is used by the FortranProgram domain.');
INSERT INTO olibdb VALUES('o','getCurve',1,'n','(%)->Curve','dTubePlot(Curve)',NULL,'\spad{getCurve(t)} returns the \spadtype{PlottableSpaceCurveCategory} representing the parametric curve of the given tube plot \spad{t}.');
INSERT INTO olibdb VALUES('o','getDatabase',1,'x','(String)->Database(IndexCard)','pOperationsQuery',NULL,'\spad{getDatabase(char)} returns a list of appropriate entries in the browser database. The legal values for \spad{char} are o (operations),{} \spad{k} (constructors),{} \spad{d} (domains),{} \spad{c} (categories) or \spad{p} (packages).');
INSERT INTO olibdb VALUES('o','getDialect',0,'n','()->Symbol','dTexFormat',NULL,'\spad{getDialect()} return current dialect setting.');
INSERT INTO olibdb VALUES('o','get_elliptics',2,'n','((UP)->UP,F)->List(Record(f_form:R,e_form:R,f_var:F,f_pol:UP))','pGenerateEllipticIntegrals(F,UP,UPUP,R)',NULL,'\spad{get_elliptics(der,{} x)} tries to find elliptic forms on \spad{R} \spad{x} is expression for variable of integration in \spad{F}');
INSERT INTO olibdb VALUES('o','getEq',1,'n','(F)->F','pRecurrenceOperator(R,F)',NULL,'\spad{getEq f} returns the defining equation,{} if \spad{f} represents the coefficient of an ADE or a recurrence.');
INSERT INTO olibdb VALUES('o','get_extension_degree',1,'n','(MD)->Integer','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{get_extension_degree(md)} returns degree of the field described by info \spad{md} over its prime subfield.');
INSERT INTO olibdb VALUES('o','get_fort_indent',0,'n','()->Integer','pFortranCodeTools',NULL,'\spad{get_fort_indent()} gets current amount of Frotran indentation');
INSERT INTO olibdb VALUES('o','getGoodPrime',1,'n','(Integer)->PositiveInteger','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{getGoodPrime n} returns the smallest prime not dividing \spad{n}');
INSERT INTO olibdb VALUES('o','getGraph',2,'n','(%,PositiveInteger)->GraphImage','dTwoDimensionalViewport',NULL,'\spad{getGraph(v,{} n)} returns the graph which is of the domain \spadtype{GraphImage} which is located in graph field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of the domain \spadtype{TwoDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','getIndexes',1,'n','(%)->List(NonNegativeInteger)','dOrientedFacet',NULL,'returns indexes in face');
INSERT INTO olibdb VALUES('o','getIndexesSigned',1,'n','(%)->List(Integer)','dOrientedFacet',NULL,'returns indexes in face with sign to give orientation');
INSERT INTO olibdb VALUES('o','getIndexs',1,'n','(%)->List(Record(left:NonNegativeInteger,right:NonNegativeInteger))','dProductFacet',NULL,'returns left indexes');
INSERT INTO olibdb VALUES('o','getIntervals',1,'n','(%)->List(Segment(Integer))','dCubicalFacet',NULL,'returns intervals in face one for each dimension');
INSERT INTO olibdb VALUES('o','getMatch',2,'n','(Pattern(R),%)->Union(S,failed)','dPatternMatchResult(R,S)',NULL,'\spad{getMatch(var,{} r)} returns the expression that \spad{var} matches in the result \spad{r},{} and failed if \spad{var} is not matched in \spad{r}.');
INSERT INTO olibdb VALUES('o','getMax',1,'n','(%)->PT','dSBoundary(PT)',NULL,'\spad{getMax(n)} returns maximum coordinate of the boundary. \spad{n} is the boundary');
INSERT INTO olibdb VALUES('o','getMaxLeft',1,'n','(%)->NonNegativeInteger','dProductFacet',NULL,'returns maximum left index');
INSERT INTO olibdb VALUES('o','getMaxRight',1,'n','(%)->NonNegativeInteger','dProductFacet',NULL,'returns maximum right index');
INSERT INTO olibdb VALUES('o','getMin',1,'n','(%)->PT','dSBoundary(PT)',NULL,'\spad{getMin(n)} returns minimum coordinate of the boundary. \spad{n} is the boundary');
INSERT INTO olibdb VALUES('o','get_mod',1,'n','(PMD)->MD','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{get_mod(pmd)} extracts field info from reduction data.');
INSERT INTO olibdb VALUES('o','getMult',1,'n','(%)->Integer','cFacetCategory',NULL,'returns multiplier of face');
INSERT INTO olibdb VALUES('o','getMultiplicationMatrix',0,'n','()->Matrix(GF)','dFiniteFieldNormalBasisExtensionByPolynomial(GF,uni)',NULL,'\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.');
INSERT INTO olibdb VALUES('o','getMultiplicationMatrix',0,'n','()->Matrix(GF)','dFiniteFieldNormalBasisExtension(GF,extdeg)',NULL,'\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.');
INSERT INTO olibdb VALUES('o','getMultiplicationMatrix',0,'x','()->Matrix(PrimeField(p))','dFiniteFieldNormalBasis(p,extdeg)',NULL,'\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.');
INSERT INTO olibdb VALUES('o','getMultiplicationTable',0,'n','()->Vector(List(Record(value:GF,index:SingleInteger)))','dFiniteFieldNormalBasisExtensionByPolynomial(GF,uni)',NULL,'\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.');
INSERT INTO olibdb VALUES('o','getMultiplicationTable',0,'n','()->Vector(List(Record(value:GF,index:SingleInteger)))','dFiniteFieldNormalBasisExtension(GF,extdeg)',NULL,'\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.');
INSERT INTO olibdb VALUES('o','getMultiplicationTable',0,'x','()->Vector(List(Record(value:PrimeField(p),index:SingleInteger)))','dFiniteFieldNormalBasis(p,extdeg)',NULL,'\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.');
INSERT INTO olibdb VALUES('o','getName',1,'n','(%)->String','cVarCat',NULL,'returns the name of the variable.');
INSERT INTO olibdb VALUES('o','getNames',1,'n','(%)->List(String)','dSceneNamedPoints(PT)',NULL,'\spad{getNames(n)} returns a list of names for this node');
INSERT INTO olibdb VALUES('o','getNotation',0,'n','()->Symbol','cJetBundleCategory',NULL,'\spad{getNotation()} shows the currently used notation.');
INSERT INTO olibdb VALUES('o','getNotation',0,'n','()->Symbol','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getNotation',0,'n','()->Symbol','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getOrder',0,'n','()->Record(low:List(S),high:List(S))','pUserDefinedPartialOrdering(S)',NULL,'\spad{getOrder()} returns \spad{[[b1,{} ...,{} bm],{} [a1,{} ...,{} an]]} such that the partial ordering on \spad{S} was given by \spad{setOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])}.');
INSERT INTO olibdb VALUES('o','get_output_mode',0,'x','()->Record(mode:String,prec:Integer)','dFloat',NULL,'\spad{get_output_mode()} returns current output mode and precision');
INSERT INTO olibdb VALUES('o','getPickedPoints',1,'n','(%)->List(Point(DoubleFloat))','dTwoDimensionalViewport',NULL,'\spad{getPickedPoints(x)} returns a list of small floats for the points the user interactively picked on the viewport for full integration into the system,{} some design issues need to be addressed: \spadignore{e.g.} how to go through the GraphImage interface,{} how to default to graphs,{} etc.');
INSERT INTO olibdb VALUES('o','get_rational_roots',1,'n','(UP)->List(Fraction(Integer))','pPolynomialRationalRoots(F,UP)',NULL,'\spad{get_rational_roots(p)} finds rational root of \spad{p}.');
INSERT INTO olibdb VALUES('o','get_rational_roots',2,'n','(F,Kernel(F))->List(Fraction(Integer))','pFunctionSpaceRationalRoots(R,F)',NULL,'\spad{get_rational_roots(f,{} k)} finds rational root of \spad{f} treated as univariate polynomial in \spad{k}.');
INSERT INTO olibdb VALUES('o','getRef',1,'n','(%)->Reference(OrderedCompletion(Integer))','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{getRef(f)} returns a reference containing the order to which the terms of \spad{f} have been computed.');
INSERT INTO olibdb VALUES('o','getSimplifyDenomsFlag',0,'x','()->Boolean','dExpression(R)','has(R,IntegralDomain)','\spad{getSimplifyDenomsFlag()} gets values of flag affecting simplification of denominators. See setSimplifyDenomsFlag.');
INSERT INTO olibdb VALUES('o','getStatement',2,'n','(OutputForm,Boolean)->List(String)','pFortranCodeTools',NULL,'\spad{getStatement(of,{} int_to_floats?)}');
INSERT INTO olibdb VALUES('o','getStream',1,'n','(%)->Stream(Record(k:Integer,c:Coef))','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{getStream(f)} returns the stream of terms representing the series \spad{f}.');
INSERT INTO olibdb VALUES('o','getType',0,'n','()->InputForm','pInputFormFunctions1(R)',NULL,'\spad{getType()} returns the input form corresponding to \spad{R}');
INSERT INTO olibdb VALUES('o','getType',1,'n','(%)->ILogic','cVarCat',NULL,'returns the type of the variable. This may be a compound type,{} for instance [a,{}\spad{b}] represents a-\spad{>b} a function from type a to type \spad{b} untyped implementations return []');
INSERT INTO olibdb VALUES('o','get_used_intrinsics',0,'n','()->List(String)','pFortranCodeTools',NULL,'\spad{get_used_intrinsics()} gets list of used intrinsics');
INSERT INTO olibdb VALUES('o','get_value',1,'x','(%)->VT','dParametricComplexCurve(VT)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getVariable',1,'n','(%)->UT','dLambda(UT)',NULL,'introspection: returns value of unbound variable in unbound leaf node or bound variable in lambda term');
INSERT INTO olibdb VALUES('o','getVariable',1,'n','(%)->UT','dSKICombinators(UT)',NULL,'returns the variable,{} if this is not a variable then return \spad{I}');
INSERT INTO olibdb VALUES('o','getVariableOrder',0,'x','()->Record(high:List(Symbol),low:List(Symbol))','pUserDefinedVariableOrdering',NULL,'\spad{getVariableOrder()} returns \spad{[[b1,{} ...,{} bm],{} [a1,{} ...,{} an]]} such that the ordering on the variables was given by \spad{setVariableOrder([b1,{} ...,{} bm],{} [a1,{} ...,{} an])}.');
INSERT INTO olibdb VALUES('o','get_variables',3,'n','(List(List(Fraction(Polynomial(Integer)))),Symbol,Symbol)->List(Symbol)','pModularHermitePade',NULL,NULL);
INSERT INTO olibdb VALUES('o','getVert',1,'n','(%)->List(S)','cPoset(S)',NULL,'\spad{getVert(s)} returns a list of all the vertices (or objects) of the graph \spad{s}. Note: different from getVertices(\spad{s}) which is inherited from FiniteGraph(\spad{S})');
INSERT INTO olibdb VALUES('o','getVertexIndex',2,'n','(A,S)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getVertexIndex',2,'n','(%,S)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{getVertexIndex(s,{} o)} gives index of object \spad{o}. returns 0 if not found');
INSERT INTO olibdb VALUES('o','getVertices',1,'n','(A)->List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','getVertices',1,'n','(%)->List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger))','cFiniteGraph(S)',NULL,'\spad{getVertices(s)} returns a list of all the vertices (or objects) of the graph \spad{s}.');
INSERT INTO olibdb VALUES('o','getZechTable',0,'n','()->PrimitiveArray(SingleInteger)','dFiniteFieldCyclicGroupExtensionByPolynomial(GF,defpol)',NULL,'\spad{getZechTable()} returns the zech logarithm table of the field it is used to perform additions in the field quickly.');
INSERT INTO olibdb VALUES('o','getZechTable',0,'n','()->PrimitiveArray(SingleInteger)','dFiniteFieldCyclicGroupExtension(GF,extdeg)',NULL,'\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly.');
INSERT INTO olibdb VALUES('o','getZechTable',0,'x','()->PrimitiveArray(SingleInteger)','dFiniteFieldCyclicGroup(p,extdeg)',NULL,'\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly.');
INSERT INTO olibdb VALUES('o','GF2FG',1,'n','(Complex(F))->FG','pInnerTrigonometricManipulations(R,F,FG)',NULL,'\spad{GF2FG(a + i b)} returns \spad{a + i b} viewed as a function with the \spad{i} pushed down into the coefficient domain.');
INSERT INTO olibdb VALUES('o','glb',2,'n','(A,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','glb',2,'n','(%,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{glb(s,{} l)} ''greatest lower bound'' or ''infimum'' of \spad{l}. In this version of \spad{glb} nodes are represented as index values. Not every subset of a poset will have a \spad{glb} in which case failed will be returned as an error indication.');
INSERT INTO olibdb VALUES('o','gnuDraw',3,'x','(Expression(Float),SegmentBinding(Float),String)->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 2d plotting,{} default options');
INSERT INTO olibdb VALUES('o','gnuDraw',3,'x','(List(DoubleFloat),List(DoubleFloat),String)->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 2d plotting from list of values,{} default options');
INSERT INTO olibdb VALUES('o','gnuDraw',4,'x','(Expression(Float),SegmentBinding(Float),SegmentBinding(Float),String)->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 3d surface plotting,{} default options');
INSERT INTO olibdb VALUES('o','gnuDraw',4,'x','(Expression(Float),SegmentBinding(Float),String,List(DrawOption))->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 2d plotting with options');
INSERT INTO olibdb VALUES('o','gnuDraw',4,'x','(List(DoubleFloat),List(DoubleFloat),String,List(DrawOption))->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 2d plotting from list of values with options');
INSERT INTO olibdb VALUES('o','gnuDraw',5,'x','(Expression(Float),SegmentBinding(Float),SegmentBinding(Float),String,List(DrawOption))->Void','pGnuDraw',NULL,'\spad{gnuDraw} provides 3d surface plotting with options');
INSERT INTO olibdb VALUES('o','goodPoint',2,'n','(List(UPUP),UPUP)->F','pChangeOfVariable(F,UP,UPUP)',NULL,'\spad{goodPoint([p1,{} ...,{} pn],{} q)} returns an integer a such that a is neither a pole of \spad{\spad{pi}(x,{} y)} for some \spad{i} nor a branch point of \spad{q(x,{} y) = 0}.');
INSERT INTO olibdb VALUES('o','GospersMethod',3,'n','(Q,V,()->V)->Union(Q,failed)','pGosperSummationMethod(E,V,R,P,Q)',NULL,'\spad{GospersMethod(b,{} n,{} new)} returns a rational function \spad{rf(n)} such that \spad{a(n) * rf(n)} is the indefinite sum of \spad{a(n)} with respect to upward difference on \spad{n},{} \spadignore{i.e.} \spad{a(n+1) * rf(n+1) - a(n) * rf(n) = a(n)},{} where \spad{b(n) = a(n)/a(n-1)} is a rational function. Returns failed if no such rational function \spad{rf(n)} exists. Note: \spad{new} is a nullary function returning a new \spad{V} every time. The condition on \spad{a(n)} is that \spad{a(n)/a(n-1)} is a rational function of \spad{n}.');
INSERT INTO olibdb VALUES('o','gotoJump',1,'n','(SingleInteger)->%','dFortranCode',NULL,'\spad{gotoJump(l)} creates a representation of a FORTRAN GOTO statement');
INSERT INTO olibdb VALUES('o','grade',1,'n','(%)->List(List(CubicalFacet))','dFiniteCubicalComplex(VS)',NULL,'A function to grade faces according to the number of non-degenerate intervals. This nests the lists according to their order Vertices,{} edges,{} squares and so on.');
INSERT INTO olibdb VALUES('o','grade',1,'n','(%)->List(List(OrientedFacet))','dFiniteSimplicialComplex(VS)',NULL,'a function to grade simplexes according to their lengths. This nests the lists according to their length. Vertices,{} edges,{} triangles and so on. The list is returned in reverse order,{} that is,{} it starts at highest grade and works down.');
INSERT INTO olibdb VALUES('o','grade',1,'x','(%)->NonNegativeInteger','dCliffordAlgebra(n,K,bLin)',NULL,'return the max grade of multivector,{} for example 1 is grade 0 \spad{e1} is grade 1 e1/\e2 is grade 2 and so on');
INSERT INTO olibdb VALUES('o','gradeInvolution',1,'x','(%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'\spad{x} = ((\spad{-1})^grade(\spad{x}))\spad{*x}');
INSERT INTO olibdb VALUES('o','gradient',2,'n','(F,FLAS)->Vector(F)','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{gradient(v,{} xlist)} computes the gradient,{} the vector of first partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in xlist.');
INSERT INTO olibdb VALUES('o','graeffe',1,'n','(UP)->UP','pComplexRootFindingPackage(R,UP)',NULL,'\spad{graeffe p} determines \spad{q} such that \spad{q(-z^2) = p(z)*p(-z)}. Note that the roots of \spad{q} are the squares of the roots of \spad{p}.');
INSERT INTO olibdb VALUES('o','gramschmidt',1,'x','(List(Matrix(Expression(Integer))))->List(Matrix(Expression(Integer)))','pRadicalEigenPackage',NULL,'\spad{gramschmidt(lv)} converts the list of column vectors \spad{lv} into a set of orthogonal column vectors of euclidean length 1 using the Gram-Schmidt algorithm.');
INSERT INTO olibdb VALUES('o','graphCurves',1,'n','(List(List(Point(DoubleFloat))))->GraphImage','pViewportPackage',NULL,'\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]])} creates a \spadtype{GraphImage} from the list of lists of points indicated by \spad{p0} through \spad{pn}.');
INSERT INTO olibdb VALUES('o','graphCurves',2,'n','(List(List(Point(DoubleFloat))),List(DrawOption))->GraphImage','pViewportPackage',NULL,'\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]],{} [options])} creates a \spadtype{GraphImage} from the list of lists of points,{} \spad{p0} through \spad{pn},{} using the options specified in the list \spad{options}.');
INSERT INTO olibdb VALUES('o','graphCurves',5,'n','(List(List(Point(DoubleFloat))),Palette,Palette,PositiveInteger,List(DrawOption))->GraphImage','pViewportPackage',NULL,'\spad{graphCurves([[p0],{} [p1],{} ...,{} [pn]],{} ptColor,{} lineColor,{} ptSize,{} [options])} creates a \spadtype{GraphImage} from the list of lists of points,{} \spad{p0} through \spad{pn},{} using the options specified in the list \spad{options}. The graph point color is specified by \spad{ptColor},{} the graph line color is specified by \spad{lineColor},{} and the size of the points is specified by \spad{ptSize}.');
INSERT INTO olibdb VALUES('o','graphImage',0,'n','()->%','dGraphImage',NULL,'\spad{graphImage()} returns an empty graph with 0 point lists of the domain \spadtype{GraphImage}. A graph image contains the graph data component of a two dimensional viewport.');
INSERT INTO olibdb VALUES('o','graphs',1,'n','(%)->Vector(Union(GraphImage,undefined))','dTwoDimensionalViewport',NULL,'\spad{graphs(v)} returns a vector,{} or list,{} which is a union of all the graphs,{} of the domain \spadtype{GraphImage},{} which are allocated for the two-dimensional viewport,{} \spad{v},{} of domain \spadtype{TwoDimensionalViewport}. Those graphs which have no data are labeled undefined,{} otherwise their contents are shown.');
INSERT INTO olibdb VALUES('o','graphs',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{graphs n} is the cycle index of the group induced on \indented{1}{the edges of a graph by applying the symmetric function to the} \indented{1}{\spad{n} nodes.}');
INSERT INTO olibdb VALUES('o','graphState',14,'n','(%,PositiveInteger,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Palette,Integer,Palette,Integer)->Void','dTwoDimensionalViewport',NULL,'\spad{graphState(v,{} num,{} sX,{} sY,{} dX,{} dY,{} pts,{} lns,{} box,{} axes,{} axesC,{} un,{} unC,{} cP)} sets the state of the characteristics for the graph indicated by \spad{num} in the given two-dimensional viewport \spad{v},{} of domain \spadtype{TwoDimensionalViewport},{} to the values given as parameters. The scaling of the graph in the \spad{x} and \spad{y} component directions is set to be \spad{sX} and \spad{sY}; the window translation in the \spad{x} and \spad{y} component directions is set to be \spad{dX} and \spad{dY}; The graph points,{} lines,{} bounding \spad{box},{} \spad{axes},{} or units will be shown in the viewport if their given parameters \spad{pts},{} \spad{lns},{} \spad{box},{} \spad{axes} or \spad{un} are set to be \spad{1},{} but will not be shown if they are set to \spad{0}. The color of the \spad{axes} and the color of the units are indicated by the palette colors \spad{axesC} and \spad{unC} respectively. To display the control panel when the viewport window is displayed,{} set \spad{cP} to \spad{1},{} otherwise set it to \spad{0}.');
INSERT INTO olibdb VALUES('o','graphStates',1,'n','(%)->Vector(Record(scaleX:DoubleFloat,scaleY:DoubleFloat,deltaX:DoubleFloat,deltaY:DoubleFloat,points:Integer,connect:Integer,spline:Integer,axes:Integer,axesColor:Palette,units:Integer,unitsColor:Palette,showing:Integer))','dTwoDimensionalViewport',NULL,'\spad{graphStates(v)} returns and shows a listing of a record containing the current state of the characteristics of each of the ten graph records in the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','green',0,'x','()->%','dColor',NULL,'\spad{green()} returns the position of the green hue from total hues.');
INSERT INTO olibdb VALUES('o','groebgen',1,'n','(List(DistributedMultivariatePolynomial(lv,F)))->Record(glbase:List(DistributedMultivariatePolynomial(lv,F)),glval:List(Integer))','pLinGroebnerPackage(lv,F)',NULL,'\spad{groebgen }\undocumented');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(Dpol))->List(Dpol)','pNGroebnerPackage(Dom,Expon,Dpol)',NULL,'\spad{groebner(lp)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(%))->List(%)','dDistributedJetBundlePolynomial(R,JB,LJV,E)','has(R,GcdDomain)','\spad{groebner(lp)} computes a Groebner basis for the ideal generated by the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(%))->List(%)','dJetBundlePolynomial(R,JB)','has(R,GcdDomain)','\spad{groebner(lp)} computes a Groebner basis for the ideal generated by \spad{lp} \spad{wrt} a lexicographic ordering.');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls))))->List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls)))','pLexTriangularPackage(R,ls)',NULL,'\spad{groebner(lp)} returns the lexicographical Groebner basis of \spad{lp}. If \spad{lp} generates a zero-dimensional ideal then the {\em FGLM} strategy is used,{} otherwise the {\em Sugar} strategy is used.');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(P))->List(P)','pJetGroebner(R,JB,LJV,P,E)',NULL,'\spad{groebner(lp)} computes a Groebner basis for the ideal generated by the polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','groebner',1,'n','(List(Polynomial(R)))->List(Polynomial(R))','pFGLMIfCanPackage(R,ls)',NULL,'\spad{groebner(lq1)} returns the lexicographical Groebner basis of \spad{lq1}. If \spad{lq1} generates a zero-dimensional ideal then the {\em FGLM} strategy is used,{} otherwise the {\em Sugar} strategy is used.');
INSERT INTO olibdb VALUES('o','groebner?',1,'x','(%)->Boolean','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{groebner?(I)} tests if the generators of the ideal \spad{I} are a Groebner basis.');
INSERT INTO olibdb VALUES('o','groebner',1,'x','(%)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{groebner(I)} returns a set of generators of \spad{I} that are a Groebner basis for \spad{I}.');
INSERT INTO olibdb VALUES('o','groebner',1,'x','(List(Dpol))->List(Dpol)','pGroebnerPackage(Dom,Expon,Dpol)',NULL,'\spad{groebner(lp)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}.');
INSERT INTO olibdb VALUES('o','groebner',2,'x','(List(Dpol),String)->List(Dpol)','pGroebnerPackage(Dom,Expon,Dpol)',NULL,'\spad{groebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}. Argument infoflag is used to get information on the computation. If infoflag is info,{} then summary information is displayed for each \spad{s}-polynomial generated. If infoflag is redcrit,{} the reduced critical pairs are displayed. If infoflag is any other string,{} no information is printed during computation.');
INSERT INTO olibdb VALUES('o','groebner',3,'x','(List(Dpol),String,String)->List(Dpol)','pGroebnerPackage(Dom,Expon,Dpol)',NULL,'\spad{groebner(lp,{} info,{} redcrit)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp},{} displaying both a summary of the critical pairs considered (\spad{info}) and the result of reducing each critical pair (redcrit). If the second or third arguments have any other string value,{} the indicated information is suppressed.');
INSERT INTO olibdb VALUES('o','groebnerFactorize',1,'x','(List(Dpol))->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{groebnerFactorize(listOfPolys)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\em listOfPolys}. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p},{} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}.');
INSERT INTO olibdb VALUES('o','groebnerFactorize',2,'x','(List(Dpol),Boolean)->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{groebnerFactorize(listOfPolys,{} info)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\em listOfPolys}. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p},{} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}. If {\em info} is \spad{true},{} information is printed about partial results.');
INSERT INTO olibdb VALUES('o','groebnerFactorize',2,'x','(List(Dpol),List(Dpol))->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\em listOfPolys} under the restriction that the polynomials of {\em nonZeroRestrictions} don\spad{''t} vanish. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p},{} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}.');
INSERT INTO olibdb VALUES('o','groebnerFactorize',3,'x','(List(Dpol),List(Dpol),Boolean)->List(List(Dpol))','pGroebnerFactorizationPackage(Dom,Expon,VarSet,Dpol)',NULL,'\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions,{} info)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\em listOfPolys} under the restriction that the polynomials of {\em nonZeroRestrictions} don\spad{''t} vanish. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}. If argument {\em info} is \spad{true},{} information is printed about partial results.');
INSERT INTO olibdb VALUES('o','groebnerIdeal',1,'x','(List(DPoly))->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{groebnerIdeal(polyList)} constructs the ideal generated by the list of polynomials \spad{polyList} which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation.');
INSERT INTO olibdb VALUES('o','groebSolve',2,'n','(List(DistributedMultivariatePolynomial(lv,F)),List(OrderedVariableList(lv)))->List(List(DistributedMultivariatePolynomial(lv,F)))','pGroebnerSolve(lv,F,R)',NULL,'\spad{groebSolve(lp,{} lv)} reduces the polynomial system \spad{lp} in variables \spad{lv} to triangular form. Algorithm based on groebner bases algorithm with linear algebra for change of ordering. Preprocessing for the general solver. The polynomials in input are of type \spadtype{DMP}.');
INSERT INTO olibdb VALUES('o','ground?',1,'n','(%)->Boolean','dJetBundleLinearFunction(JB,D)',NULL,'\spad{ground?(l)} yields \spad{true},{} if \spad{l} is an element of the ground domain \spad{D}.');
INSERT INTO olibdb VALUES('o','ground?',1,'n','(%)->Boolean','dJetLazyFunction(JB,D)',NULL,'\spad{ground(exp)} is \spad{true},{} if \spad{exp} contains only fully evaluated parts.');
INSERT INTO olibdb VALUES('o','ground',1,'n','(%)->%','dJetBundleLinearFunction(JB,D)',NULL,'\spad{ground(l)} returns the ground part of \spad{l}.');
INSERT INTO olibdb VALUES('o','ground',1,'n','(%)->Record(numer:Polynomial(Integer),denom:Polynomial(Integer))','dFakePolynomial',NULL,NULL);
INSERT INTO olibdb VALUES('o','ground?',1,'n','(S)->Boolean','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ground?',1,'n','(S)->Boolean','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ground',1,'n','(S)->R','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ground',1,'n','(S)->R','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ground?',1,'x','(%)->Boolean','cFiniteAbelianMonoidRing(R,E)',NULL,'\spad{ground?(p)} tests if polynomial \spad{p} is a member of the coefficient ring.');
INSERT INTO olibdb VALUES('o','ground?',1,'x','(%)->Boolean','cFunctionSpace2(R,K)',NULL,'\spad{ground?(f)} tests if \spad{f} is an element of \spad{R}.');
INSERT INTO olibdb VALUES('o','ground',1,'x','(%)->R','cFiniteAbelianMonoidRing(R,E)',NULL,'\spad{ground(p)} retracts polynomial \spad{p} to the coefficient ring.');
INSERT INTO olibdb VALUES('o','ground',1,'x','(%)->R','cFunctionSpace2(R,K)',NULL,'\spad{ground(f)} returns \spad{f} as an element of \spad{R}. An error occurs if \spad{f} is not an element of \spad{R}.');
INSERT INTO olibdb VALUES('o','groupPresentation',0,'n','()->%','dGroupPresentation',NULL,'construct trivial group with no generators or relations');
INSERT INTO olibdb VALUES('o','groupPresentation',1,'n','(List(NonNegativeInteger))->%','dGroupPresentation',NULL,'construct free group with generators but no relations');
INSERT INTO olibdb VALUES('o','groupPresentation',2,'n','(List(NonNegativeInteger),List(List(Integer)))->%','dGroupPresentation',NULL,'construct from generators and relations');
INSERT INTO olibdb VALUES('o','group_terms',1,'x','(List(Record(num:R,d_fact:R,d_exp:NonNegativeInteger)))->List(Record(num:R,d_fact:R,d_exp:NonNegativeInteger))','dPartialFraction(R)',NULL,'Should be local but conditional.');
INSERT INTO olibdb VALUES('o','GT',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{GT(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x>y}.');
INSERT INTO olibdb VALUES('o','guess',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guess l} applies recursively \spadfun{guessRat} to the successive differences and quotients of the list. Default options as described in \spadtype{GuessOptionFunctions0} are used.');
INSERT INTO olibdb VALUES('o','guess',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guess(l,{} options)} applies recursively \spadfun{guessRat} to the successive differences and quotients of the list. The given options are used.');
INSERT INTO olibdb VALUES('o','guess',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',3,'n','(List(AlgebraicNumber),List((List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))),List(Symbol))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',3,'x','(List(F),List((List(F),List(GuessOption))->List(Expression(Integer))),List(Symbol))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',3,'x','(List(F),List((List(F),List(GuessOption))->List(EXPRR)),List(Symbol))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guess(l,{} guessers,{} ops)} applies recursively the given \spad{guessers} to the successive differences if ops contains the symbol guessSum and quotients if ops contains the symbol guessProduct to the list. Default options as described in \spadtype{GuessOptionFunctions0} are used.');
INSERT INTO olibdb VALUES('o','guess',3,'x','(List(Fraction(Integer)),List((List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))),List(Symbol))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',3,'x','(List(Fraction(Polynomial(Integer))),List((List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))),List(Symbol))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',3,'x','(List(Fraction(Polynomial(R))),List((List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))),List(Symbol))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',4,'n','(List(AlgebraicNumber),List((List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))),List(Symbol),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',4,'x','(List(F),List((List(F),List(GuessOption))->List(Expression(Integer))),List(Symbol),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',4,'x','(List(F),List((List(F),List(GuessOption))->List(EXPRR)),List(Symbol),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guess(l,{} guessers,{} ops)} applies recursively the given \spad{guessers} to the successive differences if ops contains the symbol \spad{guessSum} and quotients if ops contains the symbol \spad{guessProduct} to the list. The given options are used.');
INSERT INTO olibdb VALUES('o','guess',4,'x','(List(Fraction(Integer)),List((List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))),List(Symbol),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',4,'x','(List(Fraction(Polynomial(Integer))),List((List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))),List(Symbol),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guess',4,'x','(List(Fraction(Polynomial(R))),List((List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))),List(Symbol),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessADE l} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}.');
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessADE q} returns a guesser that tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessADE',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessADE',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessADE(l,{} options)} tries to find an algebraic differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessADE',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessADE',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessAlg l} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}. It is equivalent to \spadfun{guessADE}(\spad{l},{} maxDerivative \spad{==} 0).');
INSERT INTO olibdb VALUES('o','guessAlg',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessAlg(l,{} options)} tries to find an algebraic equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessADE}(\spad{l},{} options) with \spad{maxDerivative == 0}.');
INSERT INTO olibdb VALUES('o','guessAlg',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlg',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'n','(List(List(AlgebraicNumber)))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'x','(List(List(F)))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'x','(List(List(F)))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessAlgDep ll} tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of \spad{ll},{} using the default options described in \spadtype{GuessOptionFunctions0}.');
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'x','(List(List(Fraction(Integer))))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'x','(List(List(Fraction(Polynomial(Integer)))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',1,'x','(List(List(Fraction(Polynomial(R)))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'n','(List(List(AlgebraicNumber)),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'x','(List(List(F)),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'x','(List(List(F)),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessAlgDep ll} tries to find an algebraic dependence between several power series whose first Taylor coefficients are given by members of \spad{ll},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'x','(List(List(Fraction(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'x','(List(List(Fraction(Polynomial(Integer)))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessAlgDep',2,'x','(List(List(Fraction(Polynomial(R)))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'n','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuessExpBin(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessBinRat q} returns a guesser that tries to find a function of the form \spad{n+}->qbinomial(a+b \spad{n},{} \spad{n}) \spad{r}(\spad{n}),{} where \spad{r}(\spad{q^n}) is a \spad{q}-rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessBinRat(l,{} options)} tries to find a function of the form \spad{n+}->binomial(a+b \spad{n},{} \spad{n}) \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessBinRat q} returns a guesser that tries to find a function of the form \spad{n+}->qbinomial(a+b \spad{n},{} \spad{n}) \spad{r}(\spad{n}),{} where \spad{r}(\spad{q^n}) is a \spad{q}-rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',2,'n','(List(F),List(GuessOption))->List(EXPRR)','pGuessExpBin(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessBinRat(l,{} options)} tries to find a function of the form \spad{n+}->binomial(a+b \spad{n},{} \spad{n}) \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessBinRat',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessBinRat(l,{} options)} tries to find a function of the form \spad{n+}->binomial(a+b \spad{n},{} \spad{n}) \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessBinRat',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessBinRat',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'n','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuessExpBin(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessExpRat q} returns a guesser that tries to find a function of the form \spad{n+}->(a+b \spad{q^n})\spad{^n} \spad{r}(\spad{q^n}),{} where \spad{r}(\spad{q^n}) is a \spad{q}-rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessExpRat l} tries to find a function of the form \spad{n+}->(a+b \spad{n})\spad{^n} \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessExpRat q} returns a guesser that tries to find a function of the form \spad{n+}->(a+b \spad{q^n})\spad{^n} \spad{r}(\spad{q^n}),{} where \spad{r}(\spad{q^n}) is a \spad{q}-rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',2,'n','(List(F),List(GuessOption))->List(EXPRR)','pGuessExpBin(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessExpRat(l,{} options)} tries to find a function of the form \spad{n+}->(a+b \spad{n})\spad{^n} \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessExpRat',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessExpRat(l,{} options)} tries to find a function of the form \spad{n+}->(a+b \spad{n})\spad{^n} \spad{r}(\spad{n}),{} where \spad{r}(\spad{n}) is a rational function,{} that fits \spad{l}.');
INSERT INTO olibdb VALUES('o','guessExpRat',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessExpRat',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessFE l} tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}.');
INSERT INTO olibdb VALUES('o','guessFE',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessFE(l,{} options)} tries to find an algebraic substitution equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessFE',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessFE',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessHolo l} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}. It is equivalent to \spadfun{guessADE}\spad{(l,{} maxPower == 1)}.');
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessHolo q} returns a guesser that tries to find a linear differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessHolo',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessHolo',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessHolo(l,{} options)} tries to find an ordinary linear differential equation for a generating function whose first Taylor coefficients are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessADE}\spad{(l,{} options)} with \spad{maxPower == 1}.');
INSERT INTO olibdb VALUES('o','guessHolo',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessHolo',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessPade(l,{} options)} tries to find a rational function whose first Taylor coefficients are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}. It is equivalent to \spadfun{guessADE}\spad{(l,{} options)} with \spad{maxDerivative == 0,{} maxPower == 1,{} allDegrees == true}.');
INSERT INTO olibdb VALUES('o','guessPade',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessPade(l,{} options)} tries to find a rational function whose first Taylor coefficients are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessADE}\spad{(l,{} maxDerivative == 0,{} maxPower == 1,{} allDegrees == true)}.');
INSERT INTO olibdb VALUES('o','guessPade',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPade',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessPRec l} tries to find a linear recurrence with polynomial coefficients whose first values are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}. It is equivalent to \spadfun{guessRec}\spad{(l,{} maxPower == 1)}.');
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessPRec q} returns a guesser that tries to find a linear \spad{q}-recurrence with polynomial coefficients whose first values are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessRec}\spad{(q)} with \spad{maxPower == 1}.');
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessPRec',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessPRec',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessPRec(l,{} options)} tries to find a linear recurrence with polynomial coefficients whose first values are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessRec}\spad{(l,{} options)} with \spad{maxPower == 1}.');
INSERT INTO olibdb VALUES('o','guessPRec',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessPRec',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessRat l} tries to find a rational function whose first values are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}. It is equivalent to \spadfun{guessRec}\spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}.');
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessRat q} returns a guesser that tries to find a \spad{q}-rational function whose first values are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessRec} with \spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}.');
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRat',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRat',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessRat(l,{} options)} tries to find a rational function whose first values are given by \spad{l},{} using the given options. It is equivalent to \spadfun{guessRec}\spad{(l,{} maxShift == 0,{} maxPower == 1,{} allDegrees == true)}.');
INSERT INTO olibdb VALUES('o','guessRat',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRat',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'n','(List(AlgebraicNumber))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'n','(Symbol)->(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber','has(AlgebraicNumber,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(List(F))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(List(F))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessRec l} tries to find an ordinary difference equation whose first values are given by \spad{l},{} using the default options described in \spadtype{GuessOptionFunctions0}.');
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(List(Fraction(Integer)))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(List(Fraction(Polynomial(Integer))))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(List(Fraction(Polynomial(R))))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(Symbol)->(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)','has(F,RetractableTo(Symbol))',NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(Symbol)->(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)','AND(has(F,RetractableTo(Symbol)),has(S,RetractableTo(Symbol)))','\spad{guessRec q} returns a guesser that finds an ordinary \spad{q}-difference equation whose first values are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(Symbol)->(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger','AND(has(Fraction(Integer),RetractableTo(Symbol)),has(Integer,RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(Symbol)->(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger','AND(has(Fraction(Polynomial(Integer)),RetractableTo(Symbol)),has(Polynomial(Integer),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRec',1,'x','(Symbol)->(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)','AND(has(Fraction(Polynomial(R)),RetractableTo(Symbol)),has(Polynomial(R),RetractableTo(Symbol)))',NULL);
INSERT INTO olibdb VALUES('o','guessRec',2,'n','(List(AlgebraicNumber),List(GuessOption))->List(Expression(Integer))','pGuessAlgebraicNumber',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',2,'x','(List(F),List(GuessOption))->List(Expression(Integer))','pGuessFinite(F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',2,'x','(List(F),List(GuessOption))->List(EXPRR)','pGuess(F,S,EXPRR,retract,coerce)',NULL,'\spad{guessRec(l,{} options)} tries to find an ordinary difference equation whose first values are given by \spad{l},{} using the given options.');
INSERT INTO olibdb VALUES('o','guessRec',2,'x','(List(Fraction(Integer)),List(GuessOption))->List(Expression(Integer))','pGuessInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',2,'x','(List(Fraction(Polynomial(Integer))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomialInteger',NULL,NULL);
INSERT INTO olibdb VALUES('o','guessRec',2,'x','(List(Fraction(Polynomial(R))),List(GuessOption))->List(Expression(Integer))','pGuessPolynomial(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hadamard',2,'n','(UnivariateFormalPowerSeries(Coef),UnivariateFormalPowerSeries(Coef))->UnivariateFormalPowerSeries(Coef)','pUnivariateFormalPowerSeriesFunctions(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hahn_p',5,'n','(F,F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hahn_p(n,{} a,{} b,{} bar_a,{} bar_b,{} z)} is the continuous Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahn_p',5,'x','(%,%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hahn_p(n,{} a,{} b,{} bar_a,{} bar_b,{} z)} is the continuous Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnQ',5,'n','(F,F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hahnQ(n,{} a,{} b,{} N,{} z)} is the Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnQ',5,'x','(%,%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hahnQ(n,{} a,{} b,{} N,{} z)} \spad{s} the Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnR',5,'n','(F,F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hahnR(n,{} c,{} d,{} N,{} z)} is the dual Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnR',5,'x','(%,%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hahnR(n,{} c,{} d,{} N,{} z)} is the dual Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnS',5,'n','(F,F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hahnS(n,{} a,{} b,{} c,{} z)} is the continuous dual Hahn polynomial.');
INSERT INTO olibdb VALUES('o','hahnS',5,'x','(%,%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hahnS(n,{} a,{} b,{} c,{} z)} is the continuous dual Hahn polynomial.');
INSERT INTO olibdb VALUES('o','halfExtendedResultant1',2,'n','(%,%)->Record(resultant:R,coef1:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{halfExtendedResultant1(a,{} b)} returns \spad{[r,{} ca]} such that \spad{extendedResultant(a,{} b)} returns \spad{[r,{} ca,{} cb]}');
INSERT INTO olibdb VALUES('o','halfExtendedResultant2',2,'n','(%,%)->Record(resultant:R,coef2:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{halfExtendedResultant2(a,{} b)} returns \spad{[r,{} ca]} such that \spad{extendedResultant(a,{} b)} returns \spad{[r,{} ca,{} cb]}');
INSERT INTO olibdb VALUES('o','halfExtendedSubResultantGcd1',2,'n','(%,%)->Record(gcd:%,coef1:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{halfExtendedSubResultantGcd1(a,{} b)} returns \spad{[g,{} ca]} such that \spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]}');
INSERT INTO olibdb VALUES('o','halfExtendedSubResultantGcd1',2,'x','(%,%)->Record(gcd:%,coef1:%)','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{halfExtendedSubResultantGcd1(a,{} b)} returns \spad{[g,{} ca]} if \spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]} otherwise produces an error.');
INSERT INTO olibdb VALUES('o','halfExtendedSubResultantGcd2',2,'n','(%,%)->Record(gcd:%,coef2:%)','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{halfExtendedSubResultantGcd2(a,{} b)} returns \spad{[g,{} cb]} such that \spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]}');
INSERT INTO olibdb VALUES('o','halfExtendedSubResultantGcd2',2,'x','(%,%)->Record(gcd:%,coef2:%)','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{halfExtendedSubResultantGcd2(a,{} b)} returns \spad{[g,{} cb]} if \spad{extendedSubResultantGcd(a,{} b)} returns \spad{[g,{} ca,{} cb]} otherwise produces an error.');
INSERT INTO olibdb VALUES('o','handle_imaginary',1,'n','(FiniteDivisor(F,UP,UPUP,R))->Record(ncurve:UPUP,n_div_numer:Vector(UPUP),n_div_denom:UPUP,need_change:Boolean)','pPointsOfFiniteOrder(R0,F,UP,UPUP,R)',NULL,'\spad{handle_imaginary(d)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','handler',3,'n','(%,Integer,String)->HANDLER','dOperatorHandlers(HANDLER)',NULL,'\spad{handler(x,{} n,{} op)} is only valid if \spad{knownHandler?(n,{} op)} is \spad{true}. It returns the respective handler stored in \spad{x}.');
INSERT INTO olibdb VALUES('o','hankelDeterminant',2,'n','(Sequence(R),NonNegativeInteger)->R','pMomentPackage(R)',NULL,'\spad{hankelDeterminant(x,{} n)} returns the \spad{n}th Hankel determinant of the sequence \spad{x}.');
INSERT INTO olibdb VALUES('o','hankelDeterminants',1,'n','(%)->Stream(R)','cDistributionCategory(R)',NULL,'\spad{hankelDeterminants(x)} returns the stream of hankel determinants of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','hankelH1',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hankelH1(v,{} z)} is first Hankel function (Bessel function of the third kind).');
INSERT INTO olibdb VALUES('o','hankelH1',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hankelH1(v,{} z)} is first Hankel function (Bessel function of the third kind).');
INSERT INTO olibdb VALUES('o','hankelH2',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hankelH2(v,{} z)} is the second Hankel function (Bessel function of the third kind).');
INSERT INTO olibdb VALUES('o','hankelH2',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hankelH2(v,{} z)} is the second Hankel function (Bessel function of the third kind).');
INSERT INTO olibdb VALUES('o','hankelIndices',1,'n','(XDistributedPolynomial(VAR,F))->List(FreeMonoid(VAR))','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{hankelIndices(p)} returns a list of all left and right factors of the monomials of a given multivariate noncommutative polynomial. Factorization: \spad{w} = u*v');
INSERT INTO olibdb VALUES('o','HankelMatrix',1,'n','(List(R))->Matrix(R)','pHankelPackage(R)',NULL,'\spad{HankelMatrix([a_0,{} a_1,{} a_2,{} ...,{} a_{2n}])} builds the Hankel matrix [ \spad{a0},{} \spad{a1},{} ...,{} an ] [ \spad{a1},{} \spad{a2},{} ... ] [ ... ] [ an,{} ...,{} a2n]');
INSERT INTO olibdb VALUES('o','hankelMatrix',1,'n','(XDistributedPolynomial(VAR,F))->Matrix(F)','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{hankelMatrix(p)} returns the Hankel matrix \spad{H}(\spad{p}) of given polynomial \spad{p},{} \spadignore{i.e.} the entries at (\spad{u},{}\spad{v}) are the coefficients of the monomials \spad{w} = u*v. Rows and columns are indexed by words.');
INSERT INTO olibdb VALUES('o','hankelMatrix',2,'n','(XDistributedPolynomial(VAR,F),VAR)->Matrix(F)','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{hankelMatrix(p,{}x)} returns a matrix with the entries of the coefficients of \spad{p} at (\spad{u},{}\spad{v}) where the monomials factorizes through \spad{w} = u*x*v. This matrix is indexed by all words of the Hankel matrix.');
INSERT INTO olibdb VALUES('o','hankelSystem',1,'n','(XDistributedPolynomial(VAR,F))->Record(rows:List(FreeMonoid(VAR)),cols:List(FreeMonoid(VAR)),H:Matrix(F))','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{hankelSystem(p)} creates a Hankel-matrix for the polynomial \spad{p} with respect to the basis of all factors in \spad{p}. Row- and column-indices can be different.');
INSERT INTO olibdb VALUES('o','harmonic',1,'x','(Integer)->Fraction(Integer)','pIntegerNumberTheoryFunctions',NULL,'\spad{harmonic(n)} returns the \spad{n}th harmonic number. This is \spad{H[n] = sum(1/k,{} k=1..n)}.');
INSERT INTO olibdb VALUES('o','has?',2,'x','(%,Symbol)->Boolean','dBasicOperator',NULL,'\spad{has?(op,{} s)} tests if property \spad{s} is attached to \spad{op}.');
INSERT INTO olibdb VALUES('o','hasDimension?',1,'n','(%)->Boolean','dSimpleCell(TheField,ThePols)',NULL,'\spad{hasDimension?(c)} returns \spad{true} if \spad{c} is of positive dimension (that is one-dimensional),{} otherwise hasDimension?(\spad{c}) returns \spad{false}');
INSERT INTO olibdb VALUES('o','hasDimension?',2,'n','(%,Symbol)->Boolean','dCell(TheField)',NULL,'\spad{hasDimension?(c)} returns \spad{true} if \spad{c} is of positive dimension. Otherwise hasDimension?(\spad{c}) returns \spad{false}.');
INSERT INTO olibdb VALUES('o','hash',1,'n','(%)->SingleInteger','cHashable',NULL,'\spad{hash(s)} calculates a hash code for \spad{s}.');
INSERT INTO olibdb VALUES('o','hash',1,'n','(S)->SingleInteger','xHashable&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hasHi',1,'x','(%)->Boolean','dUniversalSegment(S)',NULL,'\spad{hasHi(s)} tests whether the segment \spad{s} has an upper bound.');
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,A)->HashState','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,A)->HashState','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,%)->HashState','cHashable',NULL,'\spad{hashUpdate!(hs,{} s)} computes new HashState from old and \spad{s} used for incremental computation of hash values. hashUpdate! might destructively work on its first argument.');
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,S)->HashState','xFinite&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,S)->HashState','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,S)->HashState','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hashUpdate!',2,'n','(HashState,S)->HashState','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','hasoln',2,'n','(List(GR),List(GR))->Record(sysok:Boolean,z0:List(GR),n0:List(GR))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{hasoln(g,{} l)} tests whether the quasi-algebraic set defined by \spad{p} = 0 for \spad{p} in \spad{g} and \spad{q} \spad{~=} 0 for \spad{q} in \spad{l} is empty or not and returns a simplified definition of the quasi-algebraic set');
INSERT INTO olibdb VALUES('o','has_op?',2,'n','(OutputForm,Symbol)->Boolean','pOutputFormTools',NULL,'\spad{has_op?(f,{} s)} returns \spad{true} is \spad{f} is a composite from with operator \spad{s},{} otherwise returns \spad{false}');
INSERT INTO olibdb VALUES('o','hasPredicate?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{hasPredicate?(p)} tests if \spad{p} has predicates attached to it.');
INSERT INTO olibdb VALUES('o','hasSolution?',2,'x','(Matrix(F),Vector(F))->Boolean','pLinearSystemMatrixPackage1(F)',NULL,'\spad{hasSolution?(A,{} B)} tests if the linear system \spad{AX = B} has a solution.');
INSERT INTO olibdb VALUES('o','hasSolution?',2,'x','(M,Col)->Boolean','pLinearSystemMatrixPackage(F,Row,Col,M)',NULL,'\spad{hasSolution?(A,{} B)} tests if the linear system \spad{AX = B} has a solution.');
INSERT INTO olibdb VALUES('o','hasTopPredicate?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{hasTopPredicate?(p)} tests if \spad{p} has a top-level predicate.');
INSERT INTO olibdb VALUES('o','Hausdorff',3,'n','(XPOLY,XPOLY,NonNegativeInteger)->XPOLY','pXExponentialPackage(R,VarSet,XPOLY)',NULL,'\spad{Hausdorff(a,{} b,{} n)} returns log(exp(a)*exp(\spad{b})) truncated at order \spad{n}.');
INSERT INTO olibdb VALUES('o','hcenter',1,'n','(NonNegativeInteger)->(%)->%','dOutputBox',NULL,'\spad{hcenter(w)(box)} centers the box horizontally inside a box of width \spad{w}.');
INSERT INTO olibdb VALUES('o','hclf',2,'n','(%,%)->%','dFreeMonoid(S)',NULL,'\spad{hclf(x,{} y)} returns the highest common left factor of \spad{x} and \spad{y},{} \spadignore{i.e.} the largest \spad{d} such that \spad{x = d a} and \spad{y = d b}.');
INSERT INTO olibdb VALUES('o','hconcat',1,'n','(List(%))->%','dOutputBox',NULL,'\spad{hconcat(lbox)} aligns the boxes at their baseline and concats those boxes horizontally from left to right.');
INSERT INTO olibdb VALUES('o','hconcat',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{hconcat(u)} horizontally concatenates all forms in list \spad{u}.');
INSERT INTO olibdb VALUES('o','hconcat',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{hconcat(f,{} g)} horizontally concatenate forms \spad{f} and \spad{g}.');
INSERT INTO olibdb VALUES('o','hcrf',2,'n','(%,%)->%','dFreeMonoid(S)',NULL,'\spad{hcrf(x,{} y)} returns the highest common right factor of \spad{x} and \spad{y},{} \spadignore{i.e.} the largest \spad{d} such that \spad{x = a d} and \spad{y = b d}.');
INSERT INTO olibdb VALUES('o','hdmpToDmp',1,'n','(HomogeneousDistributedMultivariatePolynomial(lv,R))->DistributedMultivariatePolynomial(lv,R)','pPolToPol(lv,R)',NULL,'\spad{hdmpToDmp(p)} converts \spad{p} from a \spadtype{HDMP} to a \spadtype{DMP}.');
INSERT INTO olibdb VALUES('o','hdmpToP',1,'n','(HomogeneousDistributedMultivariatePolynomial(lv,R))->Polynomial(R)','pPolToPol(lv,R)',NULL,'\spad{hdmpToP(p)} converts \spad{p} from a \spadtype{HDMP} to a \spadtype{POLY}.');
INSERT INTO olibdb VALUES('o','head',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','head',1,'x','(%)->%','cDoublyLinkedAggregate(S)',NULL,'\spad{head(l)} returns the first element of a doubly-linked aggregate \spad{l}. Error: if \spad{l} is empty.');
INSERT INTO olibdb VALUES('o','head',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{head(p)} returns \spad{p} if \spad{p} belongs to \spad{R},{} otherwise returns its leading term (monomial in the FriCAS sense),{} where \spad{p} is viewed as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','headReduce',2,'n','(P,S)->P','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduce',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduce',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{headReduce(a,{} b)} returns a polynomial \spad{r} such that \spad{headReduced?(r,{} b)} holds and there exists an integer \spad{e} such that \spad{init(b)^e a - r} is zero modulo \spad{b}.');
INSERT INTO olibdb VALUES('o','headReduce',2,'x','(P,%)->P','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{headReduce(p,{} ts)} returns a polynomial \spad{r} such that \spad{headReduce?(r,{} ts)} holds and there exists some product \spad{h} of \spad{initials(ts)} such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.');
INSERT INTO olibdb VALUES('o','headReduced?',1,'n','(S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduced?',1,'x','(%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{headReduced?(ts)} returns \spad{true} iff the head of every element of \spad{ts} is reduced \spad{w}.\spad{r}.\spad{t} to any other element of \spad{ts}.');
INSERT INTO olibdb VALUES('o','headReduced?',2,'n','(P,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduced?',2,'n','(S,List(S))->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduced?',2,'n','(S,S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headReduced?',2,'x','(%,%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{headReduced?(a,{} b)} returns \spad{true} iff \spad{degree(head(a),{} mvar(b)) < mdeg(b)}.');
INSERT INTO olibdb VALUES('o','headReduced?',2,'x','(%,List(%))->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{headReduced?(q,{} lp)} returns \spad{true} iff \spad{headReduced?(q,{} p)} holds for every \spad{p} in \spad{lp}.');
INSERT INTO olibdb VALUES('o','headReduced?',2,'x','(P,%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{headReduced?(p,{} ts)} returns \spad{true} iff the head of \spad{p} is reduced \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','headRemainder',2,'n','(P,S)->Record(num:P,den:R)','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','headRemainder',2,'x','(P,%)->Record(num:P,den:R)','cPolynomialSetCategory(R,E,VarSet,P)','has(R,IntegralDomain)','\spad{headRemainder(a,{} ps)} returns \spad{[b,{} r]} such that the leading monomial of \spad{b} is reduced in the sense of Groebner bases \spad{w}.\spad{r}.\spad{t}. \spad{ps} and \spad{r*a - b} lies in the ideal generated by \spad{ps}.');
INSERT INTO olibdb VALUES('o','heap',1,'x','(List(S))->%','dHeap(S)',NULL,'\spad{heap(ls)} creates a heap of elements consisting of the elements of \spad{ls}.');
INSERT INTO olibdb VALUES('o','heapSort',2,'x','((S,S)->Boolean,V)->V','pFiniteLinearAggregateSort(S,V)',NULL,'\spad{heapSort(f,{} agg)} sorts the aggregate agg with the ordering function \spad{f} using the heapsort algorithm.');
INSERT INTO olibdb VALUES('o','height',1,'n','(%)->NonNegativeInteger','cKernelCategory(S)',NULL,'\spad{height(k)} returns the nesting level of \spad{k}.');
INSERT INTO olibdb VALUES('o','height',1,'n','(%)->NonNegativeInteger','dOutputBox',NULL,'\spad{height(box)} returns the height of the \spad{box} (above the baseline) including the baseline.');
INSERT INTO olibdb VALUES('o','height',1,'n','(S)->NonNegativeInteger','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','height',1,'n','(UP)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{height(p)} returns the maximal absolute value of the coefficients of the polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','height',1,'x','(%)->NonNegativeInteger','cExpressionSpace2(K)',NULL,'\spad{height(f)} returns the highest nesting level appearing in \spad{f}. Constants have height 0. Symbols have height 1. For any operator op and expressions \spad{f1},{} ...,{} \spad{fn},{} \spad{op(f1,{} ...,{} fn)} has height equal to \spad{1 + max(height(f1),{} ...,{} height(fn))}.');
INSERT INTO olibdb VALUES('o','henselFact',2,'n','(UP,Boolean)->Record(contp:Integer,factors:List(Record(irr:UP,pow:NonNegativeInteger)))','pGaloisGroupFactorizer(UP)',NULL,'\spad{henselFact(p,{} sqf)} returns the factorization of \spad{p},{} the result is a Record such that \spad{contp=}content \spad{p},{} \spad{factors=}List of irreducible factors of \spad{p} with exponent. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors).');
INSERT INTO olibdb VALUES('o','HenselLift',4,'n','(TP,List(TP),RP,PositiveInteger)->Record(plist:List(TP),modulo:RP)','pGeneralHenselPackage(RP,TP)',NULL,'\spad{HenselLift(pol,{} lfacts,{} prime,{} bound)} lifts \spad{lfacts},{} that are the factors of \spad{pol} mod \spad{prime},{} to factors of \spad{pol} mod prime^k > bound. No recombining is done .');
INSERT INTO olibdb VALUES('o','hensel_update',3,'n','(U32Vector,Integer,%)->Void','dVectorIntegerReconstructor',NULL,'\spad{hensel_update(v,{} p,{} r)} performs one step of Hensel lifting');
INSERT INTO olibdb VALUES('o','hermite',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pPolynomialNumberTheoryFunctions',NULL,'\spad{hermite(n)} returns the \spad{n}th Hermite polynomial \spad{H[n](x)}. Note: Hermite polynomials,{} denoted \spad{H[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{exp(2*t*x-t^2) = sum(H[n](x)*t^n/n!,{} n=0..infinity)}.');
INSERT INTO olibdb VALUES('o','hermite',1,'x','(M)->M','pSmithNormalForm(R,Row,Col,M)',NULL,'\spad{hermite(m)} returns the Hermite normal form of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','hermiteH',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{hermiteH(n,{} z)} is the Hermite polynomial.');
INSERT INTO olibdb VALUES('o','hermiteH',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{hermiteH(n,{} z)} is the Hermite polynomial.');
INSERT INTO olibdb VALUES('o','hermiteH',2,'x','(NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)',NULL,'\spad{hermiteH(n,{} x)} is the \spad{n}-th Hermite polynomial,{} \spad{H[n](x)}. These are defined by \spad{exp(2*t*x-t^2) = sum(H[n](x)*t^n/n!,{} n = 0..)}.');
INSERT INTO olibdb VALUES('o','HermiteIntegrate',2,'n','(Fraction(UP),(UP)->UP)->Record(answer:Fraction(UP),logpart:Fraction(UP),specpart:Fraction(UP),polypart:UP)','pTranscendentalHermiteIntegration(F,UP)',NULL,'\spad{HermiteIntegrate(f,{} D)} returns \spad{[g,{} h,{} s,{} p]} such that \spad{f = Dg + h + s + p},{} \spad{h} has a squarefree denominator normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and all the squarefree factors of the denominator of \spad{s} are special \spad{w}.\spad{r}.\spad{t}. \spad{D}. Furthermore,{} \spad{h} and \spad{s} have no polynomial parts. \spad{D} is the derivation to use on \spadtype{UP}.');
INSERT INTO olibdb VALUES('o','HermiteIntegrate',2,'n','(R,(UP)->UP)->Record(answer:R,logpart:R)','pAlgebraicHermiteIntegration(F,UP,UPUP,R)',NULL,'\spad{HermiteIntegrate(f,{} '')} returns \spad{[g,{} h]} such that \spad{f = g'' + h} and \spad{h} has a only simple finite normal poles.');
INSERT INTO olibdb VALUES('o','HermiteIntegrate',3,'n','(Fraction(UP),(UP)->UP,UP)->Record(answer:Fraction(UP),logpart:Fraction(UP),specpart:Fraction(UP),polypart:UP)','pTranscendentalHermiteIntegration(F,UP)',NULL,'\spad{HermiteIntegrate(f,{} D,{} d0)} returns \spad{[g,{} h,{} s,{} p]} such that \spad{f = Dg + g*d0 + h + s + p},{} \spad{h} has a squarefree denominator normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and all the squarefree factors of the denominator of \spad{s} are special \spad{w}.\spad{r}.\spad{t}. \spad{D}. Furthermore,{} \spad{h} and \spad{s} have no polynomial parts. \spad{D} is the derivation to use on \spadtype{UP}.');
INSERT INTO olibdb VALUES('o','HermiteIntegrate',3,'n','(R,(UP)->UP,R)->Record(answer:R,logpart:R)','pAlgebraicHermiteIntegration(F,UP,UPUP,R)',NULL,'\spad{HermiteIntegrate(f,{} '',{} d0)} returns \spad{[g,{} h]} such that \spad{f = g'' + d0*g + h} and \spad{h} has a only simple finite normal poles. Note: \spad{d0} must be integral.');
INSERT INTO olibdb VALUES('o','hessian',2,'n','(F,FLAS)->Matrix(F)','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{hessian(v,{} xlist)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in xlist.');
INSERT INTO olibdb VALUES('o','hex',1,'x','(Fraction(Integer))->%','dHexadecimalExpansion',NULL,'\spad{hex(r)} converts a rational number to a hexadecimal expansion.');
INSERT INTO olibdb VALUES('o','hexDigit',0,'x','()->%','dCharacterClass',NULL,'\spad{hexDigit()} returns the class of all characters for which \spadfunFrom{hexDigit?}{Character} is \spad{true}.');
INSERT INTO olibdb VALUES('o','hexDigit?',1,'x','(%)->Boolean','dCharacter',NULL,'\spad{hexDigit?(c)} tests if \spad{c} is a hexadecimal numeral,{} \spadignore{i.e.} one of 0..9,{} a..\spad{f} or A..\spad{F}.');
INSERT INTO olibdb VALUES('o','high',1,'x','(%)->S','cSegmentCategory(S)',NULL,'\spad{high(s)} returns the second endpoint of \spad{s}. Note: \spad{high(l..h) = h}.');
INSERT INTO olibdb VALUES('o','hilbert',1,'n','(List(NonNegativeInteger))->SparseUnivariatePolynomial(Fraction(Integer))','pCartanKuranishi(JB,D)',NULL,'\spad{hilbert(cc)} computes the Hilbert polynomial to the Cartan characters \spad{cc}.');
INSERT INTO olibdb VALUES('o','hitherPlane',2,'x','(%,Float)->Void','dThreeDimensionalViewport',NULL,'\spad{hitherPlane(v,{} h)} sets the hither clipping plane of the graph to \spad{h},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','hMonic',1,'n','(Dpol)->Dpol','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{hMonic }\undocumented');
INSERT INTO olibdb VALUES('o','hMonic',1,'n','(Dpol)->Dpol','pNGroebnerPackage(Dom,Expon,Dpol)',NULL,'\spad{hMonic(p)} tries to remove content from \spad{p}');
INSERT INTO olibdb VALUES('o','homo_fact',1,'n','(XDistributedPolynomial(vl,F))->List(XDistributedPolynomial(vl,F))','pXPolynomialFactor(vl,F)',NULL,'\spad{homo_fact(p)} factors homogeneous polynomial \spad{p} into irreducible factors.');
INSERT INTO olibdb VALUES('o','homogeneous?',1,'n','(%)->Boolean','dAntiSymm(R,lVar)',NULL,'\spad{homogeneous?(p)} tests if all of the terms of \spad{p} have the same degree.');
INSERT INTO olibdb VALUES('o','homogeneous?',1,'n','(%)->Boolean','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{homogeneous?(df)} tests if all of the terms of differential form \spad{df} have the same degree.');
INSERT INTO olibdb VALUES('o','homogeneous',1,'n','(List(GuessOption))->Union(PositiveInteger,Boolean)','dGuessOptionFunctions0',NULL,'\spad{homogeneous returns} whether we allow only homogeneous algebraic differential equations,{} default being \spad{false}');
INSERT INTO olibdb VALUES('o','homogeneous',1,'x','(Union(PositiveInteger,Boolean))->%','dGuessOption',NULL,'\spad{homogeneous(d)} specifies whether we allow only homogeneous algebraic differential equations. This option is expressed in the form \spad{homogeneous == d}. If \spad{true},{} then maxPower must be set,{} too,{} and ADEs with constant total degree are allowed. If a PositiveInteger is given,{} only ADE\spad{''s} with this total degree are allowed.');
INSERT INTO olibdb VALUES('o','homology0',0,'n','()->%','dHomology',NULL,'construct empty homology,{} useful in validation code');
INSERT INTO olibdb VALUES('o','homology',1,'n','(%)->List(Homology)','dChainComplex',NULL,'calculate homology using SmithNormalForm');
INSERT INTO olibdb VALUES('o','homology',1,'n','(%)->List(Homology)','dDeltaComplex(VS)',NULL,'calculate homology using SmithNormalForm');
INSERT INTO olibdb VALUES('o','homology',1,'n','(%)->List(Homology)','dFiniteCubicalComplex(VS)',NULL,'calculate homology using SmithNormalForm');
INSERT INTO olibdb VALUES('o','homology',1,'n','(%)->List(Homology)','dFiniteSimplicialComplex(VS)',NULL,'calculate homology using SmithNormalForm For more information: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/homology/index.\spad{htm}}');
INSERT INTO olibdb VALUES('o','homology',3,'n','(List(List(Integer)),List(Integer),List(List(Integer)))->%','dHomology',NULL,'construct from lists');
INSERT INTO olibdb VALUES('o','homologyc2',0,'n','()->%','dHomology',NULL,'construct \spad{C2} homology,{} useful in validation code');
INSERT INTO olibdb VALUES('o','homologyGroup',2,'n','(Matrix(Integer),Matrix(Integer))->%','dHomology',NULL,'construct from differential over integers uses method described by Waldek Hebisch here: https://groups.google.com/forum/?hl=en\#!topic/fricas-devel/mLOdQ-\spad{fwbO0}');
INSERT INTO olibdb VALUES('o','homologyz',0,'n','()->%','dHomology',NULL,'construct \spad{Z} homology,{} useful in validation code');
INSERT INTO olibdb VALUES('o','homologyzc2',0,'n','()->%','dHomology',NULL,'construct \spad{Z+C2} homology,{} useful in validation code');
INSERT INTO olibdb VALUES('o','homologyzz',0,'n','()->%','dHomology',NULL,'construct \spad{Z*Z} homology,{} useful in validation code');
INSERT INTO olibdb VALUES('o','horizConcat',1,'n','(List(S))->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','horizConcat',1,'x','(List(%))->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{horizConcat(l)} horizontally concatenates all members of \spad{l} Error: if the arrays do not have the same number of rows.');
INSERT INTO olibdb VALUES('o','horizConcat',2,'n','(S,S)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','horizConcat',2,'x','(%,%)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{horizConcat(x,{} y)} horizontally concatenates two arrays with an equal number of rows. The entries of \spad{y} appear to the right of the entries of \spad{x}. Error: if the arrays do not have the same number of rows.');
INSERT INTO olibdb VALUES('o','horizJoin',2,'n','(%,%)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{horizJoin(A,{} B)} horizontally concats the matrices \spad{A} and \spad{B}. It is assumed that all indices of \spad{B} are smaller than those of \spad{A}.');
INSERT INTO olibdb VALUES('o','horizSplit',2,'n','(%,C)->Record(Left:%,Right:%)','dSparseEchelonMatrix(C,D)',NULL,'\spad{horizSplit(A,{} c)} splits the matrix \spad{A} into two at the column given by \spad{c}. The first column of the right matrix is enumerated by the first index less or equal to \spad{c}.');
INSERT INTO olibdb VALUES('o','horizSplit',2,'n','(S,List(NonNegativeInteger))->List(S)','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','horizSplit',2,'n','(S,PositiveInteger)->List(S)','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','horizSplit',2,'x','(%,List(NonNegativeInteger))->List(%)','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{horizSplit(a,{} [n1,{} n2,{} ...,{} \spad{ni}])} splits a into arrays having \spad{n1},{} ...,{} \spad{ni} columns. Error: if number of columns of a is different than \spad{n1} + ... + \spad{ni}.');
INSERT INTO olibdb VALUES('o','horizSplit',2,'x','(%,PositiveInteger)->List(%)','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{horizSplit(a,{} n)} splits a into \spad{n} arrays of equal size column wise. Error: if number of columns of a is not divisible by \spad{n}.');
INSERT INTO olibdb VALUES('o','hp_solve',3,'n','(List(Vector(SparseUnivariatePolynomial(Expression(Integer)))),List(NonNegativeInteger),NonNegativeInteger)->Matrix(SparseUnivariatePolynomial(Expression(Integer)))','pVectorHermitePadeSolver',NULL,'\spad{hp_solve(lv,{} eta,{} K)} solves Hermite-Pade problem with degree bound \spad{eta} up to order \spad{K}.');
INSERT INTO olibdb VALUES('o','HP_solve',7,'n','(List(List(F)),List(Integer),Symbol,Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(S)))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(S)),Boolean)','pModularHermitePadeSolver(F,S)',NULL,'\spad{HP_solve(l,{} degs,{} kind,{} sigma,{} gen check)} finds a \spad{sigma} basis with degree bounds given by \spad{degs}. It returns \spad{false} if there is no interpolating vector that is correct up to (and including) \spad{z^}(\spad{sigma}-1) with \spad{sigma} \spad{>=} |degs+[1,{} 1,{} ...,{} 1]| or if check rejects all solutions. It returns \spad{true} if it can not handle given problem.');
INSERT INTO olibdb VALUES('o','HP_solve_A',6,'n','(List(List(AlgebraicNumber)),List(Integer),Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(AlgebraicNumber)))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(AlgebraicNumber)),Boolean)','pModularHermitePade',NULL,'HP_solve_A is a fake solver over algebraic numbers.');
INSERT INTO olibdb VALUES('o','HP_solve_I',6,'n','(List(List(Fraction(Integer))),List(Integer),Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(Integer)))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(Integer)),Boolean)','pModularHermitePade',NULL,'\spad{HP_solve_I implements} HP_solve over integers.');
INSERT INTO olibdb VALUES('o','HP_solve_M',7,'n','(List(List(Integer)),List(Integer),Symbol,Integer,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(Integer)))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(Integer)),Boolean)','pModularHermitePade',NULL,'\spad{HP_solve_M implements} HP_solve over \$\spad{Z_p}\$ with machine-sized \$\spad{p}\$.');
INSERT INTO olibdb VALUES('o','HP_solve_P',7,'n','(List(List(Fraction(Polynomial(Integer)))),List(Integer),Symbol,Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(Polynomial(Integer))))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(Polynomial(Integer))),Boolean)','pModularHermitePade',NULL,'\spad{HP_solve_P implements} HP_solve over integer polynomials.');
INSERT INTO olibdb VALUES('o','HP_solve_PA',7,'n','(List(List(Fraction(Polynomial(AlgebraicNumber)))),List(Integer),Symbol,Symbol,NonNegativeInteger,(List(U32Vector),Integer,Integer)->Vector(U32Vector),(List(SparseUnivariatePolynomial(Polynomial(AlgebraicNumber))))->Union(good,reject,no_solution))->Union(Matrix(SparseUnivariatePolynomial(Polynomial(AlgebraicNumber))),Boolean)','pModularHermitePade',NULL,'HP_solve_PA is a fake solver over polynomials having algebraic coefficients.');
INSERT INTO olibdb VALUES('o','hspace',1,'n','(Integer)->%','dOutputForm',NULL,'\spad{hspace(n)} creates white space of width \spad{n}.');
INSERT INTO olibdb VALUES('o','htrigs',1,'x','(F)->F','pTranscendentalManipulations(R,F)',NULL,'\spad{htrigs(f)} converts all the exponentials in \spad{f} into hyperbolic sines and cosines.');
INSERT INTO olibdb VALUES('o','hue',1,'n','(Point(R))->R','pPointPackage(R)',NULL,'\spad{hue(pt)} returns the third element of the two dimensional point,{} \spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} hue to express a third dimension.');
INSERT INTO olibdb VALUES('o','hue',1,'x','(%)->Color','dPalette',NULL,'\spad{hue(p)} returns the hue field of the indicated palette \spad{p}.');
INSERT INTO olibdb VALUES('o','hue',1,'x','(%)->Integer','dColor',NULL,'\spad{hue(c)} returns the hue index of the indicated color \spad{c}.');
INSERT INTO olibdb VALUES('o','hyperelliptic',0,'n','()->Union(UP,failed)','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{hyperelliptic()} returns \spad{p(x)} if the curve is the hyperelliptic defined by \spad{y^2 = p(x)},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','hyperelliptic',0,'x','()->Union(UP,failed)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{hyperelliptic()} returns \spad{p(x)} if the curve is the hyperelliptic defined by \spad{y^2 = p(x)},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','hypergeometric0F1',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','hypergeometric0F1',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','hypergeometricF',3,'n','(List(F),List(F),F)->F','pFunctionalSpecialFunction(R,F)','has(F,RetractableTo(Integer))','\spad{hypergeometricF(la,{} lb,{} z)} is the generalized hypergeometric function.');
INSERT INTO olibdb VALUES('o','hypergeometricF',3,'x','(List(%),List(%),%)->%','cSpecialFunctionCategory','has(%,RetractableTo(Integer))','\spad{hypergeometricF(la,{} lb,{} z)} is the generalized hypergeometric function.');
INSERT INTO olibdb VALUES('o','I',0,'n','()->%','dSKICombinators(UT)',NULL,'Constructs a \spad{I} combinator');
INSERT INTO olibdb VALUES('o','iAiryAi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iAiryAi(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iAiryAiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iAiryAiPrime(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iAiryBi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iAiryBi(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iAiryBiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iAiryBiPrime(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iCompose',2,'n','(%,%)->%','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{iCompose(f,{} g)} returns \spad{f(g(x))}. This is an internal function which should only be called for Taylor series \spad{f(x)} and \spad{g(x)} such that the constant coefficient of \spad{g(x)} is zero.');
INSERT INTO olibdb VALUES('o','id',1,'x','(A)->A','pMappingPackage1(A)',NULL,'\spad{id x} is \spad{x}.');
INSERT INTO olibdb VALUES('o','ideal',1,'n','(Vector(A))->%','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{ideal([f1,{} ...,{} fn])} returns the ideal \spad{(f1,{} ...,{} fn)}.');
INSERT INTO olibdb VALUES('o','ideal',1,'x','(%)->FractionalIdeal(UP,Fraction(UP),UPUP,R)','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{ideal(D)} returns the ideal corresponding to a divisor \spad{D}.');
INSERT INTO olibdb VALUES('o','ideal',1,'x','(List(DPoly))->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{ideal(polyList)} constructs the ideal generated by the list of polynomials \spad{polyList}.');
INSERT INTO olibdb VALUES('o','idealiser',2,'n','(Matrix(R),Matrix(R))->Matrix(R)','pIntegralBasisTools(R,UP,F)',NULL,'\spad{idealiser(m1,{} m2)} computes the order of an ideal defined by \spad{m1} and \spad{m2}');
INSERT INTO olibdb VALUES('o','idealiser',3,'n','(Matrix(R),Matrix(R),R)->Matrix(R)','pIntegralBasisTools(R,UP,F)',NULL,'\spad{idealiser(m1,{} m2,{} d)} computes the order of an ideal defined by \spad{m1} and \spad{m2} where \spad{d} is the known part of the denominator');
INSERT INTO olibdb VALUES('o','idealiserMatrix',2,'n','(Matrix(R),Matrix(R))->Matrix(R)','pIntegralBasisTools(R,UP,F)',NULL,'\spad{idealiserMatrix(m1,{} m2)} returns the matrix representing the linear conditions on the Ring associated with an ideal defined by \spad{m1} and \spad{m2}.');
INSERT INTO olibdb VALUES('o','idealSimplify',1,'n','(%)->%','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{idealSimplify(s)} returns a different and presumably simpler representation of \spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using Buchberger\spad{''s} algorithm.');
INSERT INTO olibdb VALUES('o','identification',2,'n','(%,%)->List(Equation(R))','dLieExponentials(VarSet,R,Order)',NULL,'\spad{identification(g,{} h)} returns the list of equations \spad{g_i = h_i},{} where \spad{g_i} (resp. \spad{h_i}) are exponential coordinates of \spad{g} (resp. \spad{h}).');
INSERT INTO olibdb VALUES('o','identity',0,'n','()->%','dSTransform(PT)',NULL,'\spad{identity()} returns the identity element which is do nothing transform');
INSERT INTO olibdb VALUES('o','identity',0,'x','()->%','dDenavitHartenbergMatrix(R)',NULL,'\spad{identity()} create the identity dhmatrix');
INSERT INTO olibdb VALUES('o','identityMatrix',1,'n','(NonNegativeInteger)->%','dThreeDimensionalMatrix(R)','has(R,Ring)','\spad{identityMatrix(n)} create an identity matrix we note that this must be square');
INSERT INTO olibdb VALUES('o','identitySquareMatrix',2,'n','(Symbol,Polynomial(Integer))->FortranCode','pFortranCodePackage1',NULL,'\spad{identitySquareMatrix(s,{} p)} \undocumented{}');
INSERT INTO olibdb VALUES('o','id_map',1,'n','(Var)->Automorphism(R)','pPartialDifferentialOperatorHelper(R,Var)',NULL,NULL);
INSERT INTO olibdb VALUES('o','iexactQuo',2,'n','(R,R)->R','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,'\spad{iexactQuo(x,{} y)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iexactQuo',2,'n','(R,R)->R','xRecursivePolynomialCategory&(S,R,E,V)',NULL,'\spad{iexactQuo(x,{} y)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iexactQuo',2,'x','(R,R)->R','cPolynomialSetCategory(R,E,VarSet,P)','has(R,IntegralDomain)','\spad{iexactQuo(x,{} y)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iexactQuo',2,'x','(R,R)->R','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{iexactQuo(x,{} y)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iExquo',3,'n','(%,%,Boolean)->Union(%,failed)','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{iExquo(f,{} g,{} taylor?)} is the quotient of the power series \spad{f} and \spad{g}. If \spad{taylor?} is \spad{true},{} then we must have \spad{order(f) >= order(g)}.');
INSERT INTO olibdb VALUES('o','ignore?',1,'n','(String)->Boolean','pDefiniteIntegrationTools(R,F)',NULL,'\spad{ignore?(s)} is \spad{true} if \spad{s} is the string that tells the integrator to assume that the function has no pole in the integration interval.');
INSERT INTO olibdb VALUES('o','iiabs',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiabs(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiacos',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacos(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiacosh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacosh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiacot',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacot(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiacoth',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacoth(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiacsc',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacsc(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiacsch',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiacsch(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiAiryAi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiAiryAi(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiAiryAiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiAiryAiPrime(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiAiryBi',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiAiryBi(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiAiryBiPrime',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiAiryBiPrime(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiasec',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiasec(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiasech',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiasech(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiasin',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiasin(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiasinh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiasinh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiatan',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiatan(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiatanh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiatanh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iiBesselI',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiBesselI(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiBesselJ',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiBesselJ(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiBesselK',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiBesselK(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiBesselY',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiBesselY(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiBeta',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiBeta(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iibinom',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{iibinom(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiconjugate',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiconjugate(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iicos',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicos(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iicosh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicosh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iicot',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicot(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iicoth',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicoth(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iicsc',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicsc(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iicsch',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iicsch(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iidigamma',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iidigamma(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iidprod',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{iidprod(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iidsum',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{iidsum(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiexp',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iiexp(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iifact',1,'n','(F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{iifact(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiGamma',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiGamma(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiHypergeometricF',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiHypergeometricF(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iilog',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iilog(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iim2',1,'n','(R)->Expression(Integer)','pGuessPolynomialFunctions(R)',NULL,'should be local but conditional');
INSERT INTO olibdb VALUES('o','iiperm',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{iiperm(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iipolygamma',1,'n','(List(F))->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iipolygamma(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiPolylog',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iiPolylog(x,{} s)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iipow',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{iipow(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iiretractVar',1,'n','(Kernel(Expression(Integer)))->Polynomial(R)','pGuessPolynomialFunctions(R)',NULL,'should be local but conditional');
INSERT INTO olibdb VALUES('o','iisec',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iisec(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iisech',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iisech(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iisin',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iisin(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iisinh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iisinh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iisqrt2',0,'n','()->F','pElementaryFunction(R,F)',NULL,'\spad{iisqrt2()} should be local but conditional');
INSERT INTO olibdb VALUES('o','iisqrt3',0,'n','()->F','pElementaryFunction(R,F)',NULL,'\spad{iisqrt3()} should be local but conditional');
INSERT INTO olibdb VALUES('o','iitan',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iitan(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iitanh',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{iitanh(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','iLambertW',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{iLambertW(x)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','imag',1,'x','(F)->Expression(R)','pComplexTrigonometricManipulations(R,F)',NULL,'\spad{imag(f)} returns the imaginary part of \spad{f} where \spad{f} is a complex function.');
INSERT INTO olibdb VALUES('o','imag',1,'x','(F)->F','pTrigonometricManipulations(R,F)',NULL,'\spad{imag(f)} returns the imaginary part of \spad{f} where \spad{f} is a complex function.');
INSERT INTO olibdb VALUES('o','imag',1,'x','(%)->R','cComplexCategory(R)',NULL,'\spad{imag(x)} returns imaginary part of \spad{x}.');
INSERT INTO olibdb VALUES('o','imagE',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagE(o)} extracts the imaginary \spad{E} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagI',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagI(o)} extracts the imaginary \spad{I} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagi',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagi(o)} extracts the \spad{i} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagI',1,'x','(%)->R','cQuaternionCategory(R)',NULL,'\spad{imagI(q)} extracts the imaginary \spad{i} part of quaternion \spad{q}.');
INSERT INTO olibdb VALUES('o','imaginary',0,'n','()->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','imaginary',0,'x','()->%','cComplexCategory(R)',NULL,'\spad{imaginary()} = sqrt(\spad{-1}) = \%\spad{i}.');
INSERT INTO olibdb VALUES('o','imagJ',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagJ(o)} extracts the imaginary \spad{J} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagj',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagj(o)} extracts the \spad{j} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagJ',1,'x','(%)->R','cQuaternionCategory(R)',NULL,'\spad{imagJ(q)} extracts the imaginary \spad{j} part of quaternion \spad{q}.');
INSERT INTO olibdb VALUES('o','imagK',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagK(o)} extracts the imaginary \spad{K} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagk',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{imagk(o)} extracts the \spad{k} part of octonion \spad{o}.');
INSERT INTO olibdb VALUES('o','imagK',1,'x','(%)->R','cQuaternionCategory(R)',NULL,'\spad{imagK(q)} extracts the imaginary \spad{k} part of quaternion \spad{q}.');
INSERT INTO olibdb VALUES('o','implies',2,'n','(%,%)->%','dILogic',NULL,'\spad{implies(a,{} b)} returns the logical implication of ILogic a and \spad{b}. a is premise,{} \spad{b} is conclusion,{} result is \spad{false} (contradiction) if premise=true and conclusion=false does not mean there is a causal connection');
INSERT INTO olibdb VALUES('o','implies',2,'x','(%,%)->%','dBoolean',NULL,'\spad{implies(a,{} b)} returns the logical implication of Boolean \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','implies',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','implies',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Boolean','cPoset(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','in?',2,'x','(%,%)->Boolean','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{in?(I,{} J)} tests if the ideal \spad{I} is contained in the ideal \spad{J}.');
INSERT INTO olibdb VALUES('o','inBounds?',3,'n','(%,%,%)->Boolean','cSPointCategory',NULL,'\spad{inBounds?(pt,{} mns,{} mxs)} returns \spad{true} if \spad{pt} is inside bounding box where bounding box is specified by min and max.');
INSERT INTO olibdb VALUES('o','inc',1,'x','(%)->%','cIntegerNumberSystem',NULL,'\spad{inc(x)} returns \spad{x + 1}.');
INSERT INTO olibdb VALUES('o','incFail',2,'n','(String,List(OutputForm))->Void','pUnittestCount',NULL,'\spad{incFail(s,{} o)} is an internal function that steps the number of failed tests and records in- and output.');
INSERT INTO olibdb VALUES('o','incFatal',1,'n','(String)->Void','pUnittestCount',NULL,'\spad{incFatal s} is an internal function that steps the number of fatal tests and records input.');
INSERT INTO olibdb VALUES('o','incidenceAlgebra',2,'n','(Matrix(R),List(S))->%','dIncidenceAlgebra(R,S)',NULL,'\spad{incidenceAlgebra(A,{} ss)} constructs an adjacency matrix with with indices \spad{ss} and Matrix A');
INSERT INTO olibdb VALUES('o','incidenceAlgebra',2,'n','(Matrix(R),OneDimensionalArray(S))->%','dIncidenceAlgebra(R,S)',NULL,'\spad{incidenceAlgebra(A,{} ss)} constructs an adjacency matrix with with indices \spad{ss} and Matrix A');
INSERT INTO olibdb VALUES('o','incidenceMatrix',1,'n','(A)->Matrix(Integer)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','incidenceMatrix',1,'n','(%)->Matrix(Integer)','cFiniteGraph(S)',NULL,'\spad{incidenceMatrix(s)} represents graph \spad{s} by a matrix of size \spad{|V|} by |E| where: V=number of vertices E=number of edges entry [vertex,{} arrow] = arrow endpoint data (undirected case case: 1 - incident,{} 0 - not incident,{} directed case: \spad{-1} - start,{} 1 - end,{} 0 - not incident).');
INSERT INTO olibdb VALUES('o','incLibraryError',2,'n','(String,List(OutputForm))->Void','pUnittestCount',NULL,'incLibraryError is an internal function that steps the number of failed tests,{} but not the number of tests.');
INSERT INTO olibdb VALUES('o','inconsistent?',1,'n','(List(GR))->Boolean','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{inconsistent?(pl)} returns \spad{true} if the system of equations \spad{p} = 0 for \spad{p} in \spad{pl} is inconsistent. It is assumed that \spad{pl} is a groebner basis.');
INSERT INTO olibdb VALUES('o','inconsistent?',1,'n','(List(Polynomial(R)))->Boolean','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{inconsistent?(pl)} returns \spad{true} if the system of equations \spad{p} = 0 for \spad{p} in \spad{pl} is inconsistent. It is assumed that \spad{pl} is a groebner basis.');
INSERT INTO olibdb VALUES('o','incPass',0,'n','()->Void','pUnittestCount',NULL,'incPass is an internal function that steps the number of passed tests.');
INSERT INTO olibdb VALUES('o','incr',1,'x','(%)->Integer','cSegmentCategory(S)',NULL,'\spad{incr(s)} returns \spad{n},{} where \spad{s} is a segment in which every \spad{n}\spad{-}th element is used. Note: \spad{incr(l..h by n) = n}.');
INSERT INTO olibdb VALUES('o','increasePrecision',1,'x','(Integer)->PositiveInteger','cFloatingPointSystem','has(%,arbitraryPrecision)','\spad{increasePrecision(n)} increases the current \spadfunFrom{precision}{FloatingPointSystem} by \spad{n} decimal digits.');
INSERT INTO olibdb VALUES('o','increment',0,'n','()->(R)->R','pIncrementingMaps(R)',NULL,'\spad{increment()} produces a function which adds \spad{1} to whatever argument it is given. For example,{} if {\spad{f} \spad{:=} increment()} then \spad{f x} is \spad{x+1}.');
INSERT INTO olibdb VALUES('o','incrementBy',1,'n','(R)->(R)->R','pIncrementingMaps(R)',NULL,'\spad{incrementBy(n)} produces a function which adds \spad{n} to whatever argument it is given. For example,{} if {\spad{f} \spad{:=} increment(\spad{n})} then \spad{f x} is \spad{x+n}.');
INSERT INTO olibdb VALUES('o','incrementKthElement',2,'n','(%,PositiveInteger)->Union(%,failed)','dSetOfMIntegersInOneToN(m,n)',NULL,'\spad{incrementKthElement(S,{} k)} increments the \spad{k^}{th} element of \spad{S},{} and returns failed if the result is not a set of \spad{M} integers in \spad{1..n} any more.');
INSERT INTO olibdb VALUES('o','incTest',0,'n','()->Void','pUnittestCount',NULL,'incTest is an internal function that steps the test number.');
INSERT INTO olibdb VALUES('o','incXfFail',0,'n','()->Void','pUnittestCount',NULL,'\spad{incXfFail()} is an internal function that steps the number expected failures.');
INSERT INTO olibdb VALUES('o','incXfFatal',1,'n','(String)->Void','pUnittestCount',NULL,'incXfFatal is like incFatal,{} but for expected failures.');
INSERT INTO olibdb VALUES('o','incXfLibraryError',2,'n','(String,List(OutputForm))->Void','pUnittestCount',NULL,'incXfLibraryError is like incLibraryError,{} but using expected failures.');
INSERT INTO olibdb VALUES('o','incXfPass',2,'n','(String,List(OutputForm))->Void','pUnittestCount',NULL,'\spad{incXfPass(s,{} o)} is an internal function that steps the number of tests that passed but were expected to fail and records in- and output.');
INSERT INTO olibdb VALUES('o','inDegree',2,'n','(A,NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inDegree',2,'n','(A,NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inDegree',2,'n','(%,NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{inDegree(s,{} a)} gives the number of arrows leading in to node ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','indentFortLevel',1,'n','(Integer)->Void','pFortranCodeTools',NULL,'\spad{indentFortLevel(i)}');
INSERT INTO olibdb VALUES('o','index',1,'n','(%)->IS','dModuleMonomial(IS,E,ff)',NULL,'\spad{index(x)} \undocumented');
INSERT INTO olibdb VALUES('o','index',1,'n','(PositiveInteger)->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index',1,'n','(%)->PositiveInteger','cJetBundleCategory',NULL,'\spad{index(jv)} yields number of the jet variable \spad{jv}.');
INSERT INTO olibdb VALUES('o','index',1,'n','(PositiveInteger)->S','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index',1,'n','(PositiveInteger)->S','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index',1,'n','(PositiveInteger)->S','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index',1,'x','(PositiveInteger)->%','cFinite',NULL,'\spad{index(i)} takes a positive integer \spad{i} less than or equal to \spad{size()} and returns the \spad{i}\spad{-}th element of the set. This operation establishes a bijection between the elements of the finite set and \spad{1..size()}.');
INSERT INTO olibdb VALUES('o','index?',2,'n','(Integer,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index?',2,'n','(Integer,A)->Boolean','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index?',2,'n','(Key,S)->Boolean','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','index',2,'n','(PositiveInteger,PositiveInteger)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{index(n,{} m)} is a index function for vectors of length \spad{n} over the ground field.');
INSERT INTO olibdb VALUES('o','index?',2,'x','(Index,%)->Boolean','cIndexedAggregate(Index,Entry)',NULL,'\spad{index?(i,{} u)} tests if \spad{i} is an index of aggregate \spad{u}.');
INSERT INTO olibdb VALUES('o','indexes',1,'n','(%)->List(List(NonNegativeInteger))','dSceneIFS(PT)',NULL,'\spad{indexes(me)} returns indexes into pointList(\spad{me})');
INSERT INTO olibdb VALUES('o','indexName',1,'n','(List(GuessOption))->Symbol','dGuessOptionFunctions0',NULL,'\spad{indexName returns} the name of the index variable used for the formulas,{} default being \spad{n}');
INSERT INTO olibdb VALUES('o','indexName',1,'x','(Symbol)->%','dGuessOption',NULL,'\spad{indexName(d)} specifies the index variable used for the formulas. This option is expressed in the form \spad{indexName == d}.');
INSERT INTO olibdb VALUES('o','indexToObject',2,'n','(A,NonNegativeInteger)->S','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','indexToObject',2,'n','(%,NonNegativeInteger)->S','cPoset(S)',NULL,'\spad{indexToObject returns} the object at a given index.');
INSERT INTO olibdb VALUES('o','indices',1,'n','(A)->List(Integer)','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','indices',1,'n','(A)->List(Integer)','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','indices',1,'n','(%)->OneDimensionalArray(S)','dIncidenceAlgebra(R,S)',NULL,'\spad{indices(A)} returns the indices of the incidence matrix A');
INSERT INTO olibdb VALUES('o','indices',1,'n','(S)->List(Key)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','indices',1,'x','(%)->List(Index)','cIndexedAggregate(Index,Entry)',NULL,'\spad{indices(u)} returns a list of indices of aggregate \spad{u} in no particular order.');
INSERT INTO olibdb VALUES('o','indiceSubResultant',3,'n','(polR,polR,NonNegativeInteger)->polR','pPseudoRemainderSequence(R,polR)',NULL,'\spad{indiceSubResultant(P,{} Q,{} i)} returns the subresultant of indice \spad{i}');
INSERT INTO olibdb VALUES('o','indiceSubResultantEuclidean',3,'n','(polR,polR,NonNegativeInteger)->Record(coef1:polR,coef2:polR,subResultant:polR)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{indiceSubResultant(P,{} Q,{} i)} returns the subresultant \spad{S_i(P,{} Q)} and carries out the equality \spad{coef1*P + coef2*Q = S_i(P,{} Q)}');
INSERT INTO olibdb VALUES('o','indicialEquation',2,'n','(L,F)->UP','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquation(op,{} a)} returns the indicial equation of \spad{op} at \spad{a}.');
INSERT INTO olibdb VALUES('o','indicialEquation',2,'n','(LQ,F)->UP','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquation(op,{} a)} returns the indicial equation of \spad{op} at \spad{a}.');
INSERT INTO olibdb VALUES('o','indicialEquationAtInfinity',1,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UP)))->UP','pRationalLODE(F,UP)',NULL,'\spad{indicialEquationAtInfinity op} returns the indicial equation of \spad{op} at infinity.');
INSERT INTO olibdb VALUES('o','indicialEquationAtInfinity',1,'n','(LinearOrdinaryDifferentialOperator2(UP,Fraction(UP)))->UP','pRationalLODE(F,UP)',NULL,'\spad{indicialEquationAtInfinity op} returns the indicial equation of \spad{op} at infinity.');
INSERT INTO olibdb VALUES('o','indicialEquations',1,'n','(L)->List(Record(center:UP,equation:UP))','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquations op} returns \spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \spad{d_i}\spad{''s} are the affine singularities of \spad{op},{} and the \spad{e_i}\spad{''s} are the indicial equations at each \spad{d_i}.');
INSERT INTO olibdb VALUES('o','indicialEquations',1,'n','(LQ)->List(Record(center:UP,equation:UP))','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquations op} returns \spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \spad{d_i}\spad{''s} are the affine singularities of \spad{op},{} and the \spad{e_i}\spad{''s} are the indicial equations at each \spad{d_i}.');
INSERT INTO olibdb VALUES('o','indicialEquations',2,'n','(LQ,UP)->List(Record(center:UP,equation:UP))','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquations(op,{} p)} returns \spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \spad{d_i}\spad{''s} are the affine singularities of \spad{op} above the roots of \spad{p},{} and the \spad{e_i}\spad{''s} are the indicial equations at each \spad{d_i}.');
INSERT INTO olibdb VALUES('o','indicialEquations',2,'n','(L,UP)->List(Record(center:UP,equation:UP))','pPrimitiveRatDE(F,UP,L,LQ)',NULL,'\spad{indicialEquations(op,{} p)} returns \spad{[[d1,{} e1],{} ...,{} [dq,{} eq]]} where the \spad{d_i}\spad{''s} are the affine singularities of \spad{op} above the roots of \spad{p},{} and the \spad{e_i}\spad{''s} are the indicial equations at each \spad{d_i}.');
INSERT INTO olibdb VALUES('o','inf',1,'x','(%)->R','cIntervalCategory(R)',NULL,'\spad{inf(u)} returns the infinum of \spad{u}.');
INSERT INTO olibdb VALUES('o','inf',2,'x','(%,%)->%','cOrderedAbelianMonoidSup',NULL,'\spad{inf(x,{} y)} returns the largest element which can be subtracted from \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','infieldint',1,'n','(Fraction(UP))->Union(Fraction(UP),failed)','pRationalIntegration(F,UP)',NULL,'\spad{infieldint(f)} returns \spad{g} such that \spad{g'' = f} or failed if the integral of \spad{f} is not a rational function.');
INSERT INTO olibdb VALUES('o','infieldIntegrate',2,'x','(Fraction(Polynomial(F)),Symbol)->Union(Fraction(Polynomial(F)),failed)','pRationalFunctionIntegration(F)',NULL,'\spad{infieldIntegrate(f,{} x)} returns a fraction \spad{g} such that \spad{dg/dx = f} if \spad{g} exists,{} failed otherwise.');
INSERT INTO olibdb VALUES('o','infinite?',1,'x','(%)->Boolean','dOnePointCompletion(R)',NULL,'\spad{infinite?(x)} tests if \spad{x} is infinite.');
INSERT INTO olibdb VALUES('o','infinite?',1,'x','(%)->Boolean','dOrderedCompletion(R)',NULL,'\spad{infinite?(x)} tests if \spad{x} is +infinity or -infinity,{}');
INSERT INTO olibdb VALUES('o','infiniteProduct',1,'x','(UTS)->UTS','pInfiniteLambertProduct(Coef,UTS)',NULL,'\spad{infiniteProduct(f(x))} computes \spad{product(n=1,{} 2,{} 3...,{} f(x^n))}. The series \spad{f(x)} should have constant coefficient 1.');
INSERT INTO olibdb VALUES('o','infinity',0,'x','()->%','dOnePointCompletion(R)',NULL,'\spad{infinity()} returns infinity.');
INSERT INTO olibdb VALUES('o','infinity',0,'x','()->OnePointCompletion(Integer)','pInfinity',NULL,'\spad{infinity()} returns infinity.');
INSERT INTO olibdb VALUES('o','infinityNorm',1,'n','(UP)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{infinityNorm(f)} returns the maximal absolute value of the coefficients of the polynomial \spad{f}.');
INSERT INTO olibdb VALUES('o','infix?',1,'n','(%)->Boolean','dOutputForm',NULL,'\spad{infix?(op)} returns \spad{true} if \spad{op} is an infix operator,{} and \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','infix',2,'n','(%,List(%))->%','dOutputForm',NULL,'\spad{infix(f,{} l)} creates a form depicting the \spad{n}-ary application of infix operation \spad{f} to a tuple of arguments \spad{l}.');
INSERT INTO olibdb VALUES('o','infix',3,'n','(%,%,%)->%','dOutputForm',NULL,'\spad{infix(op,{} a,{} b)} creates a form which prints as: a \spad{op} \spad{b}.');
INSERT INTO olibdb VALUES('o','infix',4,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{infix(op,{} p,{} h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument by \spad{h1} and the second argument by \spad{h2}. Both boxes will be horizontally concatenated with \spad{box op} in the middle. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','infix',4,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{infix(op,{} p,{} h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument by \spad{h1} and the second argument by \spad{h2}. Both boxes will be horizontally concatenated with \spad{box op} in the middle. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','infLex?',4,'n','(%,%,(V,V)->Boolean,(C,C)->Boolean)->Boolean','dSplittingNode(V,C)',NULL,'\spad{infLex?(n1,{} n2,{} o1,{} o2)} returns \spad{true} iff \spad{o1(value(n1),{} value(n2))} or \spad{value(n1) = value(n2)} and \spad{o2(condition(n1),{} condition(n2))}.');
INSERT INTO olibdb VALUES('o','infRittWu?',2,'n','(S,S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','infRittWu?',2,'n','(S,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','infRittWu?',2,'x','(%,%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{infRittWu?(a,{} b)} returns \spad{true} if \spad{a} is less than \spad{b} \spad{w}.\spad{r}.\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.');
INSERT INTO olibdb VALUES('o','infRittWu?',2,'x','(%,%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{infRittWu?(ts1,{} ts2)} returns \spad{true} iff \spad{ts2} has higher rank than \spad{ts1} in Wu Wen Tsun sense.');
INSERT INTO olibdb VALUES('o','infRittWu?',2,'x','(List(P),List(P))->Boolean','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{infRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','infRittWu?',2,'x','(List(P),List(P))->Boolean','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{infRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','infsum',1,'n','(Stream(%))->%','dGeneralizedUnivariatePowerSeries(Coef,Expon,var,cen)',NULL,'\spad{infsum(x)} computes sum of all elements of \spad{x}. Degrees of elements of \spad{x} must be nondecreasing and tend to infinity.');
INSERT INTO olibdb VALUES('o','inGroundField?',1,'x','(%)->Boolean','cExtensionField(F)',NULL,'\spad{inGroundField?(a)} tests whether an element \spad{a} is already in the ground field \spad{F}.');
INSERT INTO olibdb VALUES('o','inHallBasis?',4,'x','(Integer,Integer,Integer,Integer)->Boolean','pHallBasis',NULL,'\spad{inHallBasis?(numberOfGens,{} leftCandidate,{} rightCandidate,{} left)} tests to see if a new element should be added to the \spad{P}. Hall basis being constructed. The list \spad{[leftCandidate,{} wt,{} rightCandidate]} is included in the basis if in the unique factorization of \spad{rightCandidate},{} we have left factor leftOfRight,{} and leftOfRight \spad{<=} \spad{leftCandidate}');
INSERT INTO olibdb VALUES('o','ini_rdata',2,'n','(PA,MD)->PMD','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{ini_rdata(pv,{} p)} generates data allowing faster computation of remainders from division by \spad{pv} modulo \spad{p}. Result is used by other functions in this package,{} in particular \spad{red_pol!}.');
INSERT INTO olibdb VALUES('o','init',0,'n','()->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','init',0,'n','()->S','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','init',0,'n','()->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','init',0,'n','()->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','init',0,'x','()->%','cStepThrough',NULL,'\spad{init()} chooses an initial object for stepping.');
INSERT INTO olibdb VALUES('o','init',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','init',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{init(p)} returns an error if \spad{p} belongs to \spad{R},{} otherwise returns its leading coefficient,{} where \spad{p} is viewed as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','initial',0,'n','()->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initial',0,'n','()->%','cFiniteGraph(S)',NULL,'\spad{initial constructs} a graph without vertices or edges');
INSERT INTO olibdb VALUES('o','initial',1,'n','(A)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initial',1,'x','(%)->%','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{initial(p)} returns the leading coefficient when the differential polynomial \spad{p} is written as a univariate polynomial in its leader.');
INSERT INTO olibdb VALUES('o','initializeGroupForWordProblem',1,'x','(%)->Void','dPermutationGroup(S)',NULL,'\spad{initializeGroupForWordProblem(gp)} initializes the group {\em gp} for the word problem. Notes: it calls the other function of this name with parameters 0 and 1: {\em initializeGroupForWordProblem(gp,{} 0,{} 1)}. Notes: (1) be careful: invoking this routine will destroy the possibly information about your group (but will recompute it again) (2) users need not call this function normally for the solution of the word problem.');
INSERT INTO olibdb VALUES('o','initializeGroupForWordProblem',3,'x','(%,Integer,Integer)->Void','dPermutationGroup(S)',NULL,'\spad{initializeGroupForWordProblem(gp,{} m,{} n)} initializes the group {\em gp} for the word problem. Notes: (1) with a small integer you get shorter words,{} but the routine takes longer than the standard routine for longer words. (2) be careful: invoking this routine will destroy the possibly stored information about your group (but will recompute it again). (3) users need not call this function normally for the solution of the word problem.');
INSERT INTO olibdb VALUES('o','initiallyReduce',2,'n','(P,S)->P','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduce',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduce',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{initiallyReduce(a,{} b)} returns a polynomial \spad{r} such that \spad{initiallyReduced?(r,{} b)} holds and there exists an integer \spad{e} such that \spad{init(b)^e a - r} is zero modulo \spad{b}.');
INSERT INTO olibdb VALUES('o','initiallyReduce',2,'x','(P,%)->P','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{initiallyReduce(p,{} ts)} returns a polynomial \spad{r} such that \spad{initiallyReduced?(r,{} ts)} holds and there exists some product \spad{h} of \spad{initials(ts)} such that \spad{h*p - r} lies in the ideal generated by \spad{ts}.');
INSERT INTO olibdb VALUES('o','initiallyReduced?',1,'n','(S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduced?',1,'x','(%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{initiallyReduced?(ts)} returns \spad{true} iff for every element \spad{p} of \spad{ts} \spad{p} and all its iterated initials are reduced \spad{w}.\spad{r}.\spad{t}. to the other elements of \spad{ts} with the same main variable.');
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'n','(P,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'n','(S,List(S))->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'n','(S,S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'x','(%,%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{initiallyReduced?(a,{} b)} returns \spad{false} iff there exists an iterated initial of \spad{a} which is not reduced \spad{w}.\spad{r}.\spad{t} \spad{b}.');
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'x','(%,List(%))->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{initiallyReduced?(q,{} lp)} returns \spad{true} iff \spad{initiallyReduced?(q,{} p)} holds for every \spad{p} in \spad{lp}.');
INSERT INTO olibdb VALUES('o','initiallyReduced?',2,'x','(P,%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{initiallyReduced?(p,{} ts)} returns \spad{true} iff \spad{p} and all its iterated initials are reduced \spad{w}.\spad{r}.\spad{t}. to the elements of \spad{ts} with the same main variable.');
INSERT INTO olibdb VALUES('o','initials',1,'n','(S)->List(P)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','initials',1,'x','(%)->List(P)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{initials(ts)} returns the list of the non-constant initials of the members of \spad{ts}.');
INSERT INTO olibdb VALUES('o','initTable!',0,'n','()->Void','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{initTable!()} initializes the hash-table.');
INSERT INTO olibdb VALUES('o','innerEigenvectors',3,'n','(Matrix(K),Par,(SparseUnivariatePolynomial(K))->Factored(SparseUnivariatePolynomial(K)))->List(Record(outval:F,outmult:Integer,outvect:List(Matrix(F))))','pInnerNumericEigenPackage(K,F,Par)',NULL,'\spad{innerEigenvectors(m,{} eps,{} factor)} computes explicitly the eigenvalues and the correspondent eigenvectors of the matrix \spad{m}. The parameter \spad{eps} determines the type of the output,{} factor is the univariate factorizer used to reduce the characteristic polynomial into irreducible factors.');
INSERT INTO olibdb VALUES('o','innerint',5,'x','(F,Symbol,OrderedCompletion(F),OrderedCompletion(F),Boolean)->Union(f1:OrderedCompletion(F),f2:List(OrderedCompletion(F)),fail:failed,pole:potentialPole)','pElementaryFunctionDefiniteIntegration(R,F)',NULL,'\spad{innerint(f,{} x,{} a,{} b,{} ignore?)} should be local but conditional');
INSERT INTO olibdb VALUES('o','innerSolve1',2,'n','(Polynomial(K),Par)->List(F)','pInnerNumericFloatSolvePackage(K,F,Par)',NULL,'\spad{innerSolve1(p,{} eps)} returns the list of the zeros of the polynomial \spad{p} with precision eps.');
INSERT INTO olibdb VALUES('o','innerSolve1',2,'n','(SparseUnivariatePolynomial(K),Par)->List(F)','pInnerNumericFloatSolvePackage(K,F,Par)',NULL,'\spad{innerSolve1(up,{} eps)} returns the list of the zeros of the univariate polynomial \spad{up} with precision eps.');
INSERT INTO olibdb VALUES('o','innerSolve',4,'n','(List(Polynomial(K)),List(Polynomial(K)),List(Symbol),Par)->List(List(F))','pInnerNumericFloatSolvePackage(K,F,Par)',NULL,'\spad{innerSolve(lnum,{} lden,{} lvar,{} eps)} returns a list of solutions of the system of polynomials \spad{lnum},{} with the side condition that none of the members of \spad{lden} vanish identically on any solution. Each solution is expressed as a list corresponding to the list of variables in \spad{lvar} and with precision specified by eps.');
INSERT INTO olibdb VALUES('o','input',1,'x','(%)->Union((List(InputForm))->InputForm,failed)','dBasicOperator',NULL,'\spad{input(op)} returns the \%input property of \spad{op} if it has one attached,{} failed otherwise.');
INSERT INTO olibdb VALUES('o','input',2,'x','(%,(List(InputForm))->InputForm)->%','dBasicOperator',NULL,'\spad{input(op,{} foo)} attaches foo as the \%input property of \spad{op}. If \spad{op} has a \%input property \spad{f},{} then \spad{op(a1,{}...,{}an)} gets converted to InputForm as \spad{f(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','inR?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{inR?(p)} tests if \spad{p} is an atom (\spadignore{i.e.} an element of \spad{R}).');
INSERT INTO olibdb VALUES('o','inRadical?',2,'x','(DPoly,%)->Boolean','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{inRadical?(f,{} I)} tests if some power of the polynomial \spad{f} belongs to the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','inrootof',2,'n','(SparseUnivariatePolynomial(F),F)->F','pAlgebraicFunction(R,F)',NULL,'\spad{inrootof(p,{} x)} should be a non-exported function.');
INSERT INTO olibdb VALUES('o','insert!',2,'n','(Key,Entry)->Void','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{insert!(x,{} y)} stores the item whose key is \spad{x} and whose entry is \spad{y}.');
INSERT INTO olibdb VALUES('o','insert',2,'n','(List(D),%)->%','dJetDifferentialEquation(JB,D)',NULL,'\spad{insert(sys,{} de)} adds the system \spad{sys = 0} to the differential equation \spad{de}.');
INSERT INTO olibdb VALUES('o','insert!',2,'n','(Record(key:Key,entry:Entry),S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert!',2,'x','(S,%)->%','cBagAggregate(S)',NULL,'\spad{insert!(x,{} u)} inserts item \spad{x} into bag \spad{u}.');
INSERT INTO olibdb VALUES('o','insert!',2,'x','(S,%)->%','dBinarySearchTree(S)',NULL,'\spad{insert!(x,{} b)} inserts element \spad{x} as a leave into binary search tree \spad{b}.');
INSERT INTO olibdb VALUES('o','insert!',2,'x','(S,%)->%','dBinaryTournament(S)',NULL,'\spad{insert!(x,{} b)} inserts element \spad{x} as a leave into binary tournament \spad{b}.');
INSERT INTO olibdb VALUES('o','insert',3,'n','(A,A,Integer)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(A,A,Integer)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(A,A,Integer)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert!',3,'n','(A,A,Integer)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(A,A,Integer)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(S,A,Integer)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(S,A,Integer)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(S,A,Integer)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert!',3,'n','(S,A,Integer)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert',3,'n','(S,A,Integer)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','insert!',3,'x','(%,%,Integer)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{insert!(v,{} u,{} i)} destructively inserts aggregate \spad{v} into \spad{u} at position \spad{i}.');
INSERT INTO olibdb VALUES('o','insert',3,'x','(%,%,Integer)->%','cLinearAggregate(S)',NULL,'\spad{insert(v,{} u,{} i)} returns a copy of \spad{u} having \spad{v} inserted beginning at the \spad{i}th element. Note: \spad{insert(v,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(v,{} u(i..)))}.');
INSERT INTO olibdb VALUES('o','insert!',3,'x','(S,%,Integer)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{insert!(x,{} u,{} i)} destructively inserts \spad{x} into \spad{u} at position \spad{i}.');
INSERT INTO olibdb VALUES('o','insert',3,'x','(S,%,Integer)->%','cLinearAggregate(S)',NULL,'\spad{insert(x,{} u,{} i)} returns a copy of \spad{u} having \spad{x} as its \spad{i}th element. Note: \spad{insert(x,{} u,{} i) = concat(u(minIndex(u)..i-1),{} concat(x,{} u(i..)))}.');
INSERT INTO olibdb VALUES('o','insert!',3,'x','(S,%,NonNegativeInteger)->%','cMultiDictionary(S)',NULL,'\spad{insert!(x,{} d,{} n)} destructively inserts \spad{n} copies of \spad{x} into dictionary \spad{d}.');
INSERT INTO olibdb VALUES('o','insertBottom!',2,'x','(S,%)->S','cDequeueAggregate(S)',NULL,'\spad{insertBottom!(x,{} d)} destructively inserts \spad{x} into the dequeue \spad{d} at the bottom (back) of the dequeue.');
INSERT INTO olibdb VALUES('o','insertionSort!',1,'n','(A)->A','pSortPackage(S,A)','has(S,OrderedSet)','\spad{insertionSort! }\undocumented');
INSERT INTO olibdb VALUES('o','insertionSort!',2,'n','(A,(S,S)->Boolean)->A','pSortPackage(S,A)',NULL,'\spad{insertionSort!(a,{} f)} \undocumented');
INSERT INTO olibdb VALUES('o','insertMatch',3,'n','(Pattern(R),S,%)->%','dPatternMatchResult(R,S)',NULL,'\spad{insertMatch(var,{} expr,{} r)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} without checking predicates or previous matches for \spad{var}.');
INSERT INTO olibdb VALUES('o','insertRoot!',2,'x','(S,%)->%','dBinarySearchTree(S)',NULL,'\spad{insertRoot!(x,{} b)} inserts element \spad{x} as the root of binary search tree \spad{b}.');
INSERT INTO olibdb VALUES('o','insertRowsColumns',3,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{insertRowsColumns(f,{} lst_row,{} lst_col)} returns a new system with rows and columns inserted. An index \spad{k} means a new row/column between \spad{k} and \spad{k+1}. The number of rows and columns have to be the same!');
INSERT INTO olibdb VALUES('o','insertRowsColumns',3,'n','(%,List(NonNegativeInteger),List(NonNegativeInteger))->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{insertRowsColumns(p,{} lst_row,{} lst_col)} returns a new pencil with additional rows and columns after the specified indices. addRowsColumns(\spad{p},{} [0,{}0,{}1],{} [0,{}0,{}3]) would insert 2 rows and columns at the beginning an one row and column between rows 1 and 2 and columns 3 and 4 respectively.');
INSERT INTO olibdb VALUES('o','insertTop!',2,'x','(S,%)->S','cDequeueAggregate(S)',NULL,'\spad{insertTop!(x,{} d)} destructively inserts \spad{x} into the dequeue \spad{d},{} that is,{} at the top (front) of the dequeue. The element previously at the top of the dequeue becomes the second in the dequeue,{} and so on.');
INSERT INTO olibdb VALUES('o','inspect',1,'n','(S)->Record(key:Key,entry:Entry)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inspect',1,'x','(%)->S','cBagAggregate(S)',NULL,'\spad{inspect(u)} returns an (random) element from a bag.');
INSERT INTO olibdb VALUES('o','int',1,'n','(A)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{int(r)} returns [\spad{r},{} \spad{r+1},{} \spad{r+2},{} ...],{} where \spad{r} is a ring element.');
INSERT INTO olibdb VALUES('o','int',1,'n','(%)->%','dOutputForm',NULL,'\spad{int(expr)} creates the form prefixing \spad{expr} with an integral sign.');
INSERT INTO olibdb VALUES('o','int',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{int(expr,{} lowerlimit)} creates the form prefixing \spad{expr} by an integral sign with a lowerlimit.');
INSERT INTO olibdb VALUES('o','int',2,'n','(F,Symbol)->F','pODEIntegration(R,F)',NULL,'\spad{int(f,{} x)} returns the integral of \spad{f} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','int',3,'n','(%,%,%)->%','dOutputForm',NULL,'\spad{int(expr,{} lowerlimit,{} upperlimit)} creates the form prefixing \spad{expr} by an integral sign with both a \spad{lowerlimit} and upperlimit.');
INSERT INTO olibdb VALUES('o','intBasis',1,'n','(List(%))->%','dVectorSpaceBasis(R)',NULL,'\spad{intBasis Lb} computes a basis of the intersection of the list of subspaces represented by \spad{LLv}.');
INSERT INTO olibdb VALUES('o','intBasis',1,'n','(List(List(Vector(R))))->%','dVectorSpaceBasis(R)',NULL,'\spad{intBasis LLv} computes a basis of the intersection of the list of subspaces represented by \spad{LLv}.');
INSERT INTO olibdb VALUES('o','intBasis',2,'n','(%,%)->%','dVectorSpaceBasis(R)',NULL,'\spad{intBasis(B1,{} B2)} computes a basis of the intersection of the two subspaces.');
INSERT INTO olibdb VALUES('o','intBasis',2,'n','(List(Vector(R)),List(Vector(R)))->%','dVectorSpaceBasis(R)',NULL,'\spad{intBasis(Lv1,{} Lv2)} computes a basis of the intersection of the two subspaces spanned by the vectors of \spad{Lv1} and \spad{Lv2}.');
INSERT INTO olibdb VALUES('o','intChoose',3,'n','(SparseUnivariatePolynomial(P),List(OV),List(List(R)))->Record(upol:SparseUnivariatePolynomial(R),Lval:List(R),Lfact:List(Record(factor:SparseUnivariatePolynomial(R),exponent:NonNegativeInteger)),ctpol:R)','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{intChoose should} be local');
INSERT INTO olibdb VALUES('o','intcompBasis',3,'n','(OrderedVariableList(lv),List(HomogeneousDistributedMultivariatePolynomial(lv,F)),List(HomogeneousDistributedMultivariatePolynomial(lv,F)))->List(HomogeneousDistributedMultivariatePolynomial(lv,F))','pLinGroebnerPackage(lv,F)',NULL,'\spad{intcompBasis }\undocumented');
INSERT INTO olibdb VALUES('o','integ',1,'n','(UPS)->UPS','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{integ should} be local but conditional');
INSERT INTO olibdb VALUES('o','integ_df',2,'n','(UPS,UPS)->UPS','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{integ_df should} be local but conditional');
INSERT INTO olibdb VALUES('o','integer?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{integer?(t)} tests whether \spad{t} is equivalent to the FORTRAN type INTEGER.');
INSERT INTO olibdb VALUES('o','integer?',1,'n','(OutputForm)->Boolean','pOutputFormTools',NULL,'\spad{integer?(f)} checks if \spad{f} is an integer,{} this implies atom?(\spad{f})');
INSERT INTO olibdb VALUES('o','integer',1,'n','(OutputForm)->Integer','pOutputFormTools',NULL,'\spad{integer(f)} gives integer corresponding to \spad{f}. Valid only when integer?(\spad{f}) is \spad{true}');
INSERT INTO olibdb VALUES('o','integer?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{integer?(s)} is \spad{true} if \spad{s} is an atom and belong to Int.');
INSERT INTO olibdb VALUES('o','integer',1,'x','(%)->Int','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{integer(s)} returns \spad{s} as an element of Int. Error: if \spad{s} is not an atom that also belongs to Int.');
INSERT INTO olibdb VALUES('o','integer?',1,'x','(S)->Boolean','pIntegerRetractions(S)',NULL,'\spad{integer?(x)} is \spad{true} if \spad{x} is an integer,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','integer',1,'x','(S)->Integer','pIntegerRetractions(S)',NULL,'\spad{integer(x)} returns \spad{x} as an integer; error if \spad{x} is not an integer.');
INSERT INTO olibdb VALUES('o','integerBound',1,'n','(UP)->Integer','pBoundIntegerRoots(F,UP)',NULL,'\spad{integerBound(p)} returns a lower bound on the negative integer roots of \spad{p},{} and 0 if \spad{p} has no negative integer roots.');
INSERT INTO olibdb VALUES('o','integerBound',1,'n','(UP)->Integer','pPolynomialRationalRoots(F,UP)',NULL,'\spad{integerBound(p)} returns a lower bound on the negative integer roots of \spad{p},{} and 0 if \spad{p} has no negative integer roots.');
INSERT INTO olibdb VALUES('o','integerIfCan',1,'x','(S)->Union(Integer,failed)','pIntegerRetractions(S)',NULL,'\spad{integerIfCan(x)} returns \spad{x} as an integer,{} failed if \spad{x} is not an integer.');
INSERT INTO olibdb VALUES('o','integerPart',1,'n','(%)->NonNegativeInteger','dSmallOrdinal',NULL,'\spad{integerPart(o)} = \spad{n} when \spad{o} = \spad{l} + \spad{n} and \spad{l} is a limit ordinal');
INSERT INTO olibdb VALUES('o','integers',1,'n','(Integer)->Stream(Integer)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{integers(n)} returns \spad{[n,{} n+1,{} n+2,{} ...]}.');
INSERT INTO olibdb VALUES('o','integral',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{integral(p)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the expression as an integral with integral sign and respective limits. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','integral?',1,'n','(S)->Boolean','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integral?',1,'x','(%)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integral?(f)} tests if \spad{f} is integral over \spad{k[x]}.');
INSERT INTO olibdb VALUES('o','integral',2,'n','(F,F)->%','dIntegrationResult(F)',NULL,'\spad{integral(f,{} x)} returns the formal integral of \spad{f} with respect to \spad{x}');
INSERT INTO olibdb VALUES('o','integral',2,'n','(F,SegmentBinding(F))->F','pLiouvillianFunction(R,F)',NULL,'\spad{integral(f,{} x = a..b)} denotes the definite integral of \spad{f} with respect to \spad{x} from \spad{a} to \spad{b}.');
INSERT INTO olibdb VALUES('o','integral',2,'n','(F,Symbol)->%','dIntegrationResult(F)','has(F,RetractableTo(Symbol))','\spad{integral(f,{} x)} returns the formal integral of \spad{f} with respect to \spad{x}');
INSERT INTO olibdb VALUES('o','integral',2,'n','(F,Symbol)->F','pLiouvillianFunction(R,F)',NULL,'\spad{integral(f,{} x)} indefinite integral of \spad{f} with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','integral?',2,'n','(S,F)->Boolean','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integral?',2,'n','(S,UP)->Boolean','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integral?',2,'x','(%,F)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integral?(f,{} a)} tests whether \spad{f} is locally integral at \spad{x = a}.');
INSERT INTO olibdb VALUES('o','integral',2,'x','(%,SegmentBinding(%))->%','cPrimitiveFunctionCategory',NULL,'\spad{integral(f,{} x = a..b)} returns the formal definite integral of \spad{f} \spad{dx} for \spad{x} between \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','integral',2,'x','(%,Symbol)->%','cPrimitiveFunctionCategory',NULL,'\spad{integral(f,{} x)} returns the formal integral of \spad{f} \spad{dx}.');
INSERT INTO olibdb VALUES('o','integral?',2,'x','(%,UP)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integral?(f,{} p)} tests whether \spad{f} is locally integral at \spad{p(x) = 0}.');
INSERT INTO olibdb VALUES('o','integralAtInfinity?',1,'n','(S)->Boolean','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integralAtInfinity?',1,'x','(%)->Boolean','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralAtInfinity?(f)} tests if \spad{f} is locally integral at infinity.');
INSERT INTO olibdb VALUES('o','integralBasis',0,'n','()->Record(basis:Matrix(Integer),basisDen:Integer,basisInv:Matrix(Integer))','pNumberFieldIntegralBasis(UP,F)',NULL,'\spad{integralBasis()} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \spad{Z} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{Z}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','integralBasis',0,'n','()->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pFunctionFieldIntegralBasis(R,UP,F)',NULL,'\spad{integralBasis()} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \spad{R} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','integralBasis',0,'n','()->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pPAdicWildFunctionFieldIntegralBasis(K,R,UP,F)',NULL,'\spad{integralBasis()} returns a record \spad{[basis,{} basisDen,{} basisInv] } containing information regarding the integral closure of \spad{R} in the quotient field of the framed algebra \spad{F}. \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If ''basis'' is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of ''basis'' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix ''basisInv'' contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if ''basisInv'' is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','integralBasis',0,'n','()->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pWildFunctionFieldIntegralBasis(K,R,UP,F)',NULL,'\spad{integralBasis()} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the integral closure of \spad{R} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','integralBasis',0,'x','()->Vector(%)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralBasis()} returns the integral basis for the curve.');
INSERT INTO olibdb VALUES('o','integralBasisAtInfinity',0,'x','()->Vector(%)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralBasisAtInfinity()} returns the local integral basis at infinity.');
INSERT INTO olibdb VALUES('o','integralCoordinates',1,'x','(%)->Record(num:Vector(UP),den:UP)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralCoordinates(f)} returns \spad{[[A1,{} ...,{} An],{} D]} such that \spad{f = (A1 w1 +...+ An wn) / D} where \spad{(w1,{} ...,{} wn)} is the integral basis returned by \spad{integralBasis()}.');
INSERT INTO olibdb VALUES('o','integralDerivationMatrix',1,'x','((UP)->UP)->Record(num:Matrix(UP),den:UP)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralDerivationMatrix(d)} extends the derivation \spad{d} from UP to \$ and returns (\spad{M},{} \spad{Q}) such that the i^th row of \spad{M} divided by \spad{Q} form the coordinates of \spad{d(\spad{wi})} with respect to \spad{(w1,{} ...,{} wn)} where \spad{(w1,{} ...,{} wn)} is the integral basis returned by integralBasis().');
INSERT INTO olibdb VALUES('o','integralLastSubResultant',3,'x','(P,P,TS)->List(Record(val:P,tower:TS))','pRegularTriangularSetGcdPackage(R,E,V,P,TS)',NULL,'\spad{integralLastSubResultant(p1,{} p2,{} ts)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','integralMatrix',0,'x','()->Matrix(Fraction(UP))','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralMatrix()} returns \spad{M} such that \spad{(w1,{} ...,{} wn) = M (1,{} y,{} ...,{} y^(n-1))},{} where \spad{(w1,{} ...,{} wn)} is the integral basis of \spadfunFrom{integralBasis}{FunctionFieldCategory}.');
INSERT INTO olibdb VALUES('o','integralMatrixAtInfinity',0,'x','()->Matrix(Fraction(UP))','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralMatrixAtInfinity()} returns \spad{M} such that \spad{(v1,{} ...,{} vn) = M (1,{} y,{} ...,{} y^(n-1))} where \spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \spad{infIntBasis()}.');
INSERT INTO olibdb VALUES('o','integralRepresents',2,'x','(Vector(UP),UP)->%','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{integralRepresents([A1,{} ...,{} An],{} D)} returns \spad{(A1 w1+...+An wn)/D} where \spad{(w1,{} ...,{} wn)} is the integral basis of \spad{integralBasis()}.');
INSERT INTO olibdb VALUES('o','integrate',1,'n','(%)->%','cUnivariateSeriesWithRationalExponents(Coef,Expon)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',1,'n','(%)->%','dInnerSparseUnivariatePowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. Warning: function does not check for a term of degree \spad{-1}.');
INSERT INTO olibdb VALUES('o','integrate',1,'n','(Fraction(UP))->IntegrationResult(Fraction(UP))','pRationalIntegration(F,UP)',NULL,'\spad{integrate(f)} returns \spad{g} such that \spad{g'' = f}.');
INSERT INTO olibdb VALUES('o','integrate',1,'n','(S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integrate',1,'x','(%)->%','cUnivariatePolynomialCategory(R)','has(R,Algebra(Fraction(Integer)))','\spad{integrate(p)} integrates the univariate polynomial \spad{p} with respect to its distinguished variable.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(A,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Algebra(Fraction(Integer)))','\spad{integrate(r,{} a)} returns the integral of the power series \spad{a} with respect to the power series variable where \spad{r} denotes the constant of integration. Thus \spad{integrate(a,{} [a0,{} a1,{} a2,{} ...]) = [a,{} a0,{} a1/2,{} a2/3,{} ...]}.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(Coef,Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{integrate(c,{} f)} integrates with constant term \spad{c},{} this is simply the right shift');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,PositiveInteger)->%','cJetBundleCategory',NULL,'\spad{integrate(jv,{} i)} is like \spad{integrateIfCan(jv,{} i)} but yields an error,{} if the integration is not possible.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(S,PositiveInteger)->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Symbol)->%','cUnivariateSeriesWithRationalExponents(Coef,Expon)','AND(has(Coef,Algebra(Fraction(Integer))),has(Coef,SIGNATURE(integrate,Coef(Coef,Symbol))),has(Coef,SIGNATURE(variables,List(Symbol)(Coef))))','\spad{integrate(f(x),{} y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dSparseUnivariateLaurentSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dSparseUnivariatePuiseuxSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dSparseUnivariateTaylorSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x),{} x)} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dUnivariateLaurentSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dUnivariatePuiseuxSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(var))->%','dUnivariateTaylorSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x),{} x)} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'n','(%,Variable(''x))->%','dUnivariateFormalPowerSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))',NULL);
INSERT INTO olibdb VALUES('o','integrate',2,'x','(Fraction(Polynomial(R)),SegmentBinding(OrderedCompletion(Expression(R))))->Union(f1:OrderedCompletion(Expression(R)),f2:List(OrderedCompletion(Expression(R))),fail:failed,pole:potentialPole)','pRationalFunctionDefiniteIntegration(R)',NULL,'\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(Fraction(Polynomial(R)),SegmentBinding(OrderedCompletion(Fraction(Polynomial(R)))))->Union(f1:OrderedCompletion(Expression(R)),f2:List(OrderedCompletion(Expression(R))),fail:failed,pole:potentialPole)','pRationalFunctionDefiniteIntegration(R)',NULL,'\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(Fraction(Polynomial(R)),Symbol)->Union(Expression(R),List(Expression(R)))','pIntegrationResultRFToFunction(R)','has(R,CharacteristicZero)','\spad{integrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a real variable.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(F,SegmentBinding(OrderedCompletion(F)))->Union(f1:OrderedCompletion(F),f2:List(OrderedCompletion(F)),fail:failed,pole:potentialPole)','pElementaryFunctionDefiniteIntegration(R,F)',NULL,'\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(F,Symbol)->Union(F,List(F))','pFunctionSpaceIntegration(R,F)',NULL,'\spad{integrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a real variable.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(%,Symbol)->%','dPolynomial(R)','has(R,Algebra(Fraction(Integer)))','\spad{integrate(p,{} x)} computes the integral of \spad{p*dx},{} \spadignore{i.e.} integrates the polynomial \spad{p} with respect to the variable \spad{x}.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(UPS,Distribution(R))->S','pDistributionPolynomialPackage(R,S,UPS)',NULL,'\spad{integrate(p,{} d)} integrates the polynomial \spad{p} against the distribution \spad{d}. Same as \spad{eval(d,{} p)}.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(%,Var)->%','cMultivariateTaylorSeriesCategory(Coef,Var)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f,{} x)} returns the anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{x} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',2,'x','(%,Variable(var))->%','dGeneralUnivariatePowerSeries(Coef,var,cen)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.');
INSERT INTO olibdb VALUES('o','integrate',3,'n','(%,Var,Coef)->%','dSparseMultivariateTaylorSeries(Coef,Var,SMP)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(s,{} v,{} c)} is the integral of \spad{s} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.}');
INSERT INTO olibdb VALUES('o','integrate',3,'x','(Fraction(Polynomial(R)),SegmentBinding(OrderedCompletion(Expression(R))),String)->Union(f1:OrderedCompletion(Expression(R)),f2:List(OrderedCompletion(Expression(R))),fail:failed,pole:potentialPole)','pRationalFunctionDefiniteIntegration(R)',NULL,'\spad{integrate(f,{} x = a..b,{} noPole)} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then this function will assume that \spad{f} has no such pole. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not noPole.');
INSERT INTO olibdb VALUES('o','integrate',3,'x','(Fraction(Polynomial(R)),SegmentBinding(OrderedCompletion(Fraction(Polynomial(R)))),String)->Union(f1:OrderedCompletion(Expression(R)),f2:List(OrderedCompletion(Expression(R))),fail:failed,pole:potentialPole)','pRationalFunctionDefiniteIntegration(R)',NULL,'\spad{integrate(f,{} x = a..b,{} noPole)} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then this function will assume that \spad{f} has no such pole. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not noPole.');
INSERT INTO olibdb VALUES('o','integrate',3,'x','(F,SegmentBinding(OrderedCompletion(F)),String)->Union(f1:OrderedCompletion(F),f2:List(OrderedCompletion(F)),fail:failed,pole:potentialPole)','pElementaryFunctionDefiniteIntegration(R,F)',NULL,'\spad{integrate(f,{} x = a..b,{} noPole)} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then this function will assume that \spad{f} has no such pole. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not noPole.');
INSERT INTO olibdb VALUES('o','integrate',3,'x','(%,Symbol,Coef)->%','dTaylorSeries(Coef)','has(Coef,Algebra(Fraction(Integer)))','\spad{integrate(s,{} v,{} c)} is the integral of \spad{s} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.}');
INSERT INTO olibdb VALUES('o','integrateIfCan',2,'n','(%,PositiveInteger)->Union(%,failed)','cJetBundleCategory',NULL,'\spad{integrate(jv,{} i)} integrated \spad{jv} \spad{wrt} the \spad{i}\spad{-}th independent variable,{} if possible.');
INSERT INTO olibdb VALUES('o','integrateIfCan',2,'n','(S,PositiveInteger)->Union(S,failed)','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','integrate_sols',1,'n','(LinearOrdinaryDifferentialOperator1(Fraction(UP)))->Record(ltilde:LinearOrdinaryDifferentialOperator1(Fraction(UP)),r:Union(LinearOrdinaryDifferentialOperator1(Fraction(UP)),failed))','pRationalLODE(F,UP)',NULL,'\spad{integrate_sols(l)} integrates the solutions of an operator \spad{l}.');
INSERT INTO olibdb VALUES('o','integrate_sols',2,'n','(L,(L,F)->Record(particular:Union(F,failed),basis:List(F)))->Record(ltilde:L,r:Union(L,failed))','pIntegrateSolutions(F,L)',NULL,'\spad{integrate_sols(l,{} rat_solve)} integrates the solutions of an operator \spad{l} given rat_solve(op,{} \spad{g}) that returns \spad{[failed,{} []]} if the equation \spad{op y = g} has no rational solution. Otherwise,{} the rat_solve function should return \spad{[f,{} [y1,{} ...,{} ym]]} where \spad{f} is a particular rational solution and the \spad{yi}\spad{''s} form a basis for the rational solutions of the homogeneous equation.');
INSERT INTO olibdb VALUES('o','integt',1,'n','(UTS)->UTS','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{integt should} be local but conditional');
INSERT INTO olibdb VALUES('o','intensity',2,'x','(%,Float)->Void','dThreeDimensionalViewport',NULL,'\spad{intensity(v,{} i)} sets the intensity of the light source to \spad{i},{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','internal?',1,'n','(%)->Boolean','dSubSpace(n,R)',NULL,'\spad{internal?(x)} \undocumented');
INSERT INTO olibdb VALUES('o','internalAugment',2,'x','(List(P),%)->%','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{internalAugment(lp,{} ts)} returns \spad{ts} if \spad{lp} is empty otherwise returns \spad{internalAugment(rest lp,{} internalAugment(first lp,{} ts))}');
INSERT INTO olibdb VALUES('o','internalAugment',2,'x','(P,%)->%','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{internalAugment(p,{} ts)} assumes that \spad{augment(p,{} ts)} returns a singleton and returns it.');
INSERT INTO olibdb VALUES('o','internalAugment',7,'x','(P,%,Boolean,Boolean,Boolean,Boolean,Boolean)->List(%)','dRegularTriangularSet(R,E,V,P)',NULL,'\spad{internalAugment(p,{} ts,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalAugment',7,'x','(P,%,Boolean,Boolean,Boolean,Boolean,Boolean)->List(%)','dSquareFreeRegularTriangularSet(R,E,V,P)',NULL,'\spad{internalAugment(p,{} ts,{} b1,{} b2,{} b3,{} b4,{} b5)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalDecompose',2,'x','(P,TS)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalDecompose',2,'x','(P,TS)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalDecompose',3,'x','(P,TS,NonNegativeInteger)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalDecompose',3,'x','(P,TS,NonNegativeInteger)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalDecompose',4,'x','(P,TS,NonNegativeInteger,Boolean)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalDecompose',4,'x','(P,TS,NonNegativeInteger,Boolean)->Record(done:List(TS),todo:List(Record(val:List(P),tower:TS)))','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','internalInfRittWu?',2,'x','(List(P),List(P))->Boolean','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalInfRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalInfRittWu?',2,'x','(List(P),List(P))->Boolean','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalInfRittWu?(lp1,{} lp2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalIntegrate0',2,'x','(F,Symbol)->IntegrationResult(F)','pFunctionSpaceComplexIntegration(R,F)',NULL,'\spad{internalIntegrate0 should} be a local function,{} but is conditional.');
INSERT INTO olibdb VALUES('o','internalIntegrate',2,'n','(FG,Symbol)->IntegrationResult(FG)','pFunctionSpaceComplexIntegrationAux(G,FG)',NULL,'\spad{internalIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.');
INSERT INTO olibdb VALUES('o','internalIntegrate',2,'x','(Fraction(Polynomial(F)),Symbol)->IntegrationResult(Fraction(Polynomial(F)))','pRationalFunctionIntegration(F)',NULL,'\spad{internalIntegrate(f,{} x)} returns \spad{g} such that \spad{dg/dx = f}.');
INSERT INTO olibdb VALUES('o','internalIntegrate',2,'x','(F,Symbol)->IntegrationResult(F)','pFunctionSpaceComplexIntegration(R,F)',NULL,'\spad{internalIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.');
INSERT INTO olibdb VALUES('o','internalLastSubResultant',3,'x','(List(Record(val:List(P),tower:TS)),V,Boolean)->List(Record(val:P,tower:TS))','pRegularTriangularSetGcdPackage(R,E,V,P,TS)',NULL,'\spad{internalLastSubResultant(lpwt,{} v,{} flag)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalLastSubResultant',5,'x','(P,P,TS,Boolean,Boolean)->List(Record(val:P,tower:TS))','pRegularTriangularSetGcdPackage(R,E,V,P,TS)',NULL,'\spad{internalLastSubResultant(p1,{} p2,{} ts,{} inv?,{} break?)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalSubPolSet?',2,'x','(List(P),List(P))->Boolean','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalSubPolSet?(lp1,{} lp2)} returns \spad{true} iff \spad{lp1} is a sub-set of \spad{lp2} assuming that these lists are sorted increasingly \spad{w}.\spad{r}.\spad{t}. \spadopFrom{infRittWu?}{RecursivePolynomialCategory}.');
INSERT INTO olibdb VALUES('o','internalSubPolSet?',2,'x','(List(P),List(P))->Boolean','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalSubPolSet?(lp1,{} lp2)} returns \spad{true} iff \spad{lp1} is a sub-set of \spad{lp2} assuming that these lists are sorted increasingly \spad{w}.\spad{r}.\spad{t}. \spadopFrom{infRittWu?}{RecursivePolynomialCategory}.');
INSERT INTO olibdb VALUES('o','internalSubQuasiComponent?',2,'x','(TS,TS)->Union(Boolean,failed)','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalSubQuasiComponent?(ts,{} us)} returns a boolean \spad{b} value if the fact that the regular zero set of \spad{us} contains that of \spad{ts} can be decided (and in that case \spad{b} gives this inclusion) otherwise returns \spad{failed}.');
INSERT INTO olibdb VALUES('o','internalSubQuasiComponent?',2,'x','(TS,TS)->Union(Boolean,failed)','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{internalSubQuasiComponent?(ts,{} us)} returns a boolean \spad{b} value if the fact the regular zero set of \spad{us} contains that of \spad{ts} can be decided (and in that case \spad{b} gives this inclusion) otherwise returns \spad{failed}.');
INSERT INTO olibdb VALUES('o','internalZeroSetSplit',4,'x','(List(P),Boolean,Boolean,Boolean)->List(%)','dRegularTriangularSet(R,E,V,P)',NULL,'\spad{internalZeroSetSplit(lp,{} b1,{} b2,{} b3)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','internalZeroSetSplit',4,'x','(List(P),Boolean,Boolean,Boolean)->List(%)','dSquareFreeRegularTriangularSet(R,E,V,P)',NULL,'\spad{internalZeroSetSplit(lp,{} b1,{} b2,{} b3)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','interpolate',2,'n','(List(F),List(F))->SparseUnivariatePolynomial(F)','pPolynomialInterpolation(xx,F)',NULL,'\spad{interpolate(lf,{} lg)} \undocumented');
INSERT INTO olibdb VALUES('o','interpolate',3,'n','(List(D),List(D),NonNegativeInteger)->Fraction(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{interpolate(xlist,{} ylist,{} deg)} returns the rational function with numerator degree at most \spad{deg} and denominator degree at most \spad{\#xlist-deg-1} that interpolates the given points using fraction free arithmetic. Note that rational interpolation does not guarantee that all given points are interpolated correctly: unattainable points may make this impossible.');
INSERT INTO olibdb VALUES('o','interpolate',3,'n','(List(Fraction(D)),List(Fraction(D)),NonNegativeInteger)->Fraction(SparseUnivariatePolynomial(D))','pFractionFreeFastGaussian(D,V)',NULL,'\spad{interpolate(xlist,{} ylist,{} deg)} returns the rational function with numerator degree \spad{deg} that interpolates the given points using fraction free arithmetic.');
INSERT INTO olibdb VALUES('o','interpolate',3,'n','(UnivariatePolynomial(xx,F),List(F),List(F))->UnivariatePolynomial(xx,F)','pPolynomialInterpolation(xx,F)',NULL,'\spad{interpolate(u,{} lf,{} lg)} \undocumented');
INSERT INTO olibdb VALUES('o','interpolate',4,'n','(List(F),List(F),NonNegativeInteger,NonNegativeInteger)->Fraction(Polynomial(F))','pRationalInterpolation(xx,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','interpret',1,'n','(%)->Any','dInputForm',NULL,'\spad{interpret(f)} passes \spad{f} to the interpreter.');
INSERT INTO olibdb VALUES('o','interpret',1,'n','(InputForm)->R','pInputFormFunctions1(R)',NULL,'\spad{interpret(f)} passes \spad{f} to the interpreter,{} and transforms the result into an object of type \spad{R}.');
INSERT INTO olibdb VALUES('o','interpret_in_new_env',1,'n','(%)->Any','dInputForm',NULL,'\spad{interpret_in_new_env(f)} evaluates \spad{f} in the interpreter using fresh environment which is discarded after evaluation');
INSERT INTO olibdb VALUES('o','interpretString',1,'n','(String)->Any','pTemplateUtilities',NULL,'\spad{interpretString(s)} treats a string as a piece of FriCAS input,{} by parsing and interpreting it.');
INSERT INTO olibdb VALUES('o','interReduce',1,'n','(List(P))->List(P)','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{interReduce(lp)} returns \spad{lq} such that \spad{lp} and \spad{lq} generate the same ideal and no polynomial in \spad{lq} is reducible by the others in the sense of Groebner bases. Since no assumptions are required the result may depend on the ordering the reductions are performed.');
INSERT INTO olibdb VALUES('o','intersect',1,'x','(List(%))->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{intersect(LI)} computes the intersection of the list of ideals \spad{LI}.');
INSERT INTO olibdb VALUES('o','intersect',2,'n','(A,A)->A','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','intersect',2,'n','(List(P),List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','intersect',2,'n','(List(P),S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','intersect',2,'n','(P,List(S))->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','intersect',2,'n','(P,S)->List(S)','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','intersect',2,'x','(%,%)->%','cSetAggregate(S)',NULL,'\spad{intersect(u,{} v)} returns the set aggregate \spad{w} consisting of elements common to both set aggregates \spad{u} and \spad{v}. Note: equivalent to the notation (not currently supported) [\spad{x} for \spad{x} in \spad{u} | member?(\spad{x},{} \spad{v})].');
INSERT INTO olibdb VALUES('o','intersect',2,'x','(%,%)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{intersect(I,{} J)} computes the intersection of the ideals \spad{I} and \spad{J}.');
INSERT INTO olibdb VALUES('o','intersect',2,'x','(List(P),%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{intersect(lp,{} ts)} returns \spad{lts} a split of Lazard of the intersection of the affine variety associated with \spad{lp} and the regular zero set of \spad{ts}.');
INSERT INTO olibdb VALUES('o','intersect',2,'x','(List(P),List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{intersect(lp,{} lts)} returns the same as \spad{concat([intersect(lp,{} ts) for ts in lts])|}');
INSERT INTO olibdb VALUES('o','intersect',2,'x','(P,%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{intersect(p,{} ts)} returns the same as \spad{intersect([p],{} ts)}');
INSERT INTO olibdb VALUES('o','intersect',2,'x','(P,List(%))->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{intersect(p,{} lts)} returns the same as \spad{intersect([p],{} lts)}');
INSERT INTO olibdb VALUES('o','intersection',1,'n','(List(%))->%','dSBoundary(PT)',NULL,'\spad{intersection(x)} constructs a compound boundary from the intersection of \spad{x} \spad{x:} List \% is supplied list of boundaries to form intersection.');
INSERT INTO olibdb VALUES('o','interval',1,'x','(Fraction(Integer))->%','cIntervalCategory(R)',NULL,'\spad{interval(f)} creates a new interval around \spad{f}.');
INSERT INTO olibdb VALUES('o','interval',1,'x','(R)->%','cIntervalCategory(R)',NULL,'\spad{interval(f)} creates a new interval around \spad{f}.');
INSERT INTO olibdb VALUES('o','interval',2,'n','(NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{interval(i,{} j)} creates list [\spad{i},{} \spad{i+1},{} ...,{} \spad{j}]');
INSERT INTO olibdb VALUES('o','interval',2,'x','(R,R)->%','cIntervalCategory(R)',NULL,'\spad{interval(inf,{} sup)} creates a new interval,{} either \spad{[inf,{} sup]} if \spad{inf <= sup} or \spad{[sup,{} inf]} otherwise.');
INSERT INTO olibdb VALUES('o','intoMatrix',2,'x','(List(P),List(OV))->Record(mat:Matrix(Fraction(P)),vec:Vector(Fraction(P)))','pLinearSystemPolynomialPackage(R,E,OV,P)',NULL,'\spad{intoMatrix(lp,{} lvar)} converts linear in symbols lvar system of polynomials \spad{lp} = 0 into matrix form');
INSERT INTO olibdb VALUES('o','inv',1,'n','(%)->%','dEuclideanModularRing(S,R,Mod,reduction,merge,exactQuo)',NULL,'\spad{inv(x)} \undocumented');
INSERT INTO olibdb VALUES('o','inv',1,'n','(%)->%','dModularRing(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{inv(x)} \undocumented');
INSERT INTO olibdb VALUES('o','inv',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inv',1,'n','(S)->S','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inv',1,'n','(S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inv',1,'n','(S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','inv',1,'n','(Vector(GF))->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{inv x} \undocumented{} See \spadfunFrom{inv}{DivisionRing}');
INSERT INTO olibdb VALUES('o','inv',1,'x','(%)->%','cDivisionRing',NULL,'\spad{inv x} returns the multiplicative inverse of \spad{x}. Error: if \spad{x} is 0.');
INSERT INTO olibdb VALUES('o','inv',1,'x','(%)->%','cGroup',NULL,'\spad{inv(x)} returns the inverse of \spad{x}.');
INSERT INTO olibdb VALUES('o','inv',1,'x','(%)->%','cOctonionCategory(R)','has(R,Field)','\spad{inv(o)} returns the inverse of \spad{o} if it exists.');
INSERT INTO olibdb VALUES('o','inv',1,'x','(%)->%','dEquation(S)','has(S,Field)','\spad{inv(x)} returns the multiplicative inverse of \spad{x}.');
INSERT INTO olibdb VALUES('o','inverse',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{inverse(f)} \spad{f^}-1 using invertMIN.');
INSERT INTO olibdb VALUES('o','inverse',1,'n','(List(S))->List(S)','pTableauxBumpers(S)',NULL,'\spad{inverse(ls)} forms the inverse of a sequence \spad{ls}');
INSERT INTO olibdb VALUES('o','inverse',1,'n','(M)->Union(M2,failed)','pInnerMatrixQuotientFieldFunctions(R,Row,Col,M,QF,Row2,Col2,M2)',NULL,'\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} failed is returned. Error: if the matrix is not square. Note: the result will have entries in the quotient field.');
INSERT INTO olibdb VALUES('o','inverse',1,'n','(M)->Union(M,failed)','pInnerMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} failed is returned. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','inverse',1,'x','(M)->Union(M,failed)','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,Field)','\spad{inverse(m)} returns the inverse of the matrix. If the matrix is not invertible,{} failed is returned. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','inverse',1,'x','(%)->Union(%,failed)','cMatrixCategory(R,Row,Col)','has(R,Field)','\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} failed is returned. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','inverse',1,'x','(%)->Union(%,failed)','cSquareMatrixCategory(ndim,R,Row,Col)','has(R,Field)','\spad{inverse(m)} returns the inverse of the matrix \spad{m},{} if that matrix is invertible and returns failed otherwise.');
INSERT INTO olibdb VALUES('o','inverseColeman',3,'x','(List(Integer),List(Integer),Matrix(Integer))->List(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{inverseColeman(alpha,{} beta,{} C)}: there is a bijection from the set of matrices having nonnegative entries and row sums {\em alpha},{} column sums {\em beta} to the set of {\em Salpha - Sbeta} double cosets of the symmetric group {\em Sn}. ({\em Salpha} is the Young subgroup corresponding to the improper partition {\em alpha}). For such a matrix \spad{C},{} inverseColeman(\spad{alpha},{} \spad{beta},{} \spad{C}) calculates the lexicographical smallest {\em \spad{pi}} in the corresponding double coset. Note: the resulting permutation {\em \spad{pi}} of {\em {1,{} 2,{} ...,{} n}} is given in list form. Notes: the inverse of this map is {\em coleman}. For details,{} see James/Kerber.');
INSERT INTO olibdb VALUES('o','inverse_cyclotomic',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pCyclotomicUtilities',NULL,'\spad{inverse_cyclotomic(n)} computes \spad{n}-th inverse cyclotomic polynomial,{} that is \spad{(x^n - 1)/cyclotomic(n)}.');
INSERT INTO olibdb VALUES('o','inverseIntegralMatrix',0,'x','()->Matrix(Fraction(UP))','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{inverseIntegralMatrix()} returns \spad{M} such that \spad{M (w1,{} ...,{} wn) = (1,{} y,{} ...,{} y^(n-1))} where \spad{(w1,{} ...,{} wn)} is the integral basis of \spadfunFrom{integralBasis}{FunctionFieldCategory}.');
INSERT INTO olibdb VALUES('o','inverseIntegralMatrixAtInfinity',0,'x','()->Matrix(Fraction(UP))','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{inverseIntegralMatrixAtInfinity()} returns \spad{M} such that \spad{M (v1,{} ...,{} vn) = (1,{} y,{} ...,{} y^(n-1))} where \spad{(v1,{} ...,{} vn)} is the local integral basis at infinity returned by \spad{infIntBasis()}.');
INSERT INTO olibdb VALUES('o','inverseLaplace',3,'x','(F,Symbol,Symbol)->Union(F,failed)','pInverseLaplaceTransform(R,F)',NULL,'\spad{inverseLaplace(f,{} s,{} t)} returns the Inverse Laplace transform of \spad{f(s)} using \spad{t} as the new variable or failed if unable to find a closed form. Handles only rational \spad{f(s)}.');
INSERT INTO olibdb VALUES('o','invertALS',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{invertALS(f)} computes \spad{f^}-1 in terms of the ALS for \spad{f}. There is no check if \spad{f} is invertible!');
INSERT INTO olibdb VALUES('o','invertible?',2,'x','(P,%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{invertible?(p,{} ts)} returns \spad{true} iff \spad{p} is invertible in the tower associated with \spad{ts}.');
INSERT INTO olibdb VALUES('o','invertible?',2,'x','(P,%)->List(Record(val:Boolean,tower:%))','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{invertible?(p,{} ts)} returns \spad{lbwt} where \spad{lbwt.i} is the result of \spad{invertibleElseSplit?(p,{} lbwt.i.tower)} and the list of the \spad{(lqrwt.i).tower} is a split of Kalkbrener of \spad{ts}.');
INSERT INTO olibdb VALUES('o','invertibleElseSplit?',2,'x','(P,%)->Union(Boolean,List(%))','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{invertibleElseSplit?(p,{} ts)} returns \spad{true} (resp. \spad{false}) if \spad{p} is invertible in the tower associated with \spad{ts} or returns a split of Kalkbrener of \spad{ts}.');
INSERT INTO olibdb VALUES('o','invertibleSet',2,'x','(P,%)->List(%)','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{invertibleSet(p,{} ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \spad{I} by \spad{p} where \spad{I} is the radical of saturated of \spad{ts}.');
INSERT INTO olibdb VALUES('o','invertIfCan',1,'x','(M)->Union(M,failed)','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,IntegralDomain)','\spad{invertIfCan(m)} returns the inverse of \spad{m} over \spad{R}');
INSERT INTO olibdb VALUES('o','invertIfCan',1,'x','(%)->Union(%,failed)','dMatrix(R)','has(R,IntegralDomain)','\spad{invertIfCan(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} failed is returned. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','invertMIN',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{invertMIN(f)} uses invertSTD(\spad{f}) and minimization to construct a minimal system for \spad{f^}-1. Linear techniques are used to get a fine pivot block structure.');
INSERT INTO olibdb VALUES('o','invertSTD',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{invertSTD(f)} computes the standard inverse of \spad{f} in terems of the admissible linear system There is no check if \spad{f} is invertible!');
INSERT INTO olibdb VALUES('o','invmod',2,'n','(S,S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','invmod',2,'x','(%,%)->%','cIntegerNumberSystem',NULL,'\spad{invmod(a,{} b)},{} \spad{0<=a<b>1},{} \spad{(a,{} b)=1} means \spad{1/a mod b}.');
INSERT INTO olibdb VALUES('o','invmultisect',3,'n','(Integer,Integer,%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','invmultisect',3,'n','(Integer,Integer,%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{invmultisect(a,{} b,{} f(x))} substitutes \spad{x^((a+b)*n)} \indented{1}{for \spad{x^n} and multiples by \spad{x^b}.}');
INSERT INTO olibdb VALUES('o','invmultisect',3,'n','(Integer,Integer,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{invmultisect(a,{} b,{} st)} substitutes \spad{x^((a+b)*n)} for \spad{x^n} and multiplies by \spad{x^b}.');
INSERT INTO olibdb VALUES('o','iomode',1,'x','(%)->String','cFileCategory(Name,S)',NULL,'\spad{iomode(f)} returns the status of the file \spad{f}. The input/output status of \spad{f} may be input,{} output or closed mode.');
INSERT INTO olibdb VALUES('o','Iota',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Iota()} returns symbol for capital greek letter iota.');
INSERT INTO olibdb VALUES('o','iota',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{iota()} returns symbol for small greek letter iota.');
INSERT INTO olibdb VALUES('o','ipow',1,'n','(List(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{ipow(l)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','iprint',1,'n','(String)->Void','pInternalPrintPackage',NULL,'\spad{iprint(s)} prints \spad{s} at the current position of the cursor.');
INSERT INTO olibdb VALUES('o','iroot',2,'n','(R,Integer)->F','pAlgebraicFunction(R,F)','has(R,RetractableTo(Integer))','\spad{iroot(p,{} n)} should be a non-exported function.');
INSERT INTO olibdb VALUES('o','irootDep',1,'x','(Kernel(F))->Union(vec:Vector(Fraction(Integer)),func:F,fail:Boolean)','pElementaryFunctionStructurePackage(R,F)',NULL,'\spad{irootDep(k)} is a local function with a conditional implementation.');
INSERT INTO olibdb VALUES('o','irreducible?',1,'n','(UP)->Boolean','pUnivariateFiniteFieldFactorize(F,UP)',NULL,'\spad{irreducible?(p)} tests if \spad{p} is irreducible.');
INSERT INTO olibdb VALUES('o','irreducible?',2,'n','(PA,MD)->Boolean','pModularFactorizationGeneral(PA,MMT,MD,PMD,MO)',NULL,'\spad{irreducible?(pv,{} md)} checks if \spad{pv} is irreducible. \spad{pv} is assumed square-free and monic,{} \spad{md} is info representing finite field.');
INSERT INTO olibdb VALUES('o','irreducible?',2,'n','(PrimitiveArray(K),Record(i_mod:Integer,deg:Integer))->Boolean','pModularFactorizationK(K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','irreducible?',2,'n','(U32Vector,Integer)->Boolean','pModularFactorization',NULL,NULL);
INSERT INTO olibdb VALUES('o','irreducibleFactor',2,'x','(R,NonNegativeInteger)->%','dFactored(R)',NULL,'\spad{irreducibleFactor(base,{} exponent)} creates a factored object with a single factor whose \spad{base} is asserted to be irreducible (flag = irred).');
INSERT INTO olibdb VALUES('o','irreducibleFactors',1,'n','(List(P))->List(P)','pPolynomialSetUtilitiesPackage(R,E,V,P)','AND(has(R,CharacteristicZero),has(R,PolynomialFactorizationExplicit))','\spad{irreducibleFactors(lp)} returns \spad{lf} such that if \spad{lp = [p1,{} ...,{} pn]} and \spad{lf = [f1,{} ...,{} fm]} then \spad{p1*p2*...*pn=0} means \spad{f1*f2*...*fm=0},{} and the \spad{\spad{fi}} are irreducible over \spad{R} and are pairwise distinct.');
INSERT INTO olibdb VALUES('o','irreducibleRepresentation',1,'x','(List(Integer))->List(Matrix(Integer))','pIrrRepSymNatPackage',NULL,'\spad{irreducibleRepresentation(lambda)} is the list of the two irreducible representations corresponding to the partition {\em lambda} in Young\spad{''s} natural form for the following two generators of the symmetric group,{} whose elements permute {\em {1,{} 2,{} ...,{} n}},{} namely {\em (1 2)} (2-cycle) and {\em (1 2 ... n)} (\spad{n}-cycle).');
INSERT INTO olibdb VALUES('o','irreducibleRepresentation',2,'x','(List(Integer),List(Permutation(Integer)))->List(Matrix(Integer))','pIrrRepSymNatPackage',NULL,'\spad{irreducibleRepresentation(lambda,{} listOfPerm)} is the list of the irreducible representations corresponding to {\em lambda} in Young\spad{''s} natural form for the list of permutations given by {\em listOfPerm}.');
INSERT INTO olibdb VALUES('o','irreducibleRepresentation',2,'x','(List(Integer),Permutation(Integer))->Matrix(Integer)','pIrrRepSymNatPackage',NULL,'\spad{irreducibleRepresentation(lambda,{} \spad{pi})} is the irreducible representation corresponding to partition {\em lambda} in Young\spad{''s} natural form of the permutation {\em \spad{pi}} in the symmetric group,{} whose elements permute {\em {1,{} 2,{} ...,{} n}}.');
INSERT INTO olibdb VALUES('o','is?',2,'n','(%,BasicOperator)->Boolean','cKernelCategory(S)',NULL,'\spad{is?(op(a1,{} ...,{} an),{} f)} tests if op = \spad{f}.');
INSERT INTO olibdb VALUES('o','is?',2,'n','(S,BasicOperator)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','is?',2,'n','(S,Symbol)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','is?',2,'n','(%,Symbol)->Boolean','cKernelCategory(S)',NULL,'\spad{is?(op(a1,{} ...,{} an),{} s)} tests if the name of op is \spad{s}.');
INSERT INTO olibdb VALUES('o','is?',2,'x','(%,BasicOperator)->Boolean','cExpressionSpace2(K)',NULL,'\spad{is?(x,{} op)} tests if \spad{x} is a kernel and if its operator is op.');
INSERT INTO olibdb VALUES('o','is?',2,'x','(List(Subject),Pat)->Boolean','pPatternMatch(Base,Subject,Pat)',NULL,'\spad{is?([e1,{} ...,{} en],{} pat)} tests if the list of expressions \spad{[e1,{} ...,{} en]} matches the pattern pat.');
INSERT INTO olibdb VALUES('o','Is',2,'x','(List(Subject),Pat)->PatternMatchListResult(Base,Subject,List(Subject))','pPatternMatch(Base,Subject,Pat)',NULL,'\spad{Is([e1,{} ...,{} en],{} pat)} matches the pattern pat on the list of expressions \spad{[e1,{} ...,{} en]} and returns the result.');
INSERT INTO olibdb VALUES('o','is?',2,'x','(Subject,Pat)->Boolean','pPatternMatch(Base,Subject,Pat)',NULL,'\spad{is?(expr,{} pat)} tests if the expression \spad{expr} matches the pattern pat.');
INSERT INTO olibdb VALUES('o','Is',2,'x','(Subject,Pat)->List(Equation(Polynomial(Subject)))','pPatternMatch(Base,Subject,Pat)','AND(has(Subject,Ring),not(has(Subject,RetractableTo(Symbol))))','\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a list of matches \spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty list if either \spad{expr} is exactly equal to pat or if pat does not match \spad{expr}.');
INSERT INTO olibdb VALUES('o','Is',2,'x','(Subject,Pat)->List(Equation(Subject))','pPatternMatch(Base,Subject,Pat)','has(Subject,RetractableTo(Symbol))','\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a list of matches \spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty list if either \spad{expr} is exactly equal to pat or if pat does not match \spad{expr}.');
INSERT INTO olibdb VALUES('o','Is',2,'x','(Subject,Pat)->PatternMatchResult(Base,Subject)','pPatternMatch(Base,Subject,Pat)','AND(not(has(Subject,RetractableTo(Symbol))),not(has(Subject,Ring)))','\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a match of the form \spad{[v1 = e1,{} ...,{} vn = en]}; returns an empty match if \spad{expr} is exactly equal to pat. returns a \spadfun{failed} match if pat does not match \spad{expr}.');
INSERT INTO olibdb VALUES('o','is?',2,'x','(%,Symbol)->Boolean','cExpressionSpace2(K)',NULL,'\spad{is?(x,{} s)} tests if \spad{x} is a kernel and if the name of its operator is \spad{s}.');
INSERT INTO olibdb VALUES('o','is?',2,'x','(%,Symbol)->Boolean','dBasicOperator',NULL,'\spad{is?(op,{} s)} tests if the name of \spad{op} is \spad{s}.');
INSERT INTO olibdb VALUES('o','isAbsolutelyIrreducible?',1,'x','(List(Matrix(R)))->Boolean','pRepresentationPackage2(R)','has(R,Field)','\spad{isAbsolutelyIrreducible?(aG)} calls {\em isAbsolutelyIrreducible?(aG,{} 25)}. Note: the choice of 25 was rather arbitrary.');
INSERT INTO olibdb VALUES('o','isAbsolutelyIrreducible?',2,'x','(List(Matrix(R)),Integer)->Boolean','pRepresentationPackage2(R)','has(R,Field)','\spad{isAbsolutelyIrreducible?(aG,{} numberOfTries)} uses Norton\spad{''s} irreducibility test to check for absolute irreduciblity,{} assuming if a one-dimensional kernel is found. As no field extension changes create new elements in a one-dimensional space,{} the criterium stays \spad{true} for every extension. The method looks for one-dimensionals only by creating random elements (no fingerprints) since a run of {\em meatAxe} would have proved absolute irreducibility anyway.');
INSERT INTO olibdb VALUES('o','isAcyclic?',1,'n','(A)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isAcyclic?',1,'n','(%)->Boolean','cFiniteGraph(S)',NULL,'\spad{isAcyclic?(s)} returns \spad{true} if there are no loops');
INSERT INTO olibdb VALUES('o','isAntiChain?',1,'n','(%)->Boolean','cPoset(S)',NULL,'\spad{isAntiChain?(s)} checks if \spad{s} is an antichain,{} that is any two elements in \spad{s} are incomparable.');
INSERT INTO olibdb VALUES('o','isBasis?',1,'n','(List(Vector(R)))->Boolean','dVectorSpaceBasis(R)',NULL,'\spad{isBasis? Lv} tests for linear independence of a list of vectors.');
INSERT INTO olibdb VALUES('o','isBoundNode?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'introspection: returns \spad{true} if this is a bound leaf node');
INSERT INTO olibdb VALUES('o','isBox?',1,'n','(%)->Boolean','dSBoundary(PT)',NULL,'\spad{isBox?(n)} returns \spad{true} if this is a rectangular boundary.');
INSERT INTO olibdb VALUES('o','isChain?',1,'n','(%)->Boolean','cPoset(S)',NULL,'\spad{isChain?(s)} checks if \spad{s} is a chain,{} that is any two elements in \spad{s} are comparable.');
INSERT INTO olibdb VALUES('o','isCompound?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'introspection: returns \spad{true} if this is a compound term containing two nodes');
INSERT INTO olibdb VALUES('o','isDirected?',0,'n','()->Boolean','cFiniteGraph(S)',NULL,'\spad{isDirected?()} is \spad{true} iff \% is domain consisting of directed graphs,{} \spad{false} for undirected graphs.');
INSERT INTO olibdb VALUES('o','isDirected?',0,'n','()->Boolean','xFiniteGraph&(A,S)',NULL,'\spad{isDirected?()} is \spad{true} iff \% is domain consisting of directed graphs,{} \spad{false} for undirected graphs.');
INSERT INTO olibdb VALUES('o','isDirected?',0,'n','()->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isDirectSuccessor?',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isDirectSuccessor?',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isDirectSuccessor?',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Boolean','cFiniteGraph(S)',NULL,'\spad{isDirectSuccessor?(s,{} a,{} b)} is \spad{true} if \spad{''b''} is a direct successor of ''a'' that is,{} if there is a direct arrow from ''a'' to \spad{''b''}');
INSERT INTO olibdb VALUES('o','isEllipse?',1,'n','(%)->Boolean','dSBoundary(PT)',NULL,'\spad{isEllipse?(n)} returns \spad{true} if this is a ellipsoid boundary.');
INSERT INTO olibdb VALUES('o','isExpt',1,'n','(F)->Union(Record(var:V,exponent:Integer),failed)','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{isExpt(p)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','isExpt',1,'n','(S)->Union(Record(var:K,exponent:Integer),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isExpt',1,'n','(S)->Union(Record(var:VarSet,exponent:NonNegativeInteger),failed)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isExpt',1,'n','(%)->Union(Record(val:%,exponent:NonNegativeInteger),failed)','dPattern(R)',NULL,'\spad{isExpt(p)} returns \spad{[q,{} n]} if \spad{n > 0} and \spad{p = q ^ n},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isExpt',1,'x','(%)->Union(Record(var:K,exponent:Integer),failed)','cFunctionSpace2(R,K)','has(R,SemiGroup)','\spad{isExpt(p)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0}.');
INSERT INTO olibdb VALUES('o','isExpt',1,'x','(%)->Union(Record(var:VarSet,exponent:NonNegativeInteger),failed)','cPolynomialCategory(R,E,VarSet)','has(R,SemiRing)','\spad{isExpt(p)} returns \spad{[x,{} n]} if polynomial \spad{p} has the form \spad{x^n} and \spad{n > 0}.');
INSERT INTO olibdb VALUES('o','isExpt',2,'n','(S,BasicOperator)->Union(Record(var:K,exponent:Integer),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isExpt',2,'n','(S,Symbol)->Union(Record(var:K,exponent:Integer),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isExpt',2,'x','(%,BasicOperator)->Union(Record(var:K,exponent:Integer),failed)','cFunctionSpace2(R,K)','has(R,Ring)','\spad{isExpt(p,{} op)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0} and \spad{x = op(a)}.');
INSERT INTO olibdb VALUES('o','isExpt',2,'x','(%,Symbol)->Union(Record(var:K,exponent:Integer),failed)','cFunctionSpace2(R,K)','has(R,Ring)','\spad{isExpt(p,{} f)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0} and \spad{x = f(a)}.');
INSERT INTO olibdb VALUES('o','isFixPoint?',2,'n','(A,NonNegativeInteger)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isFixPoint?',2,'n','(A,NonNegativeInteger)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isFixPoint?',2,'n','(%,NonNegativeInteger)->Boolean','cFiniteGraph(S)',NULL,'\spad{isFixPoint?(s,{} a)} is \spad{true} if ''a'' has an arrow to itself');
INSERT INTO olibdb VALUES('o','isFreeNode?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'introspection: returns \spad{true} if this is a unbound leaf node');
INSERT INTO olibdb VALUES('o','isFunctional?',1,'n','(A)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isFunctional?',1,'n','(%)->Boolean','cFiniteGraph(S)',NULL,'\spad{isFunctional?(s)} returns \spad{true} if \spad{s} is a functional graph,{} that is a directed graph in which each vertex has a single outgoing arrow.');
INSERT INTO olibdb VALUES('o','isGreaterThan?',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isGreaterThan?',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isGreaterThan?',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Boolean','cFiniteGraph(S)',NULL,'\spad{isGreaterThan?(s,{} a,{} b)} is \spad{true} if we can get from vertex ''a'' to \spad{''b''} through a sequence of arrows but we can\spad{''t} go in the opposite direction from \spad{''b''} to ''a''');
INSERT INTO olibdb VALUES('o','isI?',1,'n','(%)->Boolean','dSKICombinators(UT)',NULL,'returns \spad{true} if this is an \spad{I} combinator node');
INSERT INTO olibdb VALUES('o','isK?',1,'n','(%)->Boolean','dSKICombinators(UT)',NULL,'returns \spad{true} if this is a \spad{K} combinator node');
INSERT INTO olibdb VALUES('o','isLambda?',1,'n','(%)->Boolean','dLambda(UT)',NULL,'introspection: returns \spad{true} if this is a lambda definition');
INSERT INTO olibdb VALUES('o','isList',1,'n','(%)->Union(List(%),failed)','dPattern(R)',NULL,'\spad{isList(p)} returns \spad{[a1,{} ...,{} an]} if \spad{p = [a1,{} ...,{} an]},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','isMult',1,'n','(S)->Union(Record(coef:Integer,var:K),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isMult',1,'x','(%)->Union(Record(coef:Integer,var:K),failed)','cFunctionSpace2(R,K)','has(R,AbelianSemiGroup)','\spad{isMult(p)} returns \spad{[n,{} x]} if \spad{p = n * x} and \spad{n ~= 0}.');
INSERT INTO olibdb VALUES('o','isNodeBranch?',1,'n','(%)->Boolean','dSceneNamedPoints(PT)',NULL,'\spad{isNodeBranch?(n)} returns \spad{true} if this is a branch.');
INSERT INTO olibdb VALUES('o','isNodeLeaf?',1,'n','(%)->Boolean','dSceneNamedPoints(PT)',NULL,'\spad{isNodeLeaf?(n)} returns \spad{true} if this is a leaf which holds Scene nodes.');
INSERT INTO olibdb VALUES('o','isNull?',1,'n','(%)->Boolean','dSBoundary(PT)',NULL,'\spad{isNull?(n)} returns \spad{true} if this is a null boundary,{} that is no boundary');
INSERT INTO olibdb VALUES('o','isobaric?',1,'n','(A)->Boolean','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isobaric?',1,'x','(%)->Boolean','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{isobaric?(p)} returns \spad{true} if every differential monomial appearing in the differential polynomial \spad{p} has same weight,{} and returns \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','isOp',1,'n','(%)->Union(Record(op:BasicOperator,arg:List(%)),failed)','dPattern(R)',NULL,'\spad{isOp(p)} returns \spad{[op,{} [a1,{} ...,{} an]]} if \spad{p = op(a1,{} ...,{} an)},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isOp',2,'n','(%,BasicOperator)->Union(List(%),failed)','dPattern(R)',NULL,'\spad{isOp(p,{} op)} returns \spad{[a1,{} ...,{} an]} if \spad{p = op(a1,{} ...,{} an)},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isPlus',1,'n','(F)->Union(List(F),failed)','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{isPlus(p)} returns [\spad{m1},{} ...,{} \spad{mn}] if \spad{p = m1 + ... + mn} and \spad{n > 1},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','isPlus',1,'n','(S)->Union(List(S),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isPlus',1,'n','(S)->Union(List(S),failed)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isPlus',1,'n','(%)->Union(List(%),failed)','dPattern(R)',NULL,'\spad{isPlus(p)} returns \spad{[a1,{} ...,{} an]} if \spad{n > 1} \indented{1}{and \spad{p = a1 + ... + an},{}} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isPlus',1,'x','(%)->Union(List(%),failed)','cFunctionSpace2(R,K)','has(R,AbelianSemiGroup)','\spad{isPlus(p)} returns \spad{[m1,{} ...,{} mn]} if \spad{p = m1 +...+ mn} and \spad{n > 1}.');
INSERT INTO olibdb VALUES('o','isPlus',1,'x','(%)->Union(List(%),failed)','cPolynomialCategory(R,E,VarSet)',NULL,'\spad{isPlus(p)} returns \spad{[m1,{} ...,{} mn]} if polynomial \spad{p = m1 + ... + mn} and \spad{n >= 2} and each \spad{mi} is a nonzero monomial.');
INSERT INTO olibdb VALUES('o','isPoint?',1,'n','(%)->Boolean','cSPointCategory',NULL,'\spad{isPoint?(p)} returns \spad{true} if this represents a point as opposed to a vector.');
INSERT INTO olibdb VALUES('o','isPointLeaf?',1,'n','(%)->Boolean','dSceneNamedPoints(PT)',NULL,'\spad{isPointLeaf?(n)} returns \spad{true} if this is a \spad{pt} node,{} that is,{} if this node contains points');
INSERT INTO olibdb VALUES('o','isPower',1,'n','(F)->Union(Record(val:F,exponent:Integer),failed)','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{isPower(p)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','isPower',1,'n','(S)->Union(Record(val:S,exponent:Integer),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isPower',1,'n','(%)->Union(Record(val:%,exponent:%),failed)','dPattern(R)',NULL,'\spad{isPower(p)} returns \spad{[a,{} b]} if \spad{p = a ^ b},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isPower',1,'x','(%)->Union(Record(val:%,exponent:Integer),failed)','cFunctionSpace2(R,K)','has(R,Ring)','\spad{isPower(p)} returns \spad{[x,{} n]} if \spad{p = x^n} and \spad{n ~= 0}.');
INSERT INTO olibdb VALUES('o','isQuotient',1,'n','(%)->Union(Record(num:%,den:%),failed)','dPattern(R)',NULL,'\spad{isQuotient(p)} returns \spad{[a,{} b]} if \spad{p = a / b},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isS?',1,'n','(%)->Boolean','dSKICombinators(UT)',NULL,'returns \spad{true} if this is a \spad{S} combinator node');
INSERT INTO olibdb VALUES('o','isSubsetOf?',2,'n','(%,%)->Boolean','dOrientedFacet',NULL,'returns \spad{true} if face ''a'' is contained in face \spad{''b''}. \spad{true} subset only : returns \spad{false} if a=b');
INSERT INTO olibdb VALUES('o','is_symbol?',2,'n','(OutputForm,Symbol)->Boolean','pOutputFormTools',NULL,'\spad{is_symbol?(f,{} s)} returns \spad{true} if form is symbol \spad{s},{} otherwise returns \spad{false}');
INSERT INTO olibdb VALUES('o','isTimes',1,'n','(F)->Union(List(F),failed)','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{isTimes(p)} returns \spad{[a1,{} ...,{} an]} if \spad{p = a1 ... an} and \spad{n > 1},{} failed otherwise.');
INSERT INTO olibdb VALUES('o','isTimes',1,'n','(S)->Union(List(S),failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isTimes',1,'n','(S)->Union(List(S),failed)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','isTimes',1,'n','(%)->Union(List(%),failed)','dPattern(R)',NULL,'\spad{isTimes(p)} returns \spad{[a1,{} ...,{} an]} if \spad{n > 1} and \spad{p = a1 * ... * an},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','isTimes',1,'x','(%)->Union(List(%),failed)','cFunctionSpace2(R,K)','has(R,SemiGroup)','\spad{isTimes(p)} returns \spad{[a1,{} ...,{} an]} if \spad{p = a1*...*an} and \spad{n > 1}.');
INSERT INTO olibdb VALUES('o','isTimes',1,'x','(%)->Union(List(%),failed)','cPolynomialCategory(R,E,VarSet)','has(R,SemiRing)','\spad{isTimes(p)} returns \spad{[a1,{} ...,{} an]} if polynomial \spad{p = a1 ... an} and \spad{n >= 2},{} and,{} for each \spad{i},{} \spad{ai} is either a nontrivial constant in \spad{R} or else of the form \spad{x^e},{} where \spad{e > 0} is an integer and \spad{x} is a member of VarSet.');
INSERT INTO olibdb VALUES('o','isVector?',1,'n','(%)->Boolean','cSPointCategory',NULL,'\spad{isVector? returns} \spad{true} if this represents a vector as opposed to a point.');
INSERT INTO olibdb VALUES('o','iter',3,'n','((A)->A,NonNegativeInteger,A)->A','pMappingPackageInternalHacks1(A)',NULL,'\spad{iter(f,{} n,{} x)} applies \spad{f} \spad{n} times to \spad{x}.');
INSERT INTO olibdb VALUES('o','iteratedInitials',1,'n','(S)->List(S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','iteratedInitials',1,'x','(%)->List(%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{iteratedInitials(p)} returns \spad{[]} if \spad{p} belongs to \spad{R},{} otherwise returns the list of the iterated initials of \spad{p}.');
INSERT INTO olibdb VALUES('o','jacobi2poly',2,'n','(Stream(R),Stream(R))->Stream(SparseUnivariatePolynomial(R))','pMomentPackage(R)',NULL,'\spad{jacobi2poly(aa,{} bb)} returns the stream of orthogonal polynomials corresponding to the Jacobi parameters \spad{a_n} and \spad{b_n}.');
INSERT INTO olibdb VALUES('o','jacobi',2,'x','(Integer,Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{jacobi(a,{} b)} returns the Jacobi symbol \spad{J(a/b)}. When \spad{b} is odd,{} \spad{J(a/b) = product(L(a/p) for p in factor b )}. Note: by convention,{} 0 is returned if \spad{gcd(a,{} b) ~= 1}. Iterative \spad{O(log(b)^2)} version coded by Michael Monagan June 1987.');
INSERT INTO olibdb VALUES('o','jacobian',2,'n','(FLAF,FLAS)->Matrix(F)','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{jacobian(vf,{} xlist)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in xlist.');
INSERT INTO olibdb VALUES('o','jacobiCn',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiCn(z,{} m)} is the Jacobi elliptic \spad{cn} function,{} defined by \spad{jacobiCn(z,{} m)^2 + jacobiSn(z,{} m)^2 = 1} and \spad{jacobiCn(0,{} m) = 1}.');
INSERT INTO olibdb VALUES('o','jacobiCn',2,'n','(UTS,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)',NULL,'\spad{jacobiCn(z,{} m)} expands the elliptic function \spad{cn} as a Taylor \indented{1}{series in \spad{z}.}');
INSERT INTO olibdb VALUES('o','jacobiCn',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{jacobiCn(z,{} m)} is the Jacobi \spad{cn} function');
INSERT INTO olibdb VALUES('o','jacobiCn',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiCn(z,{} m)} is the Jacobi elliptic \spad{cn} function,{} defined by \spad{jacobiCn(z,{} m)^2 + jacobiSn(z,{} m)^2 = 1} and \spad{jacobiCn(0,{} m) = 1}.');
INSERT INTO olibdb VALUES('o','jacobiCn',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{jacobiCn(z,{} m)} is the Jacobi \spad{cn} function');
INSERT INTO olibdb VALUES('o','jacobiDn',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiDn(z,{} m)} is the Jacobi elliptic \spad{dn} function,{} defined by \spad{jacobiDn(z,{} m)^2 + m*jacobiSn(z,{} m)^2 = 1} and \spad{jacobiDn(0,{} m) = 1}.');
INSERT INTO olibdb VALUES('o','jacobiDn',2,'n','(UTS,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)',NULL,'\spad{jacobiDn(z,{} m)} expands the elliptic function \spad{dn} as a Taylor \indented{1}{series in \spad{z}.}');
INSERT INTO olibdb VALUES('o','jacobiDn',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{jacobiDn(z,{} m)} is the Jacobi \spad{dn} function');
INSERT INTO olibdb VALUES('o','jacobiDn',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiDn(z,{} m)} is the Jacobi elliptic \spad{dn} function,{} defined by \spad{jacobiDn(z,{} m)^2 + m*jacobiSn(z,{} m)^2 = 1} and \spad{jacobiDn(0,{} m) = 1}.');
INSERT INTO olibdb VALUES('o','jacobiDn',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{jacobiDn(z,{} m)} is the Jacobi \spad{dn} function');
INSERT INTO olibdb VALUES('o','jacobiIdentity?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{jacobiIdentity?()} tests if \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors.');
INSERT INTO olibdb VALUES('o','jacobiIdentity?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{jacobiIdentity?()} tests if \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors.');
INSERT INTO olibdb VALUES('o','jacobiMatrix',1,'n','(List(%))->SparseEchelonMatrix(JB,%)','cJetBundleFunctionCategory(JB)',NULL,'\spad{jacobiMatrix(sys)} constructs the Jacobi matrix of the family \spad{sys} of functions.');
INSERT INTO olibdb VALUES('o','jacobiMatrix',1,'n','(%)->List(SparseEchelonMatrix(JB,D))','dJetDifferentialEquation(JB,D)',NULL,'\spad{jacobiMatrix(De)} returns a list of Jacobi matrices sorted by the order of the equations.');
INSERT INTO olibdb VALUES('o','jacobiMatrix',1,'n','(List(S))->SparseEchelonMatrix(JB,S)','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','jacobiMatrix',2,'n','(List(%),List(List(JB)))->SparseEchelonMatrix(JB,%)','cJetBundleFunctionCategory(JB)',NULL,'\spad{jacobiMatrix(sys,{} jvars)} constructs the Jacobi matrix of the family \spad{sys} of functions. \spad{jvars} contains for each function the effectively occurring jet variables. The columns of the matrix are ordered.');
INSERT INTO olibdb VALUES('o','jacobiMatrix',2,'n','(List(S),List(List(JB)))->SparseEchelonMatrix(JB,S)','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','jacobiP',4,'n','(F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiP(n,{} a,{} b,{} z)} is the Jacobi polynomial.');
INSERT INTO olibdb VALUES('o','jacobiP',4,'x','(%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiP(n,{} a,{} b,{} z)} is the Jacobi polynomial.');
INSERT INTO olibdb VALUES('o','jacobiParameters',1,'n','(%)->Record(an:Stream(Fraction(R)),bn:Stream(Fraction(R)))','cDistributionCategory(R)','AND(has(R,IntegralDomain),not(has(R,Field)))','\spad{jacobiParameters(x)} returns the pair of streams of Jacobi parameters of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','jacobiParameters',1,'n','(%)->Record(an:Stream(R),bn:Stream(R))','cDistributionCategory(R)','has(R,Field)','\spad{jacobiParameters(x)} returns the pair of streams of Jacobi parameters of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','jacobiPathArray',2,'n','(Stream(R),Stream(R))->Stream(List(R))','pPathArrayPackage(R)',NULL,'\spad{jacobiPathArray([b0,{} b1,{} ...],{} [c1,{} c2,{} ...])} computes Flajolet\spad{''s} Motzkin path array from the sequences [1,{} 1,{} ...],{} \spad{bi},{} \spad{ci}.');
INSERT INTO olibdb VALUES('o','jacobiSn',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiSn(z,{} m)} is the Jacobi elliptic \spad{sn} function,{} defined by the formula \spad{jacobiSn(ellipticF(z,{} m),{} m) = z}.');
INSERT INTO olibdb VALUES('o','jacobiSn',2,'n','(UTS,Coef)->UTS','pEllipticFunctionsUnivariateTaylorSeries(Coef,UTS)',NULL,'\spad{jacobiSn(z,{} m)} expands the elliptic function \spad{sn} as a Taylor \indented{1}{series in \spad{z}.}');
INSERT INTO olibdb VALUES('o','jacobiSn',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{jacobiSn(z,{} m)} is the Jacobi \spad{sn} function');
INSERT INTO olibdb VALUES('o','jacobiSn',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiSn(z,{} m)} is the Jacobi elliptic \spad{sn} function,{} defined by the formula \spad{jacobiSn(ellipticF(z,{} m),{} m) = z}.');
INSERT INTO olibdb VALUES('o','jacobiSn',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{jacobiSn(z,{} m)} is the Jacobi \spad{sn} function');
INSERT INTO olibdb VALUES('o','jacobiTheta',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiTheta(z,{} m)} is the Jacobi Theta function in Jacobi notation.');
INSERT INTO olibdb VALUES('o','jacobiTheta',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiTheta(z,{} m)} is the Jacobi Theta function in Jacobi notation.');
INSERT INTO olibdb VALUES('o','jacobiZeta',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{jacobiZeta(z,{} m)} is the Jacobi elliptic zeta function,{} defined by \spad{D(jacobiZeta(z,{} m),{} z) = jacobiDn(z,{} m)^2 - ellipticE(m)/ellipticK(m)} and \spad{jacobiZeta(0,{} m) = 0}.');
INSERT INTO olibdb VALUES('o','jacobiZeta',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{jacobiZeta(z,{} m)} is the Jacobi elliptic zeta function,{} defined by \spad{D(jacobiZeta(z,{} m),{} z) = jacobiDn(z,{} m)^2 - ellipticE(m)/ellipticK(m)} and \spad{jacobiZeta(0,{} m) = 0}.');
INSERT INTO olibdb VALUES('o','jacobiZeta',2,'x','(Float,Float)->Float','pFloatEllipticFunctions',NULL,'\spad{jacobiZeta(z,{} m)} is the Jacobi zeta function');
INSERT INTO olibdb VALUES('o','janko2',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{janko2 constructs} the janko group acting on the integers 1,{} ...,{} 100.');
INSERT INTO olibdb VALUES('o','janko2',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{janko2(\spad{li})} constructs the janko group acting on the 100 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 100 different entries');
INSERT INTO olibdb VALUES('o','JContinuedFraction',2,'x','(Distribution(R),UnivariatePolynomial(z,Fraction(R)))->ContinuedFraction(UnivariatePolynomial(z,Fraction(R)))','pDistributionContinuedFractionPackage(R,z)','AND(has(R,IntegralDomain),not(has(R,Field)))','\spad{JContinuedFraction(d,{} z)} returns the Cauchy transform as a continued fraction at \spad{z}.');
INSERT INTO olibdb VALUES('o','JContinuedFraction',2,'x','(Distribution(R),UnivariatePolynomial(z,R))->ContinuedFraction(UnivariatePolynomial(z,R))','pDistributionContinuedFractionPackage(R,z)','has(R,Field)','\spad{JContinuedFraction(d,{} z)} returns the Cauchy transform as a continued fraction at \spad{z}.');
INSERT INTO olibdb VALUES('o','jetVariables',1,'n','(%)->List(JB)','cJetBundleFunctionCategory(JB)',NULL,'\spad{jetVariables(f)} yields all jet variables effectively occurring in \spad{f} in an ordered list.');
INSERT INTO olibdb VALUES('o','join',1,'n','(List(%))->%','dLatticeJoinOfMeets',NULL,'\spad{join of} set of elements');
INSERT INTO olibdb VALUES('o','join',1,'n','(List(%))->%','dLatticeMeetOfJoins',NULL,'\spad{join of} set of elements');
INSERT INTO olibdb VALUES('o','join',2,'n','(%,%)->%','dJetDifferentialEquation(JB,D)',NULL,'\spad{join(de1,{} de2)} combines \spad{de1} and \spad{de2} to a single differential equation.');
INSERT INTO olibdb VALUES('o','join',2,'n','(%,%)->%','dOrientedFacet',NULL,'used by simplicialJoin. Returns join (union) of ''a'' and \spad{''b''}. That is: returns a facet containing indexes in both ''a'' and \spad{''b''}.');
INSERT INTO olibdb VALUES('o','join',2,'n','(%,%)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{join(A,{} B)} vertically concats the matrices \spad{A} and \spad{B}.');
INSERT INTO olibdb VALUES('o','join',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','cDcpo(S)',NULL,'returns the join of ''a'' and \spad{''b''} In this version of join nodes are represented as index values. Not every poset will have a join but DCPO will.');
INSERT INTO olibdb VALUES('o','joinIfCan',2,'n','(A,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','joinIfCan',2,'n','(%,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{joinIfCan returns} the join of a subset of lattice given by list of elements.');
INSERT INTO olibdb VALUES('o','joinIfCan',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','joinIfCan',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{joinIfCan(s,{} a,{} b)} returns the join of ''a'' and \spad{''b''} In this version of join nodes are represented as index values. In the general case,{} not every poset will have a join in which case failed will be returned as an error indication.');
INSERT INTO olibdb VALUES('o','jordanAdmissible?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \spadignore{i.e.} satisfies the Jordan identity. The property of \spadtype{CommutativeStar} follows from by definition.');
INSERT INTO olibdb VALUES('o','jordanAdmissible?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \spadignore{i.e.} satisfies the Jordan identity. The property of \spadtype{CommutativeStar} follows from by definition.');
INSERT INTO olibdb VALUES('o','jordanAlgebra?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra (Jordan identity). Example: for every associative algebra \spad{(A,{} +,{} @)} we can construct a Jordan algebra \spad{(A,{} +,{} *)},{} where \spad{a*b := (a@b+b@a)/2}.');
INSERT INTO olibdb VALUES('o','jordanAlgebra?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \spad{(a*b)*a^2 - a*(b*a^2) = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra (Jordan identity). Example: for every associative algebra \spad{(A,{} +,{} @)} we can construct a Jordan algebra \spad{(A,{} +,{} *)},{} where \spad{a*b := (a@b+b@a)/2}.');
INSERT INTO olibdb VALUES('o','K',0,'n','()->%','dSKICombinators(UT)',NULL,'Constructs a \spad{K} combinator');
INSERT INTO olibdb VALUES('o','Kappa',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Kappa()} returns symbol for capital greek letter kappa.');
INSERT INTO olibdb VALUES('o','kappa',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{kappa()} returns symbol for small greek letter kappa.');
INSERT INTO olibdb VALUES('o','karatsuba',4,'x','(U,U,NonNegativeInteger,NonNegativeInteger)->U','pUnivariatePolynomialMultiplicationPackage(R,U)',NULL,'\spad{karatsuba(a,{} b,{} l,{} k)} returns \spad{a*b} by applying Karatsuba\spad{''s} trick provided that both \spad{a} and \spad{b} have at least \spad{l} terms and \spad{k > 0} holds and by calling \spad{noKaratsuba} otherwise. The other multiplications are performed by recursive calls with the same third argument and \spad{k-1} as fourth argument.');
INSERT INTO olibdb VALUES('o','karatsubaDivide',2,'x','(%,NonNegativeInteger)->Record(quotient:%,remainder:%)','cUnivariatePolynomialCategory(R)','has(R,Ring)','\spad{karatsubaDivide(p,{} n)} returns the same as \spad{monicDivide(p,{} monomial(1,{} n))}');
INSERT INTO olibdb VALUES('o','karatsubaOnce',2,'x','(U,U)->U','pUnivariatePolynomialMultiplicationPackage(R,U)',NULL,'\spad{karatsuba(a,{} b)} returns \spad{a*b} by applying Karatsuba\spad{''s} trick once. The other multiplications are performed by calling \spad{*} from \spad{U}.');
INSERT INTO olibdb VALUES('o','kelvinBei',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kelvinBei(v,{} z)} is the Kelvin bei function defined by equality. \spad{kelvinBei(v,{} z) = imag(besselJ(v,{} exp(3*\%pi*\%i/4)*z))}. for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinBei',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kelvinBei(v,{} z)} is the Kelvin bei function defined by equality \spad{kelvinBei(v,{} z) = imag(besselJ(v,{} exp(3*\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinBer',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kelvinBer(v,{} z)} is the Kelvin ber function defined by equality \spad{kelvinBer(v,{} z) = real(besselJ(v,{} exp(3*\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinBer',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kelvinBer(v,{} z)} is the Kelvin ber function defined by equality \spad{kelvinBer(v,{} z) = real(besselJ(v,{} exp(3*\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinKei',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kelvinKei(v,{} z)} is the Kelvin kei function defined by equality \spad{kelvinKei(v,{} z) = imag(exp(-v*\%pi*\%i/2)*besselK(v,{} exp(\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinKei',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kelvinKei(v,{} z)} is the Kelvin kei function defined by equality \spad{kelvinKei(v,{} z) = imag(exp(-v*\%pi*\%i/2)*besselK(v,{} exp(\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinKer',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kelvinKer(v,{} z)} is the Kelvin kei function defined by equality \spad{kelvinKer(v,{} z) = real(exp(-v*\%pi*\%i/2)*besselK(v,{} exp(\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kelvinKer',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kelvinKer(v,{} z)} is the Kelvin kei function defined by equality \spad{kelvinKer(v,{} z) = real(exp(-v*\%pi*\%i/2)*besselK(v,{} exp(\%pi*\%i/4)*z))} for \spad{z} and \spad{v} real.');
INSERT INTO olibdb VALUES('o','kernel',1,'n','(Symbol)->%','cKernelCategory(S)',NULL,'\spad{kernel(x)} returns \spad{x} viewed as a kernel.');
INSERT INTO olibdb VALUES('o','kernel',2,'n','(BasicOperator,List(S))->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernel',2,'n','(BasicOperator,S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernel',2,'x','(BasicOperator,%)->%','cExpressionSpace2(K)',NULL,'\spad{kernel(op,{} x)} constructs \spad{op}(\spad{x}) without evaluating it.');
INSERT INTO olibdb VALUES('o','kernel',2,'x','(BasicOperator,List(%))->%','cExpressionSpace2(K)',NULL,'\spad{kernel(op,{} [f1,{} ...,{} fn])} constructs \spad{op(f1,{} ...,{} fn)} without evaluating it.');
INSERT INTO olibdb VALUES('o','kernel',3,'n','(BasicOperator,List(S),NonNegativeInteger)->%','cKernelCategory(S)',NULL,'\spad{kernel(op,{} [a1,{} ...,{} an],{} m)} returns the kernel \spad{op(a1,{} ...,{} an)} of nesting level \spad{m}. Error: if \spad{op} is \spad{k}-ary for some \spad{k} not equal to \spad{n}.');
INSERT INTO olibdb VALUES('o','kernels',1,'n','(List(S))->List(K)','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernels',1,'n','(List(S))->List(K)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernels',1,'n','(S)->List(K)','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernels',1,'n','(S)->List(K)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kernels',1,'x','(%)->List(K)','cExpressionSpace2(K)',NULL,'\spad{kernels(f)} returns the list of all the top-level kernels appearing in \spad{f},{} but not the ones appearing in the arguments of the top-level kernels.');
INSERT INTO olibdb VALUES('o','kernels',1,'x','(List(%))->List(K)','cExpressionSpace2(K)',NULL,'\spad{kernels([f1,{}...,{}fn])} returns the list of all the top-level kernels appearing in \spad{f1},{} ...,{} \spad{fn} but not the ones appearing in the arguments of the top-level kernels.');
INSERT INTO olibdb VALUES('o','key',1,'n','(%)->Integer','dGraphImage',NULL,'\spad{key(\spad{gi})} returns the process ID of the given graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.');
INSERT INTO olibdb VALUES('o','key',1,'n','(%)->Integer','dTwoDimensionalViewport',NULL,'\spad{key(v)} returns the process ID number of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','key',1,'x','(%)->Integer','dThreeDimensionalViewport',NULL,'\spad{key(v)} returns the process ID number of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','key?',2,'n','(Key,S)->Boolean','xKeyedDictionary&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','key?',2,'x','(Key,%)->Boolean','cKeyedDictionary(Key,Entry)',NULL,'\spad{key?(k,{} t)} tests if \spad{k} is a key in table \spad{t}.');
INSERT INTO olibdb VALUES('o','keys',1,'n','(%)->List(String)','dBasicKeyedAccessFile',NULL,'\spad{keys(f)} gives the list of keys of \spad{f}.');
INSERT INTO olibdb VALUES('o','keys',1,'n','(S)->List(Key)','xKeyedDictionary&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','keys',1,'x','(%)->List(Key)','cKeyedDictionary(Key,Entry)',NULL,'\spad{keys(t)} returns the list of keys in table \spad{t}.');
INSERT INTO olibdb VALUES('o','kgraph',2,'n','(List(S),String)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kgraph',2,'n','(List(S),String)->%','cFiniteGraph(S)',NULL,'\spad{kgraph(objs,{} arrowName)} constructs a graph with vertices (from \spad{objs}) and fully connected arrows,{} that is,{} each object has an arrow to every other object except itself. arrowName is a prefix for all arrow names,{} this will be followed by a number starting at 1 and incremented for each arrow');
INSERT INTO olibdb VALUES('o','kleinBottle',0,'n','()->DeltaComplex(VS)','pDeltaComplexFactory(VS)',NULL,'generate a minimal Klein bottle.');
INSERT INTO olibdb VALUES('o','kleinBottle',0,'n','()->FiniteCubicalComplex(Integer)','pCubicalComplexFactory',NULL,'generate a cubical complex of the surface of a Klein bottle.');
INSERT INTO olibdb VALUES('o','kleinBottle',0,'n','()->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'generate a minimal triangulation of the surface of a Klein bottle.');
INSERT INTO olibdb VALUES('o','kmax',1,'n','(List(Kernel(F)))->Kernel(F)','pIntegrationTools(R,F)',NULL,'\spad{kmax([k1,{} ...,{} kn])} returns the top-level \spad{ki} for integration.');
INSERT INTO olibdb VALUES('o','knownHandler?',3,'n','(%,Integer,String)->Boolean','dOperatorHandlers(HANDLER)',NULL,'\spad{knownHandler?(x,{} n,{} op)} checks whether a handler for operator \spad{op} is known. The number \spad{n} denotes the number of arguments that the operator can take. It is OK if both \spad{knownOperator?(m,{} op)} and \spad{knownOperator?(n,{} op)} return \spad{true} for different \spad{m} and \spad{n}.');
INSERT INTO olibdb VALUES('o','knownInfBasis',1,'n','(NonNegativeInteger)->Void','dAlgebraicFunctionField(F,UP,UPUP,modulus)',NULL,'\spad{knownInfBasis(n)} \undocumented{}');
INSERT INTO olibdb VALUES('o','kovacic',3,'n','(Fraction(UP),Fraction(UP),Fraction(UP))->Union(SparseUnivariatePolynomial(Fraction(UP)),failed)','pKovacic(F,UP)',NULL,'\spad{kovacic(a_0,{}a_1,{}a_2)} returns either failed or \spad{P}(\spad{u}) such that \spad{\$e^{\int(-a_1/2a_2)} e^{\int u}\$} is a solution of \indented{5}{\spad{a_2 y'''' + a_1 y'' + a0 y = 0}} whenever \spad{u} is a solution of \spad{P u = 0}. The equation must be already irreducible over the rational functions.');
INSERT INTO olibdb VALUES('o','kovacic',4,'n','(Fraction(UP),Fraction(UP),Fraction(UP),(UP)->Factored(UP))->Union(SparseUnivariatePolynomial(Fraction(UP)),failed)','pKovacic(F,UP)',NULL,'\spad{kovacic(a_0,{}a_1,{}a_2,{}ezfactor)} returns either failed or \spad{P}(\spad{u}) such that \spad{\$e^{\int(-a_1/2a_2)} e^{\int u}\$} is a solution of \indented{5}{\spad{\$a_2 y'''' + a_1 y'' + a0 y = 0\$}} whenever \spad{u} is a solution of \spad{P u = 0}. The equation must be already irreducible over the rational functions. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.');
INSERT INTO olibdb VALUES('o','kprod',1,'x','(List(Complex(Float)))->Complex(Float)','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','kprod',1,'x','(List(Float))->Float','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','krawtchoukK',4,'n','(F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{krawtchoukK(n,{} p,{} N,{} z)} is the Krawtchouk polynomial.');
INSERT INTO olibdb VALUES('o','krawtchoukK',4,'x','(%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{krawtchoukK(n,{} p,{} N,{} z)} is the Krawtchouk polynomial.');
INSERT INTO olibdb VALUES('o','kroneckerDelta',0,'x','()->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{kroneckerDelta()} is the rank 2 tensor defined by \indented{3}{\spad{kroneckerDelta()(i,{} j)}} \indented{6}{\spad{= 1\space{2}if i = j}} \indented{6}{\spad{= 0 if\space{2}i \~= j}}');
INSERT INTO olibdb VALUES('o','kronecker_prod1',7,'n','(S,Integer,List(List(NonNegativeInteger)),List(S),NonNegativeInteger,NonNegativeInteger,Union(R,one))->Void','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kronecker_prod1',7,'x','(%,Integer,List(List(NonNegativeInteger)),List(%),NonNegativeInteger,NonNegativeInteger,Union(R,one))->Void','cMatrixCategory(R,Row,Col)',NULL,'Should be local but conditional.');
INSERT INTO olibdb VALUES('o','kroneckerProduct',1,'n','(List(S))->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kroneckerProduct',1,'x','(List(%))->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{kroneckerProduct([a1,{} a2,{} ...,{} an])} calculates the Kronecker product of the matrices \spad{a1},{} \spad{a2},{} ...,{} an. This corresponds to tensor product of corresponding operators.');
INSERT INTO olibdb VALUES('o','kroneckerProduct',2,'n','(S,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kroneckerProduct',2,'x','(%,%)->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{kroneckerProduct(a,{} b)} calculates the Kronecker product of the matrices a and \spad{b}. This corresponds to tensor product of corresponding operators.');
INSERT INTO olibdb VALUES('o','kroneckerSum',1,'n','(List(S))->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kroneckerSum',1,'x','(List(%))->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{kroneckerSum([a1,{} a2,{} ...,{} an])} calculates the Kronecker sum of the matrices \spad{a1},{} \spad{a2},{} ...,{} an.');
INSERT INTO olibdb VALUES('o','kroneckerSum',2,'n','(S,S)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','kroneckerSum',2,'x','(%,%)->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{kroneckerSum(a,{} b)} calculates the Kronecker sum of the matrices a and \spad{b}.');
INSERT INTO olibdb VALUES('o','KrullNumber',2,'x','(List(P),List(TS))->NonNegativeInteger','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','KrullNumber',2,'x','(List(P),List(TS))->NonNegativeInteger','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ksec',3,'n','(Kernel(F),List(Kernel(F)),Symbol)->Kernel(F)','pIntegrationTools(R,F)',NULL,'\spad{ksec(k,{} [k1,{} ...,{} kn],{} x)} returns the second top-level \spad{ki} after \spad{k} involving \spad{x}.');
INSERT INTO olibdb VALUES('o','kummerM',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kummerM(a,{} b,{} z)} is the Kummer \spad{M} function.');
INSERT INTO olibdb VALUES('o','kummerM',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kummerM(mu,{} nu,{} z)} is the Kummer \spad{M} function.');
INSERT INTO olibdb VALUES('o','kummerU',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{kummerU(a,{} b,{} z)} is the Kummer \spad{U} function.');
INSERT INTO olibdb VALUES('o','kummerU',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{kummerU(mu,{} nu,{} z)} is the Kummer \spad{U} function.');
INSERT INTO olibdb VALUES('o','label',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{label(n,{} f)} gives form \spad{f} an equation label \spad{n}.');
INSERT INTO olibdb VALUES('o','lagrange',1,'n','(%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lagrange',1,'n','(%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{lagrange(g(x))} produces the Taylor series for \spad{f(x)} \indented{1}{where \spad{f(x)} is implicitly defined as \spad{f(x) = x*g(f(x))}.}');
INSERT INTO olibdb VALUES('o','lagrange',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{lagrange(g)} produces the power series for \spad{f} where \spad{f} is implicitly defined as \spad{f(z) = z*g(f(z))}.');
INSERT INTO olibdb VALUES('o','LagrangeInterpolation',2,'n','(List(F),List(F))->P','pPolynomialInterpolationAlgorithms(F,P)',NULL,'\spad{LagrangeInterpolation(l1,{} l2)} \undocumented');
INSERT INTO olibdb VALUES('o','laguerre',1,'n','(Integer)->SparseUnivariatePolynomial(Integer)','pPolynomialNumberTheoryFunctions',NULL,'\spad{laguerre(n)} returns the \spad{n}th Laguerre polynomial \spad{L[n](x)}. Note: Laguerre polynomials,{} denoted \spad{L[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{exp(x*t/(t-1))/(1-t) = sum(L[n](x)*t^n/n!,{} n=0..infinity)}.');
INSERT INTO olibdb VALUES('o','laguerreL',2,'x','(NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)',NULL,'\spad{laguerreL(n,{} x)} is the \spad{n}-th Laguerre polynomial,{} \spad{L[n](x)}. These are defined by \spad{exp(-t*x/(1-t))/(1-t) = sum(L[n](x)*t^n/n!,{} n = 0..)}.');
INSERT INTO olibdb VALUES('o','laguerreL',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{laguerreL(n,{} a,{} z)} is the Laguerre polynomial.');
INSERT INTO olibdb VALUES('o','laguerreL',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{laguerreL(n,{} a,{} z)} is the Laguerre polynomial.');
INSERT INTO olibdb VALUES('o','laguerreL',3,'x','(NonNegativeInteger,NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)',NULL,'\spad{laguerreL(m,{} n,{} x)} is the associated Laguerre polynomial,{} \spad{L<m>[n](x)}. This is the \spad{m}-th derivative of \spad{L[n](x)}.');
INSERT INTO olibdb VALUES('o','Lambda',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Lambda()} returns symbol for capital greek letter lambda.');
INSERT INTO olibdb VALUES('o','lambda',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{lambda()} returns symbol for small greek letter lambda.');
INSERT INTO olibdb VALUES('o','lambda',1,'n','(NonNegativeInteger)->%','dLambda(UT)',NULL,'Constructs a reference to a bound variable from its deBruijn index');
INSERT INTO olibdb VALUES('o','lambda',1,'n','(UT)->%','dLambda(UT)',NULL,'Constructs a reference to a free variable');
INSERT INTO olibdb VALUES('o','lambda',2,'n','(%,%)->%','dLambda(UT)',NULL,'Constructs a node containing multiple terms');
INSERT INTO olibdb VALUES('o','lambda',2,'n','(%,List(Symbol))->%','dInputForm',NULL,'\spad{lambda(code,{} [x1,{} ...,{} xn])} returns the input form corresponding to \spad{(x1,{} ...,{} xn) +-> code} if \spad{n > 1},{} or to \spad{x1 +-> code} if \spad{n = 1}.');
INSERT INTO olibdb VALUES('o','lambda',2,'n','(%,UT)->%','dLambda(UT)',NULL,'Constructs lambda term and bind any variables with the name provided');
INSERT INTO olibdb VALUES('o','lambert',1,'n','(%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lambert',1,'n','(%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{lambert(f(x))} returns \spad{f(x) + f(x^2) + f(x^3) + ...}. \indented{1}{\spad{f(x)} should have zero constant coefficient.} \indented{1}{This function is used for computing infinite products.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n = 1..infinity,{} f(x^n)) = exp(lambert(log(f(x))))}.}');
INSERT INTO olibdb VALUES('o','lambert',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{lambert(st)} computes \spad{f(x) + f(x^2) + f(x^3) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f(x)} is a power series with constant coefficient 1 then \spad{prod(f(x^n),{} n = 1..infinity) = exp(lambert(log(f(x))))}.');
INSERT INTO olibdb VALUES('o','lambert_inverse_series',2,'x','(Complex(DoubleFloat),Complex(DoubleFloat))->Complex(DoubleFloat)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_inverse_series',2,'x','(Complex(Float),Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_inverse_series',2,'x','(DoubleFloat,DoubleFloat)->DoubleFloat','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_inverse_series',2,'x','(Float,Float)->Float','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton1',3,'x','(Complex(DoubleFloat),Complex(DoubleFloat),DoubleFloat)->Complex(DoubleFloat)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton1',3,'x','(Complex(Float),Complex(Float),Float)->Complex(Float)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton1',3,'x','(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton1',3,'x','(Float,Float,Float)->Float','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton2',3,'x','(Complex(DoubleFloat),Complex(DoubleFloat),DoubleFloat)->Complex(DoubleFloat)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton2',3,'x','(Complex(Float),Complex(Float),Float)->Complex(Float)','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton2',3,'x','(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambert_via_newton2',3,'x','(Float,Float,Float)->Float','pFloatSpecialFunctions',NULL,'Undocumented');
INSERT INTO olibdb VALUES('o','lambertW0',1,'n','(UTS)->UTS','pSpecialFunctionUnivariateTaylorSeries(Coef,UTS)',NULL,'\spad{lambertW0(x)} applies lambertW to \spad{x}. \spad{x} must have no term of order 0.');
INSERT INTO olibdb VALUES('o','lambertW',1,'n','(F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{lambertW(x)} is the Lambert \spad{W} function at \spad{x}.');
INSERT INTO olibdb VALUES('o','lambertW',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pFloatSpecialFunctions',NULL,'\spad{lambertW(x)} is the Lambert \spad{W} function.');
INSERT INTO olibdb VALUES('o','lambertW',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{lambertW(x)} is the Lambert \spad{W} function.');
INSERT INTO olibdb VALUES('o','lambertW',1,'x','(%)->%','cSpecialFunctionCategory',NULL,'\spad{lambertW(z)} = \spad{w} is the principal branch of the solution to the equation \spad{we^w = z}.');
INSERT INTO olibdb VALUES('o','lambertW',1,'x','(DoubleFloat)->DoubleFloat','pFloatSpecialFunctions',NULL,'\spad{lambertW(x)} is the Lambert \spad{W} function.');
INSERT INTO olibdb VALUES('o','lambertW',1,'x','(Float)->Float','pFloatSpecialFunctions',NULL,'\spad{lambertW(x)} is the Lambert \spad{W} function.');
INSERT INTO olibdb VALUES('o','lambintegrate',6,'n','(Fraction(UP),F,(F)->F,(UP)->UP,(F)->Union(Record(ratpart:F,coeff:F),failed),(F)->IntegrationResult(F))->Record(answer:IntegrationResult(Fraction(UP)),a0:IntegrationResult(F))','pTranscendentalIntegration(F,UP)',NULL,'\spad{lambintegrate(f,{} dx,{} D1,{} D2,{} extint,{} int)} integrates \spad{f} in extension by LambertW function. \spad{dx} is derivative of the argument of LambertW,{} \spad{D1} is dervative on \spad{F},{} \spad{D2} is derivative on UP,{} \spad{extint} is extended integration function on \spad{F},{} int is integration function on \spad{F}.');
INSERT INTO olibdb VALUES('o','landen1',2,'x','(Complex(Float),List(Complex(Float)))->List(Complex(Float))','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','landen1',2,'x','(Float,List(Float))->List(Float)','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','landen2',3,'x','(Complex(Float),List(Complex(Float)),Float)->List(Complex(Float))','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','landen2',3,'x','(Float,List(Float),Float)->List(Float)','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','landen',2,'x','(Complex(Float),Float)->List(Complex(Float))','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','landen',2,'x','(Float,Float)->List(Float)','pFloatEllipticFunctions',NULL,'Undocumented.');
INSERT INTO olibdb VALUES('o','laplace',3,'x','(F,Symbol,Symbol)->F','pLaplaceTransform(R,F)',NULL,'\spad{laplace(f,{} t,{} s)} returns the Laplace transform of \spad{f(t)} using \spad{s} as the new variable. This is \spad{integral(exp(-s*t)*f(t),{} t = 0..\%plusInfinity)}. Returns the formal object \spad{laplace(f,{} t,{} s)} if it cannot compute the transform.');
INSERT INTO olibdb VALUES('o','laplacian',2,'n','(F,FLAS)->F','pMultiVariableCalculusFunctions(S,F,FLAF,FLAS)',NULL,'\spad{laplacian(v,{} xlist)} computes the laplacian of the scalar field \spad{v},{} \spad{v} a function of the variables listed in xlist.');
INSERT INTO olibdb VALUES('o','laplacianMatrix',1,'n','(A)->Matrix(Integer)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','laplacianMatrix',1,'n','(%)->Matrix(Integer)','cFiniteGraph(S)',NULL,'\spad{laplacianMatrix(s)} returns matrix also known as Kirchhoff matrix or Admittance matrix where: entry [\spad{i},{} \spad{j}] = inDegree(\spad{vi}) if \spad{i} = \spad{j} (number of incoming links) \spad{-1} if \spad{i} not = \spad{j} and \spad{vi} is adjacent to \spad{vj} 0 otherwise Alternatively this is defined as \spad{D} - A,{} where \spad{D} is the diagonal degree matrix. It contains both adjacency information and degree information. There are other,{} similar matrices,{} that are also called Laplacian matrices of a graph.');
INSERT INTO olibdb VALUES('o','largest',1,'n','(List(S))->S','pUserDefinedPartialOrdering(S)','has(S,OrderedSet)','\spad{largest l} returns the largest element of \spad{l} where the partial ordering induced by setOrder is completed into a total one by the ordering on \spad{S}.');
INSERT INTO olibdb VALUES('o','largest',2,'n','(List(S),(S,S)->Boolean)->S','pUserDefinedPartialOrdering(S)',NULL,'\spad{largest(l,{} fn)} returns the largest element of \spad{l} where the partial ordering induced by setOrder is completed into a total one by \spad{fn}.');
INSERT INTO olibdb VALUES('o','last',1,'n','(A)->S','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','last',1,'n','(A)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','last',1,'n','(S)->Union(P,failed)','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','last',1,'x','(%)->S','cDoublyLinkedAggregate(S)',NULL,'\spad{last(l)} returns the last element of a doubly-linked aggregate \spad{l}. Error: if \spad{l} is empty.');
INSERT INTO olibdb VALUES('o','last',1,'x','(%)->S','cUnaryRecursiveAggregate(S)',NULL,'\spad{last(u)} returns the last element of \spad{u}. Note: for lists,{} \spad{last(u) = u.(maxIndex u)}.');
INSERT INTO olibdb VALUES('o','last',1,'x','(%)->Union(P,failed)','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{last(ts)} returns the polynomial of \spad{ts} with smallest main variable if \spad{ts} is not empty,{} otherwise returns \spad{failed}.');
INSERT INTO olibdb VALUES('o','last',2,'n','(A,NonNegativeInteger)->A','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','last',2,'n','(A,NonNegativeInteger)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','last',2,'x','(%,NonNegativeInteger)->%','cUnaryRecursiveAggregate(S)',NULL,'\spad{last(u,{} n)} returns a copy of the last \spad{n} nodes of \spad{u}. Note: \spad{last(u,{} n)} is a list of \spad{n} elements.');
INSERT INTO olibdb VALUES('o','lastSubResultant',2,'n','(%,%)->%','dNewSparseUnivariatePolynomial(R)','has(R,IntegralDomain)','\spad{lastSubResultant(a,{} b)} returns \spad{resultant(a,{} b)} if \spad{a} and \spad{b} has no non-trivial \spad{gcd} in \spad{R^(-1) P} otherwise the non-zero sub-resultant with smallest index.');
INSERT INTO olibdb VALUES('o','lastSubResultant',2,'n','(polR,polR)->polR','pPseudoRemainderSequence(R,polR)',NULL,'\spad{lastSubResultant(P,{} Q)} computes the last non zero subresultant of \spad{P} and \spad{Q}');
INSERT INTO olibdb VALUES('o','lastSubResultant',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{lastSubResultant(a,{} b)} returns the last non-zero subresultant of \spad{a} and \spad{b} where \spad{a} and \spad{b} are assumed to have the same main variable \spad{v} and are viewed as univariate polynomials in \spad{v}.');
INSERT INTO olibdb VALUES('o','lastSubResultant',3,'x','(P,P,%)->List(Record(val:P,tower:%))','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{lastSubResultant(p1,{} p2,{} ts)} returns \spad{lpwt} such that \spad{lpwt.i.val} is a quasi-monic \spad{gcd} of \spad{p1} and \spad{p2} \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower},{} for every \spad{i},{} and such that the list of the \spad{lpwt.i.tower} is a split of Kalkbrener of \spad{ts}. Moreover,{} if \spad{p1} and \spad{p2} do not have a non-trivial \spad{gcd} \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower} then \spad{lpwt.i.val} is the resultant of these polynomials \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower}. This assumes that \spad{p1} and \spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \spad{ts}.');
INSERT INTO olibdb VALUES('o','lastSubResultantElseSplit',3,'x','(P,P,%)->Union(P,List(%))','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{lastSubResultantElseSplit(p1,{} p2,{} ts)} returns either \spad{g} a quasi-monic \spad{gcd} of \spad{p1} and \spad{p2} \spad{w}.\spad{r}.\spad{t}. the \spad{ts} or a split of Kalkbrener of \spad{ts}. This assumes that \spad{p1} and \spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \spad{ts}.');
INSERT INTO olibdb VALUES('o','lastSubResultantEuclidean',2,'n','(polR,polR)->Record(coef1:polR,coef2:polR,subResultant:polR)','pPseudoRemainderSequence(R,polR)',NULL,'\spad{lastSubResultantEuclidean(P,{} Q)} computes the last non zero subresultant \spad{S} and carries out the equality \spad{coef1*P + coef2*Q = S}.');
INSERT INTO olibdb VALUES('o','latex',1,'n','(S)->String','xSetCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','latex',1,'x','(%)->String','cSetCategory',NULL,'\spad{latex(s)} returns a LaTeX-printable output representation of \spad{s}.');
INSERT INTO olibdb VALUES('o','latticeJoinOfMeets',1,'n','(Union(const:Record(val:Symbol),var:Record(str:String)))->%','dLatticeJoinOfMeets',NULL,'construct a lattice with one element');
INSERT INTO olibdb VALUES('o','latticeMeetOfJoins',1,'n','(Union(const:Record(val:Symbol),var:Record(str:String)))->%','dLatticeMeetOfJoins',NULL,'construct a lattice with one element');
INSERT INTO olibdb VALUES('o','laurent',1,'x','(FE)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{laurent(f)} returns a Laurent expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.');
INSERT INTO olibdb VALUES('o','laurent',1,'x','(Symbol)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{laurent(x)} returns \spad{x} viewed as a Laurent series.');
INSERT INTO olibdb VALUES('o','laurent',1,'x','(%)->ULS','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{laurent(f(x))} converts the Puiseux series \spad{f(x)} to a Laurent series if possible. Error: if this is not possible.');
INSERT INTO olibdb VALUES('o','laurent',2,'n','(Integer,Stream(Coef))->S','xUnivariateLaurentSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','laurent',2,'n','(Integer,Stream(Coef))->S','xUnivariateLaurentSeriesConstructorCategory&(S,Coef,UTS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','laurent',2,'n','(Integer,UTS)->S','xUnivariateLaurentSeriesConstructorCategory&(S,Coef,UTS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','laurent',2,'x','(FE,Equation(FE))->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{laurent(f,{} x = a)} expands the expression \spad{f} as a Laurent series in powers of \spad{(x - a)}.');
INSERT INTO olibdb VALUES('o','laurent',2,'x','(FE,Integer)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{laurent(f,{} n)} returns a Laurent expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.');
INSERT INTO olibdb VALUES('o','laurent',2,'x','(Integer,Stream(Coef))->%','cUnivariateLaurentSeriesCategory(Coef)',NULL,'\spad{laurent(n,{} st)} returns \spad{xn * series st} where \spad{xn = monomial(1,{} n)} and \spad{series st} stands for the power series with coefficients given by the stream st.');
INSERT INTO olibdb VALUES('o','laurent',2,'x','(Integer,UTS)->%','cUnivariateLaurentSeriesConstructorCategory(Coef,UTS)',NULL,'\spad{laurent(n,{} f(x))} returns \spad{x^n * f(x)}.');
INSERT INTO olibdb VALUES('o','laurent',3,'n','((Integer)->FE,Equation(FE),UniversalSegment(Integer))->Any','pGenerateUnivariatePowerSeries2(FE)',NULL,'\spad{laurent(n +-> a(n),{} x = a,{} n0..)} returns \spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \spad{laurent(n +-> a(n),{} x = a,{} n0..n1)} returns \spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','laurent',3,'x','(FE,Equation(FE),Integer)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{laurent(f,{} x = a,{} n)} expands the expression \spad{f} as a Laurent series in powers of \spad{(x - a)}; terms will be computed up to order at least \spad{n}.');
INSERT INTO olibdb VALUES('o','laurent',3,'x','((Integer)->FE,Equation(FE),UniversalSegment(Integer))->Any','pGenerateUnivariatePowerSeries(R,FE)',NULL,NULL);
INSERT INTO olibdb VALUES('o','laurent',4,'n','(FE,Symbol,Equation(FE),UniversalSegment(Integer))->Any','pGenerateUnivariatePowerSeries2(FE)','AND(has(FE,Evalable(FE)),has(FE,RetractableTo(Integer)))','\spad{laurent(a(n),{} n,{} x=a,{} n0..)} returns \spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \spad{laurent(a(n),{} n,{} x=a,{} n0..n1)} returns \spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','laurent',4,'n','((Integer)->R,Symbol,R,UniversalSegment(Integer))->Any','pGenerateUnivariatePowerSeries1(R)',NULL,'\spad{laurent(n +-> a(n),{} x,{} a,{} n0..)} returns \spad{sum(n = n0..,{} a(n) * (x - a)^n)}; \spad{laurent(n +-> a(n),{} x,{} a,{} n0..n1)} returns \spad{sum(n = n0..n1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','laurent',4,'x','(FE,Symbol,Equation(FE),UniversalSegment(Integer))->Any','pGenerateUnivariatePowerSeries(R,FE)','AND(has(FE,Evalable(FE)),has(FE,RetractableTo(Integer)))',NULL);
INSERT INTO olibdb VALUES('o','laurentIfCan',1,'x','(%)->Union(ULS,failed)','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{laurentIfCan(f(x))} converts the Puiseux series \spad{f(x)} to a Laurent series if possible. If this is not possible,{} failed is returned.');
INSERT INTO olibdb VALUES('o','laurentRep',1,'x','(%)->ULS','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{laurentRep(f(x))} returns \spad{g(x)} where the Puiseux series \spad{f(x) = g(x^r)} is represented by \spad{[r,{} g(x)]}.');
INSERT INTO olibdb VALUES('o','LazardQuotient2',4,'n','(polR,R,R,NonNegativeInteger)->polR','pPseudoRemainderSequence(R,polR)',NULL,'\spad{LazardQuotient2(F,{} x,{} y,{} n)} computes \spad{(x^(n-1) * F) exquo y^(n-1)}');
INSERT INTO olibdb VALUES('o','LazardQuotient2',4,'x','(%,%,%,NonNegativeInteger)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{LazardQuotient2(p,{} a,{} b,{} n)} returns \spad{(a^(n-1) * p) exquo b^(n-1)} assuming that this quotient does not fail.');
INSERT INTO olibdb VALUES('o','LazardQuotient',3,'n','(R,R,NonNegativeInteger)->R','pPseudoRemainderSequence(R,polR)',NULL,'\spad{LazardQuotient(x,{} y,{} n)} computes \spad{x^n exquo y^(n-1)}');
INSERT INTO olibdb VALUES('o','LazardQuotient',3,'x','(%,%,NonNegativeInteger)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{LazardQuotient(a,{} b,{} n)} returns \spad{a^n exquo b^(n-1)} assuming that this quotient does not fail.');
INSERT INTO olibdb VALUES('o','lazy?',1,'x','(%)->Boolean','cLazyStreamAggregate(S)',NULL,'\spad{lazy?(s)} returns \spad{true} if the first node of the stream \spad{s} is a lazy evaluation mechanism which could produce an additional entry to \spad{s}.');
INSERT INTO olibdb VALUES('o','lazyEvaluate',1,'x','(%)->%','cLazyStreamAggregate(S)',NULL,'\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \spad{s}. Caution: the first node must be a lazy evaluation mechanism (satisfies \spad{lazy?(s) = true}) as there is no error check. Note: a call to this function may or may not produce an explicit first entry');
INSERT INTO olibdb VALUES('o','lazyGintegrate',3,'n','((Integer)->A,A,()->Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Field)','\spad{lazyGintegrate(f,{} r,{} g)} is used for fixed point computations.');
INSERT INTO olibdb VALUES('o','lazyIntegrate',2,'n','(A,()->Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Algebra(Fraction(Integer)))','\spad{lazyIntegrate(r,{} f)} is a version of integrate used for fixed point computations.');
INSERT INTO olibdb VALUES('o','lazyIntegrate',2,'n','(Coef,()->Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{lazyIntegrate(c,{} f)} integrates with constant term \spad{c},{} this is simply the right shift');
INSERT INTO olibdb VALUES('o','lazyIrreducibleFactors',1,'n','(List(P))->List(P)','pPolynomialSetUtilitiesPackage(R,E,V,P)','AND(has(R,CharacteristicZero),has(R,PolynomialFactorizationExplicit))','\spad{lazyIrreducibleFactors(lp)} returns \spad{lf} such that if \spad{lp = [p1,{} ...,{} pn]} and \spad{lf = [f1,{} ...,{} fm]} then \spad{p1*p2*...*pn=0} means \spad{f1*f2*...*fm=0},{} and the \spad{\spad{fi}} are irreducible over \spad{R} and are pairwise distinct. The algorithm tries to avoid factorization into irreducible factors as far as possible and makes previously use of \spad{gcd} techniques over \spad{R}.');
INSERT INTO olibdb VALUES('o','lazyPquo',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPquo',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPquo(a,{} b)} returns the polynomial \spad{q} such that \spad{lazyPseudoDivide(a,{} b)} returns \spad{[c,{} g,{} q,{} r]}.');
INSERT INTO olibdb VALUES('o','lazyPquo',3,'n','(S,S,V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPquo',3,'x','(%,%,V)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPquo(a,{} b,{} v)} returns the polynomial \spad{q} such that \spad{lazyPseudoDivide(a,{} b,{} v)} returns \spad{[c,{} g,{} q,{} r]}.');
INSERT INTO olibdb VALUES('o','lazyPrem',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPrem',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPrem(a,{} b)} returns the polynomial \spad{r} reduced \spad{w}.\spad{r}.\spad{t}. \spad{b} and such that \spad{b} divides \spad{init(b)^e a - r} where \spad{e} is the number of steps of this pseudo-division.');
INSERT INTO olibdb VALUES('o','lazyPrem',3,'n','(S,S,V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPrem',3,'x','(%,%,V)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPrem(a,{} b,{} v)} returns the polynomial \spad{r} reduced \spad{w}.\spad{r}.\spad{t}. \spad{b} viewed as univariate polynomials in the variable \spad{v} such that \spad{b} divides \spad{init(b)^e a - r} where \spad{e} is the number of steps of this pseudo-division.');
INSERT INTO olibdb VALUES('o','lazyPremWithDefault',2,'n','(S,S)->Record(coef:S,gap:NonNegativeInteger,remainder:S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPremWithDefault',2,'x','(%,%)->Record(coef:%,gap:NonNegativeInteger,remainder:%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPremWithDefault(a,{} b)} returns \spad{[c,{} g,{} r]} such that \spad{r = lazyPrem(a,{} b)} and \spad{(c^g)*r = prem(a,{} b)}.');
INSERT INTO olibdb VALUES('o','lazyPremWithDefault',3,'n','(S,S,V)->Record(coef:S,gap:NonNegativeInteger,remainder:S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPremWithDefault',3,'x','(%,%,V)->Record(coef:%,gap:NonNegativeInteger,remainder:%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPremWithDefault(a,{} b,{} v)} returns \spad{[c,{} g,{} r]} such that \spad{r = lazyPrem(a,{} b,{} v)} and \spad{(c^g)*r = prem(a,{} b,{} v)}.');
INSERT INTO olibdb VALUES('o','lazyPseudoDivide',2,'n','(%,%)->Record(coef:R,gap:NonNegativeInteger,quotient:%,remainder:%)','dNewSparseUnivariatePolynomial(R)',NULL,'\spad{lazyPseudoDivide(a,{} b)} returns \spad{[c,{} g,{} q,{} r]} such that \spad{c^n * a = q*b +r} and \spad{lazyResidueClass(a,{} b)} returns \spad{[r,{} c,{} n]} where \spad{n + g = max(0,{} degree(b) - degree(a) + 1)}.');
INSERT INTO olibdb VALUES('o','lazyPseudoDivide',2,'n','(S,S)->Record(coef:S,gap:NonNegativeInteger,quotient:S,remainder:S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPseudoDivide',2,'x','(%,%)->Record(coef:%,gap:NonNegativeInteger,quotient:%,remainder:%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPseudoDivide(a,{} b)} returns \spad{[c,{} g,{} q,{} r]} such that \spad{[c,{} g,{} r] = lazyPremWithDefault(a,{} b)} and \spad{q} is the pseudo-quotient computed in this lazy pseudo-division.');
INSERT INTO olibdb VALUES('o','lazyPseudoDivide',3,'n','(S,S,V)->Record(coef:S,gap:NonNegativeInteger,quotient:S,remainder:S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyPseudoDivide',3,'x','(%,%,V)->Record(coef:%,gap:NonNegativeInteger,quotient:%,remainder:%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyPseudoDivide(a,{} b,{} v)} returns \spad{[c,{} g,{} q,{} r]} such that \spad{r = lazyPrem(a,{} b,{} v)},{} \spad{(c^g)*r = prem(a,{} b,{} v)} and \spad{q} is the pseudo-quotient computed in this lazy pseudo-division.');
INSERT INTO olibdb VALUES('o','lazyPseudoQuotient',2,'n','(%,%)->%','dNewSparseUnivariatePolynomial(R)',NULL,'\spad{lazyPseudoQuotient(a,{} b)} returns \spad{q} if \spad{lazyPseudoDivide(a,{} b)} returns \spad{[c,{} g,{} q,{} r]}');
INSERT INTO olibdb VALUES('o','lazyPseudoRemainder',2,'n','(%,%)->%','dNewSparseUnivariatePolynomial(R)',NULL,'\spad{lazyPseudoRemainder(a,{} b)} returns \spad{r} if \spad{lazyResidueClass(a,{} b)} returns \spad{[r,{} c,{} n]}. This lazy pseudo-remainder is computed by means of the \spadopFrom{fmecg}{NewSparseUnivariatePolynomial} operation.');
INSERT INTO olibdb VALUES('o','lazyResidueClass',2,'n','(%,%)->Record(polnum:%,polden:R,power:NonNegativeInteger)','dNewSparseUnivariatePolynomial(R)',NULL,'\spad{lazyResidueClass(a,{} b)} returns \spad{[r,{} c,{} n]} such that \spad{r} is reduced \spad{w}.\spad{r}.\spad{t}. \spad{b} and \spad{b} divides \spad{c^n * a - r} where \spad{c} is \spad{leadingCoefficient(b)} and \spad{n} is as small as possible with the previous properties.');
INSERT INTO olibdb VALUES('o','lazyResidueClass',2,'n','(S,S)->Record(polnum:S,polden:S,power:NonNegativeInteger)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lazyResidueClass',2,'x','(%,%)->Record(polnum:%,polden:%,power:NonNegativeInteger)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{lazyResidueClass(a,{} b)} returns \spad{[p,{} q,{} n]} where \spad{p / q^n} represents the residue class of \spad{a} modulo \spad{b} and \spad{p} is reduced \spad{w}.\spad{r}.\spad{t}. \spad{b} and \spad{q} is \spad{init(b)}.');
INSERT INTO olibdb VALUES('o','lazyVariations',3,'x','(List(TheField),Integer,Integer)->NonNegativeInteger','pRealPolynomialUtilitiesPackage(TheField,ThePols)','has(TheField,OrderedRing)','\spad{lazyVariations(l,{} s1,{} sn)} is the number of sign variations in the list of non null numbers [s1::l]\spad{@sn},{}');
INSERT INTO olibdb VALUES('o','lc',2,'x','(%,%)->%','dCliffordAlgebra(n,K,bLin)',NULL,'left contraction inner product');
INSERT INTO olibdb VALUES('o','lcm',1,'n','(List(S))->S','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lcm',1,'x','(List(%))->%','cGcdDomain',NULL,'\spad{lcm(l)} returns the least common multiple of the elements of the list \spad{l}.');
INSERT INTO olibdb VALUES('o','lcm',2,'n','(S,S)->S','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lcm',2,'x','(%,%)->%','cGcdDomain',NULL,'\spad{lcm(x,{} y)} returns the least common multiple of \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','lcm',4,'n','(PrimitiveArray(U32Vector),Integer,Integer,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'\spad{lcm(a,{} lo,{} \spad{hi},{} p)} computes \spad{lcm} of elements a(\spad{lo}),{} a(\spad{lo+1}),{} ...,{} a(\spad{hi}).');
INSERT INTO olibdb VALUES('o','lcmCoef',2,'n','(%,%)->Record(llcm_res:%,coeff1:%,coeff2:%)','cLeftOreRing',NULL,'\spad{lcmCoef(c1,{} c2)} computes (llcm_res,{} \spad{coeff1},{} \spad{coeff2}) such that llcm_res is least left common multiple of \spad{c1} and \spad{c2} and llcm_res = \spad{coeff1*c1} = \spad{coeff2*c2}');
INSERT INTO olibdb VALUES('o','lcmCoef',2,'n','(S,S)->Record(llcm_res:S,coeff1:S,coeff2:S)','xGcdDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lcx0',2,'n','(SparseMultivariatePolynomial(Integer,Symbol),List(Symbol))->Record(lcx0lc:SparseMultivariatePolynomial(Integer,Symbol),lcx0m:SparseMultivariatePolynomial(Integer,Symbol))','pPrimGCD',NULL,'\spad{lcx0(x,{} lv)} computes leading coefficient of \spad{x} and corresponding product of variables (monomial with coefficient 1) with respect to variables in \spad{lv} Variables in \spad{lv} must be decreasing and bigger than all other variables of \spad{x}.');
INSERT INTO olibdb VALUES('o','lcz',2,'n','(SparseMultivariatePolynomial(Integer,Symbol),Symbol)->Record(lczlc:SparseMultivariatePolynomial(Integer,Symbol),k:Integer)','pPrimGCD',NULL,'\spad{lcz(x,{} z)} computes leading coefficient and degree of \spad{x} with respect to variable \spad{z}.');
INSERT INTO olibdb VALUES('o','ldegree',2,'n','(PT,Symbol)->NonNegativeInteger','cModularEvaluationCategory(PT,MP)',NULL,'\spad{ldegree(p,{} v)} computes degree of \spad{p} with respect to \spad{v}. \spad{v} must be one of auxiliary variables and must be lexicographically first variable which appears in \spad{p}. Moreover,{} \spad{p} must be a polynomial in \spad{v} (not a rational function).');
INSERT INTO olibdb VALUES('o','ldivide',2,'n','(XDistributedPolynomial(vl,F),XDistributedPolynomial(vl,F))->Record(quotient:XDistributedPolynomial(vl,F),remainder:XDistributedPolynomial(vl,F))','pXPolynomialFactor(vl,F)',NULL,'\spad{ldivide(a,{} b)} returns [\spad{c},{} \spad{r}] such that a = \spad{b*c} + \spad{r},{} \spad{r} is is of minimal possible degree and homogeneous part of of \spad{r} of maximal degree contains no terms divisible from left by leading term of \spad{b}.');
INSERT INTO olibdb VALUES('o','LE',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{LE(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x<=y}.');
INSERT INTO olibdb VALUES('o','le',3,'n','(A,S,S)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','le',3,'n','(%,S,S)->Boolean','cPreorder(S)',NULL,'\spad{le(s,{} x,{} y)} returns \spad{true} if and only if \spad{x} is less than or equal to \spad{y}. Note: at first glance we would like to use ''<=''. But le needs 3 arguments while ''<='' has only 2.');
INSERT INTO olibdb VALUES('o','leader',1,'n','(A)->V','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leader',1,'x','(%)->V','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \spad{p} Note: an error occurs if \spad{p} is in the ground ring.');
INSERT INTO olibdb VALUES('o','leadingBasisTerm',1,'n','(%)->%','dAntiSymm(R,lVar)',NULL,'\spad{leadingBasisTerm(p)} returns the leading basis term of antisymmetric polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','leadingBasisTerm',1,'n','(%)->%','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{leadingBasisTerm(df)} returns the leading basis term of differential form \spad{df}.');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->A','cIndexedProductCategory(A,S)','has(S,Comparable)','\spad{leadingCoefficient(z)} returns the coefficient of the leading (with respect to the ordering on the indexing set) monomial of \spad{z}. Error: if \spad{z} has no support.');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(A)->R','xFreeModuleCategory&(A,R,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->Expression(CoefRing)','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{leadingCoefficient(df)} returns the leading coefficient of differential form \spad{df}.');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->R','cSolvableSkewPolynomialCategory(R,Expon)',NULL,'\spad{leadingCoefficient(p)} returns the coefficient of the highest degree term of \spad{p}.');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->R','dAntiSymm(R,lVar)',NULL,'\spad{leadingCoefficient(p)} returns the leading coefficient of antisymmetric polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->R','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{leadingCoefficient(x)} \undocumented');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(%)->R','dLaurentPolynomial(R,UP)',NULL,'\spad{leadingCoefficient }\undocumented');
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(S)->Coef','xUnivariatePowerSeriesCategory&(S,Coef,Expon)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'n','(S)->R','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingCoefficient',1,'x','(%)->Coef','cPowerSeriesCategory(Coef,Expon,Var)',NULL,'\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \spad{f}');
INSERT INTO olibdb VALUES('o','leadingCoefficient',2,'n','(S,V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingCoefficient',2,'x','(%,V)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{leadingCoefficient(p,{} v)} returns the leading coefficient of \spad{p},{} where \spad{p} is viewed as A univariate polynomial in \spad{v}.');
INSERT INTO olibdb VALUES('o','leadingCoefficientRicDE',1,'n','(L)->List(Record(deg:NonNegativeInteger,eq:UP))','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{leadingCoefficientRicDE(op)} returns \spad{[[m1,{} p1],{} [m2,{} p2],{} ... ,{} [mk,{} pk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y = 0} must have degree \spad{mj} for some \spad{j},{} and its leading coefficient is then a zero of \spad{pj}. In addition,{} \spad{m1>m2> ... >mk}.');
INSERT INTO olibdb VALUES('o','leadingDer',1,'n','(%)->JB','cJetBundleFunctionCategory(JB)',NULL,'\spad{leadingDer(fun)} yields the leading derivative of \spad{fun}. If \spad{fun} contains no derivatives \spad{1} is returned.');
INSERT INTO olibdb VALUES('o','leadingDer',1,'n','(S)->JB','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingExponent',1,'n','(%)->E','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{leadingExponent(x)} \undocumented');
INSERT INTO olibdb VALUES('o','leadingIdeal',1,'x','(%)->%','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{leadingIdeal(I)} is the ideal generated by the leading terms of the elements of the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','leadingIndex',1,'n','(%)->IS','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{leadingIndex(x)} \undocumented');
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'n','(A)->A','xFreeModuleCategory&(A,R,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'n','(%)->%','cIndexedProductCategory(A,S)','has(S,Comparable)','\spad{leadingMonomial(x)} returns the monomial supported by the first element from \spad{S}. Error: if \spad{x} has no support.');
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'n','(%)->%','cSolvableSkewPolynomialCategory(R,Expon)',NULL,'\spad{leadingMonomial(p)} returns the monomial of \spad{p} with the highest degree.');
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'n','(%)->ModuleMonomial(IS,E,ff)','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{leadingMonomial(x)} \undocumented');
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'n','(S)->S','xUnivariatePowerSeriesCategory&(S,Coef,Expon)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingMonomial',1,'x','(%)->%','cPowerSeriesCategory(Coef,Expon,Var)',NULL,'\spad{leadingMonomial(f)} returns the monomial of \spad{f} of lowest order.');
INSERT INTO olibdb VALUES('o','leadingSupport',1,'n','(A)->S','xFreeModuleCategory&(A,R,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leadingSupport',1,'n','(%)->S','cIndexedProductCategory(A,S)','has(S,Comparable)','\spad{leadingSupport(z)} returns the index of leading (with respect to the ordering on the indexing set) monomial of \spad{z}. Error: if \spad{z} has no support.');
INSERT INTO olibdb VALUES('o','leadingTerm',1,'n','(%)->Record(k:S,c:A)','cIndexedProductCategory(A,S)','has(S,Comparable)','\spad{leadingTerm(x)} returns the leading (with respect to the ordering on the indexing set) term of \spad{z}. Error: if \spad{z} has no support.');
INSERT INTO olibdb VALUES('o','leaf?',1,'n','(A)->Boolean','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaf?',1,'n','(A)->Boolean','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaf?',1,'n','(A)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaf?',1,'n','(%)->Boolean','dSubSpace(n,R)',NULL,'\spad{leaf?(x)} \undocumented');
INSERT INTO olibdb VALUES('o','leaf?',1,'x','(%)->Boolean','cRecursiveAggregate(S)',NULL,'\spad{leaf?(u)} tests if \spad{u} is a terminal node.');
INSERT INTO olibdb VALUES('o','leastAffineMultiple',1,'n','(SparseUnivariatePolynomial(GF))->SparseUnivariatePolynomial(GF)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{leastAffineMultiple(f)} computes the least affine polynomial which is divisible by the polynomial \spad{f} over the finite field {\em GF},{} \spadignore{i.e.} a polynomial whose exponents are 0 or a power of \spad{q},{} the size of {\em GF}.');
INSERT INTO olibdb VALUES('o','leastMonomial',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leastMonomial',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{leastMonomial(p)} returns an error if \spad{p} is \spad{O},{} otherwise,{} if \spad{p} belongs to \spad{R} returns \spad{1},{} otherwise,{} the monomial of \spad{p} with lowest degree,{} where \spad{p} is viewed as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','leastPower',2,'n','(NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','pIntegralBasisTools(R,UP,F)',NULL,'\spad{leastPower(p,{} n)} returns \spad{e},{} where \spad{e} is the smallest integer such that \spad{p ^e >= n}');
INSERT INTO olibdb VALUES('o','leaves',1,'n','(A)->List(S)','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaves',1,'n','(A)->List(S)','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaves',1,'n','(A)->List(S)','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaves',1,'n','(A)->List(S)','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leaves',1,'x','(%)->List(S)','cRecursiveAggregate(S)',NULL,'\spad{leaves(u)} returns the list of leaves in aggregate \spad{u}.');
INSERT INTO olibdb VALUES('o','left',1,'n','(%)->%','dFreeMagma(VarSet)',NULL,'\spad{left(x)} returns left subtree of \spad{x} or error if \spadopFrom{retractable?}{FreeMagma}(\spad{x}) is \spad{true}.');
INSERT INTO olibdb VALUES('o','left',1,'n','(%)->%','dLyndonWord(VarSet)',NULL,'\spad{left(x)} returns left subtree of \spad{x} or error if \spadopFrom{retractable?}{LyndonWord}(\spad{x}) is \spad{true}.');
INSERT INTO olibdb VALUES('o','left',1,'n','(%)->%','dOutputForm',NULL,'\spad{left(f)} left-justifies form \spad{f} in total space.');
INSERT INTO olibdb VALUES('o','left',1,'x','(%)->%','cBinaryRecursiveAggregate(S)',NULL,'\spad{left(a)} returns the left child.');
INSERT INTO olibdb VALUES('o','left',1,'x','(%)->TheField','dRightOpenIntervalRootCharacterization(TheField,ThePolDom)',NULL,'\spad{left(rootChar)} is the left bound of the isolating interval');
INSERT INTO olibdb VALUES('o','left',2,'n','(%,Integer)->%','dOutputForm',NULL,'\spad{left(f,{} n)} left-justifies form \spad{f} within space of width \spad{n}.');
INSERT INTO olibdb VALUES('o','leftAlternative?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{leftAlternative?()} tests if \spad{2*associator(a,{} a,{} b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','leftAlternative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftAlternative?()} tests if \spad{2*associator(a,{} a,{} b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{''t} know whether \spad{2*a=0} implies \spad{a=0}.');
INSERT INTO olibdb VALUES('o','leftCharacteristicPolynomial',1,'n','(S)->SparseUnivariatePolynomial(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftCharacteristicPolynomial',1,'x','(%)->SparseUnivariatePolynomial(R)','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \spad{a} with respect to any basis.');
INSERT INTO olibdb VALUES('o','leftDiscriminant',0,'n','()->R','xFramedNonAssociativeAlgebra&(S,R)',NULL,'\spad{leftDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(leftTraceMatrix())}.');
INSERT INTO olibdb VALUES('o','leftDiscriminant',0,'x','()->R','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{leftDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(leftTraceMatrix())}.');
INSERT INTO olibdb VALUES('o','leftDiscriminant',1,'n','(Vector(S))->R','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftDiscriminant',1,'n','(Vector(S))->R','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftDiscriminant',1,'x','(Vector(%))->R','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftDiscriminant([v1,{} ...,{} vn])} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj}. Note: the same as \spad{determinant(leftTraceMatrix([v1,{} ...,{} vn]))}.');
INSERT INTO olibdb VALUES('o','leftDivide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftDivide(a,{} b)} returns the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called');
INSERT INTO olibdb VALUES('o','leftDivide',3,'n','(C,C,Automorphism(R))->Record(quotient:C,remainder:C)','pUnivariateSkewPolynomialCategoryOps(R,C)','has(R,Field)','\spad{leftDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called');
INSERT INTO olibdb VALUES('o','leftExactQuotient',2,'n','(S,S)->Union(S,failed)','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftExactQuotient',2,'x','(%,%)->Union(%,failed)','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftExactQuotient(a,{} b)} computes the value \spad{q},{} if it exists,{} \indented{1}{such that \spad{a = b*q}.}');
INSERT INTO olibdb VALUES('o','leftExtendedGcd',2,'n','(S,S)->Record(coef1:S,coef2:S,generator:S)','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftExtendedGcd',2,'x','(%,%)->Record(coef1:%,coef2:%,generator:%)','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftExtendedGcd(a,{} b)} returns \spad{[c,{} d,{} g]} such that \spad{g = a * c + b * d = leftGcd(a,{} b)}.');
INSERT INTO olibdb VALUES('o','left_ext_GCD',2,'n','(XDistributedPolynomial(vl,F),XDistributedPolynomial(vl,F))->Union(Record(g:XDistributedPolynomial(vl,F),c1:XDistributedPolynomial(vl,F),c2:XDistributedPolynomial(vl,F),cu:XDistributedPolynomial(vl,F),cv:XDistributedPolynomial(vl,F)),failed)','pXPolynomialFactor(vl,F)',NULL,'\spad{left_ext_GCD(a,{} b)} returns [\spad{g},{} \spad{u0},{} \spad{v0},{} \spad{u},{} \spad{v}] where \spad{g} is left \spad{GCD} of a and \spad{b},{} \spad{g} = \spad{a*u0} + \spad{b*v0} and au = - \spad{bv} is least common right multiple of a and \spad{b} when a and \spad{b} have least common right multiple. Otherwise left_ext_GCD(a,{} \spad{b}) returns failed.');
INSERT INTO olibdb VALUES('o','leftFactor',2,'n','(%,NonNegativeInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{leftFactor(f,{}k)} returns the left factor of rank \spad{k} of a polynomial \spad{f} or 1 if it\spad{''s} not possible by linear techniques.');
INSERT INTO olibdb VALUES('o','leftFactorIfCan',2,'x','(UP,UP)->Union(UP,failed)','pUnivariatePolynomialDecompositionPackage(R,UP)',NULL,'\spad{leftFactorIfCan(f,{} h)} returns the left factor (\spad{g} in \spad{f} = \spad{g} \spad{o} \spad{h}) of the functional decomposition of the polynomial \spad{f} with given \spad{h} or \spad{failed} if \spad{g} does not exist.');
INSERT INTO olibdb VALUES('o','leftFamily',1,'n','(%)->List(OutputForm)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{leftFamily(f)} prints the left family s=A^-1*v.');
INSERT INTO olibdb VALUES('o','leftGcd',2,'n','(S,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftGcd',2,'x','(%,%)->%','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftGcd(a,{} b)} computes the value \spad{g} of highest degree such that \indented{3}{\spad{a = g*aa}} \indented{3}{\spad{b = g*bb}} for some values \spad{aa} and \spad{bb}. The value \spad{g} is computed using left-division.');
INSERT INTO olibdb VALUES('o','leftIdentity',1,'n','(%)->Matrix(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{leftIdentity(p)} returns the left identity matrix.');
INSERT INTO olibdb VALUES('o','leftLcm',2,'n','(S,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftLcm',2,'x','(%,%)->%','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftLcm(a,{} b)} computes the value \spad{m} of lowest degree such that \spad{m = aa*a = bb*b} for some values \spad{aa} and \spad{bb}. The value \spad{m} is computed using right-division.');
INSERT INTO olibdb VALUES('o','leftMinimalPolynomial',1,'n','(S)->SparseUnivariatePolynomial(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftMinimalPolynomial',1,'x','(%)->SparseUnivariatePolynomial(R)','cFiniteRankNonAssociativeAlgebra(R)','has(R,IntegralDomain)','\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit.');
INSERT INTO olibdb VALUES('o','leftMinimization',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{leftMinimization(f,{} i_min,{} i_max)} tries to apply a left minimization step with respect to the pivot block with the rows/columns (\spad{i_min},{} ...,{} i_max).');
INSERT INTO olibdb VALUES('o','leftMult',2,'n','(S,%)->%','dListMonoidOps(S,E,un)',NULL,'\spad{leftMult(s,{} a)} returns \spad{s * a} where \spad{*} is the monoid operation,{} which is assumed non-commutative.');
INSERT INTO olibdb VALUES('o','leftNorm',1,'n','(S)->R','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftNorm',1,'x','(%)->R','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftNorm(a)} returns the determinant of the left regular representation of \spad{a}.');
INSERT INTO olibdb VALUES('o','leftOne',1,'x','(%)->Union(%,failed)','dEquation(S)','has(S,Group)','\spad{leftOne(eq)} divides by the left hand side.');
INSERT INTO olibdb VALUES('o','leftOne',1,'x','(%)->Union(%,failed)','dEquation(S)','has(S,Monoid)','\spad{leftOne(eq)} divides by the left hand side.');
INSERT INTO olibdb VALUES('o','leftPower',2,'n','(S,NonNegativeInteger)->S','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftPower',2,'n','(S,PositiveInteger)->S','xMagma&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftPower',2,'n','(S,PositiveInteger)->S','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftPower',2,'x','(%,NonNegativeInteger)->%','cMagmaWithUnit',NULL,'\spad{leftPower(a,{} n)} returns the \spad{n}\spad{-}th left power of \spad{a},{} \spadignore{i.e.} \spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \spad{leftPower(a,{} 0) := 1}.');
INSERT INTO olibdb VALUES('o','leftPower',2,'x','(%,PositiveInteger)->%','cMagma',NULL,'\spad{leftPower(a,{} n)} returns the \spad{n}\spad{-}th left power of \spad{a},{} \spadignore{i.e.} \spad{leftPower(a,{} n) := a * leftPower(a,{} n-1)} and \spad{leftPower(a,{} 1) := a}.');
INSERT INTO olibdb VALUES('o','leftQuotient',2,'n','(S,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftQuotient',2,'x','(%,%)->%','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftQuotient(a,{} b)} computes the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{q} is returned.');
INSERT INTO olibdb VALUES('o','leftRank',1,'x','(A)->NonNegativeInteger','pAlgebraPackage(R,A)',NULL,'\spad{leftRank(x)} determines the number of linearly independent elements in \spad{x*b1},{} ...,{} \spad{x*bn},{} where \spad{b=[b1,{} ...,{} bn]} is a basis.');
INSERT INTO olibdb VALUES('o','leftRankPolynomial',0,'n','()->SparseUnivariatePolynomial(Fraction(Polynomial(R)))','dGenericNonAssociativeAlgebra(R,n,ls,gamma)','has(R,IntegralDomain)','\spad{leftRankPolynomial()} returns the left minimimal polynomial of the generic element');
INSERT INTO olibdb VALUES('o','leftRankPolynomial',0,'n','()->SparseUnivariatePolynomial(Polynomial(R))','xFramedNonAssociativeAlgebra&(S,R)',NULL,'\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.');
INSERT INTO olibdb VALUES('o','leftRankPolynomial',0,'x','()->SparseUnivariatePolynomial(Polynomial(R))','cFramedNonAssociativeAlgebra(R)','has(R,Field)','\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.');
INSERT INTO olibdb VALUES('o','leftRecip',1,'n','(S)->Union(S,failed)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRecip',1,'n','(S)->Union(S,failed)','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRecip',1,'x','(%)->Union(%,failed)','cFiniteRankNonAssociativeAlgebra(R)','has(R,IntegralDomain)','\spad{leftRecip(a)} returns an element,{} which is a left inverse of \spad{a},{} or \spad{failed} if there is no unit element,{} if such an element doesn\spad{''t} exist or cannot be determined (see unitsKnown).');
INSERT INTO olibdb VALUES('o','leftRecip',1,'x','(%)->Union(%,failed)','cMagmaWithUnit',NULL,'\spad{leftRecip(a)} returns an element,{} which is a left inverse of \spad{a},{} or \spad{failed} if such an element doesn\spad{''t} exist or cannot be determined (see unitsKnown).');
INSERT INTO olibdb VALUES('o','leftRegularRepresentation',1,'n','(S)->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRegularRepresentation',1,'x','(%)->Matrix(R)','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \spad{a} with respect to the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','leftRegularRepresentation',2,'n','(S,Vector(S))->Matrix(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRegularRepresentation',2,'n','(S,Vector(S))->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRegularRepresentation',2,'x','(%,Vector(%))->Matrix(R)','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftRegularRepresentation(a,{} [v1,{} ...,{} vn])} returns the matrix \spad{m} of the linear map defined by left multiplication by \spad{a} with respect to the \spad{R}-module basis \spad{b = [v1,{} ...,{} vn]}. That is for all \spad{x} \spad{coordinates(a*x,{} b) = m*coordinates(x,{} b)}.');
INSERT INTO olibdb VALUES('o','leftRemainder',2,'n','(S,S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftRemainder',2,'x','(%,%)->%','cUnivariateSkewPolynomialCategory(R)','has(R,Field)','\spad{leftRemainder(a,{} b)} computes the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{r} is returned.');
INSERT INTO olibdb VALUES('o','leftScalarTimes!',3,'n','(Matrix(R),R,Matrix(R))->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{leftScalarTimes!(c,{} r,{} a)} computes the scalar product \spad{r * a} and stores the result in the matrix \spad{c}. Error: if \spad{a} and \spad{c} do not have the same dimensions.');
INSERT INTO olibdb VALUES('o','leftTrace',1,'n','(S)->R','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftTrace',1,'x','(%)->R','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftTrace(a)} returns the trace of the left regular representation of \spad{a}.');
INSERT INTO olibdb VALUES('o','leftTraceMatrix',0,'n','()->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,'\spad{leftTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by left trace of the product \spad{vi*vj},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','leftTraceMatrix',0,'x','()->Matrix(R)','cFramedNonAssociativeAlgebra(R)',NULL,'\spad{leftTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by left trace of the product \spad{vi*vj},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('o','leftTraceMatrix',1,'n','(Vector(S))->Matrix(R)','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftTraceMatrix',1,'n','(Vector(S))->Matrix(R)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftTraceMatrix',1,'x','(Vector(%))->Matrix(R)','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{leftTraceMatrix([v1,{} ...,{} vn])} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj}.');
INSERT INTO olibdb VALUES('o','leftTrim',2,'n','(A,S)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftTrim',2,'x','(%,CharacterClass)->%','cStringAggregate',NULL,'\spad{leftTrim(s,{} cc)} returns \spad{s} with all leading characters in \spad{cc} deleted. For example,{} \spad{leftTrim((abc),{} charClass ())} returns \spad{abc)}.');
INSERT INTO olibdb VALUES('o','leftTrim',2,'x','(%,S)->%','cLinearAggregate(S)','AND(has(%,finiteAggregate),has(S,BasicType))','\spad{leftTrim(u,{} x)} returns a copy of \spad{u} with all leading \spad{x} deleted. For example,{} \spad{leftTrim( abc ,{} char  )} returns \spad{abc }.');
INSERT INTO olibdb VALUES('o','leftUnit',0,'n','()->Union(S,failed)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftUnit',0,'x','()->Union(%,failed)','cFiniteRankNonAssociativeAlgebra(R)','has(R,IntegralDomain)','\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \spad{failed} if there is none.');
INSERT INTO olibdb VALUES('o','leftUnits',0,'n','()->Union(Record(particular:%,basis:List(%)),failed)','dGenericNonAssociativeAlgebra(R,n,ls,gamma)',NULL,'\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \spad{failed} if there is none');
INSERT INTO olibdb VALUES('o','leftUnits',0,'n','()->Union(Record(particular:S,basis:List(S)),failed)','xFramedNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','leftUnits',0,'x','()->Union(Record(particular:%,basis:List(%)),failed)','cFiniteRankNonAssociativeAlgebra(R)','has(R,IntegralDomain)','\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \spad{failed} if there is none.');
INSERT INTO olibdb VALUES('o','leftZero',1,'x','(%)->%','dEquation(S)','has(S,AbelianGroup)','\spad{leftZero(eq)} subtracts the left hand side.');
INSERT INTO olibdb VALUES('o','legendre',1,'n','(Integer)->SparseUnivariatePolynomial(Fraction(Integer))','pPolynomialNumberTheoryFunctions',NULL,'\spad{legendre(n)} returns the \spad{n}th Legendre polynomial \spad{P[n](x)}. Note: Legendre polynomials,{} denoted \spad{P[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{1/sqrt(1-2*t*x+t^2) = sum(P[n](x)*t^n,{} n=0..infinity)}.');
INSERT INTO olibdb VALUES('o','legendre',2,'x','(Integer,Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{legendre(a,{} p)} returns the Legendre symbol \spad{L(a/p)}. \spad{L(a/p) = (-1)^((p-1)/2) mod p} (\spad{p} prime),{} which is 0 if \spad{a} is 0,{} 1 if \spad{a} is a quadratic residue \spad{mod p} and \spad{-1} otherwise. Note: because the primality test is expensive,{} if it is known that \spad{p} is prime then use \spad{jacobi(a,{} p)}.');
INSERT INTO olibdb VALUES('o','legendreP',2,'x','(NonNegativeInteger,R)->R','pOrthogonalPolynomialFunctions(R)','has(R,Algebra(Fraction(Integer)))','\spad{legendreP(n,{} x)} is the \spad{n}-th Legendre polynomial,{} \spad{P[n](x)}. These are defined by \spad{1/sqrt(1-2*x*t+t^2) = sum(P[n](x)*t^n,{} n = 0..)}.');
INSERT INTO olibdb VALUES('o','legendreP',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{legendreP(nu,{} mu,{} z)} is the Legendre \spad{P} function.');
INSERT INTO olibdb VALUES('o','legendreP',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{legendreP(nu,{} mu,{} z)} is the Legendre \spad{P} function.');
INSERT INTO olibdb VALUES('o','legendreQ',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{legendreQ(nu,{} mu,{} z)} is the Legendre \spad{Q} function.');
INSERT INTO olibdb VALUES('o','legendreQ',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{legendreQ(nu,{} mu,{} z)} is the Legendre \spad{Q} function.');
INSERT INTO olibdb VALUES('o','length',1,'n','(%)->NonNegativeInteger','dFreeMonoid(S)',NULL,'\spad{length(x)} returns the length of \spad{x}.');
INSERT INTO olibdb VALUES('o','length',1,'n','(%)->NonNegativeInteger','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,'\spad{length([l1]*[l2]*...[ln])} returns the length of the word \spad{l1*l2*...*ln}.');
INSERT INTO olibdb VALUES('o','length',1,'n','(%)->PositiveInteger','dFreeMagma(VarSet)',NULL,'\spad{length(x)} returns the number of entries in \spad{x}.');
INSERT INTO olibdb VALUES('o','length',1,'n','(%)->PositiveInteger','dLyndonWord(VarSet)',NULL,'\spad{length(x)} returns the number of entries in \spad{x}.');
INSERT INTO olibdb VALUES('o','length',1,'n','(S)->R','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','length',1,'n','(UP)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{length(p)} returns the sum of the absolute values of the coefficients of the polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','length',1,'x','(%)->%','cIntegerNumberSystem',NULL,'\spad{length(a)} length of \spad{a} in digits.');
INSERT INTO olibdb VALUES('o','length',1,'x','(%)->R','cVectorCategory(R)','AND(has(R,RadicalCategory),has(R,Ring))','\spad{length(v)} computes the sqrt(dot(\spad{v},{} \spad{v})),{} \spadignore{i.e.} the euclidean length');
INSERT INTO olibdb VALUES('o','lepol',1,'n','(Dpol)->Integer','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{lepol }\undocumented');
INSERT INTO olibdb VALUES('o','lerchPhi',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{lerchPhi(z,{} s,{} a)} is the Lerch Phi function.');
INSERT INTO olibdb VALUES('o','lerchPhi',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{lerchPhi(z,{} s,{} a)} is the Lerch Phi function.');
INSERT INTO olibdb VALUES('o','less?',2,'n','(A,NonNegativeInteger)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','less?',2,'n','(A,NonNegativeInteger)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','less?',2,'n','(S,NonNegativeInteger)->Boolean','xAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','less?',2,'n','(S,NonNegativeInteger)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','less?',2,'n','(S,S)->Union(Boolean,failed)','pUserDefinedPartialOrdering(S)',NULL,'\spad{less?(a,{} b)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder.');
INSERT INTO olibdb VALUES('o','less?',2,'x','(%,NonNegativeInteger)->Boolean','cAggregate',NULL,'\spad{less?(u,{} n)} tests if \spad{u} has less than \spad{n} elements.');
INSERT INTO olibdb VALUES('o','less?',3,'n','(S,S,(S,S)->Boolean)->Boolean','pUserDefinedPartialOrdering(S)',NULL,'\spad{less?(a,{} b,{} fn)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder,{} and returns \spad{fn(a,{} b)} if \spad{a} and \spad{b} are not comparable in that ordering.');
INSERT INTO olibdb VALUES('o','level',1,'n','(%)->NonNegativeInteger','dSubSpace(n,R)',NULL,'\spad{level(s)} returns a non negative integer which is the current level field of the indicated 3 dimensional subspace \spad{s}.');
INSERT INTO olibdb VALUES('o','leviCivitaSymbol',0,'x','()->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{leviCivitaSymbol()} is the rank \spad{dim} tensor defined by \spad{leviCivitaSymbol()(i1,{} ...idim) = +1/0/-1} if \spad{i1,{} ...,{} idim} is an even/is nota /is an odd permutation of \spad{minix,{} ...,{} minix+dim-1}.');
INSERT INTO olibdb VALUES('o','lex',1,'n','(List(List(S)))->List(List(S))','pTableauxBumpers(S)',NULL,'\spad{lex(ls)} sorts a list of pairs to lexicographic order');
INSERT INTO olibdb VALUES('o','lexGroebner',2,'x','(List(Polynomial(F)),List(Symbol))->List(Polynomial(F))','pPolyGroebner(F)',NULL,'\spad{lexGroebner(lp,{} lv)} computes Groebner basis for the list of polynomials \spad{lp} in lexicographic order. The variables are ordered by their position in the list \spad{lv}.');
INSERT INTO olibdb VALUES('o','lexico',2,'n','(%,%)->Boolean','dFreeMagma(VarSet)',NULL,'\spad{lexico(x,{} y)} returns \spad{true} iff \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \spad{VarSet}. \spad{N}.\spad{B}. This operation does not take into account the tree structure of its arguments. Thus this is not a total ordering.');
INSERT INTO olibdb VALUES('o','lexico',2,'n','(%,%)->Boolean','dFreeMonoid(S)','has(S,OrderedSet)','\spad{lexico(x,{} y)} returns \spad{true} iff \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the pure lexicographical ordering induced by \spad{S}.');
INSERT INTO olibdb VALUES('o','lexico',2,'n','(%,%)->Boolean','dLyndonWord(VarSet)',NULL,'\spad{lexico(x,{} y)} returns \spad{true} iff \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \spad{VarSet}.');
INSERT INTO olibdb VALUES('o','lexSmaller?',2,'n','(SparseUnivariatePolynomial(GF),SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{lexSmaller?(f,{} g)} compares monic \spad{f} and \spad{g} of the same degree in the following order. Error: if \spad{f} or \spad{g} is not monic or if \spad{f} and \spad{g} have different degrees or if common degree is 0. \spad{f < g} if the number of monomials of \spad{f} is less than this number for \spad{g}. If \spad{f} and \spad{g} have the same number of monomials,{} the lists of exponents are compared lexicographically. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of {\em GF} given by {\em lookup}.');
INSERT INTO olibdb VALUES('o','lexTriangular',2,'n','(List(NewSparseMultivariatePolynomial(R,OrderedVariableList(ls))),Boolean)->List(RegularChain(R,ls))','pLexTriangularPackage(R,ls)',NULL,'\spad{lexTriangular(base,{} norm?)} decomposes the variety associated with \spad{base} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \spad{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \spad{norm?} is \spad{true} then the regular sets are normalized.');
INSERT INTO olibdb VALUES('o','lfextendedint',3,'n','(F,Symbol,F)->Union(Record(ratpart:F,coeff:F),failed)','pElementaryIntegration(R,F)',NULL,'\spad{lfextendedint(f,{} x,{} g)} returns functions \spad{[h,{} c]} such that \spad{dh/dx = f - cg},{} if (\spad{h},{} \spad{c}) exist,{} failed otherwise.');
INSERT INTO olibdb VALUES('o','lfintegrate',2,'n','(F,Symbol)->IntegrationResult(F)','pElementaryIntegration(R,F)',NULL,'\spad{lfintegrate(f,{} x)} = \spad{g} such that \spad{dg/dx = f}.');
INSERT INTO olibdb VALUES('o','lfunc',2,'x','(Integer,Integer)->Integer','pHallBasis',NULL,'\spad{lfunc(d,{} n)} computes the rank of the \spad{n}th factor in the lower central series of the free \spad{d}-generated free Lie algebra; This rank is \spad{d} if \spad{n} = 1 and binom(\spad{d},{} 2) if \spad{n} = 2');
INSERT INTO olibdb VALUES('o','lhs',1,'n','(%)->S1','dSuchThat(S1,S2)',NULL,'\spad{lhs(f)} returns the left side of \spad{f}');
INSERT INTO olibdb VALUES('o','lhs',1,'x','(%)->F','dRewriteRule(Base,R,F)',NULL,'\spad{lhs(r)} returns the left hand side of the rule \spad{r}.');
INSERT INTO olibdb VALUES('o','lhs',1,'x','(%)->S','dEquation(S)',NULL,'\spad{lhs(eqn)} returns the left hand side of equation \spad{eqn}.');
INSERT INTO olibdb VALUES('o','li',1,'n','(F)->F','pLiouvillianFunction(R,F)',NULL,'\spad{\spad{li}(f)} denotes the logarithmic integral');
INSERT INTO olibdb VALUES('o','li',1,'x','(%)->%','cLiouvillianFunctionCategory',NULL,'\spad{\spad{li}(x)} returns the logarithmic integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{dx / log(x)}.');
INSERT INTO olibdb VALUES('o','li',1,'x','(Complex(Float))->Complex(Float)','pFloatLiouvilianFunctions',NULL,'\spad{\spad{li}(f)} denotes the logarithmic integral');
INSERT INTO olibdb VALUES('o','li',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','li',1,'x','(Float)->Float','pFloatLiouvilianFunctions',NULL,'\spad{\spad{li}(f)} denotes the logarithmic integral');
INSERT INTO olibdb VALUES('o','li2',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{li2(z)} is polylog(2,{} \spad{z})');
INSERT INTO olibdb VALUES('o','library',1,'x','(FileName)->%','dLibrary',NULL,'\spad{library(ln)} creates a new library file.');
INSERT INTO olibdb VALUES('o','lie',2,'n','(%,%)->%','dJetVectorField(JB,D)',NULL,'\spad{lie(v,{} w)} calculates the Lie derivative of \spad{w} with respect to \spad{v}. (This yields the commutator of the fields.)');
INSERT INTO olibdb VALUES('o','lie',2,'n','(JetVectorField(JB,D),%)->%','dJetDifferential(JB,D)',NULL,'\spad{lie(v,{} om)} calculates the Lie derivative of \spad{om} with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','lieAdmissible?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition.');
INSERT INTO olibdb VALUES('o','lieAdmissible?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition.');
INSERT INTO olibdb VALUES('o','lieAlgebra?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{lieAlgebra?()} tests if the algebra is anticommutative and \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \spad{(A,{} +,{} @)} we can construct a Lie algebra \spad{(A,{} +,{} *)},{} where \spad{a*b := a@b-b@a}.');
INSERT INTO olibdb VALUES('o','lieAlgebra?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{lieAlgebra?()} tests if the algebra is anticommutative and \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{} \spad{b},{} \spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \spad{(A,{} +,{} @)} we can construct a Lie algebra \spad{(A,{} +,{} *)},{} where \spad{a*b := a@b-b@a}.');
INSERT INTO olibdb VALUES('o','LiePoly',1,'x','(LyndonWord(VarSet))->%','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{LiePoly(l)} returns the bracketed form of \spad{l} as a Lie polynomial.');
INSERT INTO olibdb VALUES('o','LiePolyIfCan',1,'n','(%)->Union(LiePolynomial(VarSet,R),failed)','dXPBWPolynomial(VarSet,R)',NULL,'\spad{LiePolyIfCan(p)} return \spad{p} if \spad{p} is a Lie polynomial.');
INSERT INTO olibdb VALUES('o','LiePolyIfCan',1,'n','(XDistributedPolynomial(VarSet,R))->Union(%,failed)','dLiePolynomial(VarSet,R)',NULL,'\spad{LiePolyIfCan(p)} returns \spad{p} in Lyndon basis if \spad{p} is a Lie polynomial,{} otherwise \spad{failed} is returned.');
INSERT INTO olibdb VALUES('o','lift',1,'n','(%)->FPol','dResidueRing(F,Expon,VarSet,FPol,LFPol)',NULL,'\spad{lift(x)} return the canonical representative of the equivalence class \spad{x}');
INSERT INTO olibdb VALUES('o','lift',1,'n','(%)->Rep','dModMonic(R,Rep)',NULL,'\spad{lift(x)} returns \spad{x} as a polynomial.');
INSERT INTO olibdb VALUES('o','lift',1,'n','(S)->SparseUnivariatePolynomial(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lift',1,'x','(%)->UP','cMonogenicAlgebra(R,UP)',NULL,'\spad{lift(z)} returns a minimal degree univariate polynomial up such that \spad{z=reduce up}.');
INSERT INTO olibdb VALUES('o','lift',2,'n','(SparseUnivariatePolynomial(F),Kernel(F))->SparseUnivariatePolynomial(Fraction(SparseUnivariatePolynomial(F)))','pGenusZeroIntegration(R,F,L)',NULL,'\spad{lift(u,{} k)} \undocumented');
INSERT INTO olibdb VALUES('o','lift',8,'n','(SparseUnivariatePolynomial(P),SparseUnivariatePolynomial(R),SparseUnivariatePolynomial(R),P,List(OV),List(NonNegativeInteger),List(R),R)->Union(List(SparseUnivariatePolynomial(P)),failed)','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{lift should} be local');
INSERT INTO olibdb VALUES('o','lifting',7,'n','(SparseUnivariatePolynomial(P),List(OV),List(SparseUnivariatePolynomial(R)),List(R),List(P),List(NonNegativeInteger),(List(SparseUnivariatePolynomial(R)))->Union((SparseUnivariatePolynomial(R))->Union(List(SparseUnivariatePolynomial(R)),failed),failed))->Union(List(SparseUnivariatePolynomial(P)),failed)','pMultivariateLifting(E,OV,R,P)',NULL,'\spad{lifting(u,{} lv,{} lu,{} lr,{} lp,{} ln,{} gen_solv)} lifts univariate factorization,{} returning recovered factors or failed in case of bad reduction. \spad{u} is multivariate polynomial to factor,{} \spad{lu} is list of univariate factors,{} \spad{lv} is list of variables,{} \spad{ln} is list of degrees corresponding to variables,{} \spad{lr} is list of evaluation points,{} \spad{lp} is list of leading coefficients of factors if known,{} empty otherwise,{} gen_solv delivers solver for polynomial equations');
INSERT INTO olibdb VALUES('o','lifting',7,'n','(SparseUnivariatePolynomial(P),List(OV),List(SparseUnivariatePolynomial(R)),List(R),List(P),List(NonNegativeInteger),R)->Union(List(SparseUnivariatePolynomial(P)),failed)','pMultivariateLifting(E,OV,R,P)','has(R,EuclideanDomain)','\spad{lifting(u,{} lv,{} lu,{} lr,{} lp,{} ln,{} r)} is lifting(\spad{u},{} \spad{lv},{} \spad{lu},{} \spad{lr},{} \spad{lp},{} \spad{ln},{} solv(\spad{r})) where solv(\spad{r}) is solver using reduction modulo \spad{r} and lifting. Memberes of \spad{lu} must be relatively prime modulo \spad{r}');
INSERT INTO olibdb VALUES('o','light',1,'x','(Color)->%','dPalette',NULL,'\spad{light(c)} sets the shade of a hue,{} \spad{c},{} to it\spad{''s} highest value.');
INSERT INTO olibdb VALUES('o','lighting',4,'x','(%,Float,Float,Float)->Void','dThreeDimensionalViewport',NULL,'\spad{lighting(v,{} x,{} y,{} z)} sets the position of the light source to the coordinates \spad{x},{} \spad{y},{} and \spad{z} and displays the graph for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','li_int',3,'n','(Fraction(SparseUnivariatePolynomial(F)),Kernel(F),Symbol)->Record(answer:Fraction(SparseUnivariatePolynomial(F)),logpart:Fraction(SparseUnivariatePolynomial(F)),ir:IntegrationResult(Fraction(SparseUnivariatePolynomial(F))))','pDenominatorIntegration(R,F)',NULL,'\spad{li_int(f,{} k,{} x)} generates logarithmic integrals.');
INSERT INTO olibdb VALUES('o','limit',2,'n','(%,NonNegativeInteger)->Loop','dFunctionGraph(S)',NULL,'apply ''function'' represented by this graph to ''a'' repeatedly until we reach a loop which is returned as a sequence of vertex indexes.');
INSERT INTO olibdb VALUES('o','limit',2,'x','(FE,Equation(OrderedCompletion(FE)))->Union(OrderedCompletion(FE),Record(leftHandLimit:Union(OrderedCompletion(FE),failed),rightHandLimit:Union(OrderedCompletion(FE),failed)),failed)','pPowerSeriesLimitPackage(R,FE)',NULL,'\spad{limit(f(x),{} x = a)} computes the real limit \spad{lim(x -> a,{} f(x))}.');
INSERT INTO olibdb VALUES('o','limit',2,'x','(Fraction(Polynomial(R)),Equation(Fraction(Polynomial(R))))->Union(OrderedCompletion(Fraction(Polynomial(R))),Record(leftHandLimit:Union(OrderedCompletion(Fraction(Polynomial(R))),failed),rightHandLimit:Union(OrderedCompletion(Fraction(Polynomial(R))),failed)),failed)','pRationalFunctionLimitPackage(R)',NULL,'\spad{limit(f(x),{} x = a)} computes the real two-sided limit of \spad{f} as its argument \spad{x} approaches \spad{a}.');
INSERT INTO olibdb VALUES('o','limit',2,'x','(Fraction(Polynomial(R)),Equation(OrderedCompletion(Polynomial(R))))->Union(OrderedCompletion(Fraction(Polynomial(R))),Record(leftHandLimit:Union(OrderedCompletion(Fraction(Polynomial(R))),failed),rightHandLimit:Union(OrderedCompletion(Fraction(Polynomial(R))),failed)),failed)','pRationalFunctionLimitPackage(R)',NULL,'\spad{limit(f(x),{} x = a)} computes the real two-sided limit of \spad{f} as its argument \spad{x} approaches \spad{a}.');
INSERT INTO olibdb VALUES('o','limit',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Loop','dMultifunctionGraph(S)',NULL,'apply ''function'' represented by this graph to ''a'' repeatedly until we reach a loop which is returned as a sequence of vertex indexes.');
INSERT INTO olibdb VALUES('o','limit',3,'x','(FE,Equation(FE),String)->Union(OrderedCompletion(FE),failed)','pPowerSeriesLimitPackage(R,FE)',NULL,'\spad{limit(f(x),{}x=a,{}left)} computes the left hand real limit \spad{lim(x -> a-,{} f(x))}; \spad{limit(f(x),{}x=a,{}right)} computes the right hand real limit \spad{lim(x -> a+,{} f(x))}.');
INSERT INTO olibdb VALUES('o','limit',3,'x','(Fraction(Polynomial(R)),Equation(Fraction(Polynomial(R))),String)->Union(OrderedCompletion(Fraction(Polynomial(R))),failed)','pRationalFunctionLimitPackage(R)',NULL,'\spad{limit(f(x),{}x,{}a,{}left)} computes the real limit of \spad{f} as its argument \spad{x} approaches \spad{a} from the left; limit(\spad{f}(\spad{x}),{}\spad{x},{}a,{}right) computes the corresponding limit as \spad{x} approaches \spad{a} from the right.');
INSERT INTO olibdb VALUES('o','limitPart',1,'n','(%)->%','dSmallOrdinal',NULL,'\spad{limitPart(o)} = \spad{l} when \spad{o} = \spad{l} + \spad{n} and \spad{l} is a limit ordinal and \spad{n} is a nonnegative integer');
INSERT INTO olibdb VALUES('o','limitPlus',1,'n','(%)->Union(OrderedCompletion(FE),failed)','dExponentialExpansion(R,FE,var,cen)',NULL,'\spad{limitPlus(f(var))} returns \spad{limit(var -> a+,{} f(var))}.');
INSERT INTO olibdb VALUES('o','limitPlus',1,'n','(%)->Union(OrderedCompletion(FE),failed)','dUnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,var,cen)',NULL,'\spad{limitPlus(f(var))} returns \spad{limit(var -> cen+,{} f(var))}.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(F),List(F))->F','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(F),List(Fraction(UP)))->Fraction(UP)','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(F),List(LaurentPolynomial(F,UP)))->LaurentPolynomial(F,UP)','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(F),List(UP))->UP','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(F),List(Vector(F)))->Vector(F)','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal positive length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(Fraction(Integer)),List(F))->F','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb',2,'n','(Vector(Fraction(Integer)),List(Fraction(UP)))->Fraction(UP)','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb(v,{} [f1,{} ...,{} fn])} computes linear combination \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn}. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','lin_comb!',3,'n','(Vector(F),Vector(F),List(Vector(F)))->Vector(F)','pLinearCombinationUtilities(F,UP)',NULL,'\spad{lin_comb!(v,{} w,{} [f1,{} ...,{} fn])} computes linear combination \spad{w} + \spad{v}(1) \spad{f1} + ... \spad{v}(\spad{n}) \spad{fn} by modifying \spad{w} in place. Vector \spad{v} and list [\spad{f1},{} ...,{} \spad{fn}] must be of equal length.');
INSERT INTO olibdb VALUES('o','line',0,'n','()->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'create a simplicial complex containing a line.');
INSERT INTO olibdb VALUES('o','linear?',1,'n','(P)->Boolean','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{linear?(p)} returns \spad{true} iff \spad{p} does not lie in the base ring \spad{R} and has main degree \spad{1}.');
INSERT INTO olibdb VALUES('o','linear',1,'n','(UP)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{linear(u)} \undocumented');
INSERT INTO olibdb VALUES('o','linear',2,'n','(F,F)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{linear(f,{} g)} \undocumented');
INSERT INTO olibdb VALUES('o','linearAssociatedExp',2,'n','(S,SparseUnivariatePolynomial(F))->S','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','linearAssociatedExp',2,'x','(%,SparseUnivariatePolynomial(F))->%','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{linearAssociatedExp(a,{} f)} is linear over {\em F},{} \spadignore{i.e.} for elements {\em a} from {\em \$},{} {\em c,{} d} form {\em F} and {\em f,{} g} univariate polynomials over {\em F} we have \spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\em c} times \spadfun{linearAssociatedExp}(a,{} \spad{f}) plus {\em d} times \spadfun{linearAssociatedExp}(a,{} \spad{g}). Therefore \spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\em F[X]}: \spadfun{linearAssociatedExp}(a,{} monomial(1,{} \spad{k})\spad{\$}SUP(\spad{F})) is defined to be \spadfun{Frobenius}(a,{} \spad{k}) which is {\em a^(q^k)},{} where {\em q=size()\$F}.');
INSERT INTO olibdb VALUES('o','linearAssociatedLog',1,'n','(S)->SparseUnivariatePolynomial(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','linearAssociatedLog',1,'x','(%)->SparseUnivariatePolynomial(F)','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{linearAssociatedLog(a)} returns a polynomial {\em g},{} such that \spadfun{linearAssociatedExp}(normalElement(),{} \spad{g}) equals {\em a}.');
INSERT INTO olibdb VALUES('o','linearAssociatedLog',2,'n','(S,S)->Union(SparseUnivariatePolynomial(F),failed)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','linearAssociatedLog',2,'x','(%,%)->Union(SparseUnivariatePolynomial(F),failed)','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{linearAssociatedLog(b,{} a)} returns a polynomial {\em g},{} such that the \spadfun{linearAssociatedExp}(\spad{b},{} \spad{g}) equals {\em a}. If there is no such polynomial {\em g},{} then \spadfun{linearAssociatedLog} fails.');
INSERT INTO olibdb VALUES('o','linearAssociatedOrder',1,'n','(S)->SparseUnivariatePolynomial(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','linearAssociatedOrder',1,'x','(%)->SparseUnivariatePolynomial(F)','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{linearAssociatedOrder(a)} returns the monic polynomial {\em g} of least degree,{} such that \spadfun{linearAssociatedExp}(a,{} \spad{g}) is 0.');
INSERT INTO olibdb VALUES('o','linearDependence',1,'n','(Vector(R))->Union(Vector(S),failed)','pLinearDependence(S,R)',NULL,'\spad{linearDependence([v1,{} ...,{} vn])} returns \spad{[c1,{} ...,{} cn]} if \spad{c1*v1 + ... + cn*vn = 0} and not all the \spad{ci}\spad{''s} are 0,{} failed if the \spad{vi}\spad{''s} are linearly independent over \spad{S}.');
INSERT INTO olibdb VALUES('o','linearDependenceOverConstants',2,'n','(Vector(F),List((F)->F))->Union(Vector(F),failed)','pConstantLinearDependence(R,F)',NULL,'\spad{linearlyDependenceOverConstants([v1,{} ...,{} vn],{} ld)} returns \spad{[c1,{} ...,{} cn]} if \spad{c1*v1 + ... + cn*vn = 0} and not all the \spad{ci}\spad{''s} are 0,{} failed if the \spad{vi}\spad{''s} are linearly independent over constants.');
INSERT INTO olibdb VALUES('o','linearDependenceOverZ',1,'x','(Vector(R))->Union(Vector(Integer),failed)','pIntegerLinearDependence(R)',NULL,'\spad{linearlyDependenceOverZ([v1,{} ...,{} vn])} returns \spad{[c1,{} ...,{} cn]} if \spad{c1*v1 + ... + cn*vn = 0} and not all the \spad{ci}\spad{''s} are 0,{} failed if the \spad{vi}\spad{''s} are linearly independent over the integers.');
INSERT INTO olibdb VALUES('o','linearExtend',2,'n','((List(B))->M2,TensorPower(n,R,B,M1))->M2','pTensorPowerFunctions2(n,R,B,M1,M2)',NULL,'\spad{linearExtend: (f,{} x)} returns the linear extension of a multilinear map defined on the basis of \spad{M2} applied to a linear combination');
INSERT INTO olibdb VALUES('o','linearExtend',2,'x','((S)->M2,M1)->M2','pFreeModuleFunctions2(R,S,M1,M2)',NULL,'\spad{linearExtend: (f,{} x)} returns the linear extension of a map defined on the basis of \spad{M2} applied to a linear combination');
INSERT INTO olibdb VALUES('o','linearExtend',2,'x','((S)->R,%)->R','cFreeModuleCategory(R,S)','has(R,CommutativeRing)','\spad{linearExtend: (f,{} x)} returns the linear extension of a map defined on the basis applied to a linear combination');
INSERT INTO olibdb VALUES('o','linearization',1,'n','(%)->Matrix(%)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{linearization(f)} returns the element \spad{f} as linearization with entries represented by admissible linear systems in minimal refined form.');
INSERT INTO olibdb VALUES('o','linearization',1,'n','(%)->Matrix(XDistributedPolynomial(VAR,F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{linearization(f)} returns the element \spad{f} as linearization.');
INSERT INTO olibdb VALUES('o','linearize',1,'n','(List(JetBundleExpression(JetBundleSymAna(JB1,xi,eta))))->List(JetBundleLinearFunction(JetBundleSymAna(JB1,xi,eta),JetBundleXExpression(JetBundleSymAna(JB1,xi,eta))))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{linearize(sys)} tries to retract all equations in \spad{sys} to a linear one. If that is not possible,{} an error occurs.');
INSERT INTO olibdb VALUES('o','linearlyDependent?',1,'n','(Vector(R))->Boolean','pLinearDependence(S,R)',NULL,'\spad{linearlyDependent?([v1,{} ...,{} vn])} returns \spad{true} if the \spad{vi}\spad{''s} are linearly dependent over \spad{S},{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','linearlyDependentOverConstants?',2,'n','(Vector(F),List((F)->F))->Boolean','pConstantLinearDependence(R,F)',NULL,'\spad{linearlyDependentOverConstants?([v1,{} ...,{} vn],{} ld)} returns \spad{true} if the \spad{vi}\spad{''s} are linearly dependent over constants,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','linearlyDependentOverZ?',1,'x','(Vector(R))->Boolean','pIntegerLinearDependence(R)',NULL,'\spad{linearlyDependentOverZ?([v1,{} ...,{} vn])} returns \spad{true} if the \spad{vi}\spad{''s} are linearly dependent over the integers,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','linearPolynomials',1,'n','(List(P))->Record(goodPols:List(P),badPols:List(P))','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{linearPolynomials(lp)} returns \spad{lps,{} nlps} where \spad{lps} is a list of the linear polynomials in \spad{lp},{} and \spad{nlps} are the other ones.');
INSERT INTO olibdb VALUES('o','linearSearch',1,'n','((S)->Boolean)->Union(S,failed)','pSortedCache(S)',NULL,'\spad{linearSearch(f)} searches the cache,{} calling \spad{f(y)} find desired \spad{y}. It returns \spad{y} from cache if \spad{f}(\spad{y}) is \spad{true} or failed if no such \spad{y} exists.');
INSERT INTO olibdb VALUES('o','lineColorDefault',0,'x','()->Palette','pViewDefaultsPackage',NULL,'\spad{lineColorDefault()} returns the default color of lines connecting points in a 2D viewport.');
INSERT INTO olibdb VALUES('o','lineColorDefault',1,'x','(Palette)->Palette','pViewDefaultsPackage',NULL,'\spad{lineColorDefault(p)} sets the default color of lines connecting points in a 2D viewport to the palette \spad{p}.');
INSERT INTO olibdb VALUES('o','lineIntersect',2,'n','(%,PT)->PT','dSBoundary(PT)',NULL,'\spad{lineIntersect(n,{} p)} returns the point where a line,{} from the centre of the boundary to the point \spad{p},{} intersects with the boundary. \spad{n:} \% is the boundary \spad{p:} \spad{PT} is the point at the end of the line (outside boundary)');
INSERT INTO olibdb VALUES('o','lines',1,'n','(%)->List(String)','dOutputBox',NULL,'\spad{lines(box)} returns the contents of the \spad{box} as strings (all of the same length (width(\spad{box})).');
INSERT INTO olibdb VALUES('o','linGenPos',1,'n','(List(HomogeneousDistributedMultivariatePolynomial(lv,F)))->Record(gblist:List(DistributedMultivariatePolynomial(lv,F)),gvlist:List(Integer))','pLinGroebnerPackage(lv,F)',NULL,'\spad{linGenPos }\undocumented');
INSERT INTO olibdb VALUES('o','link',2,'n','(%,%)->List(PT)','dSBoundary(PT)',NULL,'\spad{link(m,{} n)} returns a line which is the shortest distance between the two boundaries. The line is represented by its two endpoints. \spad{m:} \% is the first boundary to be linked \spad{n:} \% is the second boundary to be linked');
INSERT INTO olibdb VALUES('o','link',2,'n','(NonNegativeInteger,NonNegativeInteger)->%','dDeltaComplex(VS)',NULL,'a simplicial complex with one link');
INSERT INTO olibdb VALUES('o','link',2,'n','(%,OrientedFacet)->%','dFiniteSimplicialComplex(VS)',NULL,'The ''link'' of a simplicial complex and a vertex contains the boundary of the simplexes of \spad{s} which include simplex.');
INSERT INTO olibdb VALUES('o','lin_sol',2,'n','(List(F),List(Symbol))->Union(List(F),failed)','pExpressionLinearSolve(R,F)',NULL,'\spad{lin_sol(eql,{} vl)} solves system of equations \spad{eql} for variables in \spad{vl}. Equations must be linear in variables from \spad{vl}.');
INSERT INTO olibdb VALUES('o','linSolve',2,'x','(List(P),List(OV))->Record(particular:Union(Vector(Fraction(P)),failed),basis:List(Vector(Fraction(P))))','pLinearSystemPolynomialPackage(R,E,OV,P)',NULL,'\spad{linSolve(lp,{} lvar)} finds the solutions of the linear system of polynomials \spad{lp} = 0 with respect to the list of symbols lvar.');
INSERT INTO olibdb VALUES('o','lintgcd',1,'n','(List(Integer))->Integer','pHeuGcd(BP)',NULL,'\spad{lintgcd([a1,{} ..,{} ak])} = \spad{gcd} of a list of integers');
INSERT INTO olibdb VALUES('o','list',1,'n','(S)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','list?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{list?(s)} is \spad{true} if \spad{s} is a Lisp list,{} possibly ().');
INSERT INTO olibdb VALUES('o','list',1,'x','(S)->%','cListAggregate(S)',NULL,'\spad{list(x)} returns the list of one element \spad{x}.');
INSERT INTO olibdb VALUES('o','listBranches',1,'x','(%)->List(List(Point(DoubleFloat)))','cPlottablePlaneCurveCategory',NULL,'\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \spad{c}.');
INSERT INTO olibdb VALUES('o','listBranches',1,'x','(%)->List(List(Point(DoubleFloat)))','cPlottableSpaceCurveCategory',NULL,'\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \spad{c}.');
INSERT INTO olibdb VALUES('o','listConjugateBases',3,'n','(Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R)),NonNegativeInteger,NonNegativeInteger)->List(Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R)))','pChineseRemainderToolsForIntegralBases(K,R,UP)',NULL,'\spad{listConjugateBases(bas,{} q,{} n)} returns the list \spad{[bas,{} bas^Frob,{} bas^(Frob^2),{} ...bas^(Frob^(n-1))]},{} where \spad{Frob} raises the coefficients of all polynomials appearing in the basis \spad{bas} to the \spad{q}th power.');
INSERT INTO olibdb VALUES('o','listLoops',1,'n','(%)->List(List(Point(DoubleFloat)))','dTubePlot(Curve)',NULL,'\spad{listLoops(t)} returns the list of lists of points,{} or the ''loops'',{} of the given tube plot \spad{t}.');
INSERT INTO olibdb VALUES('o','listOfLists',1,'n','(S)->List(List(R))','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','listOfLists',1,'x','(%)->List(List(R))','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{listOfLists(m)} returns the rows of the matrix \spad{m} as a list of lists.');
INSERT INTO olibdb VALUES('o','listOfLists',1,'x','(%)->List(List(R))','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{listOfLists(m)} returns the rows of the array \spad{m} as a list of lists.');
INSERT INTO olibdb VALUES('o','listOfLists',1,'x','(%)->List(List(S))','dTableau(S)',NULL,'\spad{listOfLists t} converts a tableau \spad{t} to a list of lists.');
INSERT INTO olibdb VALUES('o','listOfMonoms',1,'n','(%)->List(Record(gen:S,exp:E))','dListMonoidOps(S,E,un)',NULL,'\spad{listOfMonoms(l)} returns the list of the monomials forming \spad{l}.');
INSERT INTO olibdb VALUES('o','listOfTerms',1,'n','(%)->List(LyndonWord(VarSet))','dPoincareBirkhoffWittLyndonBasis(VarSet)',NULL,'\spad{listOfTerms([l1]*[l2]*...[ln])} returns the list of words \spad{l1,{} l2,{} .... ln}.');
INSERT INTO olibdb VALUES('o','listOfTerms',1,'n','(%)->List(Record(k:PoincareBirkhoffWittLyndonBasis(VarSet),c:R))','dLieExponentials(VarSet,R,Order)',NULL,'\spad{listOfTerms(p)} returns the internal representation of \spad{p}.');
INSERT INTO olibdb VALUES('o','listOfTerms',1,'x','(%)->List(Record(k:S,c:A))','cIndexedDirectProductCategory(A,S)',NULL,'\spad{listOfTerms(x)} returns a list \spad{lt} of terms with type \spad{Record(k: S,{} c: R)} such that \spad{x} equals \spad{construct(lt)}. If \spad{S has Comparable} than \spad{x} equals \spad{constructOrdered(lt)}.');
INSERT INTO olibdb VALUES('o','listRepresentation',1,'x','(%)->Record(preimage:List(S),image:List(S))','dPermutation(S)',NULL,'\spad{listRepresentation(p)} produces a representation {\em rep} of the permutation \spad{p} as a list of preimages and images,{} \spad{i}.\spad{e} \spad{p} maps {\em (rep.preimage).k} to {\em (rep.image).k} for all indices \spad{k}. Elements of \spad{S} not in {\em (rep.preimage).k} are fixed points,{} and these are the only fixed points of the permutation.');
INSERT INTO olibdb VALUES('o','lists',1,'n','(%)->PatternMatchResult(R,L)','dPatternMatchListResult(R,S,L)',NULL,'\spad{lists(r)} returns the list of matches that match lists.');
INSERT INTO olibdb VALUES('o','listYoungTableaus',1,'x','(List(Integer))->List(Matrix(Integer))','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{listYoungTableaus(lambda)} where {\em lambda} is a proper partition generates the list of all standard tableaus of shape {\em lambda} by means of lattice permutations. The numbers of the lattice permutation are interpreted as column labels. Hence the contents of these lattice permutations are the conjugate of {\em lambda}. Notes: the functions {\em nextLatticePermutation} and {\em makeYoungTableau} are used. The entries are from {\em 0,{} ...,{} n-1}.');
INSERT INTO olibdb VALUES('o','LLFI_to_LPA',3,'n','(List(List(Fraction(Integer))),Integer,Integer)->Union(List(U32Vector),failed)','pModularHermitePade',NULL,'evaluation routine');
INSERT INTO olibdb VALUES('o','LLFPI_to_LPA',5,'n','(List(List(Fraction(Polynomial(Integer)))),Integer,List(Symbol),List(Integer),Integer)->Union(List(U32Vector),failed)','pModularHermitePade',NULL,'evaluation routine');
INSERT INTO olibdb VALUES('o','LLF_to_LPA',5,'n','(List(List(F)),Integer,List(Symbol),List(Integer),Integer)->Union(List(U32Vector),failed)','pModularHermitePadeSolver(F,S)',NULL,'modular reduction');
INSERT INTO olibdb VALUES('o','LLL',1,'n','(Matrix(Integer))->Matrix(Integer)','pLLLReduction',NULL,'\spad{LLL(m)} computes \spad{LLL} reduction of \spad{m} \spad{LLL}(\spad{m}) is the same as extendedLLL!(copy \spad{m},{} ncols \spad{m}).');
INSERT INTO olibdb VALUES('o','lllip',1,'x','(%)->List(List(List(NonNegativeInteger)))','cThreeSpaceCategory(R)',NULL,'\spad{lllip(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of indices to points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','lllp',1,'x','(%)->List(List(List(Point(R))))','cThreeSpaceCategory(R)',NULL,'\spad{lllp(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','llprop',1,'x','(%)->List(List(SubSpaceComponentProperty))','cThreeSpaceCategory(R)',NULL,'\spad{llprop(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of curves which are lists of the subspace component properties of the curves,{} and if so,{} returns the list of lists; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','localAbs',1,'n','(FE)->FE','pFunctionSpaceToExponentialExpansion(R,FE,x,cen)',NULL,'\spad{localAbs(fcn)} = \spad{abs(fcn)} or \spad{sqrt(fcn^2)} depending on whether or not FE has a function \spad{abs}. This should be a local function,{} but the compiler won\spad{''t} allow it.');
INSERT INTO olibdb VALUES('o','localAbs',1,'n','(FE)->FE','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{localAbs(fcn)} = \spad{abs(fcn)} or \spad{sqrt(fcn^2)} depending on whether or not FE has a function \spad{abs}. This should be a local function,{} but the compiler won\spad{''t} allow it.');
INSERT INTO olibdb VALUES('o','localIntegralBasis',1,'n','(Integer)->Record(basis:Matrix(Integer),basisDen:Integer,basisInv:Matrix(Integer))','pNumberFieldIntegralBasis(UP,F)',NULL,'\spad{integralBasis(p)} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \spad{Z} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{Z}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','localIntegralBasis',1,'n','(R)->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pFunctionFieldIntegralBasis(R,UP,F)',NULL,'\spad{integralBasis(p)} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','localIntegralBasis',1,'n','(R)->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pPAdicWildFunctionFieldIntegralBasis(K,R,UP,F)',NULL,'\spad{integralBasis(p)} returns a record \spad{[basis,{} basisDen,{} basisInv] } containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of the framed algebra \spad{F}. \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If ''basis'' is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of ''basis'' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix ''basisInv'' contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if ''basisInv'' is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','localIntegralBasis',1,'n','(R)->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pWildFunctionFieldIntegralBasis(K,R,UP,F)',NULL,'\spad{integralBasis(p)} returns a record \spad{[basis,{} basisDen,{} basisInv]} containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','localReal?',1,'n','(F)->Boolean','pElementaryFunction(R,F)',NULL,'\spad{localReal?(x)} should be local but conditional');
INSERT INTO olibdb VALUES('o','LODO2FUN',1,'n','(L)->(List(UTS))->UTS','pUTSodetools(F,UP,L,UTS)',NULL,'\spad{LODO2FUN(op)} returns the function to pass to the series ODE solver in order to solve \spad{op y = 0}.');
INSERT INTO olibdb VALUES('o','log10',0,'x','()->%','dFloat',NULL,'\spad{log10()} returns \spad{ln 10}: \spad{2.3025809299...}.');
INSERT INTO olibdb VALUES('o','log10',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{log10(x)} represents the Fortran intrinsic function \spad{LOG10}');
INSERT INTO olibdb VALUES('o','log10',1,'n','(PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{log10(b)} computes approximation to log(10) accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','log10',1,'x','(%)->%','dDoubleFloat',NULL,'\spad{log10(x)} computes the logarithm with base 10 for \spad{x}.');
INSERT INTO olibdb VALUES('o','log10',1,'x','(%)->%','dFloat',NULL,'\spad{log10(x)} computes the logarithm for \spad{x} to base 10.');
INSERT INTO olibdb VALUES('o','log1',1,'n','(Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesOperations(Coef)',NULL,'\spad{log1(f)} returns the logarithm of the power series represented by cons(1,{} \spad{f}),{} \spadignore{i.e.} assuming that the constant term is 1 and therefore transcendentality is not involved.');
INSERT INTO olibdb VALUES('o','log',1,'n','(%)->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{log(x)} represents the Fortran intrinsic function LOG');
INSERT INTO olibdb VALUES('o','log',1,'n','(Factored(M))->List(Record(coef:NonNegativeInteger,logand:M))','pFactoredFunctions(M)',NULL,'\spad{log(f)} returns \spad{[(a1,{} b1),{} ...,{} (am,{} bm)]} such that the logarithm of \spad{f} is equal to \spad{a1*log(b1) + ... + am*log(bm)}.');
INSERT INTO olibdb VALUES('o','log',1,'n','(F)->F','pElementaryFunction(R,F)',NULL,'\spad{log(x)} applies the logarithm operator to \spad{x}');
INSERT INTO olibdb VALUES('o','log',1,'n','(%)->LiePolynomial(VarSet,R)','dLieExponentials(VarSet,R,Order)',NULL,'\spad{log(p)} returns the logarithm of \spad{p}.');
INSERT INTO olibdb VALUES('o','log',1,'n','(S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','log',1,'n','(S)->S','xUnivariateTaylorSeriesCategory&(S,Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','log',1,'n','(Stream(Coef))->Stream(Coef)','pStreamExponentialSeriesTranscendentalFunctions(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','log',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctions(Coef)',NULL,'\spad{log(st)} computes the log of a power series.');
INSERT INTO olibdb VALUES('o','log',1,'n','(Stream(Coef))->Stream(Coef)','pStreamTranscendentalFunctionsNonCommutative(Coef)',NULL,'\spad{log(st)} computes the log of a power series.');
INSERT INTO olibdb VALUES('o','log',1,'n','(ULS)->ULS','dElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS)',NULL,'\spad{log(z)} returns the logarithm of Laurent series \spad{z}.');
INSERT INTO olibdb VALUES('o','log',1,'n','(UPXS)->UPXS','dElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS)',NULL,'\spad{log(z)} returns the logarithm of a Puiseux series \spad{z}.');
INSERT INTO olibdb VALUES('o','log',1,'x','(%)->%','cElementaryFunctionCategory',NULL,'\spad{log(x)} returns the natural logarithm of \spad{x}. When evaluated into some subset of the complex numbers,{} the branch cut lies along the negative real axis,{} continuous with quadrant II. The domain does not contain the origin.');
INSERT INTO olibdb VALUES('o','log2',0,'x','()->%','dFloat',NULL,'\spad{log2()} returns \spad{ln 2},{} \spadignore{i.e.} \spad{0.6931471805...}.');
INSERT INTO olibdb VALUES('o','log2',1,'n','(PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{log2(b)} computes approximation to log(2) accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','log2',1,'x','(%)->%','dDoubleFloat',NULL,'\spad{log2(x)} computes the logarithm with base 2 for \spad{x}.');
INSERT INTO olibdb VALUES('o','log2',1,'x','(%)->%','dFloat',NULL,'\spad{log2(x)} computes the logarithm for \spad{x} to base 2.');
INSERT INTO olibdb VALUES('o','log',2,'n','(%,NonNegativeInteger)->%','dXPBWPolynomial(VarSet,R)','has(R,Module(Fraction(Integer)))','\spad{log(p,{} n)} returns the logarithm of \spad{p} (truncated up to order \spad{n}).');
INSERT INTO olibdb VALUES('o','log',2,'n','(Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{log(x,{} b)} computes approximation to exp(\spad{x}) accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','log',2,'n','(XPOLY,NonNegativeInteger)->XPOLY','pXExponentialPackage(R,VarSet,XPOLY)',NULL,'\spad{log(p,{} n)} returns the logarithm of \spad{p} truncated at order \spad{n}.');
INSERT INTO olibdb VALUES('o','logDependenceQ',2,'n','(List(Fraction(Integer)),Fraction(Integer))->Union(Vector(Fraction(Integer)),failed)','pMultiplicativeDependence',NULL,'\spad{logDependenceQ([q1,{} ...,{} qn],{} q0)} finds rational constants \spad{c1,{} ...cn} such that \spad{q1^c1*...*qn^cn=u*q0} where \spad{u} is a unit');
INSERT INTO olibdb VALUES('o','logextint',3,'n','(Symbol,List(Kernel(F)),List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer))))','pParametricIntegration(R,F)',NULL,'\spad{logextint(x,{} lk,{} lg)} returns [[\spad{u1},{} ...,{} um],{} bas] giving basis of solution of the homogeneous systym \spad{c1*g1 + ... + cn*gn + c_{n+1}u1''/u1 + ... c_{n+m}um''/um = 0}');
INSERT INTO olibdb VALUES('o','logextint',5,'n','((UP)->UP,(UP)->Factored(UP),(Matrix(F))->List(Vector(Fraction(Integer))),(List(UP))->Record(logands:List(Fraction(UP)),basis:List(Vector(Fraction(Integer)))),List(Fraction(UP)))->Record(logands:List(Fraction(UP)),basis:List(Vector(Fraction(Integer))))','pParametricTranscendentalIntegration(F,UP)',NULL,'\spad{logextint(der,{} ufactor,{} csolve,{} rec,{} [g1,{} ...,{} gn])} returns [[\spad{u1},{} ...,{} um],{} bas] giving basis of solution of the homogeneous systym \spad{c1*g1 + ... + cn*gn + c_{n+1}u1''/u1 + ... c_{n+m}um''/um = 0}');
INSERT INTO olibdb VALUES('o','logGamma',1,'x','(Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','logGamma',1,'x','(Complex(Float))->Complex(Float)','pFloatSpecialFunctions',NULL,'\spad{logGamma(x)} is the natural log of \spad{Gamma(x)}.');
INSERT INTO olibdb VALUES('o','logGamma',1,'x','(DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','logGamma',1,'x','(Float)->Float','pFloatSpecialFunctions',NULL,'\spad{logGamma(x)} is the natural log of \spad{Gamma(x)}.');
INSERT INTO olibdb VALUES('o','logical?',1,'n','(%)->Boolean','dFortranScalarType',NULL,'\spad{logical?(t)} tests whether \spad{t} is equivalent to the FORTRAN type LOGICAL.');
INSERT INTO olibdb VALUES('o','logicF',0,'n','()->%','dILogic',NULL,'\spad{false} (contradiction) is a logical constant.');
INSERT INTO olibdb VALUES('o','logicF',0,'n','()->%','dLatticeJoinOfMeets',NULL,'construct \spad{false} (contradiction): a logical constant.');
INSERT INTO olibdb VALUES('o','logicF',0,'n','()->%','dLatticeMeetOfJoins',NULL,'construct \spad{false} (contradiction): a logical constant.');
INSERT INTO olibdb VALUES('o','logicT',0,'n','()->%','dILogic',NULL,'\spad{true} is a logical constant.');
INSERT INTO olibdb VALUES('o','logicT',0,'n','()->%','dLatticeJoinOfMeets',NULL,'construct true: a logical constant.');
INSERT INTO olibdb VALUES('o','logicT',0,'n','()->%','dLatticeMeetOfJoins',NULL,'construct true: a logical constant.');
INSERT INTO olibdb VALUES('o','logIfCan',1,'x','(K)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{logIfCan(z)} returns log(\spad{z}) if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','logpart',1,'n','(%)->List(Record(scalar:Fraction(Integer),coeff:SparseUnivariatePolynomial(F),logand:SparseUnivariatePolynomial(F)))','dIntegrationResult(F)',NULL,'\spad{logpart(ir)} returns the logarithmic part of an integration result');
INSERT INTO olibdb VALUES('o','log_plus_1',1,'n','(DoubleFloat)->DoubleFloat','pDoubleFloatElementaryFunctions',NULL,'\spad{log_plus_1(x)} computes \spad{log(1 + x)} with good accuracy.');
INSERT INTO olibdb VALUES('o','log_series',2,'n','(Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,NULL);
INSERT INTO olibdb VALUES('o','lommelS1',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{lommelS1(mu,{} nu,{} z)} is the Lommel \spad{s} function.');
INSERT INTO olibdb VALUES('o','lommelS1',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{lommelS1(mu,{} nu,{} z)} is the Lommel \spad{s} function.');
INSERT INTO olibdb VALUES('o','lommelS2',3,'n','(F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{lommelS2(mu,{} nu,{} z)} is the Lommel \spad{S} function.');
INSERT INTO olibdb VALUES('o','lommelS2',3,'x','(%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{lommelS2(mu,{} nu,{} z)} is the Lommel \spad{S} function.');
INSERT INTO olibdb VALUES('o','lookup',1,'n','(A)->PositiveInteger','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lookup',1,'n','(S)->PositiveInteger','xDirectProductCategory&(S,dim,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lookup',1,'n','(S)->PositiveInteger','xFramedModule&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lookup',1,'n','(S)->PositiveInteger','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lookup',1,'n','(Vector(GF))->PositiveInteger','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{lookup(x)} \undocumented{} See \spadfunFrom{lookup}{Finite}');
INSERT INTO olibdb VALUES('o','lookup',1,'x','(%)->PositiveInteger','cFinite',NULL,'\spad{lookup(x)} returns a positive integer such that \spad{x = index lookup x}.');
INSERT INTO olibdb VALUES('o','loop',1,'n','(List(NonNegativeInteger))->%','dLoop',NULL,'\spad{loop(\spad{li})} constructs loop from list of indexes \spad{li}');
INSERT INTO olibdb VALUES('o','loopPoints',5,'n','(Point(DoubleFloat),Point(DoubleFloat),Point(DoubleFloat),DoubleFloat,List(List(DoubleFloat)))->List(Point(DoubleFloat))','pTubePlotTools',NULL,'\spad{loopPoints(p,{} n,{} b,{} r,{} lls)} creates and returns a list of points which form the loop with radius \spad{r},{} around the center point indicated by the point \spad{p},{} with the principal normal vector of the space curve at point \spad{p} given by the point(vector) \spad{n},{} and the binormal vector given by the point(vector) \spad{b},{} and a list of lists,{} \spad{lls},{} which is the \spadfun{cosSinInfo} of the number of points defining the loop.');
INSERT INTO olibdb VALUES('o','loopsArrows',1,'n','(A)->List(Loop)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','loopsArrows',1,'n','(%)->List(Loop)','cFiniteGraph(S)',NULL,'\spad{loopsArrows(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through. to-do: it would be better to use a more efficient algorithm,{} currently the code calls spanningForestArrow and traverses the result for loops,{} it might be more efficient to use Floyds algorithm.');
INSERT INTO olibdb VALUES('o','loopsAtNode',2,'n','(A,NonNegativeInteger)->List(Loop)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','loopsAtNode',2,'n','(%,NonNegativeInteger)->List(Loop)','cFiniteGraph(S)',NULL,'\spad{loopsAtNode(s,{} a)} returns a list of loops for this graph that pass through vertex index ''a''');
INSERT INTO olibdb VALUES('o','loopsNodes',1,'n','(A)->List(Loop)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','loopsNodes',1,'n','(%)->List(Loop)','cFiniteGraph(S)',NULL,'\spad{loopsNodes(s)} returns a list of loops for this graph in this case the loop is represented by the indexes of the sequence of nodes passed through.');
INSERT INTO olibdb VALUES('o','looseEquals',2,'n','(A,A)->Boolean','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','looseEquals',2,'n','(A,A)->Boolean','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','looseEquals',2,'n','(%,%)->Boolean','cFiniteGraph(S)',NULL,'\spad{looseEquals(x,{} y)} is \spad{true} if \spad{x} ''equals'' \spad{y} this is a looser version of equality test but is not as general as isomorphism. it only requires the same number of vertices but does not require the objects themselves being equal. the arrows must be the same,{} that is it may return \spad{false} if the order of vertices is changed so this is not isomorphism test.');
INSERT INTO olibdb VALUES('o','low',1,'x','(%)->S','cSegmentCategory(S)',NULL,'\spad{low(s)} returns the first endpoint of \spad{s}. Note: \spad{low(l..h) = l}.');
INSERT INTO olibdb VALUES('o','lowerCase',0,'x','()->%','dCharacterClass',NULL,'\spad{lowerCase()} returns the class of all characters for which \spadfunFrom{lowerCase?}{Character} is \spad{true}.');
INSERT INTO olibdb VALUES('o','lowerCase',1,'n','(S)->S','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lowerCase?',1,'x','(%)->Boolean','dCharacter',NULL,'\spad{lowerCase?(c)} tests if \spad{c} is an lower case letter,{} \spadignore{i.e.} one of a..\spad{z}.');
INSERT INTO olibdb VALUES('o','lowerCase!',1,'x','(%)->%','cStringAggregate',NULL,'\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \spad{s} by lower case.');
INSERT INTO olibdb VALUES('o','lowerCase',1,'x','(%)->%','cStringAggregate',NULL,'\spad{lowerCase(s)} returns the string with all characters in lower case.');
INSERT INTO olibdb VALUES('o','lowerCase',1,'x','(%)->%','dCharacter',NULL,'\spad{lowerCase(c)} converts an upper case letter to the corresponding lower case letter. If \spad{c} is not an upper case letter,{} then it is returned unchanged.');
INSERT INTO olibdb VALUES('o','lowerPolynomial',1,'n','(SparseUnivariatePolynomial(P))->SparseUnivariatePolynomial(R)','pFactoringUtilities(E,OV,R,P)',NULL,'\spad{lowerPolynomial(upoly)} converts \spad{upoly} to be a univariate polynomial over \spad{R}. An error if the coefficients contain variables.');
INSERT INTO olibdb VALUES('o','lowerSet',1,'n','(%)->%','cPoset(S)',NULL,'a subset \spad{U} with the property that,{} if \spad{x} is in \spad{U} and \spad{x} \spad{>=} \spad{y},{} then \spad{y} is in \spad{U}');
INSERT INTO olibdb VALUES('o','LowTriBddDenomInv',2,'n','(M,R)->M','pTriangularMatrixOperations(R,Row,Col,M)',NULL,'\spad{LowTriBddDenomInv(B,{} d)} returns \spad{M},{} where \spad{B} is a non-singular lower triangular matrix and \spad{d} is an element of \spad{R} such that \spad{M = d * inv(B)} has entries in \spad{R}.');
INSERT INTO olibdb VALUES('o','lp',1,'x','(%)->List(Point(R))','cThreeSpaceCategory(R)',NULL,'\spad{lp(s)} returns the list of points component which the \spadtype{ThreeSpace},{} \spad{s},{} contains; these points are used by reference,{} \spadignore{i.e.} the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points.');
INSERT INTO olibdb VALUES('o','lprop',1,'x','(%)->List(SubSpaceComponentProperty)','cThreeSpaceCategory(R)',NULL,'\spad{lprop(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of subspace component properties,{} and if so,{} returns the list; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','lquo',2,'n','(%,S)->Union(%,failed)','dFreeMonoid(S)',NULL,'\spad{lquo(x,{} s)} returns the exact left quotient of \spad{x} by \spad{s}.');
INSERT INTO olibdb VALUES('o','lquo',2,'n','(%,%)->Union(%,failed)','dFreeMonoid(S)',NULL,'\spad{lquo(x,{} y)} returns the exact left quotient of \spad{x} by \spad{y} \spadignore{i.e.} \spad{q} such that \spad{x = y * q},{} failed if \spad{x} is not of the form \spad{y * q}.');
INSERT INTO olibdb VALUES('o','lquo',2,'x','(%,%)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{lquo(x,{} y)} is a bilinear extention of \spad{lquo} from words to \spad{\%}.');
INSERT INTO olibdb VALUES('o','lquo',2,'x','(%,FreeMonoid(vl))->%','cXFreeAlgebra(vl,R)',NULL,'\spad{lquo(x,{} w)} returns the left simplification of \spad{x} by the word \spad{w}.');
INSERT INTO olibdb VALUES('o','lquo',2,'x','(%,vl)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{lquo(x,{} v)} returns the left simplification of \spad{x} by the variable \spad{v}.');
INSERT INTO olibdb VALUES('o','lquo',2,'x','(XRecursivePolynomial(VarSet,R),%)->XRecursivePolynomial(VarSet,R)','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{lquo(x,{} y)} returns the left simplification of \spad{x} by \spad{y}.');
INSERT INTO olibdb VALUES('o','lSpaceBasis',1,'n','(%)->Vector(R)','dFiniteDivisor(F,UP,UPUP,R)',NULL,'\spad{lSpaceBasis(d)} returns a basis for \spad{L(d) = {f | (f) >= -d}} as a module over \spad{K[x]}.');
INSERT INTO olibdb VALUES('o','LT',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{LT(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x<y}.');
INSERT INTO olibdb VALUES('o','lub',2,'n','(A,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','lub',2,'n','(%,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{lub(s,{} l)} is ''least upper bound'' or ''supremum'' of \spad{l}. In this version of lub nodes are represented as index values. Not every subset of a poset will have a lub in which case failed will be returned as an error indication.');
INSERT INTO olibdb VALUES('o','LUDecomp',1,'n','(Matrix(D))->Record(LU:Matrix(D),Perm:Vector(Integer),Pivots:List(D))','pLUDecomposition(D)',NULL,'\spad{LUDecomp(A)} computes a LU decomposition of \spad{A} using the algorithm of Crout. \spad{LU} contains both triangular matrices; \spad{Perm} is the permutation used for partial pivoting and \spad{Pivots} yields the used pivots.');
INSERT INTO olibdb VALUES('o','LUInverse',1,'n','(Matrix(D))->Record(Inv:Matrix(D),Pivots:List(D))','pLUDecomposition(D)',NULL,'\spad{LUInverse(A)} computes the inverse of \spad{A} using a LU decomposition.');
INSERT INTO olibdb VALUES('o','LUSolve',3,'n','(Matrix(D),Vector(Integer),Vector(D))->Vector(D)','pLUDecomposition(D)',NULL,'\spad{LUSolve(LU,{} Perm,{} B)} uses a previously computed \spad{LU} decomposition to solve a linear system with right hand side \spad{B}. \spad{LU} and \spad{Perm} are as given by \spad{LUDecomp}.');
INSERT INTO olibdb VALUES('o','lyndon?',1,'n','(FreeMonoid(VarSet))->Boolean','dLyndonWord(VarSet)',NULL,'\spad{lyndon?(w)} test if \spad{w} is a Lyndon word.');
INSERT INTO olibdb VALUES('o','lyndon',1,'n','(FreeMonoid(VarSet))->%','dLyndonWord(VarSet)',NULL,'\spad{lyndon(w)} convert \spad{w} into a Lyndon word,{} error if \spad{w} is not a Lyndon word.');
INSERT INTO olibdb VALUES('o','LyndonBasis',1,'n','(List(VarSet))->List(LiePolynomial(VarSet,R))','dLieExponentials(VarSet,R,Order)',NULL,'\spad{LyndonBasis(lv)} returns the Lyndon basis of the nilpotent free Lie algebra.');
INSERT INTO olibdb VALUES('o','LyndonCoordinates',1,'n','(%)->List(Record(k:LyndonWord(VarSet),c:R))','dLieExponentials(VarSet,R,Order)',NULL,'\spad{LyndonCoordinates(g)} returns the exponential coordinates of \spad{g}.');
INSERT INTO olibdb VALUES('o','lyndonIfCan',1,'n','(FreeMonoid(VarSet))->Union(%,failed)','dLyndonWord(VarSet)',NULL,'\spad{lyndonIfCan(w)} convert \spad{w} into a Lyndon word.');
INSERT INTO olibdb VALUES('o','LyndonWordsList1',2,'n','(List(VarSet),PositiveInteger)->OneDimensionalArray(List(%))','dLyndonWord(VarSet)',NULL,'\spad{LyndonWordsList1(vl,{} n)} returns an array of lists of Lyndon words over the alphabet \spad{vl},{} up to order \spad{n}.');
INSERT INTO olibdb VALUES('o','LyndonWordsList',2,'n','(List(VarSet),PositiveInteger)->List(%)','dLyndonWord(VarSet)',NULL,'\spad{LyndonWordsList(vl,{} n)} returns the list of Lyndon words over the alphabet \spad{vl},{} up to order \spad{n}.');
INSERT INTO olibdb VALUES('o','m2r',1,'n','(List(NonNegativeInteger))->List(PositiveInteger)','cJetBundleCategory',NULL,'\spad{m2r(ind)} transforms a multi-index into a repeated index.');
INSERT INTO olibdb VALUES('o','m2r',1,'n','(List(NonNegativeInteger))->List(PositiveInteger)','xJetBundleCategory&(S)',NULL,'\spad{m2r(ind)} transforms a multi-index into a repeated index.');
INSERT INTO olibdb VALUES('o','mainCharacterization',1,'x','(%)->Union(RightOpenIntervalRootCharacterization(%,SparseUnivariatePolynomial(%)),failed)','dRealClosure(TheField)',NULL,'\spad{mainCharacterization(x)} is the main algebraic quantity of \spad{x} (\spad{SEG})');
INSERT INTO olibdb VALUES('o','mainCoefficients',1,'n','(S)->List(S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainCoefficients',1,'x','(%)->List(%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{mainCoefficients(p)} returns an error if \spad{p} is \spad{O},{} otherwise,{} if \spad{p} belongs to \spad{R} returns [\spad{p}],{} otherwise returns the list of the coefficients of \spad{p},{} where \spad{p} is viewed as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','mainContent',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainContent',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,GcdDomain)','\spad{mainContent(p)} returns the content of \spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \spad{R}.');
INSERT INTO olibdb VALUES('o','mainDefiningPolynomial',1,'x','(%)->Union(SparseUnivariatePolynomial(%),failed)','cRealClosedField',NULL,'\spad{mainDefiningPolynomial(x)} is the defining polynomial for the main algebraic quantity of \spad{x}');
INSERT INTO olibdb VALUES('o','mainForm',1,'x','(%)->Union(OutputForm,failed)','cRealClosedField',NULL,'\spad{mainForm(x)} is the main algebraic quantity name of \spad{x}');
INSERT INTO olibdb VALUES('o','mainKernel',1,'n','(S)->Union(K,failed)','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainKernel',1,'n','(S)->Union(K,failed)','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainKernel',1,'x','(%)->Union(K,failed)','cExpressionSpace2(K)',NULL,'\spad{mainKernel(f)} returns a kernel of \spad{f} with maximum nesting level,{} or failed if \spad{f} has no kernels (\spadignore{i.e.} \spad{f} is a constant).');
INSERT INTO olibdb VALUES('o','mainMonomial',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainMonomial',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{mainMonomial(p)} returns an error if \spad{p} is \spad{O},{} otherwise,{} if \spad{p} belongs to \spad{R} returns \spad{1},{} otherwise,{} \spad{mvar(p)} raised to the power \spad{mdeg(p)}.');
INSERT INTO olibdb VALUES('o','mainMonomials',1,'n','(S)->List(S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainMonomials',1,'x','(%)->List(%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{mainMonomials(p)} returns an error if \spad{p} is \spad{O},{} otherwise,{} if \spad{p} belongs to \spad{R} returns [1],{} otherwise returns the list of the monomials of \spad{p},{} where \spad{p} is viewed as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','mainPrimitivePart',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainPrimitivePart',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,GcdDomain)','\spad{mainPrimitivePart(p)} returns the primitive part of \spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \spad{R}.');
INSERT INTO olibdb VALUES('o','mainSquareFreePart',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainSquareFreePart',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,GcdDomain)','\spad{mainSquareFreePart(p)} returns the square free part of \spad{p} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \spad{R}.');
INSERT INTO olibdb VALUES('o','mainValue',1,'x','(%)->Union(SparseUnivariatePolynomial(%),failed)','cRealClosedField',NULL,'\spad{mainValue(x)} is the expression of \spad{x} in terms of \spad{SparseUnivariatePolynomial(\%)}');
INSERT INTO olibdb VALUES('o','mainVariable',1,'n','(F)->Union(V,failed)','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \spad{f},{} failed if \spad{f} has no variables.');
INSERT INTO olibdb VALUES('o','mainVariable',1,'n','(S)->Union(SingletonAsOrderedSet,failed)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainVariable',1,'n','(%)->Union(VarSet,failed)','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \spad{p},{} or failed if no variables are present. fails precisely if polynomial satisfies ground?');
INSERT INTO olibdb VALUES('o','mainVariable',1,'x','(Fraction(Polynomial(R)))->Union(Symbol,failed)','pRationalFunction(R)',NULL,'\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \spad{f},{} failed if \spad{f} has no variables.');
INSERT INTO olibdb VALUES('o','mainVariable?',2,'n','(VarSet,S)->Boolean','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainVariable?',2,'x','(VarSet,%)->Boolean','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{mainVariable?(v,{} ps)} returns \spad{true} iff \spad{v} is the main variable of some polynomial in \spad{ps}.');
INSERT INTO olibdb VALUES('o','mainVariableOf',1,'n','(%)->Symbol','dCell(TheField)',NULL,'\spad{mainVariableOf(c)} returns main variable of \spad{c}');
INSERT INTO olibdb VALUES('o','mainVariables',1,'n','(S)->List(VarSet)','xPolynomialSetCategory&(S,R,E,VarSet,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mainVariables',1,'x','(%)->List(VarSet)','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{mainVariables(ps)} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \spad{ps}.');
INSERT INTO olibdb VALUES('o','makeCell',1,'n','(List(SimpleCell(TheField,SparseUnivariatePolynomial(TheField))))->%','dCell(TheField)',NULL,'\spad{makeCell(lc)} creates a cell from list of simple cells \spad{lc}');
INSERT INTO olibdb VALUES('o','makeCell',2,'n','(SimpleCell(TheField,SparseUnivariatePolynomial(TheField)),%)->%','dCell(TheField)',NULL,'\spad{makeCell(c,{} sc)} creates a cell which consists of \spad{sc} in main variable and which has projection \spad{c}');
INSERT INTO olibdb VALUES('o','makeCos',2,'x','(E,R)->%','dFourierSeries(R,E)',NULL,'\spad{makeCos(e,{} r)} makes a sin expression with given argument and coefficient');
INSERT INTO olibdb VALUES('o','makeCrit',3,'n','(Record(totdeg:NonNegativeInteger,pol:Dpol),Dpol,NonNegativeInteger)->Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol)','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{makeCrit }\undocumented');
INSERT INTO olibdb VALUES('o','makeDisjoint',2,'n','(%,%)->%','dFiniteSimplicialComplex(VS)',NULL,'If index numbers of \spad{''b''} overlap with index numbers of ''a'' then refactor \spad{''b''} so that it does not overlap.');
INSERT INTO olibdb VALUES('o','makeEq',2,'n','(List(F),List(Symbol))->List(Equation(Polynomial(F)))','pInnerNumericFloatSolvePackage(K,F,Par)',NULL,'\spad{makeEq(lsol,{} lvar)} returns a list of equations formed by corresponding members of lvar and \spad{lsol}.');
INSERT INTO olibdb VALUES('o','makeFEq',6,'n','(BasicOperator,Symbol,Symbol,F,List(F),Stream(F))->F','pRecurrenceOperator(R,F)',NULL,'\spad{evalADE(f,{} x,{} n,{} eq,{} parameters,{} values)} creates an expression that stands for the coefficient of \spad{x^n} in the Taylor expansion of \spad{f}(\spad{x}),{} where \spad{f}(\spad{x}) is given by the functional equation \spad{eq}. The argument values specifies the first few Taylor coefficients.');
INSERT INTO olibdb VALUES('o','makeFloatFunction',2,'x','(S,Symbol)->(DoubleFloat)->DoubleFloat','pMakeFloatCompiledFunction(S)',NULL,'\spad{makeFloatFunction(expr,{} x)} returns a Lisp function \spad{f}: \spadtype{DoubleFloat} \spad{->} \spadtype{DoubleFloat} defined by \spad{f(x) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spadtype{DoubleFloat}.');
INSERT INTO olibdb VALUES('o','makeFloatFunction',3,'x','(S,Symbol,Symbol)->(DoubleFloat,DoubleFloat)->DoubleFloat','pMakeFloatCompiledFunction(S)',NULL,'\spad{makeFloatFunction(expr,{} x,{} y)} returns a Lisp function \spad{f}: (\spadtype{DoubleFloat},{} \spadtype{DoubleFloat}) \spad{->} \spadtype{DoubleFloat} defined by \spad{f(x,{} y) == expr}. Function \spad{f} is compiled and directly applicable to objects of type (\spadtype{DoubleFloat},{} \spadtype{DoubleFloat}).');
INSERT INTO olibdb VALUES('o','makeFR',1,'n','(Record(contp:Integer,factors:List(Record(irr:UP,pow:NonNegativeInteger))))->Factored(UP)','pGaloisGroupFactorizer(UP)',NULL,'\spad{makeFR(flist)} turns the final factorization of henselFact into a \spadtype{Factored} object.');
INSERT INTO olibdb VALUES('o','makeFR',2,'x','(R,List(Record(flag:Union(nil,sqfr,irred,prime),factor:R,exponent:NonNegativeInteger)))->%','dFactored(R)',NULL,'\spad{makeFR(unit,{} listOfFactors)} creates a factored object (for use by factoring code).');
INSERT INTO olibdb VALUES('o','makeGraphImage',1,'n','(List(List(Point(DoubleFloat))))->%','dGraphImage',NULL,'\spad{makeGraphImage(llp)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} with default point size and default point and line colours.');
INSERT INTO olibdb VALUES('o','makeGraphImage',4,'n','(List(List(Point(DoubleFloat))),List(Palette),List(Palette),List(PositiveInteger))->%','dGraphImage',NULL,'\spad{makeGraphImage(llp,{} lpal1,{} lpal2,{} lp)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} whose point colors are indicated by the list of palette colors,{} \spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \spad{lpal2}. The parameter \spad{lp} is a list of integers which denote the size of the data points.');
INSERT INTO olibdb VALUES('o','makeGraphImage',5,'n','(List(List(Point(DoubleFloat))),List(Palette),List(Palette),List(PositiveInteger),List(DrawOption))->%','dGraphImage',NULL,'\spad{makeGraphImage(llp,{} lpal1,{} lpal2,{} lp,{} lopt)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} whose point colors are indicated by the list of palette colors,{} \spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \spad{lpal2}. The parameter \spad{lp} is a list of integers which denote the size of the data points,{} and \spad{lopt} is the list of draw command options.');
INSERT INTO olibdb VALUES('o','make_imaginary_part_function',2,'x','(S,Symbol)->(DoubleFloat)->DoubleFloat','pMakeFloatCompiledFunction(S)',NULL,'\spad{make_imaginary_part_function(expr,{} x)} returns a Lisp function \spad{f}: \spadtype{DoubleFloat} \spad{->} \spadtype{DoubleFloat} defined by \spad{f(x) == imag(expr)}. Function \spad{f} is compiled and directly applicable to objects of type \spadtype{DoubleFloat}.');
INSERT INTO olibdb VALUES('o','makeMulti',1,'n','(List(Record(gen:S,exp:E)))->%','dListMonoidOps(S,E,un)',NULL,'\spad{makeMulti(l)} returns the element whose list of monomials is \spad{l}.');
INSERT INTO olibdb VALUES('o','makeObject',2,'x','((DoubleFloat)->Point(DoubleFloat),Segment(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(sp,{} curve(f,{} g,{} h),{} a..b)} returns the space \spad{sp} of the domain \spadtype{ThreeSpace} with the addition of the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','makeObject',2,'x','(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(sp,{} curve(f,{} g,{} h),{} a..b)} returns the space \spad{sp} of the domain \spadtype{ThreeSpace} with the addition of the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}.');
INSERT INTO olibdb VALUES('o','makeObject',2,'x','(ParametricSpaceCurve(Ex),SegmentBinding(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(curve(f(t),{} g(t),{} h(t)),{} t = a..b)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{h(t)} is the default title.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(Float),Segment(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(f,{} a..b,{} c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','((DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(Float),Segment(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{f(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','((DoubleFloat)->DoubleFloat,Segment(Float),List(DrawOption))->GraphImage','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(f,{} a..b,{} l)} creates the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','((DoubleFloat)->Point(DoubleFloat),Segment(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(curve(f,{} g,{} h),{} a..b,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(Ex,SegmentBinding(Float),List(DrawOption))->GraphImage','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(f(x),{} x = a..b,{} l)} creates the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(Ex,SegmentBinding(Float),SegmentBinding(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(f(x,{} y),{} x = a..b,{} y = c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{f(x,{} y)} appears as the default title.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricComplexCurve(Ex),SegmentBinding(Float),List(DrawOption))->GraphImage','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(c,{} b,{} l)} is like version for plane curves,{} but uses complex curve.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricPlaneCurve((DoubleFloat)->DoubleFloat),Segment(Float),List(DrawOption))->GraphImage','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(curve(f,{} g),{} a..b,{} l)} creates the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricPlaneCurve(Ex),SegmentBinding(Float),List(DrawOption))->GraphImage','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(curve(f(t),{} g(t)),{} t = a..b,{} l)} creates the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricSpaceCurve((DoubleFloat)->DoubleFloat),Segment(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(curve(f,{} g,{} h),{} a..b,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricSpaceCurve(Ex),SegmentBinding(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(curve(f(t),{} g(t),{} h(t)),{} t = a..b,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(Float),Segment(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}.');
INSERT INTO olibdb VALUES('o','makeObject',3,'x','(ParametricSurface(Ex),SegmentBinding(Float),SegmentBinding(Float))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{h(t)} is the default title.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','((DoubleFloat,DoubleFloat)->DoubleFloat,Segment(Float),Segment(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)},{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','((DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(Float),Segment(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(f,{} a..b,{} c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{f(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','(Equation(Ex),Symbol,Symbol,List(DrawOption))->GraphImage','pTopLevelDrawFunctionsForAlgebraicCurves(R,Ex)',NULL,'\spad{makeObject(f(x,{} y) = g(x,{} y),{} x,{} y,{} l)} creates the graph of a polynomial equation. The list \spad{l} of draw options must specify a region in the plane in which the curve is to sketched.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','(Ex,SegmentBinding(Float),SegmentBinding(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(f(x,{} y),{} x = a..b,{} y = c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{} y)} as \spad{x} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{y} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{f(x,{} y)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','(ParametricSurface((DoubleFloat,DoubleFloat)->DoubleFloat),Segment(Float),Segment(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctionsForCompiledFunctions',NULL,'\spad{makeObject(surface(f,{} g,{} h),{} a..b,{} c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeObject',4,'x','(ParametricSurface(Ex),SegmentBinding(Float),SegmentBinding(Float),List(DrawOption))->ThreeSpace(DoubleFloat)','pTopLevelDrawFunctions(Ex)',NULL,'\spad{makeObject(surface(f(u,{} v),{} g(u,{} v),{} h(u,{} v)),{} u = a..b,{} v = c..d,{} l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{} v)},{} \spad{y = g(u,{} v)},{} \spad{z = h(u,{} v)} as \spad{u} ranges from \spad{min(a,{} b)} to \spad{max(a,{} b)} and \spad{v} ranges from \spad{min(c,{} d)} to \spad{max(c,{} d)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.');
INSERT INTO olibdb VALUES('o','makeop',2,'n','(R,FreeGroup(BasicOperator))->%','dOperator(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','makeop',2,'x','(R,FreeGroup(BasicOperator))->%','dModuleOperator(R,M)',NULL,'\spad{makeop should} be local but conditional');
INSERT INTO olibdb VALUES('o','make_real_part_function',2,'x','(S,Symbol)->(DoubleFloat)->DoubleFloat','pMakeFloatCompiledFunction(S)',NULL,'\spad{make_real_part_function(expr,{} x)} returns a Lisp function \spad{f}: \spadtype{DoubleFloat} \spad{->} \spadtype{DoubleFloat} defined by \spad{f(x) == real(expr)}. Function \spad{f} is compiled and directly applicable to objects of type \spadtype{DoubleFloat}.');
INSERT INTO olibdb VALUES('o','makeRec',5,'n','(BasicOperator,Symbol,F,List(F),Stream(F))->F','pRecurrenceOperator(R,F)',NULL,'\spad{makeRec(u,{} n,{} eq,{} parameters,{} values)} creates an expression that stands for \spad{u}(\spad{n}),{} where \spad{u}(\spad{n}) is given by the equation \spad{eq}. The argument \spad{parameters} has to contain all variables (or kernels) that appear eventually in the stream of values. The argument values specifies the initial values of the recurrence \spad{u}(0),{} \spad{u}(1),{} ... For the moment we don\spad{''t} allow recursions that contain \spad{u} inside of another operator.');
INSERT INTO olibdb VALUES('o','makeRecord',2,'x','(S,T)->Record(part1:S,part2:T)','pMakeRecord(S,T)',NULL,'\spad{makeRecord(a,{} b)} creates a record object with type Record(\spad{part1} : \spad{S},{} \spad{part2} : \spad{T}),{} where \spad{part1} is \spad{a} and \spad{part2} is \spad{b}.');
INSERT INTO olibdb VALUES('o','makeResult',2,'n','(PatternMatchResult(R,S),PatternMatchResult(R,L))->%','dPatternMatchListResult(R,S,L)',NULL,'\spad{makeResult(r1,{} r2)} makes the combined result [\spad{r1},{} \spad{r2}].');
INSERT INTO olibdb VALUES('o','makeSeries',2,'n','(Reference(OrderedCompletion(Integer)),Stream(Record(k:Integer,c:Coef)))->%','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{makeSeries(refer,{} str)} creates a power series from the reference \spad{refer} and the stream \spad{str}.');
INSERT INTO olibdb VALUES('o','makeSin',2,'x','(E,R)->%','dFourierSeries(R,E)',NULL,'\spad{makeSin(e,{} r)} makes a sin expression with given argument and coefficient');
INSERT INTO olibdb VALUES('o','makeSketch',5,'n','(Polynomial(Integer),Symbol,Symbol,Segment(Fraction(Integer)),Segment(Fraction(Integer)))->%','dPlaneAlgebraicCurvePlot',NULL,'\spad{makeSketch(p,{} x,{} y,{} a..b,{} c..d)} creates an ACPLOT of the curve \spad{p = 0} in the region {\em a <= x <= b,{} c <= y <= d}. More specifically,{} ''makeSketch'' plots a non-singular algebraic curve \spad{p = 0} in an rectangular region {\em xMin <= x <= xMax},{} {\em yMin <= y <= yMax}. The user inputs \spad{makeSketch(p,{} x,{} y,{} xMin..xMax,{} yMin..yMax)}. Here \spad{p} is a polynomial in the variables \spad{x} and \spad{y} with integer coefficients (\spad{p} belongs to the domain \spad{Polynomial Integer}). The case where \spad{p} is a polynomial in only one of the variables is allowed. The variables \spad{x} and \spad{y} are input to specify the the coordinate axes. The horizontal axis is the \spad{x}-axis and the vertical axis is the \spad{y}-axis. The rational numbers xMin,{} ...,{} yMax specify the boundaries of the region in which the curve is to be plotted.');
INSERT INTO olibdb VALUES('o','makeSUP',1,'n','(S)->SparseUnivariatePolynomial(R)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','makeSUP',1,'x','(%)->SparseUnivariatePolynomial(R)','cUnivariatePolynomialCategory(R)',NULL,'\spad{makeSUP(p)} converts the polynomial \spad{p} to be of type SparseUnivariatePolynomial over the same coefficients.');
INSERT INTO olibdb VALUES('o','makeSystem',1,'n','(List(D))->%','dJetDifferentialEquation(JB,D)',NULL,'\spad{makeSystem(sys)} creates a differential equation from a system.');
INSERT INTO olibdb VALUES('o','makeTerm',2,'n','(S,E)->%','dListMonoidOps(S,E,un)',NULL,'\spad{makeTerm(s,{} e)} returns the monomial \spad{s} exponentiated by \spad{e} (\spadignore{e.g.} s^e or \spad{e} * \spad{s}).');
INSERT INTO olibdb VALUES('o','makeUnit',0,'n','()->%','dListMonoidOps(S,E,un)',NULL,'\spad{makeUnit()} returns the unit element of the monomial.');
INSERT INTO olibdb VALUES('o','makeVariable',1,'n','(A)->(NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','makeVariable',1,'n','(S)->(NonNegativeInteger)->A','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','makeVariable',1,'x','(%)->(NonNegativeInteger)->%','cDifferentialPolynomialCategory(R,S,V,E)','has(R,DifferentialRing)','\spad{makeVariable(p)} views \spad{p} as an element of a differential ring,{} in such a way that the \spad{n}-th derivative of \spad{p} may be simply referenced as \spad{z}.\spad{n} where \spad{z} \spad{:=} makeVariable(\spad{p}). Note: In the interpreter,{} \spad{z} is given as an internal map,{} which may be ignored.');
INSERT INTO olibdb VALUES('o','makeVariable',1,'x','(S)->(NonNegativeInteger)->%','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{makeVariable(s)} views \spad{s} as a differential indeterminate,{} in such a way that the \spad{n}-th derivative of \spad{s} may be simply referenced as \spad{z}.\spad{n} where \spad{z} \spad{:=} makeVariable(\spad{s}). Note: In the interpreter,{} \spad{z} is given as an internal map,{} which may be ignored.');
INSERT INTO olibdb VALUES('o','makeVariable',2,'x','(S,NonNegativeInteger)->%','cDifferentialVariableCategory(S)',NULL,'\spad{makeVariable(s,{} n)} returns the \spad{n}-th derivative of a differential indeterminate \spad{s} as an algebraic indeterminate.');
INSERT INTO olibdb VALUES('o','makeViewport2D',1,'n','(%)->%','dTwoDimensionalViewport',NULL,'\spad{makeViewport2D(v)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and displays a viewport window on the screen which contains the contents of \spad{v}.');
INSERT INTO olibdb VALUES('o','makeViewport2D',2,'n','(GraphImage,List(DrawOption))->%','dTwoDimensionalViewport',NULL,'\spad{makeViewport2D(\spad{gi},{} lopt)} creates and displays a viewport window of the domain \spadtype{TwoDimensionalViewport} whose graph field is assigned to be the given graph,{} \spad{\spad{gi}},{} of domain \spadtype{GraphImage},{} and whose options field is set to be the list of options,{} \spad{lopt} of domain \spadtype{DrawOption}.');
INSERT INTO olibdb VALUES('o','makeViewport3D',1,'x','(%)->%','dThreeDimensionalViewport',NULL,'\spad{makeViewport3D(v)} takes the given three-dimensional viewport,{} \spad{v},{} of the domain \spadtype{ThreeDimensionalViewport} and displays a viewport window on the screen which contains the contents of \spad{v}.');
INSERT INTO olibdb VALUES('o','makeViewport3D',2,'x','(ThreeSpace(DoubleFloat),List(DrawOption))->%','dThreeDimensionalViewport',NULL,'\spad{makeViewport3D(sp,{} lopt)} takes the given space,{} \spad{sp} which is of the domain \spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \spad{sp},{} and whose draw options are indicated by the list \spad{lopt},{} which is a list of options from the domain \spad{DrawOption}.');
INSERT INTO olibdb VALUES('o','makeViewport3D',2,'x','(ThreeSpace(DoubleFloat),String)->%','dThreeDimensionalViewport',NULL,'\spad{makeViewport3D(sp,{} s)} takes the given space,{} \spad{sp} which is of the domain \spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \spad{sp},{} and whose title is given by \spad{s}.');
INSERT INTO olibdb VALUES('o','makeYoungTableau',2,'x','(List(Integer),List(Integer))->Matrix(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{makeYoungTableau(lambda,{} gitter)} computes for a given lattice permutation {\em gitter} and for an improper partition {\em lambda} the corresponding standard tableau of shape {\em lambda}. Notes: see {\em listYoungTableaus}. The entries are from {\em 0,{} ...,{} n-1}.');
INSERT INTO olibdb VALUES('o','makingStats?',0,'n','()->Boolean','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{makingStats?()} returns \spad{true} iff the statistics process is running.');
INSERT INTO olibdb VALUES('o','mantissa',1,'n','(%)->Integer','dMachineFloat',NULL,'\spad{mantissa(u)} returns the mantissa of \spad{u}');
INSERT INTO olibdb VALUES('o','mantissa',1,'x','(%)->Integer','cFloatingPointSystem',NULL,'\spad{mantissa(x)} returns the mantissa part of \spad{x}.');
INSERT INTO olibdb VALUES('o','map',2,'n','((A)->A,%)->%','cIndexedProductCategory(A,S)',NULL,'\spad{map(f,{} z)} returns the new element created by applying the function \spad{f} to each component of the direct product element \spad{z}.');
INSERT INTO olibdb VALUES('o','map',2,'n','((A)->B,MA)->MB','pTwoDimensionalArrayFunctions(A,RA,CA,MA,B,RB,CB,MB)',NULL,'\spad{map(f,{} m)} applies the function \spad{f} to every element of the array \spad{m} producing a new array containing the values.');
INSERT INTO olibdb VALUES('o','map!',2,'n','((Entry)->Entry,S)->S','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Entry)->Entry,S)->S','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map!',2,'n','((Entry)->Entry,S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Entry)->Entry,S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Expression(CoefRing))->Expression(CoefRing),%)->%','dDeRhamComplex(CoefRing,listIndVar)',NULL,'\spad{map(f,{} df)} replaces each coefficient \spad{x} of differential form \spad{df} by \spad{f(x)}.');
INSERT INTO olibdb VALUES('o','map',2,'n','((Polynomial(Integer))->Polynomial(Integer),Record(var:Symbol,coef:SparseUnivariatePolynomial(Fraction(Polynomial(Integer)))))->%','dFakePolynomial',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Polynomial(Integer))->Polynomial(Integer),%)->Union(%,failed)','dFakePolynomial',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Polynomial(R))->PPR,PPR)->PPR','pPushVariables(R,E,OV,PPR)',NULL,'\spad{map(f,{} p)} \undocumented{}');
INSERT INTO olibdb VALUES('o','map',2,'n','((R1)->R2,A1)->A2','pFiniteAbelianMonoidRingFunctions2(E,R1,A1,R2,A2)',NULL,'\spad{map}(\spad{f},{} a) applies the map \spad{f} to each coefficient in a. It is assumed that \spad{f} maps 0 to 0');
INSERT INTO olibdb VALUES('o','map',2,'n','((R1)->R2,UPUP1)->UPUP2','pMultipleMap(R1,UP1,UPUP1,R2,UP2,UPUP2)',NULL,'\spad{map(f,{} p)} lifts \spad{f} to the domain of \spad{p} then applies it to \spad{p}.');
INSERT INTO olibdb VALUES('o','map!',2,'n','((Record(key:Key,entry:Entry))->Record(key:Key,entry:Entry),S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Record(key:Key,entry:Entry))->Record(key:Key,entry:Entry),S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Record(numer:Polynomial(Integer),denom:Polynomial(Integer)))->Union(Polynomial(Integer),failed),%)->Union(SparseUnivariatePolynomial(Polynomial(Integer)),failed)','dFakePolynomial',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,%)->%','dAntiSymm(R,lVar)',NULL,'\spad{map(f,{} p)} changes each coefficient of \spad{p} by the application of \spad{f}.');
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,%)->%','dXPolynomialRing(R,E)',NULL,'\spad{map(fn,{} x)} returns \spad{Sum(fn(r_i) w_i)} if \spad{x} writes \spad{Sum(r_i w_i)}.');
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,S)->S','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,S)->S','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,S)->S','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map!',2,'n','((R)->R,S)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->R,S)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((R)->S,NewSparseUnivariatePolynomial(R))->NewSparseUnivariatePolynomial(S)','pNewSparseUnivariatePolynomialFunctions2(R,S)',NULL,'\spad{map(func,{} poly)} creates a new polynomial by applying \spad{func} to every non-zero coefficient of the polynomial poly.');
INSERT INTO olibdb VALUES('o','map!',2,'n','((S)->S,A)->A','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((S)->S,A)->A','xBinaryTreeCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((S)->S,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map!',2,'n','((S)->S,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((S)->S,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((S)->S,A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map!',2,'n','((S)->S,A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((S)->S,K)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',2,'n','((Vars1)->Vars2,PR1)->PR2','pMPolyCatFunctions3(Vars1,Vars2,E1,E2,R,PR1,PR2)',NULL,'\spad{map(f,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,DirectProduct(dim,A))->DirectProduct(dim,B)','pDirectProductFunctions2(dim,A,B)',NULL,'\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,Fraction(A))->Fraction(B)','pFractionFunctions2(A,B)',NULL,'\spad{map(func,{} frac)} applies the function \spad{func} to the numerator and denominator of the fraction frac.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,InfiniteTuple(A))->InfiniteTuple(B)','pInfiniteTupleFunctions2(A,B)',NULL,'\spad{map(f,{} [x0,{} x1,{} x2,{} ...])} returns \spad{[f(x0),{} f(x1),{} f(x2),{} ..]}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,List(A))->List(B)','pListFunctions2(A,B)',NULL,'\spad{map(fn,{} u)} applies \spad{fn} to each element of list \spad{u} and returns a new list with the results. For example \spad{map(square,{} [1,{} 2,{} 3]) = [1,{} 4,{} 9]}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,OneDimensionalArray(A))->OneDimensionalArray(B)','pOneDimensionalArrayFunctions2(A,B)',NULL,'\spad{map(f,{} a)} applies function \spad{f} to each member of one-dimensional array \spad{a} resulting in a new one-dimensional array over a possibly different underlying domain.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,PatternMatchResult(R,A))->PatternMatchResult(R,B)','pPatternMatchResultFunctions2(R,A,B)',NULL,'\spad{map(f,{} [(v1,{} a1),{} ...,{} (vn,{} an)])} returns the matching result [(\spad{v1},{} \spad{f}(\spad{a1})),{} ...,{} (\spad{vn},{} \spad{f}(an))].');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,PrimitiveArray(A))->PrimitiveArray(B)','pPrimitiveArrayFunctions2(A,B)',NULL,'\spad{map(f,{} a)} applies function \spad{f} to each member of primitive array \spad{a} resulting in a new primitive array over a possibly different underlying domain.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,R)->S','pQuotientFieldCategoryFunctions2(A,B,R,S)',NULL,'\spad{map(func,{} frac)} applies the function \spad{func} to the numerator and denominator of frac.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,Stream(A))->Stream(B)','pStreamFunctions2(A,B)',NULL,'\spad{map(f,{} s)} returns a stream whose elements are the function \spad{f} applied to the corresponding elements of \spad{s}. Note: \spad{map(f,{} [x0,{} x1,{} x2,{} ...]) = [f(x0),{} f(x1),{} f(x2),{} ..]}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->B,Vector(A))->Vector(B)','pVectorFunctions2(A,B)',NULL,'\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values.');
INSERT INTO olibdb VALUES('o','map',2,'x','((A)->Union(B,failed),Vector(A))->Union(Vector(B),failed)','pVectorFunctions2(A,B)',NULL,'\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values or \spad{failed}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((CF1)->CF2,ParametricPlaneCurve(CF1))->ParametricPlaneCurve(CF2)','pParametricPlaneCurveFunctions2(CF1,CF2)',NULL,'\spad{map(f,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((CF1)->CF2,ParametricSpaceCurve(CF1))->ParametricSpaceCurve(CF2)','pParametricSpaceCurveFunctions2(CF1,CF2)',NULL,'\spad{map(f,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((CF1)->CF2,ParametricSurface(CF1))->ParametricSurface(CF2)','pParametricSurfaceFunctions2(CF1,CF2)',NULL,'\spad{map(f,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((Coef1)->Coef2,UnivariateLaurentSeries(Coef1,var1,cen1))->UnivariateLaurentSeries(Coef2,var2,cen2)','pUnivariateLaurentSeriesFunctions2(Coef1,Coef2,var1,var2,cen1,cen2)',NULL,'\spad{map(f,{} g(x))} applies the map \spad{f} to the coefficients of the Laurent series \spad{g(x)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((Coef1)->Coef2,UnivariatePuiseuxSeries(Coef1,var1,cen1))->UnivariatePuiseuxSeries(Coef2,var2,cen2)','pUnivariatePuiseuxSeriesFunctions2(Coef1,Coef2,var1,var2,cen1,cen2)',NULL,'\spad{map(f,{} g(x))} applies the map \spad{f} to the coefficients of the Puiseux series \spad{g(x)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((Coef1)->Coef2,UTS1)->UTS2','pUnivariateTaylorSeriesFunctions2(Coef1,Coef2,UTS1,UTS2)',NULL,'\spad{map(f,{} g(x))} applies the map \spad{f} to the coefficients of \indented{1}{the Taylor series \spad{g(x)}.}');
INSERT INTO olibdb VALUES('o','map',2,'x','((E)->F,IntegrationResult(E))->IntegrationResult(F)','pIntegrationResultFunctions2(E,F)',NULL,'\spad{map(f,{} ire)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((E)->F,Kernel(E))->F','pExpressionSpaceFunctions2(E,F)',NULL,'\spad{map(f,{} k)} returns \spad{g = op(f(a1),{} ...,{} f(an))} where \spad{k = op(a1,{} ...,{} an)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((E)->F,Union(E,failed))->Union(F,failed)','pIntegrationResultFunctions2(E,F)',NULL,'\spad{map(f,{} ue)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((E)->F,Union(Record(mainpart:E,limitedlogs:List(Record(coeff:E,logand:E))),failed))->Union(Record(mainpart:F,limitedlogs:List(Record(coeff:F,logand:F))),failed)','pIntegrationResultFunctions2(E,F)',NULL,'\spad{map(f,{} ufe)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((E)->F,Union(Record(ratpart:E,coeff:E),failed))->Union(Record(ratpart:F,coeff:F),failed)','pIntegrationResultFunctions2(E,F)',NULL,'\spad{map(f,{} ure)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((%)->%,K)->%','cExpressionSpace2(K)',NULL,'\spad{map(f,{} k)} returns \spad{op(f(x1),{} ...,{} f(xn))} where \spad{k = op(x1,{} ...,{} xn)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,F1)->F2','pFunctionFieldCategoryFunctions2(R1,UP1,UPUP1,F1,R2,UP2,UPUP2,F2)',NULL,'\spad{map(f,{} p)} lifts \spad{f} to \spad{F1} and applies it to \spad{p}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,FiniteDivisor(R1,UP1,UPUP1,F1))->FiniteDivisor(R2,UP2,UPUP2,F2)','pFiniteDivisorFunctions2(R1,UP1,UPUP1,F1,R2,UP2,UPUP2,F2)',NULL,'\spad{map(f,{} d)} \undocumented{}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,FractionalIdeal(R1,F1,U1,A1))->FractionalIdeal(R2,F2,U2,A2)','pFractionalIdealFunctions2(R1,F1,U1,A1,R2,F2,U2,A2)',NULL,'\spad{map(f,{} i)} \undocumented{}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,M1)->M2','pFreeModuleCoefficientFunctions2(R1,R2,S,M1,M2)',NULL,'\spad{map(f,{} x)} applies the function \spad{f} to every coefficient of \spad{x}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,M1)->M2','pMatrixCategoryFunctions2(R1,Row1,Col1,M1,R2,Row2,Col2,M2)',NULL,'\spad{map(f,{} m)} applies the function \spad{f} to the elements of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,M1)->M2','pRectangularMatrixCategoryFunctions2(m,n,R1,Row1,Col1,M1,R2,Row2,Col2,M2)',NULL,'\spad{map(f,{} m)} applies the function \spad{f} to the elements of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,Point(R1))->Point(R2)','pPointFunctions2(R1,R2)',NULL,'\spad{map(f,{} p)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->R2,Sequence(R1))->Sequence(R2)','pSequenceFunctions2(R1,R2)',NULL,'\spad{map(f,{} x)} maps the function \spad{f} on the entries of \spad{x}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R1)->Union(R2,failed),M1)->Union(M2,failed)','pMatrixCategoryFunctions2(R1,Row1,Col1,M1,R2,Row2,Col2,M2)',NULL,'\spad{map(f,{} m)} applies the function \spad{f} to the elements of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->R,%)->%','cFullyEvalableOver(R)',NULL,'\spad{map(f,{} ex)} evaluates ex,{} applying \spad{f} to values of type \spad{R} in ex.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->R,%)->%','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{map(f,{} a)} returns \spad{b},{} where \spad{b(i,{} j) = a(i,{} j)} for all \spad{i},{} \spad{j}.');
INSERT INTO olibdb VALUES('o','map!',2,'x','((R)->R,%)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{map!(f,{} a)} assign \spad{a(i,{} j)} to \spad{f(a(i,{} j))} for all \spad{i,{} j}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->R,%)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{map(f,{} a)} returns \spad{b},{} where \spad{b(i,{} j) = f(a(i,{} j))} for all \spad{i,{} j}');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->R,%)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{map(fn,{} x)} returns \spad{Sum(fn(r_i) w_i)} if \spad{x} writes \spad{Sum(r_i w_i)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->R,%)->%','dFactored(R)',NULL,'\spad{map(fn,{} u)} maps the function \userfun{\spad{fn}} across the factors of \spadvar{\spad{u}} and creates a new factored object. Note: this clears the information flags (sets them to nil) because the effect of \userfun{\spad{fn}} is clearly not known in general.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,A)->B','pFunctionSpaceFunctions2(R,A,S,B)',NULL,'\spad{map(f,{} a)} applies \spad{f} to all the constants in \spad{R} appearing in \spad{a}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,AR)->AS','pFramedNonAssociativeAlgebraFunctions2(AR,R,AS,S)',NULL,'\spad{map(f,{} u)} maps \spad{f} onto the coordinates of \spad{u} to get an element in \spad{AS} via identification of the basis of \spad{AR} as beginning part of the basis of \spad{AS}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Complex(R))->Complex(S)','pComplexFunctions2(R,S)',NULL,'\spad{map(f,{} u)} maps \spad{f} onto real and imaginary parts of \spad{u}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Expression(R))->Expression(S)','pExpressionFunctions2(R,S)',NULL,'\spad{map(f,{} e)} applies \spad{f} to all the constants appearing in \spad{e}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Factored(R))->Factored(S)','pFactoredFunctions2(R,S)',NULL,'\spad{map(fn,{} u)} is used to apply the function \userfun{\spad{fn}} to every factor of \spadvar{\spad{u}}. The new factored object will have all its information flags set to nil. This function is used,{} for example,{} to coerce every factor base to another type.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,MonoidRing(R,M))->MonoidRing(S,M)','pMonoidRingFunctions2(R,S,M)',NULL,'\spad{map(f,{} u)} maps \spad{f} onto the coefficients \spad{f} the element \spad{u} of the monoid ring to create an element of a monoid ring with the same monoid \spad{b}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,OnePointCompletion(R))->OnePointCompletion(S)','pOnePointCompletionFunctions2(R,S)',NULL,'\spad{map(f,{} r)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(infinity) = infinity.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,OrderedCompletion(R))->OrderedCompletion(S)','pOrderedCompletionFunctions2(R,S)',NULL,'\spad{map(f,{} r)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(plusInfinity) = plusInfinity and that \spad{f}(minusInfinity) = minusInfinity.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,OR)->OS','pOctonionCategoryFunctions2(OR,R,OS,S)',NULL,'\spad{map(f,{} u)} maps \spad{f} onto the component parts of the octonion \spad{u}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Pattern(R))->Pattern(S)','pPatternFunctions2(R,S)',NULL,'\spad{map(f,{} p)} applies \spad{f} to all the leaves of \spad{p} and returns the result as a pattern over \spad{S}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Polynomial(R))->Polynomial(S)','pPolynomialFunctions2(R,S)',NULL,'\spad{map(f,{} p)} produces a new polynomial as a result of applying the function \spad{f} to every coefficient of the polynomial \spad{p}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,PR)->PS','pMPolyCatFunctions2(VarSet,E1,E2,R,S,PR,PS)',NULL,'\spad{map(f,{} p)} \undocumented');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,PR)->PS','pUnivariatePolynomialCategoryFunctions2(R,PR,S,PS)',NULL,'\spad{map(f,{} p)} takes a function \spad{f} from \spad{R} to \spad{S},{} and applies it to each (non-zero) coefficient of a polynomial \spad{p} over \spad{R},{} getting a new polynomial over \spad{S}. Note: since the map is not applied to zero elements,{} it may map zero to zero.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,QR)->QS','pQuaternionCategoryFunctions2(QR,R,QS,S)',NULL,'\spad{map(f,{} u)} maps \spad{f} onto the component parts of the quaternion \spad{u}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,SegmentBinding(R))->SegmentBinding(S)','pSegmentBindingFunctions2(R,S)',NULL,'\spad{map(f,{} v=a..b)} returns the value given by \spad{v=f(a)..f(b)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Segment(R))->List(S)','pSegmentFunctions2(R,S)','has(R,OrderedRing)','\spad{map(f,{} s)} expands the segment \spad{s},{} applying \spad{f} to each value. For example,{} if \spad{s = l..h by k},{} then the list \spad{[f(l),{} f(l+k),{} ...,{} f(lN)]} is computed,{} where \spad{lN <= h < lN+k}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,Segment(R))->Segment(S)','pSegmentFunctions2(R,S)',NULL,'\spad{map(f,{} l..h)} returns a new segment \spad{f(l)..f(h)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,SparseUnivariatePolynomial(R))->SparseUnivariatePolynomial(S)','pSparseUnivariatePolynomialFunctions2(R,S)',NULL,'\spad{map(func,{} poly)} creates a new polynomial by applying \spad{func} to every non-zero coefficient of the polynomial poly.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,UnivariatePolynomial(x,R))->UnivariatePolynomial(y,S)','pUnivariatePolynomialFunctions2(x,R,y,S)',NULL,'\spad{map(func,{} poly)} creates a new polynomial by applying \spad{func} to every non-zero coefficient of the polynomial poly.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,UniversalSegment(R))->Stream(S)','pUniversalSegmentFunctions2(R,S)','has(R,OrderedRing)','\spad{map(f,{} s)} expands the segment \spad{s},{} applying \spad{f} to each value.');
INSERT INTO olibdb VALUES('o','map',2,'x','((R)->S,UniversalSegment(R))->UniversalSegment(S)','pUniversalSegmentFunctions2(R,S)',NULL,'\spad{map(f,{} seg)} returns the new segment obtained by applying \spad{f} to the endpoints of seg.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->R,A)->B','pFiniteLinearAggregateFunctions2(S,A,R,B)',NULL,'\spad{map(f,{} a)} applies function \spad{f} to each member of aggregate \spad{a} resulting in a new aggregate over a possibly different underlying domain.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->R,A)->B','pFiniteSetAggregateFunctions2(S,A,R,B)',NULL,'\spad{map(f,{} a)} applies function \spad{f} to each member of aggregate \spad{a},{} creating a new aggregate with a possibly different underlying domain.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->R,Equation(S))->Equation(R)','pEquationFunctions2(S,R)',NULL,'\spad{map(f,{} eq)} returns an equation where \spad{f} is applied to the sides of eq');
INSERT INTO olibdb VALUES('o','map!',2,'x','((S)->S,%)->%','cHomogeneousAggregate(S)','has(%,shallowlyMutable)','\spad{map!(f,{} u)} destructively replaces each element \spad{x} of \spad{u} by \spad{f(x)}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->S,%)->%','cHomogeneousAggregate(S)',NULL,'\spad{map(f,{} u)} returns a copy of \spad{u} with each element \spad{x} replaced by \spad{f}(\spad{x}). For collections,{} \spad{map(f,{} u) = [f(x) for x in u]}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->S,%)->%','dEquation(S)',NULL,'\spad{map(f,{} eqn)} constructs a new equation by applying \spad{f} to both sides of eqn.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->S,%)->%','dInfiniteTuple(S)',NULL,'\spad{map(f,{} t)} replaces the tuple \spad{t} by \spad{[f(x) for x in t]}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->S,%)->L','cSegmentExpansionCategory(S,L)',NULL,'\spad{map(f,{} l..h by k)} produces a value of type \spad{L} by applying \spad{f} to each of the successive elements of the segment,{} that is,{} \spad{[f(l),{} f(l+k),{} ...,{} f(lN)]},{} where \spad{lN <= h < lN+k}.');
INSERT INTO olibdb VALUES('o','map',2,'x','((S)->T,CartesianTensor(minix,dim,S))->CartesianTensor(minix,dim,T)','pCartesianTensorFunctions2(minix,dim,S,T)',NULL,'\spad{map(f,{} ts)} does a componentwise conversion of the tensor \spad{ts} to a tensor with components of type \spad{T}.');
INSERT INTO olibdb VALUES('o','map',3,'n','((Entry,Entry)->Entry,S,S)->S','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',3,'n','((F)->S,Symbol,Kernel(F))->S','pExpressionSpaceFunctions1(F,S)',NULL,'\spad{map(f,{} p,{} k)} uses the property \spad{p} of the operator of \spad{k},{} in order to lift \spad{f} and apply it to \spad{k}.');
INSERT INTO olibdb VALUES('o','map',3,'n','((R,R)->R,S,S)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',3,'n','((S,S)->S,A,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',3,'n','((S,S)->S,A,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',3,'n','((Vars)->S,(R)->S,P)->S','pPolynomialCategoryLifting(E,Vars,R,P,S)',NULL,'\spad{map(varmap,{} coefmap,{} p)} takes a \spad{varmap},{} a mapping from the variables of polynomial \spad{p} into \spad{S},{} \spad{coefmap},{} a mapping from coefficients of \spad{p} into \spad{S},{} and \spad{p},{} and produces a member of \spad{S} using the corresponding arithmetic in \spad{S}.');
INSERT INTO olibdb VALUES('o','map',3,'x','((A,B)->C,InfiniteTuple(A),InfiniteTuple(B))->InfiniteTuple(C)','pInfiniteTupleFunctions3(A,B,C)',NULL,'\spad{map(f,{} a,{} b)} \undocumented');
INSERT INTO olibdb VALUES('o','map',3,'x','((A,B)->C,InfiniteTuple(A),Stream(B))->Stream(C)','pInfiniteTupleFunctions3(A,B,C)',NULL,'\spad{map(f,{} a,{} b)} \undocumented');
INSERT INTO olibdb VALUES('o','map',3,'x','((A,B)->C,List(A),List(B))->List(C)','pListFunctions3(A,B,C)',NULL,'\spad{map(fn,{} u1,{} u2)} applies the binary function \spad{fn} to corresponding elements of lists \spad{u1} and \spad{u2} and returns a list of the results (in the same order). Thus \spad{map(/,{} [1,{} 2,{} 3],{} [4,{} 5,{} 6]) = [1/4,{} 2/5,{} 1/2]}. The computation terminates when the end of either list is reached. That is,{} the length of the result list is equal to the minimum of the lengths of \spad{u1} and \spad{u2}.');
INSERT INTO olibdb VALUES('o','map',3,'x','((A,B)->C,Stream(A),InfiniteTuple(B))->Stream(C)','pInfiniteTupleFunctions3(A,B,C)',NULL,'\spad{map(f,{} a,{} b)} \undocumented');
INSERT INTO olibdb VALUES('o','map',3,'x','((A,B)->C,Stream(A),Stream(B))->Stream(C)','pStreamFunctions3(A,B,C)',NULL,'\spad{map(f,{} st1,{} st2)} returns the stream whose elements are the function \spad{f} applied to the corresponding elements of \spad{st1} and \spad{st2}. Note: \spad{map(f,{} [x0,{} x1,{} x2,{} ..],{} [y0,{} y1,{} y2,{} ..]) = [f(x0,{} y0),{} f(x1,{} y1),{} ..]}.');
INSERT INTO olibdb VALUES('o','map',3,'x','((Entry,Entry)->Entry,%,%)->%','cTableAggregate(Key,Entry)',NULL,'\spad{map(fn,{} t1,{} t2)} creates a new table \spad{t} from given tables \spad{t1} and \spad{t2} with elements \spad{fn}(\spad{x},{} \spad{y}) where \spad{x} and \spad{y} are corresponding elements from \spad{t1} and \spad{t2} respectively.');
INSERT INTO olibdb VALUES('o','map',3,'x','((R,R)->R,%,%)->%','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{map(f,{} a,{} b)} returns \spad{c},{} where \spad{c} is such that \spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \spad{i},{} \spad{j}.');
INSERT INTO olibdb VALUES('o','map',3,'x','((R,R)->R,%,%)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{map(f,{} a,{} b)} returns \spad{c},{} where \spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} for all \spad{i,{} j}');
INSERT INTO olibdb VALUES('o','map',3,'x','((R)->S,OnePointCompletion(R),OnePointCompletion(S))->OnePointCompletion(S)','pOnePointCompletionFunctions2(R,S)',NULL,'\spad{map(f,{} r,{} i)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(infinity) = \spad{i}.');
INSERT INTO olibdb VALUES('o','map',3,'x','((S,S)->S,%,%)->%','cLinearAggregate(S)',NULL,'\spad{map(f,{} u,{} v)} returns a new aggregate \spad{w} with elements \spad{z = f(x,{} y)} for corresponding elements \spad{x} and \spad{y} from \spad{u} and \spad{v}. Note: \spad{w.i = f(u.i,{} v.i)}.');
INSERT INTO olibdb VALUES('o','map',4,'n','((R,R)->R,S,S,R)->S','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',4,'x','((R,R)->R,%,%,R)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{map(f,{} a,{} b,{} r)} returns \spad{c},{} where \spad{c(i,{} j) = f(a(i,{} j),{} b(i,{} j))} when both \spad{a(i,{} j)} and \spad{b(i,{} j)} exist; else \spad{c(i,{} j) = f(r,{} b(i,{} j))} when \spad{a(i,{} j)} does not exist; else \spad{c(i,{} j) = f(a(i,{} j),{} r)} when \spad{b(i,{} j)} does not exist; otherwise \spad{c(i,{} j) = f(r,{} r)}.');
INSERT INTO olibdb VALUES('o','map',4,'x','((R)->S,OrderedCompletion(R),OrderedCompletion(S),OrderedCompletion(S))->OrderedCompletion(S)','pOrderedCompletionFunctions2(R,S)',NULL,'\spad{map(f,{} r,{} p,{} m)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(plusInfinity) = \spad{p} and that \spad{f}(minusInfinity) = \spad{m}.');
INSERT INTO olibdb VALUES('o','map',5,'n','(A,List(NonNegativeInteger),List(S),Integer,Integer)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','map',5,'n','(%,List(NonNegativeInteger),List(S),Integer,Integer)->%','cFiniteGraph(S)',NULL,'\spad{map(s,{} m,{} newOb,{} offsetX,{} offsetY)} creates a new graph by mapping from this one \spad{newOb} should contain the new list of vertices. \spad{m} should contain a NNI value for each vertex,{} this is the new index into \spad{newOb}. It is allowed that \spad{newOb} may contain less objects than \spad{s} (for surjective mapping) or more objects than \spad{s} (for injective mapping)');
INSERT INTO olibdb VALUES('o','mapall',2,'x','((R1)->R2,Distribution(R1))->Distribution(R2)','pDistributionFunctions2(R1,R2)',NULL,'\spad{map(f,{} x)} maps the moments and cumulants from the ring \spad{R1} to \spad{R2}.');
INSERT INTO olibdb VALUES('o','mapBivariate',2,'n','((K)->L,UP)->SparseUnivariatePolynomial(SparseUnivariatePolynomial(L))','pIntegralBasisPolynomialTools(K,R,UP,L)',NULL,'\spad{mapBivariate(f,{} p(x,{} y))} applies the function \spad{f} to the coefficients of \spad{p(x,{} y)}.');
INSERT INTO olibdb VALUES('o','mapContra',5,'n','(A,List(NonNegativeInteger),List(S),Integer,Integer)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mapContra',5,'n','(%,List(NonNegativeInteger),List(S),Integer,Integer)->%','cFiniteGraph(S)',NULL,'\spad{mapContra(s,{} m,{} newOb,{} offsetX,{} offsetY)} is similar to map function but reverses the directions of the arrows');
INSERT INTO olibdb VALUES('o','mapdiv',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Field)','\spad{mapdiv([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \spad{[a0/b0,{} a1/b1,{} ..]}.');
INSERT INTO olibdb VALUES('o','mapDown!',3,'x','(%,S,(S,S)->S)->%','dBalancedBinaryTree(S)',NULL,'\spad{mapDown!(t,{}p,{}f)} returns \spad{t} after traversing \spad{t} in preorder (node then left then right) fashion replacing the successive interior nodes as follows. The root value \spad{x} is replaced by \spad{q} \spad{:=} \spad{f}(\spad{p},{} \spad{x}). The mapDown!(\spad{l},{} \spad{q},{} \spad{f}) and mapDown!(\spad{r},{} \spad{q},{} \spad{f}) are evaluated for the left and right subtrees \spad{l} and \spad{r} of \spad{t}.');
INSERT INTO olibdb VALUES('o','mapDown!',3,'x','(%,S,(S,S,S)->List(S))->%','dBalancedBinaryTree(S)',NULL,'\spad{mapDown!(t,{}p,{}f)} returns \spad{t} after traversing \spad{t} in preorder (node then left then right) fashion replacing the successive interior nodes as follows. Let \spad{l} and \spad{r} denote the left and right subtrees of \spad{t}. The root value \spad{x} of \spad{t} is replaced by \spad{p}. Then \spad{f}(value \spad{l},{} value \spad{r},{} \spad{p}),{} where \spad{l} and \spad{r} denote the left and right subtrees of \spad{t},{} is evaluated producing two values \spad{pl} and \spad{pr}. Then \spad{mapDown!(l,{} pl,{} f)} and \spad{mapDown!(l,{} pr,{} f)} are evaluated.');
INSERT INTO olibdb VALUES('o','mapExpon',2,'n','((E)->E,%)->%','dListMonoidOps(S,E,un)',NULL,'\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.');
INSERT INTO olibdb VALUES('o','mapExpon',2,'n','((Integer)->Integer,%)->%','dFreeGroup(S)',NULL,'\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.');
INSERT INTO olibdb VALUES('o','mapExpon',2,'n','((NonNegativeInteger)->NonNegativeInteger,%)->%','dFreeMonoid(S)',NULL,'\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.');
INSERT INTO olibdb VALUES('o','mapExponents',2,'n','((E)->E,S)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mapExponents',2,'x','((E)->E,%)->%','cFiniteAbelianMonoidRing(R,E)',NULL,'\spad{mapExponents(fn,{} u)} maps function \spad{fn} onto the exponents of the non-zero monomials of polynomial \spad{u}.');
INSERT INTO olibdb VALUES('o','mapGen',2,'n','((S)->S,%)->%','dFreeGroup(S)',NULL,'\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.');
INSERT INTO olibdb VALUES('o','mapGen',2,'n','((S)->S,%)->%','dFreeMonoid(S)',NULL,'\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.');
INSERT INTO olibdb VALUES('o','mapGen',2,'n','((S)->S,%)->%','dListMonoidOps(S,E,un)',NULL,'\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.');
INSERT INTO olibdb VALUES('o','mapMatrixIfCan',2,'n','((L)->Union(K,failed),Matrix(SparseUnivariatePolynomial(L)))->Union(Matrix(R),failed)','pIntegralBasisPolynomialTools(K,R,UP,L)',NULL,'\spad{mapMatrixIfCan(f,{} mat)} applies the function \spad{f} to the coefficients of the entries of \spad{mat} if possible,{} and returns \spad{failed} otherwise.');
INSERT INTO olibdb VALUES('o','mapmult',2,'n','(Stream(A),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{mapmult([a0,{} a1,{} ..],{} [b0,{} b1,{} ..])} returns \spad{[a0*b0,{} a1*b1,{} ..]}.');
INSERT INTO olibdb VALUES('o','map_preserving',2,'x','((R)->S,Factored(R))->Factored(S)','pFactoredFunctions2(R,S)',NULL,'\spad{map_preserving(fn,{} u)} is used to apply the function \userfun{\spad{fn}} to every factor of \spadvar{\spad{u}}. The new factored object will have the same flags as original.');
INSERT INTO olibdb VALUES('o','mapUnivariate',2,'n','((K)->L,R)->SparseUnivariatePolynomial(L)','pIntegralBasisPolynomialTools(K,R,UP,L)',NULL,'\spad{mapUnivariate(f,{} p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)}.');
INSERT INTO olibdb VALUES('o','mapUnivariate',2,'n','((L)->K,SparseUnivariatePolynomial(L))->R','pIntegralBasisPolynomialTools(K,R,UP,L)',NULL,'\spad{mapUnivariate(f,{} p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)}.');
INSERT INTO olibdb VALUES('o','mapUnivariateIfCan',2,'n','((L)->Union(K,failed),SparseUnivariatePolynomial(L))->Union(R,failed)','pIntegralBasisPolynomialTools(K,R,UP,L)',NULL,'\spad{mapUnivariateIfCan(f,{} p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)},{} if possible,{} and returns \spad{failed} otherwise.');
INSERT INTO olibdb VALUES('o','mapUp!',2,'x','(%,(S,S)->S)->S','dBalancedBinaryTree(S)',NULL,'\spad{mapUp!(t,{}f)} traverses balanced binary tree \spad{t} in an endorder (left then right then node) fashion returning \spad{t} with the value at each successive interior node of \spad{t} replaced by \spad{f}(\spad{l},{} \spad{r}) where \spad{l} and \spad{r} are the values at the immediate left and right nodes.');
INSERT INTO olibdb VALUES('o','mapUp!',3,'x','(%,%,(S,S,S,S)->S)->%','dBalancedBinaryTree(S)',NULL,'\spad{mapUp!(t,{}t1,{}f)} traverses \spad{t} in an endorder (left then right then node) fashion returning \spad{t} with the value at each successive interior node of \spad{t} replaced by \spad{f}(\spad{l},{} \spad{r},{} \spad{l1},{} \spad{r1}) where \spad{l} and \spad{r} are the values at the immediate left and right nodes. Values \spad{l1} and \spad{r1} are values at the corresponding nodes of a balanced binary tree \spad{t1},{} of identical shape at \spad{t}.');
INSERT INTO olibdb VALUES('o','mask',1,'n','(S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mask',1,'x','(%)->%','cIntegerNumberSystem',NULL,'\spad{mask(n)} returns \spad{2^n-1} (an \spad{n} bit mask).');
INSERT INTO olibdb VALUES('o','match',2,'x','(List(A),List(B))->(A)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb)} creates a map with no default source or target values defined by lists \spad{la} and \spad{lb} of equal length. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length. Note: when this map is applied,{} an error occurs when applied to a value missing from \spad{la}.');
INSERT INTO olibdb VALUES('o','match?',3,'x','(%,%,Character)->Boolean','cStringAggregate',NULL,'\spad{match?(s,{} t,{} c)} tests if \spad{s} matches \spad{t} except perhaps for multiple and consecutive occurrences of character \spad{c}. Typically \spad{c} is the blank character.');
INSERT INTO olibdb VALUES('o','match',3,'x','(List(A),List(B),(A)->B)->(A)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb,{} f)} creates a map defined by lists \spad{la} and \spad{lb} of equal length. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Argument \spad{f} is used as the function to call when the given function argument is not in \spad{la}. The value returned is \spad{f} applied to that argument.');
INSERT INTO olibdb VALUES('o','match',3,'x','(List(A),List(B),A)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb,{} a)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} where \spad{a} is used as the default source value if the given one is not in \spad{la}. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length.');
INSERT INTO olibdb VALUES('o','match',3,'x','(List(A),List(B),B)->(A)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb,{} b)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} where \spad{b} is used as the default target value if the given function argument is not in \spad{la}. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length.');
INSERT INTO olibdb VALUES('o','match',4,'x','(List(A),List(B),A,(A)->B)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb,{} a,{} f)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} and applies this map to a. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Argument \spad{f} is a default function to call if a is not in \spad{la}. The value returned is then obtained by applying \spad{f} to argument a.');
INSERT INTO olibdb VALUES('o','match',4,'x','(List(A),List(B),A,B)->B','pListToMap(A,B)',NULL,'\spad{match(la,{} lb,{} a,{} b)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} and applies this map to a. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index in \spad{lb}. Argument \spad{b} is the default target value if a is not in \spad{la}. Error: if \spad{la} and \spad{lb} are not of equal length.');
INSERT INTO olibdb VALUES('o','mathieu11',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu11 constructs} the mathieu group acting on the integers 1,{} ...,{} 11.');
INSERT INTO olibdb VALUES('o','mathieu11',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu11(\spad{li})} constructs the mathieu group acting on the 11 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. error,{} if {\em \spad{li}} has less or more than 11 different entries.');
INSERT INTO olibdb VALUES('o','mathieu12',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu12 constructs} the mathieu group acting on the integers 1,{} ...,{} 12.');
INSERT INTO olibdb VALUES('o','mathieu12',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu12(\spad{li})} constructs the mathieu group acting on the 12 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed Error: if {\em \spad{li}} has less or more than 12 different entries.');
INSERT INTO olibdb VALUES('o','mathieu22',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu22 constructs} the mathieu group acting on the integers 1,{} ...,{} 22.');
INSERT INTO olibdb VALUES('o','mathieu22',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu22(\spad{li})} constructs the mathieu group acting on the 22 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 22 different entries.');
INSERT INTO olibdb VALUES('o','mathieu23',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu23 constructs} the mathieu group acting on the integers 1,{} ...,{} 23.');
INSERT INTO olibdb VALUES('o','mathieu23',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu23(\spad{li})} constructs the mathieu group acting on the 23 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 23 different entries.');
INSERT INTO olibdb VALUES('o','mathieu24',0,'x','()->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu24 constructs} the mathieu group acting on the integers 1,{} ...,{} 24.');
INSERT INTO olibdb VALUES('o','mathieu24',1,'x','(List(Integer))->PermutationGroup(Integer)','pPermutationGroupExamples',NULL,'\spad{mathieu24(\spad{li})} constructs the mathieu group acting on the 24 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 24 different entries.');
INSERT INTO olibdb VALUES('o','matrix',1,'n','(List(List(%)))->%','dOutputForm',NULL,'\spad{matrix(llf)} makes \spad{llf} (a list of lists of forms) into a form which displays as a matrix.');
INSERT INTO olibdb VALUES('o','matrix',1,'n','(List(List(R)))->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','matrix',1,'n','(%)->Matrix(R)','dIncidenceAlgebra(R,S)',NULL,'\spad{matrix(A)} returns the underlying matrix of the incidence matrix A');
INSERT INTO olibdb VALUES('o','matrix',1,'n','(%)->Matrix(XDistributedPolynomial(VAR,F))','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{matrix(f)} returns the matrix of the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','matrix',1,'x','(List(List(R)))->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{matrix(l)} converts the list of lists \spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix.');
INSERT INTO olibdb VALUES('o','matrix',1,'x','(List(List(R)))->%','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{matrix(l)} converts the list of lists \spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix.');
INSERT INTO olibdb VALUES('o','matrix',1,'x','(%)->SquareMatrix(n,K)','dQuadraticForm(n,K)',NULL,'\spad{matrix(qf)} creates a square matrix from the quadratic form \spad{qf}.');
INSERT INTO olibdb VALUES('o','matrix',2,'n','(%,FreeMonoid(VAR))->Matrix(F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{matrix(f,{}m)} returns the coefficient matrix for the monomial \spad{m} of the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','matrix',2,'n','(%,NonNegativeInteger)->Matrix(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{matrix(p,{} l)} returns matrix \spad{l} in the linear pencil \spad{p}.');
INSERT INTO olibdb VALUES('o','matrix',2,'n','(String,String)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{matrix(left,{} right)} returns a handler that typesets a matrix with parentheses given by \spad{left} and right where rows are formatted using \spad{h}.');
INSERT INTO olibdb VALUES('o','matrix',3,'n','(NonNegativeInteger,NonNegativeInteger,(Integer,Integer)->R)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','matrix',3,'x','(NonNegativeInteger,NonNegativeInteger,(Integer,Integer)->R)->%','cMatrixCategory(R,Row,Col)',NULL,'\spad{matrix(n,{}m,{}f)} constructs an \spad{n * m} matrix with the \spad{(i,{}j)} entry equal to \spad{f(i,{}j)}.');
INSERT INTO olibdb VALUES('o','matrixConcat3D',3,'n','(Symbol,%,%)->%','dThreeDimensionalMatrix(R)',NULL,'\spad{matrixConcat3D(s,{} x,{} y)} concatenates two 3-\spad{D} matrices along a specified axis');
INSERT INTO olibdb VALUES('o','matrixDimensions',1,'n','(%)->Vector(NonNegativeInteger)','dThreeDimensionalMatrix(R)',NULL,'\spad{matrixDimensions(x)} returns the dimensions of a matrix');
INSERT INTO olibdb VALUES('o','matrixGcd',3,'n','(Matrix(R),R,NonNegativeInteger)->R','pIntegralBasisTools(R,UP,F)',NULL,'\spad{matrixGcd(mat,{} sing,{} n)} is \spad{gcd(sing,{} g)} where \spad{g} is the \spad{gcd} of the entries of the \spad{n}-by-\spad{n} upper-triangular matrix \spad{mat}.');
INSERT INTO olibdb VALUES('o','max',0,'x','()->%','cFloatingPointSystem','AND(not(has(%,arbitraryExponent)),not(has(%,arbitraryPrecision)))','\spad{max()} returns the maximum floating point number.');
INSERT INTO olibdb VALUES('o','max',0,'x','()->%','dSingleInteger',NULL,'\spad{max()} returns the largest single integer.');
INSERT INTO olibdb VALUES('o','max',1,'n','(A)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',1,'n','(A)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',1,'n','(A)->S','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',1,'n','(A)->S','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',1,'n','(%)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{max(s)} returns index of the vertex which can be reached from all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.');
INSERT INTO olibdb VALUES('o','max',1,'x','(%)->S','cHomogeneousAggregate(S)','AND(has(%,finiteAggregate),has(S,OrderedSet))','\spad{max(u)} returns maximal element of \spad{u}. Error if \spad{u} is empty.');
INSERT INTO olibdb VALUES('o','max',1,'x','(%)->S','cPriorityQueueAggregate(S)',NULL,'\spad{max(q)} returns the maximum element of priority queue \spad{q}.');
INSERT INTO olibdb VALUES('o','max',2,'n','(A,List(NonNegativeInteger))->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',2,'n','(A,List(NonNegativeInteger))->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',2,'n','(%,%)->%','cSPointCategory',NULL,'\spad{max(a,{} b)} returns a point whose value in each dimension is the maximum. So if a has the largest \spad{x} value and \spad{b} has the largest \spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points.');
INSERT INTO olibdb VALUES('o','max',2,'n','(%,List(NonNegativeInteger))->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{max(s,{} sub)} returns index of the vertex which can be reached from a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.');
INSERT INTO olibdb VALUES('o','max',2,'n','((S,S)->Boolean,A)->S','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',2,'n','((S,S)->Boolean,A)->S','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',2,'n','(S,S)->S','xOrderedSet&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','max',2,'x','(%,%)->%','cOrderedSet',NULL,'\spad{max(x,{}y)} returns the maximum of \spad{x} and \spad{y} relative to \spad{<}.');
INSERT INTO olibdb VALUES('o','max',2,'x','((S,S)->Boolean,%)->S','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{max(p,{} u)} returns maximal element of \spad{u} with respect to total ordering predicate \spad{p}. Error if \spad{u} is empty.');
INSERT INTO olibdb VALUES('o','maxColIndex',1,'x','(%)->Integer','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{maxColIndex(m)} returns the index of the ''last'' column of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','maxColIndex',1,'x','(%)->Integer','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{maxColIndex(m)} returns the index of the ''last'' column of the array \spad{m}');
INSERT INTO olibdb VALUES('o','maxdeg',1,'n','(%)->E','dXPolynomialRing(R,E)',NULL,'\spad{maxdeg(p)} returns the greatest word occurring in the polynomial \spad{p} with a non-zero coefficient. An error is produced if \spad{p} is zero.');
INSERT INTO olibdb VALUES('o','maxdeg',1,'x','(%)->FreeMonoid(vl)','cXPolynomialsCat(vl,R)',NULL,'\spad{maxdeg(p)} returns the greatest leading word in the support of \spad{p}.');
INSERT INTO olibdb VALUES('o','maxDegree',1,'n','(List(GuessOption))->Union(NonNegativeInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxDegree returns} the specified maxDegree.');
INSERT INTO olibdb VALUES('o','maxDegree',1,'x','(Union(NonNegativeInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxDegree(d)} specifies the maximum degree of the coefficient polynomials in an algebraic differential equation or a recursion with polynomial coefficients. For rational functions with an exponential term,{} \spad{maxDegree} bounds the degree of the denominator polynomial. This option is expressed in the form \spad{maxDegree == d}.');
INSERT INTO olibdb VALUES('o','maxDerivative',1,'n','(List(GuessOption))->Union(NonNegativeInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxDerivative returns} the specified maxDerivative.');
INSERT INTO olibdb VALUES('o','maxDerivative',1,'x','(Union(NonNegativeInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxDerivative(d)} specifies the maximum derivative in an algebraic differential equation. This option is expressed in the form \spad{maxDerivative == d}.');
INSERT INTO olibdb VALUES('o','maximumExponent',0,'n','()->Integer','dMachineFloat',NULL,'\spad{maximumExponent()} returns the maximum exponent in the model');
INSERT INTO olibdb VALUES('o','maximumExponent',1,'n','(Integer)->Integer','dMachineFloat',NULL,'\spad{maximumExponent(e)} sets the maximum exponent in the model to \spad{e}');
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(A)->Integer','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(A)->Integer','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(%)->NonNegativeInteger','dFiniteCubicalComplex(VS)',NULL,'find the maximum index.');
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(%)->NonNegativeInteger','dFiniteSimplicialComplex(VS)',NULL,'find the maximum index.');
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(%)->NonNegativeInteger','dOrientedFacet',NULL,'returns maximum index');
INSERT INTO olibdb VALUES('o','maxIndex',1,'n','(S)->Index','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','maxIndex',1,'x','(%)->Index','cIndexedAggregate(Index,Entry)','has(Index,OrderedSet)','\spad{maxIndex(u)} returns the maximum index \spad{i} of aggregate \spad{u}. Note: in general,{} \spad{maxIndex(u) = reduce(max,{} indices u)}; for List,{} \spad{maxIndex(u) = \#u}.');
INSERT INTO olibdb VALUES('o','maxint',0,'n','()->PositiveInteger','dMachineInteger',NULL,'\spad{maxint()} returns the maximum integer in the model');
INSERT INTO olibdb VALUES('o','maxint',1,'n','(PositiveInteger)->PositiveInteger','dMachineInteger',NULL,'\spad{maxint(u)} sets the maximum integer in the model to \spad{u}');
INSERT INTO olibdb VALUES('o','maxLevel',1,'n','(List(GuessOption))->Union(NonNegativeInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxLevel returns} the specified maxLevel.');
INSERT INTO olibdb VALUES('o','maxLevel',1,'x','(Union(NonNegativeInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxLevel(d)} specifies the maximum number of recursion levels operators guessProduct and guessSum will be applied. This option is expressed in the form spad{maxLevel \spad{==} \spad{d}}.');
INSERT INTO olibdb VALUES('o','maxMixedDegree',1,'n','(List(GuessOption))->NonNegativeInteger','dGuessOptionFunctions0',NULL,'\spad{maxMixedDegree returns} the specified maxMixedDegree.');
INSERT INTO olibdb VALUES('o','maxMixedDegree',1,'x','(NonNegativeInteger)->%','dGuessOption',NULL,'\spad{maxMixedDegree(d)} specifies the maximum \spad{q}-degree of the coefficient polynomials in a recurrence with polynomial coefficients,{} in the case of mixed shifts. Although slightly inconsistent,{} maxMixedDegree(0) specifies that no mixed shifts are allowed. This option is expressed in the form \spad{maxMixedDegree == d}.');
INSERT INTO olibdb VALUES('o','maxPoints',0,'n','()->Integer','dPlot',NULL,'\spad{maxPoints()} returns the maximum number of points in a plot');
INSERT INTO olibdb VALUES('o','maxPoints',0,'x','()->Integer','pGraphicsDefaults',NULL,'\spad{maxPoints()} returns the maximum number of points in a plot.');
INSERT INTO olibdb VALUES('o','maxPoints',1,'x','(Integer)->Integer','pGraphicsDefaults',NULL,'\spad{maxPoints()} sets the maximum number of points in a plot.');
INSERT INTO olibdb VALUES('o','maxPoints3D',0,'n','()->Integer','dPlot3D',NULL,'\spad{maxPoints3D()} returns the maximum number of points in a plot.');
INSERT INTO olibdb VALUES('o','maxPower',1,'n','(List(GuessOption))->Union(PositiveInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxPower returns} the specified maxPower.');
INSERT INTO olibdb VALUES('o','maxPower',1,'x','(Union(PositiveInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxPower(d)} specifies the maximum degree in an algebraic differential equation. For example,{} the degree of (\spad{f}\spad{''''})\spad{^3} \spad{f''} is 4. maxPower(\spad{-1}) specifies that the maximum exponent can be arbitrary. This option is expressed in the form \spad{maxPower == d}.');
INSERT INTO olibdb VALUES('o','maxPrecedence',0,'n','()->Integer','cFormatterCategory',NULL,'\spad{maxPrecedence()} returns the maximal precedence value,{}');
INSERT INTO olibdb VALUES('o','maxPrecedence',0,'n','()->Integer','xFormatterCategory&(S)',NULL,'\spad{maxPrecedence()} returns the maximal precedence value,{}');
INSERT INTO olibdb VALUES('o','maxrank',1,'n','(List(Record(rank:NonNegativeInteger,eqns:List(Record(det:GR,rows:List(Integer),cols:List(Integer))),fgb:List(GR))))->NonNegativeInteger','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{maxrank(r)} returns the maximum rank in the list \spad{r} of regimes');
INSERT INTO olibdb VALUES('o','maxrow',6,'n','(List(S),List(List(List(S))),List(List(S)),List(List(List(S))),List(List(List(S))),List(List(List(S))))->Record(f1:List(S),f2:List(List(List(S))),f3:List(List(S)),f4:List(List(List(S))))','pTableauxBumpers(S)',NULL,'\spad{maxrow(a,{} b,{} c,{} d,{} e)} is an auxiliary function for \spad{mr}');
INSERT INTO olibdb VALUES('o','maxRowIndex',1,'x','(%)->Integer','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{maxRowIndex(m)} returns the index of the ''last'' row of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','maxRowIndex',1,'x','(%)->Integer','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{maxRowIndex(m)} returns the index of the ''last'' row of the array \spad{m}');
INSERT INTO olibdb VALUES('o','maxShift',1,'n','(List(GuessOption))->Union(NonNegativeInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxShift returns} the specified maxShift.');
INSERT INTO olibdb VALUES('o','maxShift',1,'x','(Union(NonNegativeInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxShift(d)} specifies the maximum shift in a recurrence equation. This option is expressed in the form \spad{maxShift == d}.');
INSERT INTO olibdb VALUES('o','maxSubst',1,'n','(List(GuessOption))->Union(PositiveInteger,arbitrary)','dGuessOptionFunctions0',NULL,'\spad{maxSubst returns} the specified maxSubst.');
INSERT INTO olibdb VALUES('o','maxSubst',1,'x','(Union(PositiveInteger,arbitrary))->%','dGuessOption',NULL,'\spad{maxSubst(d)} specifies the maximum degree of the monomial substituted into the function we are looking for. That is,{} if \spad{maxSubst == d},{} we look for polynomials such that \$\spad{p}(\spad{f}(\spad{x}),{} \spad{f}(\spad{x^2}),{} ...,{} \spad{f}(\spad{x^d}))\spad{=0}\$. equation. This option is expressed in the form \spad{maxSubst == d}.');
INSERT INTO olibdb VALUES('o','mdeg',1,'n','(S)->NonNegativeInteger','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mdeg',1,'x','(%)->NonNegativeInteger','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{mdeg(p)} returns an error if \spad{p} is \spad{0},{} otherwise,{} if \spad{p} belongs to \spad{R} returns \spad{0},{} otherwise,{} returns the degree of \spad{p} in its main variable.');
INSERT INTO olibdb VALUES('o','meatAxe',1,'x','(List(Matrix(R)))->List(List(Matrix(R)))','pRepresentationPackage2(R)','AND(has(R,Field),has(R,Finite))','\spad{meatAxe(aG)} calls {\em meatAxe(aG,{} false,{} 25,{} 7)} returns a 2-list of representations as follows. All matrices of argument \spad{aG} are assumed to be square and of equal size. Then \spad{aG} generates a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an A-module in the usual way. meatAxe(\spad{aG}) creates at most 25 random elements of the algebra,{} tests them for singularity. If singular,{} it tries at most 7 elements of its kernel to generate a proper submodule. If successful a list which contains first the list of the representations of the submodule,{} then a list of the representations of the factor module is returned. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\spad{''s} irreducibility test can be used either to prove irreducibility or to find the splitting. Notes: the first 6 tries use Parker\spad{''s} fingerprints. Also,{} 7 covers the case of three-dimensional kernels over the field with 2 elements.');
INSERT INTO olibdb VALUES('o','meatAxe',2,'x','(List(Matrix(R)),Boolean)->List(List(Matrix(R)))','pRepresentationPackage2(R)','AND(has(R,Field),has(R,Finite))','\spad{meatAxe(aG,{} randomElements)} calls {\em meatAxe(aG,{} false,{} 6,{} 7)},{} only using Parker\spad{''s} fingerprints,{} if {\em randomElemnts} is \spad{false}. If it is \spad{true},{} it calls {\em meatAxe(aG,{} true,{} 25,{} 7)},{} only using random elements. Note: the choice of 25 was rather arbitrary. Also,{} 7 covers the case of three-dimensional kernels over the field with 2 elements.');
INSERT INTO olibdb VALUES('o','meatAxe',2,'x','(List(Matrix(R)),PositiveInteger)->List(List(Matrix(R)))','pRepresentationPackage2(R)','AND(has(R,Field),has(R,Finite))','\spad{meatAxe(aG,{} numberOfTries)} calls {\em meatAxe(aG,{} true,{} numberOfTries,{} 7)}. Notes: 7 covers the case of three-dimensional kernels over the field with 2 elements.');
INSERT INTO olibdb VALUES('o','meatAxe',4,'x','(List(Matrix(R)),Boolean,Integer,Integer)->List(List(Matrix(R)))','pRepresentationPackage2(R)','AND(has(R,Field),has(R,Finite))','\spad{meatAxe(aG,{} randomElements,{} numberOfTries,{} maxTests)} returns a 2-list of representations as follows. All matrices of argument \spad{aG} are assumed to be square and of equal size. Then \spad{aG} generates a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an A-module in the usual way. meatAxe(\spad{aG},{} \spad{numberOfTries},{} maxTests) creates at most {\em numberOfTries} random elements of the algebra,{} tests them for singularity. If singular,{} it tries at most {\em maxTests} elements of its kernel to generate a proper submodule. If successful,{} a 2-list is returned: first,{} a list containing first the list of the representations of the submodule,{} then a list of the representations of the factor module. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\spad{''s} irreducibility test can be used either to prove irreducibility or to find the splitting. If {\em randomElements} is {\em false},{} the first 6 tries use Parker\spad{''s} fingerprints.');
INSERT INTO olibdb VALUES('o','medialSet',1,'x','(List(P))->Union(%,failed)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{medial(ps)} returns the same as \spad{medialSet(ps,{} initiallyReduced?,{} initiallyReduce)}.');
INSERT INTO olibdb VALUES('o','medialSet',3,'x','(List(P),(P,P)->Boolean,(P,P)->P)->Union(%,failed)','dWuWenTsunTriangularSet(R,E,V,P)',NULL,'\spad{medialSet(ps,{} redOp?,{} redOp)} returns \spad{bs} a basic set (in Wu Wen Tsun sense \spad{w}.\spad{r}.\spad{t} the reduction-test \spad{redOp?}) of some set generating the same ideal as \spad{ps} (with rank not higher than any basic set of \spad{ps}),{} if no non-zero constant polynomials appear during the computations,{} else \spad{failed} is returned. In the former case,{} \spad{bs} has to be understood as a candidate for being a characteristic set of \spad{ps}. In the original algorithm,{} \spad{bs} is simply a basic set of \spad{ps}.');
INSERT INTO olibdb VALUES('o','meet',1,'n','(List(%))->%','dLatticeJoinOfMeets',NULL,'\spad{meet of} set of elements');
INSERT INTO olibdb VALUES('o','meet',1,'n','(List(%))->%','dLatticeMeetOfJoins',NULL,'\spad{meet of} set of elements');
INSERT INTO olibdb VALUES('o','meet',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->NonNegativeInteger','cCoDcpo(S)',NULL,'returns the meet of ''a'' and \spad{''b''} In this version of meet nodes are represented as index values. Not every poset will have a meet but CoDCPO will.');
INSERT INTO olibdb VALUES('o','meetIfCan',2,'n','(A,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','meetIfCan',2,'n','(%,List(NonNegativeInteger))->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{meetIfCan returns} the meet of a subset of lattice given by list of elements.');
INSERT INTO olibdb VALUES('o','meetIfCan',3,'n','(A,NonNegativeInteger,NonNegativeInteger)->Union(NonNegativeInteger,failed)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','meetIfCan',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Union(NonNegativeInteger,failed)','cPoset(S)',NULL,'\spad{meetIfCan(s,{} a,{} b)} returns the meet of ''a'' and \spad{''b''} In this version of meet nodes are represented as index values. In the general case,{} not every poset will have a meet in which case failed will be returned as an error indication.');
INSERT INTO olibdb VALUES('o','meijerG',5,'n','(List(F),List(F),List(F),List(F),F)->F','pFunctionalSpecialFunction(R,F)','has(F,RetractableTo(Integer))','\spad{meijerG(la,{} lb,{} lc,{} ld,{} z)} is the meijerG function.');
INSERT INTO olibdb VALUES('o','meijerG',5,'x','(List(%),List(%),List(%),List(%),%)->%','cSpecialFunctionCategory','has(%,RetractableTo(Integer))','\spad{meijerG(la,{} lb,{} lc,{} ld,{} z)} is the meijerG function.');
INSERT INTO olibdb VALUES('o','meixnerM',4,'n','(F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{meixnerM(n,{} b,{} c,{} z)} is the Meixner polynomial.');
INSERT INTO olibdb VALUES('o','meixnerM',4,'x','(%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{meixnerM(n,{} b,{} c,{} z)} is the Meixner polynomial.');
INSERT INTO olibdb VALUES('o','meixnerP',4,'n','(F,F,F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{meixnerP(n,{} phi,{} lambda,{} z)} is the Meixner-Pollaczek polynomial.');
INSERT INTO olibdb VALUES('o','meixnerP',4,'x','(%,%,%,%)->%','cSpecialFunctionCategory',NULL,'\spad{meixnerP(n,{} phi,{} lambda,{} z)} is the Meixner–Pollaczek polynomial.');
INSERT INTO olibdb VALUES('o','member?',2,'n','(PositiveInteger,%)->Boolean','dSetOfMIntegersInOneToN(m,n)',NULL,'\spad{member?(p,{} s)} returns \spad{true} is \spad{p} is in \spad{s},{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','member?',2,'n','(Record(key:Key,entry:Entry),S)->Boolean','xKeyedDictionary&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','member?',2,'n','(R,S)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','member?',2,'n','(S,A)->Boolean','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','member?',2,'n','(S,A)->Boolean','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','member?',2,'n','(Vector(R),%)->Boolean','dVectorSpaceBasis(R)',NULL,'\spad{member?(v,{} B)} tests if the vector \spad{v} is in the subspace spanned by \spad{B}.');
INSERT INTO olibdb VALUES('o','member?',2,'x','(Permutation(S),%)->Boolean','dPermutationGroup(S)',NULL,'\spad{member?(pp,{} gp)} answers the question,{} whether the permutation {\em pp} is in the group {\em gp} or not.');
INSERT INTO olibdb VALUES('o','member?',2,'x','(S,%)->Boolean','cHomogeneousAggregate(S)','AND(has(%,finiteAggregate),has(S,BasicType))','\spad{member?(x,{} u)} tests if \spad{x} is a member of \spad{u}. For collections,{} \spad{member?(x,{} u) = reduce(or,{} [x=y for y in u],{} false)}. However,{} \spad{member?(x,{} u)} returns as soon as it finds a member.');
INSERT INTO olibdb VALUES('o','members',1,'n','(A)->List(S)','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','members',1,'n','(%)->List(P)','dFiniteMoebiusFunction(P)',NULL,'\spad{members(mf)} returns the elements of the subposet');
INSERT INTO olibdb VALUES('o','members',1,'n','(%)->List(P)','dGeneralizedFiniteMoebiusFunction(P,R)',NULL,'\spad{members(mf)} returns the elements of the subposet');
INSERT INTO olibdb VALUES('o','members',1,'x','(%)->List(S)','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{members(u)} returns a list of the consecutive elements of \spad{u}. For multisets \spadfun{members} gives result with no repetition. See also \spadfun{parts}.');
INSERT INTO olibdb VALUES('o','merge',1,'n','(List(%))->%','dSubSpace(n,R)',NULL,'\spad{merge(ls)} a list of subspaces,{} \spad{ls},{} into one subspace.');
INSERT INTO olibdb VALUES('o','merge',1,'x','(List(%))->%','cThreeSpaceCategory(R)',NULL,'\spad{merge([s1,{} s2,{} ...,{} sn])} will create a new \spadtype{ThreeSpace} that has the components of all the ones in the list; Groupings of components into composites are maintained.');
INSERT INTO olibdb VALUES('o','merge2',7,'n','(Integer,List(Integer),List(Integer),Vector(Integer),SortedExponentVector,Vector(Integer),SortedExponentVector)->Record(offsetdata:Vector(Integer),expdata:SortedExponentVector)','pInnerModularHermitePade',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge!',2,'n','(A,A)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',2,'n','(A,A)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge!',2,'n','(A,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',2,'n','(A,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',2,'n','(A,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',2,'n','(A,A)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',2,'n','(%,%)->%','cFiniteGraph(S)',NULL,'\spad{merge(a,{} b)} returns sum : union (not necessarily disjoint) of nodes with arrows merged in from appropriate input,{} if arrow exists from both inputs then it will be duplicated.');
INSERT INTO olibdb VALUES('o','merge',2,'n','(%,%)->%','dFiniteSimplicialComplex(VS)',NULL,'Forms union of two simplicial complexes.');
INSERT INTO olibdb VALUES('o','merge',2,'n','(%,%)->%','dSubSpace(n,R)',NULL,'\spad{merge(s1,{} s2)} the subspaces \spad{s1} and \spad{s2} into a single subspace.');
INSERT INTO olibdb VALUES('o','merge!',2,'x','(%,%)->%','cExtensibleLinearAggregate(S)','has(S,OrderedSet)','\spad{merge!(u,{} v)} destructively merges \spad{u} and \spad{v} in ascending order.');
INSERT INTO olibdb VALUES('o','merge',2,'x','(%,%)->%','cLinearAggregate(S)','AND(has(%,finiteAggregate),has(S,OrderedSet))','\spad{merge(u,{} v)} merges \spad{u} and \spad{v} in ascending order. Note: \spad{merge(u,{} v) = merge(<=,{} u,{} v)}.');
INSERT INTO olibdb VALUES('o','merge',2,'x','(%,%)->%','cPriorityQueueAggregate(S)',NULL,'\spad{merge(q1,{} q2)} returns combines priority queues \spad{q1} and \spad{q2} to return a single priority queue \spad{q}.');
INSERT INTO olibdb VALUES('o','merge!',2,'x','(%,%)->%','cPriorityQueueAggregate(S)',NULL,'\spad{merge!(q,{} q1)} destructively changes priority queue \spad{q} to include the values from priority queue \spad{q1}.');
INSERT INTO olibdb VALUES('o','merge',2,'x','(%,%)->%','cThreeSpaceCategory(R)',NULL,'\spad{merge(s1,{} s2)} will create a new \spadtype{ThreeSpace} that has the components of \spad{s1} and \spad{s2}; Groupings of components into composites are maintained.');
INSERT INTO olibdb VALUES('o','merge!',3,'n','((S,S)->Boolean,A,A)->A','xExtensibleLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',3,'n','((S,S)->Boolean,A,A)->A','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge!',3,'n','((S,S)->Boolean,A,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',3,'n','((S,S)->Boolean,A,A)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge',3,'n','((S,S)->Boolean,A,A)->A','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','merge!',3,'x','((S,S)->Boolean,%,%)->%','cExtensibleLinearAggregate(S)',NULL,'\spad{merge!(p,{} u,{} v)} destructively merges \spad{u} and \spad{v} using predicate \spad{p}.');
INSERT INTO olibdb VALUES('o','merge',3,'x','((S,S)->Boolean,%,%)->%','cLinearAggregate(S)','has(%,finiteAggregate)','\spad{merge(p,{} a,{} b)} returns an aggregate \spad{c} which merges \spad{a} and \spad{b}. The result is produced by examining each element \spad{x} of \spad{a} and \spad{y} of \spad{b} successively. If \spad{p(x,{} y)} is \spad{true},{} then \spad{x} is inserted into the result; otherwise \spad{y} is inserted. If \spad{x} is chosen,{} the next element of \spad{a} is examined,{} and so on. When all the elements of one aggregate are examined,{} the remaining elements of the other are appended. For example,{} \spad{merge(<,{} [1,{} 3],{} [2,{} 7,{} 5])} returns \spad{[1,{} 2,{} 3,{} 7,{} 5]}.');
INSERT INTO olibdb VALUES('o','mergeDifference',2,'x','(List(S),List(S))->List(S)','pMergeThing(S)',NULL,'\spad{mergeDifference(l1,{} l2)} returns a list of elements in \spad{l1} not present in \spad{l2}. Assumes lists are ordered and all \spad{x} in \spad{l2} are also in \spad{l1}.');
INSERT INTO olibdb VALUES('o','merge_exponents',5,'n','(Integer,Vector(Integer),SortedExponentVector,Vector(Integer),SortedExponentVector)->List(List(Integer))','pInnerModularHermitePade',NULL,NULL);
INSERT INTO olibdb VALUES('o','mergeFactors',2,'x','(%,%)->%','dFactored(R)',NULL,'\spad{mergeFactors(u,{} v)} is used when the factorizations of \spadvar{\spad{u}} and \spadvar{\spad{v}} are known to be disjoint,{} \spadignore{e.g.} resulting from a content/primitive part split. Essentially,{} it creates a new factored object by multiplying the units together and appending the lists of factors.');
INSERT INTO olibdb VALUES('o','mesh?',1,'x','(%)->Boolean','cThreeSpaceCategory(R)',NULL,'\spad{mesh?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} is composed of one component,{} a mesh comprising a list of curves which are lists of points,{} or returns \spad{false} if otherwise');
INSERT INTO olibdb VALUES('o','mesh',1,'x','(List(List(Point(R))))->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh([[p0],{} [p1],{} ...,{} [pn]])} creates a surface defined by a list of curves which are lists,{} \spad{p0} through \spad{pn},{} of points,{} and returns a \spadtype{ThreeSpace} whose component is the surface.');
INSERT INTO olibdb VALUES('o','mesh',1,'x','(%)->List(List(Point(R)))','cThreeSpaceCategory(R)',NULL,'\spad{mesh(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single surface component defined by a list curves which contain lists of points,{} and if so,{} returns the list of lists of points; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','mesh',3,'x','(List(List(Point(R))),Boolean,Boolean)->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh([[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} creates a surface defined over a list of curves,{} \spad{p0} through \spad{pn},{} which are lists of points; the booleans \spad{close1} and \spad{close2} indicate how the surface is to be closed: \spad{close1} set to \spad{true} means that each individual list (a curve) is to be closed (that is,{} the last point of the list is to be connected to the first point); \spad{close2} set to \spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the \spadtype{ThreeSpace} containing this surface is returned.');
INSERT INTO olibdb VALUES('o','mesh',4,'x','(%,List(List(List(R))),Boolean,Boolean)->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} close1,{} close2)} adds a surface component to the \spadtype{ThreeSpace} \spad{s},{} which is defined over a rectangular domain of size \spad{WxH} where \spad{W} is the number of lists of points from the domain \spad{PointDomain(R)} and \spad{H} is the number of elements in each of those lists; the booleans \spad{close1} and \spad{close2} indicate how the surface is to be closed: if \spad{close1} is \spad{true} this means that each individual list (a curve) is to be closed (\spadignore{i.e.} the last point of the list is to be connected to the first point); if \spad{close2} is \spad{true},{} this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).');
INSERT INTO olibdb VALUES('o','mesh',4,'x','(%,List(List(List(R))),List(SubSpaceComponentProperty),SubSpaceComponentProperty)->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh(s,{} [ [[r10]...,{} [r1m]],{} [[r20]...,{} [r2m]],{} ...,{} [[rn0]...,{} [rnm]] ],{} [props],{} prop)} adds a surface component to the \spadtype{ThreeSpace} \spad{s},{} which is defined over a rectangular domain of size \spad{WxH} where \spad{W} is the number of lists of points from the domain \spad{PointDomain(R)} and \spad{H} is the number of elements in each of those lists; lprops is the list of the subspace component properties for each curve list,{} and prop is the subspace component property by which the points are defined.');
INSERT INTO olibdb VALUES('o','mesh',4,'x','(%,List(List(Point(R))),Boolean,Boolean)->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} close1,{} close2)} adds a surface component to the \spadtype{ThreeSpace},{} which is defined over a list of curves,{} in which each of these curves is a list of points. The boolean arguments \spad{close1} and \spad{close2} indicate how the surface is to be closed. Argument \spad{close1} equal \spad{true} means that each individual list (a curve) is to be closed,{} \spadignore{i.e.} the last point of the list is to be connected to the first point. Argument \spad{close2} equal \spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end,{} \spadignore{i.e.} the boundaries are defined as the first list of points (curve) and the last list of points (curve).');
INSERT INTO olibdb VALUES('o','mesh',4,'x','(%,List(List(Point(R))),List(SubSpaceComponentProperty),SubSpaceComponentProperty)->%','cThreeSpaceCategory(R)',NULL,'\spad{mesh(s,{} [[p0],{} [p1],{} ...,{} [pn]],{} [props],{} prop)} adds a surface component,{} defined over a list curves which contains lists of points,{} to the \spadtype{ThreeSpace} \spad{s}; props is a list which contains the subspace component properties for each surface parameter,{} and prop is the subspace component property by which the points are defined.');
INSERT INTO olibdb VALUES('o','meshFun2Var',5,'n','((DoubleFloat,DoubleFloat)->DoubleFloat,Union((DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat,undefined),Segment(DoubleFloat),Segment(DoubleFloat),List(DrawOption))->ThreeSpace(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{meshFun2Var(f,{} g,{} s1,{} s2,{} l)} \undocumented');
INSERT INTO olibdb VALUES('o','meshPar1Var',6,'n','(Expression(Integer),Expression(Integer),Expression(Integer),(DoubleFloat)->DoubleFloat,Segment(DoubleFloat),List(DrawOption))->ThreeSpace(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{meshPar1Var(s,{} t,{} u,{} f,{} s1,{} l)} \undocumented');
INSERT INTO olibdb VALUES('o','meshPar2Var',4,'n','((DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),List(DrawOption))->ThreeSpace(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{meshPar2Var(f,{} s1,{} s2,{} l)} \undocumented');
INSERT INTO olibdb VALUES('o','meshPar2Var',5,'n','(ThreeSpace(DoubleFloat),(DoubleFloat,DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),List(DrawOption))->ThreeSpace(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{meshPar2Var(sp,{} f,{} s1,{} s2,{} l)} \undocumented');
INSERT INTO olibdb VALUES('o','meshPar2Var',7,'n','((DoubleFloat,DoubleFloat)->DoubleFloat,(DoubleFloat,DoubleFloat)->DoubleFloat,(DoubleFloat,DoubleFloat)->DoubleFloat,Union((DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat,undefined),Segment(DoubleFloat),Segment(DoubleFloat),List(DrawOption))->ThreeSpace(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{meshPar2Var(f,{} g,{} h,{} j,{} s1,{} s2,{} l)} \undocumented');
INSERT INTO olibdb VALUES('o','message',1,'n','(String)->%','dOutputForm',NULL,'\spad{message(s)} creates an form with no string quotes from string \spad{s}.');
INSERT INTO olibdb VALUES('o','messagePrint',1,'n','(String)->Void','dOutputForm',NULL,'\spad{messagePrint(s)} prints \spad{s} without string quotes. Note: \spad{messagePrint(s)} is equivalent to \spad{print message(s)}.');
INSERT INTO olibdb VALUES('o','mfactor',2,'n','(PA,MD)->List(PA)','pModularFactorizationGeneral(PA,MMT,MD,PMD,MO)',NULL,'\spad{mfactor(pv,{} md)} computes factorization of \spad{pv} into irreducibles over field described by \spad{md}. \spad{pv} is assumed square-free and monic,{} \spad{md} is info representing finite field.');
INSERT INTO olibdb VALUES('o','mfactor',2,'n','(PrimitiveArray(K),Record(i_mod:Integer,deg:Integer))->List(PrimitiveArray(K))','pModularFactorizationK(K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mfactor',2,'n','(U32Vector,Integer)->List(U32Vector)','pModularFactorization',NULL,NULL);
INSERT INTO olibdb VALUES('o','middle',1,'x','(%)->TheField','dRightOpenIntervalRootCharacterization(TheField,ThePolDom)',NULL,'\spad{middle(rootChar)} is the middle of the isolating interval');
INSERT INTO olibdb VALUES('o','midpoint',1,'x','(Record(left:Fraction(Integer),right:Fraction(Integer)))->Fraction(Integer)','pRealZeroPackage(Pol)',NULL,'\spad{midpoint(int)} returns the midpoint of the interval \spad{int}.');
INSERT INTO olibdb VALUES('o','midpoints',1,'x','(List(Record(left:Fraction(Integer),right:Fraction(Integer))))->List(Fraction(Integer))','pRealZeroPackage(Pol)',NULL,'\spad{midpoints(isolist)} returns the list of midpoints for the list of intervals \spad{isolist}.');
INSERT INTO olibdb VALUES('o','mightHaveRoots',2,'x','(ThePolDom,%)->Boolean','dRightOpenIntervalRootCharacterization(TheField,ThePolDom)',NULL,'\spad{mightHaveRoots(p,{} r)} is \spad{false} if \spad{p.r} is not 0');
INSERT INTO olibdb VALUES('o','min',0,'x','()->%','cFloatingPointSystem','AND(not(has(%,arbitraryExponent)),not(has(%,arbitraryPrecision)))','\spad{min()} returns the minimum floating point number.');
INSERT INTO olibdb VALUES('o','min',0,'x','()->%','dSingleInteger',NULL,'\spad{min()} returns the smallest single integer.');
INSERT INTO olibdb VALUES('o','min',1,'n','(A)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',1,'n','(A)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',1,'n','(A)->S','xFiniteSetAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',1,'n','(A)->S','xHomogeneousAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',1,'n','(%)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{min(s)} returns index of the vertex which can reach to all other vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.');
INSERT INTO olibdb VALUES('o','min',1,'x','(%)->S','cHomogeneousAggregate(S)','AND(has(%,finiteAggregate),has(S,OrderedSet))','\spad{min(u)} returns minimal element of \spad{u}. Error if \spad{u} is empty.');
INSERT INTO olibdb VALUES('o','min',1,'x','(%)->S','cOrderedMultisetAggregate(S)',NULL,'\spad{min(u)} returns the smallest entry in the multiset aggregate \spad{u}.');
INSERT INTO olibdb VALUES('o','min',2,'n','(A,List(NonNegativeInteger))->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',2,'n','(A,List(NonNegativeInteger))->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',2,'n','(%,%)->%','cSPointCategory',NULL,'\spad{min(a,{} b)} returns a point whose value in each dimension is the minimum. So if a has the smallest \spad{x} value and \spad{b} has the smallest \spad{y} value then the result will combine these. This is useful for constructing boundary boxes around sets of points.');
INSERT INTO olibdb VALUES('o','min',2,'n','(%,List(NonNegativeInteger))->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{min(s,{} sub)} returns index of the vertex which can reach to a given subset of the vertices. Gives 0 if no such node exists or if it is not unique,{} if there is a loop for instance.');
INSERT INTO olibdb VALUES('o','min',2,'n','(S,S)->S','xOrderedSet&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','min',2,'x','(%,%)->%','cOrderedSet',NULL,'\spad{min(x,{}y)} returns the minimum of \spad{x} and \spad{y} relative to \spad{<}.');
INSERT INTO olibdb VALUES('o','minColIndex',1,'x','(%)->Integer','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{minColIndex(m)} returns the index of the ''first'' column of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','minColIndex',1,'x','(%)->Integer','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{minColIndex(m)} returns the index of the ''first'' column of the array \spad{m}');
INSERT INTO olibdb VALUES('o','mindeg',1,'n','(%)->E','dXPolynomialRing(R,E)',NULL,'\spad{mindeg(p)} returns the smallest word occurring in the polynomial \spad{p} with a non-zero coefficient. An error is produced if \spad{p} is zero.');
INSERT INTO olibdb VALUES('o','mindeg',1,'x','(%)->FreeMonoid(vl)','cXFreeAlgebra(vl,R)',NULL,'\spad{mindeg(x)} returns the little word which appears in \spad{x}. Error if \spad{x=0}.');
INSERT INTO olibdb VALUES('o','mindegTerm',1,'x','(%)->Record(k:FreeMonoid(vl),c:R)','cXFreeAlgebra(vl,R)',NULL,'\spad{mindegTerm(x)} returns the term whose word is \spad{mindeg(x)}.');
INSERT INTO olibdb VALUES('o','minGbasis',1,'n','(List(Dpol))->List(Dpol)','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{minGbasis }\undocumented');
INSERT INTO olibdb VALUES('o','minimal?',1,'n','(%)->Boolean','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{minimal?(f)} is \spad{f} represented by a minimal ALS?');
INSERT INTO olibdb VALUES('o','minimalMatrix',2,'n','(Matrix(F),NonNegativeInteger)->Matrix(F)','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{minimalMatrix(A,{}r)} returns the minimal (upper-left) submatrix of A such that the rank corresponds to the given.');
INSERT INTO olibdb VALUES('o','minimalPolynomial',1,'n','(S)->SparseUnivariatePolynomial(F)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimalPolynomial',1,'n','(S)->SparseUnivariatePolynomial(R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimalPolynomial',1,'n','(S)->UP','xFramedAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimalPolynomial',1,'n','(Vector(GF))->SparseUnivariatePolynomial(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{minimalPolynomial(x)} \undocumented{} See \spadfunFrom{minimalPolynomial}{FiniteAlgebraicExtensionField}');
INSERT INTO olibdb VALUES('o','minimalPolynomial',1,'x','(%)->UP','cFiniteRankAlgebra(R,UP)','has(R,Field)','\spad{minimalPolynomial(a)} returns the minimal polynomial of \spad{a}.');
INSERT INTO olibdb VALUES('o','minimalPolynomial',2,'n','(S,PositiveInteger)->SparseUnivariatePolynomial(S)','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimalPolynomial',2,'x','(%,PositiveInteger)->SparseUnivariatePolynomial(%)','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{minimalPolynomial(x,{} n)} computes the minimal polynomial of \spad{x} over the field of extension degree \spad{n} over the ground field \spad{F}.');
INSERT INTO olibdb VALUES('o','minimalRepresentation',1,'n','(XDistributedPolynomial(VAR,F))->Record(alpha:Matrix(F),mu:List(Matrix(F)),var:List(VAR),beta:Matrix(F))','pXDistributedPolynomialFunctions(VAR,F)',NULL,'\spad{minimalRepresentation(p)} returns a minimal representation using the generalized Ho algorithm [Fornasini,{} 1978] \spad{p} = sum_w alpha*mu(\spad{w})*beta*w [Theorem 3.3,{} Salomaa--Soittola 1978]');
INSERT INTO olibdb VALUES('o','minimize',1,'n','(%)->%','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{minimize(I)} returns a reduced set of generators for \spad{I}.');
INSERT INTO olibdb VALUES('o','minimize',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{minimize(f)} minimizes the underlying ALS by applying left and right block minimization steps. Minimality is only guaranteed if the remaining blocks are refined.');
INSERT INTO olibdb VALUES('o','minimumDegree',1,'n','(S)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimumDegree',1,'x','(%)->E','cFiniteAbelianMonoidRing(R,E)',NULL,'\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \spad{p}. Error: if applied to 0.');
INSERT INTO olibdb VALUES('o','minimumDegree',2,'n','(S,List(SingletonAsOrderedSet))->List(NonNegativeInteger)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimumDegree',2,'n','(S,SingletonAsOrderedSet)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minimumDegree',2,'x','(%,List(VarSet))->List(NonNegativeInteger)','cPolynomialCategory(R,E,VarSet)',NULL,'\spad{minimumDegree(p,{} lv)} gives the list of minimum degrees of the polynomial \spad{p} with respect to each of the variables in the list \spad{lv}');
INSERT INTO olibdb VALUES('o','minimumDegree',2,'x','(%,VarSet)->NonNegativeInteger','cPolynomialCategory(R,E,VarSet)',NULL,'\spad{minimumDegree(p,{} v)} gives the minimum degree of polynomial \spad{p} with respect to \spad{v},{} \spadignore{i.e.} viewed a univariate polynomial in \spad{v}');
INSERT INTO olibdb VALUES('o','minimumExponent',0,'n','()->Integer','dMachineFloat',NULL,'\spad{minimumExponent()} returns the minimum exponent in the model');
INSERT INTO olibdb VALUES('o','minimumExponent',1,'n','(Integer)->Integer','dMachineFloat',NULL,'\spad{minimumExponent(e)} sets the minimum exponent in the model to \spad{e}');
INSERT INTO olibdb VALUES('o','minIndex',1,'n','(A)->Integer','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minIndex',1,'n','(%)->NonNegativeInteger','dFiniteSimplicialComplex(VS)',NULL,'find the minimum index.');
INSERT INTO olibdb VALUES('o','minIndex',1,'n','(%)->NonNegativeInteger','dOrientedFacet',NULL,'returns minimum index');
INSERT INTO olibdb VALUES('o','minIndex',1,'n','(S)->Index','xIndexedAggregate&(S,Index,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','minIndex',1,'x','(%)->Index','cIndexedAggregate(Index,Entry)','has(Index,OrderedSet)','\spad{minIndex(u)} returns the minimum index \spad{i} of aggregate \spad{u}. Note: in general,{} \spad{minIndex(a) = reduce(min,{} indices a)}; for List,{} \spad{minIndex(a) = 1}.');
INSERT INTO olibdb VALUES('o','minordet',1,'x','(M)->R','pMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','minordet',1,'x','(%)->R','cMatrixCategory(R,Row,Col)','has(R,CommutativeRing)','\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','minordet',1,'x','(%)->R','cSquareMatrixCategory(ndim,R,Row,Col)','has(R,CommutativeRing)','\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors.');
INSERT INTO olibdb VALUES('o','minPoints',0,'n','()->Integer','dPlot',NULL,'\spad{minPoints()} returns the minimum number of points in a plot');
INSERT INTO olibdb VALUES('o','minPoints',0,'x','()->Integer','pGraphicsDefaults',NULL,'\spad{minPoints()} returns the minimum number of points in a plot.');
INSERT INTO olibdb VALUES('o','minPoints',1,'x','(Integer)->Integer','pGraphicsDefaults',NULL,'\spad{minPoints()} sets the minimum number of points in a plot.');
INSERT INTO olibdb VALUES('o','minPoints3D',0,'n','()->Integer','dPlot3D',NULL,'\spad{minPoints3D()} returns the minimum number of points in a plot.');
INSERT INTO olibdb VALUES('o','minPol',2,'n','(List(HomogeneousDistributedMultivariatePolynomial(lv,F)),OrderedVariableList(lv))->HomogeneousDistributedMultivariatePolynomial(lv,F)','pLinGroebnerPackage(lv,F)',NULL,'\spad{minPol }\undocumented');
INSERT INTO olibdb VALUES('o','minPol',3,'n','(List(HomogeneousDistributedMultivariatePolynomial(lv,F)),List(HomogeneousDistributedMultivariatePolynomial(lv,F)),OrderedVariableList(lv))->HomogeneousDistributedMultivariatePolynomial(lv,F)','pLinGroebnerPackage(lv,F)',NULL,'\spad{minPol }\undocumented');
INSERT INTO olibdb VALUES('o','minPoly',1,'n','(Kernel(F))->SparseUnivariatePolynomial(F)','pAlgebraicFunction(R,F)','has(R,RetractableTo(Integer))','\spad{minPoly(k)} returns the defining polynomial of \spad{k}.');
INSERT INTO olibdb VALUES('o','minPoly',1,'x','(K)->SparseUnivariatePolynomial(%)','cExpressionSpace2(K)','has(%,Ring)','\spad{minPoly(k)} returns \spad{p} such that \spad{p(k) = 0}.');
INSERT INTO olibdb VALUES('o','minPrecedence',0,'n','()->Integer','cFormatterCategory',NULL,'\spad{minPrecedence()} returns the minimal precedence value.');
INSERT INTO olibdb VALUES('o','minPrecedence',0,'n','()->Integer','xFormatterCategory&(S)',NULL,'\spad{minPrecedence()} returns the minimal precedence value.');
INSERT INTO olibdb VALUES('o','minrank',1,'n','(List(Record(rank:NonNegativeInteger,eqns:List(Record(det:GR,rows:List(Integer),cols:List(Integer))),fgb:List(GR))))->NonNegativeInteger','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{minrank(r)} returns the minimum rank in the list \spad{r} of regimes');
INSERT INTO olibdb VALUES('o','minRowIndex',1,'x','(%)->Integer','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{minRowIndex(m)} returns the index of the ''first'' row of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','minRowIndex',1,'x','(%)->Integer','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{minRowIndex(m)} returns the index of the ''first'' row of the array \spad{m}');
INSERT INTO olibdb VALUES('o','minset',1,'n','(List(List(GR)))->List(List(GR))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{minset(sl)} returns the sublist of \spad{sl} consisting of the minimal lists (with respect to inclusion) in the list \spad{sl} of lists');
INSERT INTO olibdb VALUES('o','minShift',1,'n','(List(T))->List(T)','pListPackage(T)','has(T,OrderedSet)','\spad{minShift(l)} returns the lexicographically minimal cyclic rotation of the list \spad{l}');
INSERT INTO olibdb VALUES('o','minus!',2,'n','(Matrix(R),Matrix(R))->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{minus!(c,{} a)} computes \spad{-a} and stores the result in the matrix \spad{c}. Error: if a and \spad{c} do not have the same dimensions.');
INSERT INTO olibdb VALUES('o','minus',2,'n','(Record(mantissa:Integer,exponent:Integer),Record(mantissa:Integer,exponent:Integer))->Record(mantissa:Integer,exponent:Integer)','pFloatingPointOperations',NULL,'\spad{minus(x,{} y)} computes \spad{x - y} with no rounding.');
INSERT INTO olibdb VALUES('o','minus!',3,'n','(Matrix(R),Matrix(R),Matrix(R))->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{!minus!(c,{} a,{} b)} computes the matrix difference \spad{a - b} and stores the result in the matrix \spad{c}. Error: if \spad{a},{} \spad{b},{} and \spad{c} do not have the same dimensions.');
INSERT INTO olibdb VALUES('o','minus',3,'n','(Record(mantissa:Integer,exponent:Integer),Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{minus(x,{} y,{} b)} computes approximation to \spad{x - y} accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','minusInfinity',0,'x','()->%','dOrderedCompletion(R)',NULL,'\spad{minusInfinity()} returns -infinity.');
INSERT INTO olibdb VALUES('o','minusInfinity',0,'x','()->OrderedCompletion(Integer)','pInfinity',NULL,'\spad{minusInfinity()} returns minusInfinity.');
INSERT INTO olibdb VALUES('o','m_inverse',4,'n','(Polynomial(Integer),List(Polynomial(Integer)),List(Symbol),Integer)->Union(Polynomial(Integer),failed)','dModularAlgebraicGcdTools3',NULL,'\spad{m_inverse(x,{} lm,{} lv,{} p)} computes inverse of \spad{x} in algebraic extension defined by \spad{lm}.');
INSERT INTO olibdb VALUES('o','mirror',1,'n','(%)->%','dFreeMagma(VarSet)',NULL,'\spad{mirror(x)} returns the reversed word of \spad{x}. That is \spad{x} itself if \spadopFrom{retractable?}{FreeMagma}(\spad{x}) is \spad{true} and \spad{mirror(z) * mirror(y)} if \spad{x} is \spad{y*z}.');
INSERT INTO olibdb VALUES('o','mirror',1,'n','(%)->%','dFreeMonoid(S)',NULL,'\spad{mirror(x)} returns the reversed word of \spad{x}.');
INSERT INTO olibdb VALUES('o','mirror',1,'n','(%)->%','dLieExponentials(VarSet,R,Order)',NULL,'\spad{mirror(g)} is the mirror of the internal representation of \spad{g}.');
INSERT INTO olibdb VALUES('o','mirror',1,'x','(%)->%','cFreeLieAlgebra(VarSet,R)',NULL,'\spad{mirror(x)} returns \spad{Sum(r_i mirror(w_i))} if \spad{x} is \spad{Sum(r_i w_i)}.');
INSERT INTO olibdb VALUES('o','mirror',1,'x','(%)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{mirror(x)} returns \spad{Sum(r_i mirror(w_i))} if \spad{x} writes \spad{Sum(r_i w_i)}.');
INSERT INTO olibdb VALUES('o','mix',1,'n','(List(Record(den:Integer,gcdnum:Integer)))->Integer','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{mix(l)} \undocumented');
INSERT INTO olibdb VALUES('o','mkAnswer',3,'n','(F,List(Record(scalar:Fraction(Integer),coeff:SparseUnivariatePolynomial(F),logand:SparseUnivariatePolynomial(F))),List(Record(integrand:F,intvar:F)))->%','dIntegrationResult(F)',NULL,'\spad{mkAnswer(r,{} l,{} ne)} creates an integration result from a rational part \spad{r},{} a logarithmic part \spad{l},{} and a non-elementary part ne.');
INSERT INTO olibdb VALUES('o','mkcomm',1,'x','(Integer)->%','dCommutator',NULL,'\spad{mkcomm(i)} \undocumented{}');
INSERT INTO olibdb VALUES('o','mkcomm',2,'x','(%,%)->%','dCommutator',NULL,'\spad{mkcomm(i,{} j)} \undocumented{}');
INSERT INTO olibdb VALUES('o','mk_erf',2,'n','(F,F)->F','pElementaryRischDEX(R,F)',NULL,'\spad{mk_erf(u,{} f)} should be local but conditional');
INSERT INTO olibdb VALUES('o','mkIntegral',1,'n','(UPUP)->Record(coef:Fraction(UP),poly:UPUP)','pChangeOfVariable(F,UP,UPUP)',NULL,'\spad{mkIntegral(p(x,{} y))} returns \spad{[c(x),{} q(x,{} z)]} such that \spad{z = c * y} is integral. The algebraic relation between \spad{x} and \spad{y} is \spad{p(x,{} y) = 0}. The algebraic relation between \spad{x} and \spad{z} is \spad{q(x,{} z) = 0}.');
INSERT INTO olibdb VALUES('o','mkPrim',2,'n','(F,Symbol)->F','pIntegrationTools(R,F)','AND(has(R,GcdDomain),has(F,ElementaryFunctionCategory))','\spad{mkPrim(f,{} x)} makes the logs in \spad{f} which are linear in \spad{x} primitive with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','mod_exp',3,'n','(PA,Integer,PMD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{mod_exp(pv,{} d,{} rd)} computes \spad{pv^d} modulo reduction data in \spad{rd}.');
INSERT INTO olibdb VALUES('o','modifyPoint',3,'n','(%,List(NonNegativeInteger),NonNegativeInteger)->%','dSubSpace(n,R)',NULL,'\spad{modifyPoint(s,{} \spad{li},{} i)} replaces an existing point in the 3 dimensional subspace,{} \spad{s},{} with the 4 dimensional point indicated by the index location,{} \spad{i}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \spad{s} is empty,{} otherwise the subspace \spad{s} is returned with the point modification.');
INSERT INTO olibdb VALUES('o','modifyPoint',3,'n','(%,List(NonNegativeInteger),Point(R))->%','dSubSpace(n,R)',NULL,'\spad{modifyPoint(s,{} \spad{li},{} p)} replaces an existing point in the 3 dimensional subspace,{} \spad{s},{} with the 4 dimensional point,{} \spad{p}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \spad{s} is empty,{} otherwise the subspace \spad{s} is returned with the point modification.');
INSERT INTO olibdb VALUES('o','modifyPoint',3,'n','(%,NonNegativeInteger,Point(R))->%','dSubSpace(n,R)',NULL,'\spad{modifyPoint(s,{} ind,{} p)} modifies the point referenced by the index location,{} \spad{ind},{} by replacing it with the point,{} \spad{p} in the 3 dimensional subspace,{} \spad{s}. An error message occurs if \spad{s} is empty,{} otherwise the subspace \spad{s} is returned with the point modification.');
INSERT INTO olibdb VALUES('o','modifyPointData',3,'x','(%,NonNegativeInteger,Point(DoubleFloat))->Void','dThreeDimensionalViewport',NULL,'\spad{modifyPointData(v,{} ind,{} pt)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport},{} and places the data point,{} \spad{pt} into the list of points database of \spad{v} at the index location given by \spad{ind}.');
INSERT INTO olibdb VALUES('o','modifyPointData',3,'x','(%,NonNegativeInteger,Point(R))->%','cThreeSpaceCategory(R)',NULL,'\spad{modifyPointData(s,{} i,{} p)} changes the point at the indexed location \spad{i} in the \spadtype{ThreeSpace},{} \spad{s},{} to that of point \spad{p}. This is useful for making changes to a point which has been transformed.');
INSERT INTO olibdb VALUES('o','modpeval',4,'n','(Polynomial(Integer),List(Symbol),List(Integer),Integer)->Integer','pPolynomialEvaluationUtilities',NULL,'\spad{modpeval(pol,{} lv,{} lpt,{} p)} evaluates polynomial \spad{pol} in variables form \spad{lv} at point from \spad{lpt} modulo a prime \spad{p}');
INSERT INTO olibdb VALUES('o','modpreduction',2,'n','(Fraction(Polynomial(Integer)),Integer)->Union(Record(numer:Polynomial(Integer),denom:Polynomial(Integer)),failed)','pPolynomialEvaluationUtilities',NULL,'\spad{modpreduction(r,{} p)} reduces a rational function \spad{r} modulo prime \spad{p}.');
INSERT INTO olibdb VALUES('o','modpreduction',2,'n','(MP,Integer)->Union(MP,failed)','cModularEvaluationCategory(PT,MP)',NULL,'\spad{modpreduction(p,{} q)} reduces all coefficients of \spad{p} modulo \spad{q}.');
INSERT INTO olibdb VALUES('o','modpreduction',2,'n','(Polynomial(Integer),Integer)->Polynomial(Integer)','pPolynomialEvaluationUtilities',NULL,'\spad{modpreduction(pol,{} p)} reduces polynomial \spad{pol} modulo prime \spad{p}.');
INSERT INTO olibdb VALUES('o','modTree',2,'x','(R,List(R))->List(R)','pCRApackage(R)',NULL,'\spad{modTree(r,{} l)} \undocumented{}');
INSERT INTO olibdb VALUES('o','modular_compose',5,'n','(PA,MMT,PA,NonNegativeInteger,PMD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{modular_compose(pol,{} pm,{} p1,{} l1,{} rd)} computes composion of \spad{pol} with \spad{p0} modulo reduction data \spad{rd}. \spad{pm} and \spad{p1} are as from call to \spad{power_matrix(p0,{} l1,{} rd)}.');
INSERT INTO olibdb VALUES('o','modularFactor',2,'n','(UP,Set(NonNegativeInteger))->Record(prime:Integer,factors:List(UP))','pGaloisGroupFactorizer(UP)',NULL,'\spad{modularFactor(f,{} d)} chooses a good prime and returns the factorization of \spad{f} modulo this prime in a form that may be used by \spadfunFrom{completeHensel}{GeneralHenselPackage}. If prime is zero it means that \spad{f} has been proved to be irreducible over the integers or that \spad{f} is a unit (\spadignore{i.e.} 1 or \spad{-1}). \spad{f} shall be primitive (\spadignore{i.e.} content(\spad{p})\spad{=1}) and square free (\spadignore{i.e.} without repeated factors). \spad{d} is set of possible degrees of factors.');
INSERT INTO olibdb VALUES('o','modularGcdPrimitive',1,'n','(List(BP))->BP','pInnerModularGcd(R,BP,pMod,nextMod)',NULL,'\spad{modularGcdPrimitive(listf)} computes the \spad{gcd} of the list of primitive polynomials \spad{listf} by modular methods.');
INSERT INTO olibdb VALUES('o','modularInvariantJ',1,'x','(Complex(Float))->Complex(Float)','pFloatEllipticFunctions',NULL,'\spad{modularInvariantJ(tau)} computes modular invariant \spad{j},{} that is \spad{1728*g2^3/(g2^3 - 27*g3^2)} where \spad{g2},{} \spad{g3} are invariants corresponding to half periods \spad{w1},{} \spad{w2} such that \spad{tau = w1/w2}.');
INSERT INTO olibdb VALUES('o','module',1,'n','(FractionalIdeal(R,F,UP,A))->%','dFractionalIdealAsModule(R,F,UP,A,ibasis)','has(A,RetractableTo(F))','\spad{module(I)} returns \spad{I} viewed has a module over \spad{R}.');
INSERT INTO olibdb VALUES('o','module',1,'n','(Vector(A))->%','dFractionalIdealAsModule(R,F,UP,A,ibasis)',NULL,'\spad{module([f1,{} ...,{} fn])} = the module generated by \spad{(f1,{} ...,{} fn)} over \spad{R}.');
INSERT INTO olibdb VALUES('o','moduleSum',2,'n','(Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R)),Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R)))->Record(basis:Matrix(R),basisDen:R,basisInv:Matrix(R))','pIntegralBasisTools(R,UP,F)',NULL,'\spad{moduleSum(m1,{} m2)} returns the sum of two modules in the framed algebra \spad{F}. Each module \spad{\spad{mi}} is represented as follows: \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{} w2,{} ...,{} wn} and \spad{\spad{mi}} is a record \spad{[basis,{} basisDen,{} basisInv]}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then a basis \spad{v1,{} ...,{} vn} for \spad{\spad{mi}} is given by \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of ''basis'' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{} ...,{} vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.');
INSERT INTO olibdb VALUES('o','moduloP',1,'x','(%)->Integer','cPAdicIntegerCategory(p)',NULL,'\spad{modulo(x)} returns a,{} where \spad{x = a + b p}.');
INSERT INTO olibdb VALUES('o','modulus',0,'n','()->Rep','dModMonic(R,Rep)',NULL,'\spad{modulus()} returns current modulus.');
INSERT INTO olibdb VALUES('o','modulus',0,'x','()->Integer','cPAdicIntegerCategory(p)',NULL,'\spad{modulus()} returns the value of \spad{p}.');
INSERT INTO olibdb VALUES('o','modulus',1,'n','(%)->Mod','dEuclideanModularRing(S,R,Mod,reduction,merge,exactQuo)',NULL,'\spad{modulus(x)} \undocumented');
INSERT INTO olibdb VALUES('o','modulus',1,'n','(%)->Mod','dModularField(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{modulus(x)} \undocumented');
INSERT INTO olibdb VALUES('o','modulus',1,'n','(%)->Mod','dModularRing(R,Mod,reduction,merge,exactQuo)',NULL,'\spad{modulus(x)} \undocumented');
INSERT INTO olibdb VALUES('o','moebius',1,'n','(A)->IncidenceAlgebra(Integer,S)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','moebius',1,'n','(%)->IncidenceAlgebra(Integer,S)','cPoset(S)',NULL,'\spad{moebius incidence} matrix for this poset This function is based on code by Franz Lehner. Notes by Martin Baker on the webpage here: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/moebius/}');
INSERT INTO olibdb VALUES('o','moebius',4,'n','(F,F,F,F)->%','dMoebiusTransform(F)',NULL,'\spad{moebius(a,{} b,{} c,{} d)} returns \spad{matrix [[a,{} b],{} [c,{} d]]}.');
INSERT INTO olibdb VALUES('o','moebiusBand',0,'n','()->FiniteCubicalComplex(Integer)','pCubicalComplexFactory',NULL,'Generate a cubical complex of the surface of a Moebius band. A one sided surface with a single external boundary line.');
INSERT INTO olibdb VALUES('o','moebiusBand',0,'n','()->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'Generate a minimal triangulation of the surface of a Moebius band. A one sided surface with a single external boundary line.');
INSERT INTO olibdb VALUES('o','moebiusFunction',1,'n','(List(P))->%','dFiniteMoebiusFunction(P)',NULL,'\spad{moebiusFunction(pp)} creates the canonical zeta matrix and inverts it.');
INSERT INTO olibdb VALUES('o','moebiusMatrix',1,'n','(%)->Matrix(Integer)','dFiniteMoebiusFunction(P)',NULL,'\spad{moebiusMatrix(P)} returns the Moebius matrix');
INSERT INTO olibdb VALUES('o','moebiusMatrix',1,'n','(%)->Matrix(R)','dGeneralizedFiniteMoebiusFunction(P,R)',NULL,'\spad{moebiusMatrix()} returns the Moebius matrix');
INSERT INTO olibdb VALUES('o','moebiusMu',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{moebiusMu(n)} returns the Moebius function \spad{mu(n)}. \spad{mu(n)} is either \spad{-1},{} 0 or 1 as follows: \spad{mu(n) = 0} if \spad{n} is divisible by a square > 1,{} \spad{mu(n) = (-1)^k} if \spad{n} is square-free and has \spad{k} distinct prime divisors.');
INSERT INTO olibdb VALUES('o','moebiusMu',3,'n','(%,P,P)->Integer','dFiniteMoebiusFunction(P)',NULL,'\spad{moebiusMu(mf,{} \spad{pi},{} \spad{si})} evaluates the Moebius function');
INSERT INTO olibdb VALUES('o','moment2booleanCumulant',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{moment2booleanCumulant(mm)} computes the sequence of boolean cumulants from the sequence of moments \spad{mm}');
INSERT INTO olibdb VALUES('o','moment2cumulant',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{moment2cumulant(mm)} computes the sequence of classical cumulants from the sequence of moments \spad{mm}');
INSERT INTO olibdb VALUES('o','moment2freeCumulant',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{moment2freeCumulant(mm)} computes the sequence of free cumulants from the sequence of moments \spad{mm}');
INSERT INTO olibdb VALUES('o','moment2jacobi',1,'n','(Sequence(R))->Record(an:Stream(R),bn:Stream(R))','pMomentPackage(R)','has(R,Field)','\spad{moment2jacobi(mm)} computes the Jacobi parameters as pair of streams.');
INSERT INTO olibdb VALUES('o','moment2jacobi2',1,'n','(Sequence(R))->Stream(Record(an:R,bn:R))','pMomentPackage(R)','has(R,Field)','\spad{moment2jacobi2(mm)} computes the Jacobi parameters as stream of pairs \$(an,{} \spad{bn})\$.');
INSERT INTO olibdb VALUES('o','moment2monotoneCumulant',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)','has(R,Algebra(Fraction(Integer)))','\spad{moment2monotoneCumulant(x)} returns the sequence of monotone cumulants of the moment sequence \spad{x}');
INSERT INTO olibdb VALUES('o','moment2monotoneCumulant',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{moment2monotoneCumulant(x)} returns the sequence of monotone cumulants of the moment sequence \spad{x}');
INSERT INTO olibdb VALUES('o','moment',2,'n','(%,NonNegativeInteger)->R','cDistributionCategory(R)',NULL,'\spad{moment(x,{} n)} returns the \spad{n}-th moment of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','moment2nthJacobi',1,'n','(List(R))->Record(an:List(R),bn:List(R))','pMomentPackage(R)','has(R,Field)','\spad{moment2nthJacobi(mm)} computes the list of Jacobi parameters from the list of moments \spad{mm} as far as possible.');
INSERT INTO olibdb VALUES('o','moment2Stransform',1,'n','(Sequence(R))->Record(puiseux:Fraction(Integer),laurent:Fraction(Integer),coef:Sequence(R))','pMomentPackage(R)','has(R,Algebra(Fraction(Integer)))','\spad{moment2Stransform(x)} returns the Puiseux and Laurent order and coefficients of the \spad{S} transform of \spad{x}');
INSERT INTO olibdb VALUES('o','moments',1,'n','(%)->Sequence(R)','cDistributionCategory(R)',NULL,'\spad{moments(x)} returns the sequence of moments of the distribution \spad{x}');
INSERT INTO olibdb VALUES('o','monic?',1,'n','(S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monic?',1,'n','(UP)->Boolean','pGaloisGroupPolynomialUtilities(R,UP)',NULL,'\spad{monic?(p)} tests if \spad{p} is monic (\spadignore{i.e.} leading coefficient equal to 1).');
INSERT INTO olibdb VALUES('o','monic?',1,'x','(%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{monic?(p)} returns \spad{false} if \spad{p} belongs to \spad{R},{} otherwise returns \spad{true} iff \spad{p} is monic as a univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','monicCompleteDecompose',1,'x','(UP)->List(UP)','pUnivariatePolynomialDecompositionPackage(R,UP)',NULL,'\spad{monicCompleteDecompose(f)} returns a list of factors of \spad{f} for the functional decomposition of monic polynomial \spad{f}. [\spad{f1},{} ...,{} \spad{fn}] means \spad{f} = \spad{f1} \spad{o} ... \spad{o} \spad{fn}.');
INSERT INTO olibdb VALUES('o','monicDecomposeIfCan',1,'x','(UP)->Union(Record(left:UP,right:UP),failed)','pUnivariatePolynomialDecompositionPackage(R,UP)',NULL,'\spad{monicDecomposeIfCan(f)} returns a functional decomposition of the monic polynomial \spad{f} or failed if it has not found any.');
INSERT INTO olibdb VALUES('o','monicDivide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cUnivariatePolynomialCategory(R)','has(R,Ring)','\spad{monicDivide(p,{} q)} divide the polynomial \spad{p} by the monic polynomial \spad{q},{} returning the pair \spad{[quotient,{} remainder]}. Error: if \spad{q} isn\spad{''t} monic.');
INSERT INTO olibdb VALUES('o','monicDivide',3,'n','(S,S,VarSet)->Record(quotient:S,remainder:S)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monicDivide',3,'x','(%,%,VarSet)->Record(quotient:%,remainder:%)','cPolynomialCategory(R,E,VarSet)','has(R,Ring)','\spad{monicDivide(a,{} b,{} v)} divides the polynomial a by the polynomial \spad{b},{} with each viewed as a univariate polynomial in \spad{v} returning both the quotient and remainder. Error: if \spad{b} is not monic with respect to \spad{v}.');
INSERT INTO olibdb VALUES('o','monicLeftDivide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cUnivariateSkewPolynomialCategory(R)','has(R,IntegralDomain)','\spad{monicLeftDivide(a,{} b)} returns the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called');
INSERT INTO olibdb VALUES('o','monicLeftDivide',3,'n','(C,C,Automorphism(R))->Record(quotient:C,remainder:C)','pUnivariateSkewPolynomialCategoryOps(R,C)','has(R,IntegralDomain)','\spad{monicLeftDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{} r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called');
INSERT INTO olibdb VALUES('o','monicModulo',2,'n','(%,%)->%','dNewSparseUnivariatePolynomial(R)',NULL,'\spad{monicModulo(a,{} b)} returns \spad{r} such that \spad{r} is reduced \spad{w}.\spad{r}.\spad{t}. \spad{b} and \spad{b} divides \spad{a - r} where \spad{b} is monic.');
INSERT INTO olibdb VALUES('o','monicModulo',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monicModulo',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{monicModulo(a,{} b)} computes \spad{a mod b},{} if \spad{b} is monic as univariate polynomial in its main variable.');
INSERT INTO olibdb VALUES('o','monicRightDivide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cUnivariateSkewPolynomialCategory(R)','has(R,IntegralDomain)','\spad{monicRightDivide(a,{} b)} returns the pair \spad{[q,{} r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called');
INSERT INTO olibdb VALUES('o','monicRightDivide',3,'n','(C,C,Automorphism(R))->Record(quotient:C,remainder:C)','pUnivariateSkewPolynomialCategoryOps(R,C)','has(R,IntegralDomain)','\spad{monicRightDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{} r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called');
INSERT INTO olibdb VALUES('o','monicRightFactorIfCan',2,'x','(UP,NonNegativeInteger)->Union(UP,failed)','pUnivariatePolynomialDecompositionPackage(R,UP)',NULL,'\spad{monicRightFactorIfCan(f,{} d)} returns a candidate to be the monic right factor (\spad{h} in \spad{f} = \spad{g} \spad{o} \spad{h}) of degree \spad{d} of a functional decomposition of the polynomial \spad{f} or \spad{failed} if no such candidate.');
INSERT INTO olibdb VALUES('o','monologextint',3,'n','(List(UP),(Matrix(F))->List(Vector(Fraction(Integer))),(List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer)))))->Record(logands:List(Fraction(UP)),basis:List(Vector(Fraction(Integer))))','pParametricTranscendentalIntegration(F,UP)',NULL,'\spad{monologextint(lup,{} csolve,{} rec)} is a helper for logextint');
INSERT INTO olibdb VALUES('o','monom',2,'n','(A,Integer)->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{monom(deg,{} coef)} is a monomial of degree \spad{deg} with coefficient coef.');
INSERT INTO olibdb VALUES('o','monomial1',1,'n','(MD)->PA','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{monomial1(md)} returns monomial of degree 1 with coefficient 1.');
INSERT INTO olibdb VALUES('o','monomial?',1,'n','(%)->Boolean','cIndexedProductCategory(A,S)',NULL,'\spad{monomial?(x)} returns \spad{true} if \spad{x} is a single monomial,{} that is support of \spad{x} consists of a single element.');
INSERT INTO olibdb VALUES('o','monomial?',1,'n','(%)->Boolean','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{monomial?(f)} tests if \spad{f} is a single monomial.');
INSERT INTO olibdb VALUES('o','monomial?',1,'n','(%)->Boolean','dLaurentPolynomial(R,UP)',NULL,'\spad{monomial?(x)} \undocumented');
INSERT INTO olibdb VALUES('o','monomial?',1,'n','(S)->Boolean','xAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial?',1,'x','(%)->Boolean','cXFreeAlgebra(vl,R)',NULL,'\spad{monomial?(x)} returns \spad{true} if \spad{x} is a monomial');
INSERT INTO olibdb VALUES('o','monomial',2,'n','(A,S)->%','cIndexedProductCategory(A,S)',NULL,'\spad{monomial(a,{} s)} constructs a direct product element with the \spad{s} component set to \spad{a}');
INSERT INTO olibdb VALUES('o','monomial',2,'n','(R,E)->S','xMaybeSkewPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',2,'n','(R,Expon)->%','cSolvableSkewPolynomialCategory(R,Expon)',NULL,'\spad{monomial(r,{} e)} makes a term from a coefficient \spad{r} and an exponent \spad{e}.');
INSERT INTO olibdb VALUES('o','monomial',2,'n','(R,Integer)->%','dLaurentPolynomial(R,UP)',NULL,'\spad{monomial(x,{} n)} \undocumented');
INSERT INTO olibdb VALUES('o','monomial',2,'n','(R,ModuleMonomial(IS,E,ff))->%','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{monomial(r,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','monomial',2,'n','(R,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',2,'x','(K,List(PositiveInteger))->%','dCliffordAlgebra(n,K,bLin)',NULL,'\spad{monomial(c,{} [i1,{} i2,{} ...,{} iN])} produces the value given by \spad{c*e(i1)*e(i2)*...*e(iN)}.');
INSERT INTO olibdb VALUES('o','monomial',2,'x','(R,FreeMonoid(vl))->%','cXFreeAlgebra(vl,R)',NULL,'\spad{monomial(r,{} w)} returns the product of the word \spad{w} by the coefficient \spad{r}.');
INSERT INTO olibdb VALUES('o','monomial',3,'n','(%,List(VarSet),List(NonNegativeInteger))->%','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{monomial(a,{} [v1..vn],{} [e1..en])} returns \spad{a*prod(vi^ei)}.');
INSERT INTO olibdb VALUES('o','monomial',3,'n','(S,List(SingletonAsOrderedSet),List(NonNegativeInteger))->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',3,'n','(S,List(VarSet),List(NonNegativeInteger))->S','xMaybeSkewPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',3,'n','(S,SingletonAsOrderedSet,NonNegativeInteger)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',3,'n','(S,VarSet,NonNegativeInteger)->S','xMaybeSkewPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomial',3,'n','(%,VarSet,NonNegativeInteger)->%','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{monomial(a,{} x,{} n)} creates the monomial \spad{a*x^n} where \spad{a} is a polynomial,{} \spad{x} is a variable and \spad{n} is a nonnegative integer.');
INSERT INTO olibdb VALUES('o','monomial',3,'x','(%,List(Var),List(NonNegativeInteger))->%','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{monomial(a,{} [x1,{} x2,{} ...,{} xk],{} [n1,{} n2,{} ...,{} nk])} returns \spad{a * x1^n1 * ... * xk^nk}.');
INSERT INTO olibdb VALUES('o','monomial',3,'x','(%,Var,NonNegativeInteger)->%','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{monomial(a,{} x,{} n)} returns \spad{a*x^n}.');
INSERT INTO olibdb VALUES('o','monomialIntegrate',2,'n','(Fraction(UP),(UP)->UP)->Record(ir:IntegrationResult(Fraction(UP)),specpart:Fraction(UP),polypart:UP)','pTranscendentalIntegration(F,UP)',NULL,'\spad{monomialIntegrate(f,{} '')} returns \spad{[ir,{} s,{} p]} such that \spad{f = ir'' + s + p} and all the squarefree factors of the denominator of \spad{s} are special \spad{w}.\spad{r}.\spad{t} the derivation ''.');
INSERT INTO olibdb VALUES('o','monomialIntPoly',2,'n','(UP,(UP)->UP)->Record(answer:UP,polypart:UP)','pTranscendentalIntegration(F,UP)',NULL,'\spad{monomialIntPoly(p,{} '')} returns [\spad{q},{} \spad{r}] such that \spad{p = q'' + r} and \spad{degree(r) < degree(t'')}. Error if \spad{degree(t'') < 2}.');
INSERT INTO olibdb VALUES('o','monomials',1,'n','(A)->List(A)','xFreeModuleCategory&(A,R,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomials',1,'n','(%)->List(%)','cMaybeSkewPolynomialCategory(R,E,VarSet)',NULL,'\spad{monomials(p)} returns the list of non-zero monomials of polynomial \spad{p},{} \spadignore{i.e.} \spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),{} ...,{} a_(n) X^(n)]}.');
INSERT INTO olibdb VALUES('o','monomials',1,'n','(S)->List(S)','xMaybeSkewPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','monomials',1,'x','(%)->List(%)','cFreeModuleCategory(R,S)',NULL,'\spad{monomials(x)} returns the list of \spad{r_i*b_i} whose sum is \spad{x}.');
INSERT INTO olibdb VALUES('o','monotoneConvolution',2,'n','(%,%)->%','cDistributionCategory(R)',NULL,'\spad{monotoneConvolution(x,{} y)} returns the monotone convolution of the distributions \spad{x} and \spad{y}');
INSERT INTO olibdb VALUES('o','monotoneCumulant2moment',1,'n','(Sequence(R))->Sequence(R)','pMomentPackage(R)',NULL,'\spad{monotoneCumulant2moment(hh)} computes the sequence of moments from the sequence of monotone cumulants \spad{hh}');
INSERT INTO olibdb VALUES('o','monotoneCumulant2momentPoly',1,'n','(Sequence(R))->Sequence(SparseUnivariatePolynomial(R))','pMomentPackage(R)',NULL,'\spad{monotoneCumulant2momentPoly(hh)} computes the sequence of moment polynomials \$\spad{m_n}(\spad{t})\$ from the sequence of monotone cumulants \spad{hh}');
INSERT INTO olibdb VALUES('o','monotoneCumulants',1,'n','(%)->Sequence(R)','cDistributionCategory(R)','has(R,Algebra(Fraction(Integer)))','\spad{monotoneCumulants(x)} returns the sequence of monotone cumulants of the distribution \spad{x}.');
INSERT INTO olibdb VALUES('o','more?',2,'n','(A,NonNegativeInteger)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','more?',2,'n','(A,NonNegativeInteger)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','more?',2,'n','(S,NonNegativeInteger)->Boolean','xAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','more?',2,'n','(S,NonNegativeInteger)->Boolean','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','more?',2,'n','(S,S)->Boolean','pUserDefinedPartialOrdering(S)','has(S,OrderedSet)','\spad{more?(a,{} b)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder,{} and uses the ordering on \spad{S} if \spad{a} and \spad{b} are not comparable in the partial ordering.');
INSERT INTO olibdb VALUES('o','more?',2,'x','(%,NonNegativeInteger)->Boolean','cAggregate',NULL,'\spad{more?(u,{} n)} tests if \spad{u} has more than \spad{n} elements.');
INSERT INTO olibdb VALUES('o','moreAlgebraic?',2,'x','(TS,TS)->Boolean','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{moreAlgebraic?(ts,{} us)} returns \spad{false} iff \spad{ts} and \spad{us} are both empty,{} or \spad{ts} has less elements than \spad{us},{} or some variable is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{us} and is not \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','moreAlgebraic?',2,'x','(TS,TS)->Boolean','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{moreAlgebraic?(ts,{} us)} returns \spad{false} iff \spad{ts} and \spad{us} are both empty,{} or \spad{ts} has less elements than \spad{us},{} or some variable is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{us} and is not \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','morphism',1,'n','((R,Integer)->R)->%','dAutomorphism(R)',NULL,'\spad{morphism(f)} returns the morphism given by \spad{f^n(x) = f(x,{} n)}.');
INSERT INTO olibdb VALUES('o','morphism',1,'n','((R)->R)->%','dAutomorphism(R)',NULL,'\spad{morphism(f)} returns the non-invertible morphism given by \spad{f}.');
INSERT INTO olibdb VALUES('o','morphism',2,'n','((R)->R,(R)->R)->%','dAutomorphism(R)',NULL,'\spad{morphism(f,{} g)} returns the invertible morphism given by \spad{f},{} where \spad{g} is the inverse of \spad{f}..');
INSERT INTO olibdb VALUES('o','motzkinPathArray',3,'n','(Stream(R),Stream(R),Stream(R))->Stream(List(R))','pPathArrayPackage(R)',NULL,'\spad{motzkinPathArray([a0,{} a1,{} ...],{} [b0,{} b1,{} ...],{} [c1,{} c2,{} ...])} computes Flajolet\spad{''s} Motzkin path array from the sequences \spad{ai},{} \spad{bi},{} \spad{ci}.');
INSERT INTO olibdb VALUES('o','move',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Void','dTwoDimensionalViewport',NULL,'\spad{move(v,{} x,{} y)} displays the two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \spad{x},{} \spad{y}.');
INSERT INTO olibdb VALUES('o','move',3,'x','(%,NonNegativeInteger,NonNegativeInteger)->Void','dThreeDimensionalViewport',NULL,'\spad{move(v,{} x,{} y)} displays the three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \spad{x},{} \spad{y}.');
INSERT INTO olibdb VALUES('o','movedPoints',1,'x','(%)->Set(S)','dPermutationGroup(S)',NULL,'\spad{movedPoints(gp)} returns the points moved by the group {\em gp}.');
INSERT INTO olibdb VALUES('o','movedPoints',1,'x','(%)->Set(S)','dPermutation(S)',NULL,'\spad{movedPoints(p)} returns the set of points moved by the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','mpsode',2,'n','(List(Coef),List((List(UTS))->UTS))->List(UTS)','pUnivariateTaylorSeriesODESolver(Coef,UTS)',NULL,'\spad{mpsode(r,{} f)} solves the system of differential equations \spad{dy[i]/dx =f[i] [x,{} y[1],{} y[2],{} ...,{} y[n]]},{} \spad{y[i](a) = r[i]} for \spad{i} in 1..\spad{n}.');
INSERT INTO olibdb VALUES('o','MPtoMPT',4,'n','(MP,Symbol,List(Symbol),MD)->Union(MPT,failed)','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{MPtoMPT(p,{} s,{} ls,{} m)} converts \spad{p} to packed representation.');
INSERT INTO olibdb VALUES('o','mr',1,'n','(List(List(List(S))))->Record(f1:List(S),f2:List(List(List(S))),f3:List(List(S)),f4:List(List(List(S))))','pTableauxBumpers(S)',NULL,'\spad{mr(t)} is an auxiliary function which finds the position of the maximum element of a tableau \spad{t} which is in the lowest row,{} producing a record of results');
INSERT INTO olibdb VALUES('o','mrv_cmp',4,'n','(Kernel(Expression(Integer)),Kernel(Expression(Integer)),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(Record(sign:Integer,coeff:Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_cmp compare} kernels.');
INSERT INTO olibdb VALUES('o','mrv_limit1',2,'n','(Expression(Integer),Symbol)->Union(OrderedCompletion(Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit1(f,{} x)} normalizes and computes limit.');
INSERT INTO olibdb VALUES('o','mrv_limit',2,'n','(Expression(Integer),Equation(OrderedCompletion(Expression(Integer))))->Union(OrderedCompletion(Expression(Integer)),Record(leftHandLimit:Union(OrderedCompletion(Expression(Integer)),failed),rightHandLimit:Union(OrderedCompletion(Expression(Integer)),failed)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit(f,{} x=a)} computes limit(\spad{f}(\spad{x}),{} x=a) for a finite or infinite limit point a.');
INSERT INTO olibdb VALUES('o','mrv_limit',3,'n','(Expression(Integer),Equation(Expression(Integer)),String)->Union(OrderedCompletion(Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit(f,{} x = a,{} str)} computes limit(\spad{f}(\spad{x}),{} x=a) for a strictly finite limit point a. This function computes one-sided limits from the left or right.');
INSERT INTO olibdb VALUES('o','mrv_limit',3,'n','(Expression(Integer),Symbol,OrderedCompletion(Expression(Integer)))->Union(OrderedCompletion(Expression(Integer)),Record(leftHandLimit:Union(OrderedCompletion(Expression(Integer)),failed),rightHandLimit:Union(OrderedCompletion(Expression(Integer)),failed)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit(f,{} x,{} a)} is like mrv_limit(\spad{f},{} \spad{x} = a).');
INSERT INTO olibdb VALUES('o','mrv_limit',3,'n','(Expression(Integer),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(OrderedCompletion(Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit(f,{} x,{} s)} computes limit.');
INSERT INTO olibdb VALUES('o','mrv_limit',4,'n','(Expression(Integer),Symbol,Expression(Integer),String)->Union(OrderedCompletion(Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_limit(f,{} x,{} a,{} str)} is like mrv_limit(\spad{f},{} \spad{x} = a,{} \spad{str}).');
INSERT INTO olibdb VALUES('o','mrv_normalize',3,'n','(Expression(Integer),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Expression(Integer)','pMrvLimitPackage',NULL,'\spad{mrv_normalize(f,{} x,{} s)} transform \spad{f} to the form acceptable by core variant of mrv_limit.');
INSERT INTO olibdb VALUES('o','mrv_rewrite0',4,'n','(Expression(Integer),List(Kernel(Expression(Integer))),List(Expression(Integer)),Expression(Integer))->Expression(Integer)','pMrvLimitPackage',NULL,'\spad{mrv_rewrite0 rewrites} comparable kernels in terms of a single one.');
INSERT INTO olibdb VALUES('o','mrv_rewrite',5,'n','(Expression(Integer),List(Kernel(Expression(Integer))),List(Expression(Integer)),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(Record(degree:OrderedExpression,coeff:Expression(Integer)),failed)','pMrvLimitPackage',NULL,'\spad{mrv_rewrite rewrites} comparable kernels and computes leading term of series expansion.');
INSERT INTO olibdb VALUES('o','mrv_set',3,'n','(Expression(Integer),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(Record(lk:List(Kernel(Expression(Integer))),lc:List(Expression(Integer))),failed)','pMrvLimitPackage',NULL,'\spad{mrv_set compute} \spad{MRV} set.');
INSERT INTO olibdb VALUES('o','mrv_sign',3,'n','(Expression(Integer),Symbol,Record(tan_syms:List(Symbol),atan_syms:List(Symbol),tan_kers:List(Kernel(Expression(Integer))),atan_kers:List(Kernel(Expression(Integer)))))->Union(Integer,failed)','pMrvLimitPackage',NULL,'\spad{mrv_sign(f,{} x,{} s)} computes sign of \spad{f} near \spad{x}.');
INSERT INTO olibdb VALUES('o','Mu',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Mu()} returns symbol for capital greek letter mu.');
INSERT INTO olibdb VALUES('o','mu',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{mu()} returns symbol for small greek letter mu.');
INSERT INTO olibdb VALUES('o','mul',3,'n','(U32Vector,U32Vector,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'Polynomial multiplication.');
INSERT INTO olibdb VALUES('o','mul_by_binomial',3,'n','(U32Vector,Integer,Integer)->Void','pU32VectorPolynomialOperations',NULL,'\spad{mul_by_binomial(v,{} pt,{} p)} treats \spad{v} a polynomial and multiplies in place this polynomial by binomial (\spad{x} + \spad{pt}). Highest coefficient of product is ignored.');
INSERT INTO olibdb VALUES('o','mul_by_binomial',4,'n','(U32Vector,Integer,Integer,Integer)->Void','pU32VectorPolynomialOperations',NULL,'\spad{mul_by_binomial(v,{} deg,{} pt,{} p)} treats \spad{v} as coefficients of polynomial of degree \spad{deg} - 1 and multiplies in place this polynomial by binomial (\spad{x} + \spad{pt}). Highest coefficient of product is ignored.');
INSERT INTO olibdb VALUES('o','mul_by_scalar',3,'n','(PrimitiveArray(K),Integer,K)->Void','dModularFactorizationTools3(K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mul_by_scalar',4,'n','(U32Vector,Integer,Integer,Integer)->Void','pU32VectorPolynomialOperations',NULL,'\spad{mul_by_scalar(v,{} deg,{} c,{} p)} treats \spad{v} as coefficients of polynomial of degree \spad{deg} and multiplies in place this polynomial by scalar \spad{c}');
INSERT INTO olibdb VALUES('o','mulmod',3,'x','(%,%,%)->%','cIntegerNumberSystem',NULL,'\spad{mulmod(a,{} b,{} p)},{} \spad{0<=a,{} b<p>1},{} means \spad{a*b mod p}.');
INSERT INTO olibdb VALUES('o','multiEuclidean',2,'n','(List(S),S)->Union(List(S),failed)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','multiEuclidean',2,'x','(List(%),%)->Union(List(%),failed)','cEuclideanDomain',NULL,'\spad{multiEuclidean([f1,{} ...,{} fn],{} z)} returns a list of coefficients \spad{[a1,{} ...,{} an]} such that \spad{ z / prod \spad{fi} = sum aj/fj}. If no such list of coefficients exists,{} failed is returned.');
INSERT INTO olibdb VALUES('o','multiEuclideanTree',2,'x','(List(R),R)->List(R)','pCRApackage(R)',NULL,'\spad{multiEuclideanTree(l,{} r)} \undocumented{}');
INSERT INTO olibdb VALUES('o','multifunctionGraph',1,'n','(List(Permutation(S)))->%','dMultifunctionGraph(S)',NULL,'construct graph from a list of permutations.');
INSERT INTO olibdb VALUES('o','multifunctionGraph',1,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger,next:List(NonNegativeInteger),map:List(List(NonNegativeInteger)))))->%','dMultifunctionGraph(S)',NULL,'\spad{multifunctionGraph(l)} constructs a graph with given list \spad{l} of objects. More objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','multifunctionGraph',1,'n','(List(S))->%','dMultifunctionGraph(S)',NULL,'\spad{multifunctionGraph(l)} constructs a graph with given list \spad{l} of object names. Use this version of the constructor if you don\spad{''t} intend to create diagrams and therefore don\spad{''t} care about \spad{x},{} \spad{y} coordinates. More objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','multifunctionGraph',2,'n','(List(Record(value:S,posX:NonNegativeInteger,posY:NonNegativeInteger)),List(Record(name:String,arrType:NonNegativeInteger,fromOb:NonNegativeInteger,toOb:NonNegativeInteger,xOffset:Integer,yOffset:Integer,map:List(NonNegativeInteger))))->%','dMultifunctionGraph(S)',NULL,'\spad{multifunctionGraph(lo,{} la)} constructs a graph with given list of objects la and list of arrows la. More objects and arrows can be added later if required.');
INSERT INTO olibdb VALUES('o','multifunctionGraph',2,'n','(List(S),List(List(NonNegativeInteger)))->%','dMultifunctionGraph(S)',NULL,'\spad{multifunctionGraph(lo,{} am)} constructs a graph given list of objects \spad{lo} and adjacency matrix am.');
INSERT INTO olibdb VALUES('o','multiIndex',1,'n','(%)->List(NonNegativeInteger)','cJetBundleCategory',NULL,'\spad{multiIndex(jv)} returns the multi-index of the jet variable \spad{jv}.');
INSERT INTO olibdb VALUES('o','multinomial',2,'x','(I,List(I))->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{multinomial(n,{} [m1,{} m2,{} ...,{} mk])} returns the multinomial coefficient \spad{n!/(m1! m2! ... mk!)}.');
INSERT INTO olibdb VALUES('o','multiple?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{multiple?(p)} tests if \spad{p} is a single matching variable allowing list matching or multiple term matching in a sum or product.');
INSERT INTO olibdb VALUES('o','multiple',1,'x','(F)->F','pFunctionSpaceAssertions(R,F)',NULL,'\spad{multiple(x)} tells the pattern matcher that \spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\spad{x}) tells the pattern matcher that \spad{x} should match a list instead of an element of a list. Error: if \spad{x} is not a symbol.');
INSERT INTO olibdb VALUES('o','multiple',1,'x','(Symbol)->Expression(Integer)','pPatternMatchAssertions',NULL,'\spad{multiple(x)} tells the pattern matcher that \spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\spad{x}) tells the pattern matcher that \spad{x} should match a list instead of an element of a list.');
INSERT INTO olibdb VALUES('o','multiplicative?',2,'n','(%,PositiveInteger)->Boolean','dDirichletRing(Coef)',NULL,'\spad{multiplicative?(a,{} n)} returns \spad{true} if the first \spad{n} coefficients of a are multiplicative');
INSERT INTO olibdb VALUES('o','multiplyALS',2,'n','(%,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{multiplyALS(f,{}g)} computes \spad{f*g} in terms of the admissible linear systems for \spad{f} and \spad{g} (without minimization).');
INSERT INTO olibdb VALUES('o','multiplyCoefficients',2,'n','((Integer)->Coef,%)->%','dInnerSparseUnivariatePowerSeries(Coef)',NULL,'\spad{multiplyCoefficients(fn,{} f)} returns the series \spad{sum(fn(n) * an * x^n,{} n = n0..)},{} where \spad{f} is the series \spad{sum(an * x^n,{} n = n0..)}.');
INSERT INTO olibdb VALUES('o','multiplyCoefficients',2,'x','((Integer)->Coef,%)->%','cUnivariateLaurentSeriesCategory(Coef)',NULL,'\spad{multiplyCoefficients(f,{} sum(n = n0..infinity,{} a[n] * x^n)) = sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Puiseux series are represented by a Laurent series and an exponent.');
INSERT INTO olibdb VALUES('o','multiplyCoefficients',2,'x','((Integer)->Coef,%)->%','cUnivariateTaylorSeriesCategory(Coef)',NULL,'\spad{multiplyCoefficients(f,{} sum(n = 0..infinity,{} a[n] * x^n))} returns \spad{sum(n = 0..infinity,{} f(n) * a[n] * x^n)}. This function is used when Laurent series are represented by a Taylor series and an order.');
INSERT INTO olibdb VALUES('o','multiplyColumn!',3,'n','(%,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{multiplyColumn!(f,{} i,{} alpha)} multiplies column(\spad{i}) by alpha in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','multiplyColumn!',3,'n','(%,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{multiplyColumn!(p,{} j,{} alphat)} multiplies column(\spad{j}) by alpha.');
INSERT INTO olibdb VALUES('o','multiplyExponents',2,'x','(%,Fraction(Integer))->%','cUnivariatePuiseuxSeriesCategory(Coef)',NULL,'\spad{multiplyExponents(f,{} r)} multiplies all exponents of the power series \spad{f} by the positive rational number \spad{r}.');
INSERT INTO olibdb VALUES('o','multiplyExponents',2,'x','(%,NonNegativeInteger)->%','cUnivariatePolynomialCategory(R)',NULL,'\spad{multiplyExponents(p,{} n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \spad{p} by the non negative integer \spad{n}.');
INSERT INTO olibdb VALUES('o','multiplyExponents',2,'x','(%,PositiveInteger)->%','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{multiplyExponents(f,{} n)} multiplies all exponents of the power series \spad{f} by the positive integer \spad{n}.');
INSERT INTO olibdb VALUES('o','multiplyMIN',2,'n','(%,%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{multiplyMIN(f,{}g)} uses multiplyALS(\spad{f},{}\spad{g}) with minimization.');
INSERT INTO olibdb VALUES('o','multiplyRow!',3,'n','(%,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{multiplyRow!(f,{} i,{} alpha)} multiplies row(\spad{i}) by alpha in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','multiplyRow!',3,'n','(%,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{multiplyRow!(p,{} i,{} alpha)} multiplies row(\spad{i}) by alpha.');
INSERT INTO olibdb VALUES('o','multisect',3,'n','(Integer,Integer,%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','multisect',3,'n','(Integer,Integer,%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{multisect(a,{} b,{} f(x))} selects the coefficients of \indented{1}{\spad{x^((a+b)*n+a)},{} and changes this monomial to \spad{x^n}.}');
INSERT INTO olibdb VALUES('o','multisect',3,'n','(Integer,Integer,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{multisect(a,{} b,{} st)} selects the coefficients of \spad{x^((a+b)*n+a)},{} and changes them to \spad{x^n}.');
INSERT INTO olibdb VALUES('o','multiset',0,'x','()->%','dMultiset(S)',NULL,'\spad{multiset()}\$\spad{D} creates an empty multiset of domain \spad{D}.');
INSERT INTO olibdb VALUES('o','multiset',1,'x','(List(S))->%','dMultiset(S)',NULL,'\spad{multiset(ls)} creates a multiset with elements from \spad{ls}.');
INSERT INTO olibdb VALUES('o','multiset',1,'x','(S)->%','dMultiset(S)',NULL,'\spad{multiset(s)} creates a multiset with singleton \spad{s}.');
INSERT INTO olibdb VALUES('o','multi_SPDE',5,'n','(SparseUnivariatePolynomial(F),SparseUnivariatePolynomial(F),List(SparseUnivariatePolynomial(F)),Integer,(SparseUnivariatePolynomial(F))->SparseUnivariatePolynomial(F))->Union(List(Record(ans:SparseUnivariatePolynomial(F),remainder:SparseUnivariatePolynomial(F))),Record(ans:List(SparseUnivariatePolynomial(F)),acoeff:SparseUnivariatePolynomial(F),eegen:SparseUnivariatePolynomial(F),bpar:SparseUnivariatePolynomial(F),lcpar:List(SparseUnivariatePolynomial(F)),dpar:Integer))','pRDEaux(F)',NULL,'\spad{multi_SPDE(a,{} b,{} lc,{} d,{} der)}');
INSERT INTO olibdb VALUES('o','multivariate',2,'n','(Fraction(SparseUnivariatePolynomial(F)),V)->F','pPolynomialCategoryQuotientFunctions(E,V,R,P,F)',NULL,'\spad{multivariate(f,{} v)} applies both the numerator and denominator of \spad{f} to \spad{v}.');
INSERT INTO olibdb VALUES('o','multivariate',2,'x','(Fraction(SparseUnivariatePolynomial(Fraction(Polynomial(R)))),Symbol)->Fraction(Polynomial(R))','pRationalFunction(R)',NULL,'\spad{multivariate(f,{} v)} applies both the numerator and denominator of \spad{f} to \spad{v}.');
INSERT INTO olibdb VALUES('o','multivariate',2,'x','(SparseUnivariatePolynomial(R),VarSet)->%','cPolynomialCategory(R,E,VarSet)',NULL,'\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \spad{sup} to a polynomial in the variable \spad{v}.');
INSERT INTO olibdb VALUES('o','multivariate',2,'x','(SparseUnivariatePolynomial(%),VarSet)->%','cPolynomialCategory(R,E,VarSet)',NULL,'\spad{multivariate(sup,{} v)} converts an anonymous univariable polynomial \spad{sup} to a polynomial in the variable \spad{v}.');
INSERT INTO olibdb VALUES('o','multivariate',3,'n','(SparseUnivariatePolynomial(Fraction(SparseUnivariatePolynomial(F))),Kernel(F),F)->F','pGenusZeroIntegration(R,F,L)',NULL,'\spad{multivariate(u,{} k,{} f)} \undocumented');
INSERT INTO olibdb VALUES('o','multivector',1,'x','(List(K))->%','dCliffordAlgebra(n,K,bLin)',NULL,'to allow entries like: 1+2*e1+3*e2+4*e1e2 = multivector[1,{} 2,{} 3,{} 4]');
INSERT INTO olibdb VALUES('o','multMonom',3,'n','(R,E,%)->%','dGeneralModulePolynomial(vl,R,IS,E,ff,P)',NULL,'\spad{multMonom(r,{} e,{} x)} \undocumented');
INSERT INTO olibdb VALUES('o','musserTrials',0,'n','()->PositiveInteger','pGaloisGroupFactorizer(UP)',NULL,'\spad{musserTrials()} returns the number of primes that are tried in \spadfun{modularFactor}.');
INSERT INTO olibdb VALUES('o','musserTrials',1,'n','(PositiveInteger)->PositiveInteger','pGaloisGroupFactorizer(UP)',NULL,'\spad{musserTrials(n)} sets to \spad{n} the number of primes to be tried in \spadfun{modularFactor} and returns the previous value.');
INSERT INTO olibdb VALUES('o','mutable?',1,'n','(%)->Boolean','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{mutable?(f)} is the underlying ALS of \spad{f} mutable?');
INSERT INTO olibdb VALUES('o','mvar',1,'n','(S)->V','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mvar',1,'n','(S)->V','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','mvar',1,'x','(%)->VarSet','cPolynomialSetCategory(R,E,VarSet,P)',NULL,'\spad{mvar(ps)} returns the main variable of the non constant polynomial with the greatest main variable,{} if any,{} else an error is returned.');
INSERT INTO olibdb VALUES('o','mvar',1,'x','(%)->V','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{mvar(p)} returns an error if \spad{p} belongs to \spad{R},{} otherwise returns its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in \spad{V}.');
INSERT INTO olibdb VALUES('o','myDegree',3,'n','(SparseUnivariatePolynomial(P),List(OV),NonNegativeInteger)->List(NonNegativeInteger)','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{myDegree should} be local');
INSERT INTO olibdb VALUES('o','my_digamma',1,'n','(FE)->FE','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{my_digamma should} be local but conditional');
INSERT INTO olibdb VALUES('o','my_root3',1,'n','(F)->F','pRootUtilities(R,F)',NULL,'\spad{my_root3(a)} should be local but conditional');
INSERT INTO olibdb VALUES('o','my_sqrt',1,'n','(F)->F','pRootUtilities(R,F)',NULL,'\spad{my_sqrt(a)} should be local but conditional');
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahn0',8,'n','(Vector(U32Vector),Vector(U32Vector),Vector(Integer),NonNegativeInteger,Integer,(Integer)->Integer,(U32Vector,Integer,Integer)->Void,(U32Vector,Integer,Integer)->Void)->Void','pNaiveBeckermannLabahnModular',NULL,'main solver routine');
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahn1',7,'n','(Vector(SparseUnivariatePolynomial(Integer)),Vector(Integer),NonNegativeInteger,Integer,(Integer)->Integer,(U32Vector,Integer,Integer)->Void,(U32Vector,Integer,Integer)->Void)->List(Any)','pNaiveBeckermannLabahnModular',NULL,NULL);
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahn1',7,'n','(Vector(U32Vector),Vector(Integer),NonNegativeInteger,Integer,(Integer)->Integer,(U32Vector,Integer,Integer)->Void,(U32Vector,Integer,Integer)->Void)->List(Any)','pNaiveBeckermannLabahnModular',NULL,NULL);
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahn',4,'n','(Vector(SparseUnivariatePolynomial(Integer)),Vector(Integer),NonNegativeInteger,Integer)->List(Any)','pNaiveBeckermannLabahnModular',NULL,'\spad{naiveBeckermannLabahn(f,{} degs,{} sigma,{} p)} solves modulo \$\spad{p}\$ Hermite-Pade interpolation problem of order \$\spad{sigma}\$. \$\spad{degs}\$ specifies degree bounds for solution. The first element of result contains \spad{sigma}-basis. The second gives defects of elements of \spad{sigma}-basis. The third one contains residuals \spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \spad{sigma}-basis which are within bounds,{} but non-zero otherwise.');
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahn',4,'n','(Vector(U32Vector),Vector(Integer),NonNegativeInteger,Integer)->List(Any)','pNaiveBeckermannLabahnModular',NULL,'\spad{naiveBeckermannLabahn(f,{} degs,{} sigma,{} p)} solves modulo \$\spad{p}\$ Hermite-Pade interpolation problem of order \$\spad{sigma}\$. \$\spad{degs}\$ specifies degree bounds for solution. The first element of result contains \spad{sigma}-basis. The second gives defects of elements of \spad{sigma}-basis. The third one contains residuals \spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \spad{sigma}-basis which are within bounds,{} but non-zero otherwise.');
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahnMultipoint',4,'n','(Vector(SparseUnivariatePolynomial(Integer)),Vector(Integer),U32Vector,Integer)->List(Any)','pNaiveBeckermannLabahnModular',NULL,'\spad{naiveBeckermannLabahnMultipoint(f,{} degs,{} sigma,{} p)} solves modulo \$\spad{p}\$ multipoint Hermite-Pade interpolation problem of order \$\spad{sigma}\$. \$\spad{degs}\$ specifies degree bounds for solution. The first element of result contains \spad{sigma}-basis. The second gives defects of elements of \spad{sigma}-basis. The third one contains residuals \spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \spad{sigma}-basis which are within bounds,{} but non-zero otherwise.');
INSERT INTO olibdb VALUES('o','naiveBeckermannLabahnMultipoint',4,'n','(Vector(U32Vector),Vector(Integer),U32Vector,Integer)->List(Any)','pNaiveBeckermannLabahnModular',NULL,'\spad{naiveBeckermannLabahnMultipoint(f,{} degs,{} sigma,{} p)} solves modulo \$\spad{p}\$ multipoint Hermite-Pade interpolation problem of order \$\spad{sigma}\$. \$\spad{degs}\$ specifies degree bounds for solution. The first element of result contains \spad{sigma}-basis. The second gives defects of elements of \spad{sigma}-basis. The third one contains residuals \spad{--} we stop updating solution if this would violate degree bounds,{} so residual is zero for elements of \spad{sigma}-basis which are within bounds,{} but non-zero otherwise.');
INSERT INTO olibdb VALUES('o','name',1,'n','(%)->Symbol','cJetBundleCategory',NULL,'\spad{name(jv)} yields the name of the jet variable \spad{jv}.');
INSERT INTO olibdb VALUES('o','name',1,'n','(%)->Symbol','cKernelCategory(S)',NULL,'\spad{name(op(a1,{} ...,{} an))} returns the name of op.');
INSERT INTO olibdb VALUES('o','name',1,'n','(%)->Symbol','dFunctionCalled(f)',NULL,'\spad{name(x)} returns the symbol');
INSERT INTO olibdb VALUES('o','name',1,'n','(%)->Symbol','dRuleCalled(f)',NULL,'\spad{name(x)} returns the symbol');
INSERT INTO olibdb VALUES('o','name',1,'x','(%)->%','dSymbol',NULL,'\spad{name(s)} returns \spad{s} without its scripts.');
INSERT INTO olibdb VALUES('o','name',1,'x','(%)->Name','cFileCategory(Name,S)',NULL,'\spad{name(f)} returns the external name of the file \spad{f}.');
INSERT INTO olibdb VALUES('o','name',1,'x','(%)->String','cFileNameCategory',NULL,'\spad{name(f)} returns the name part of the file name.');
INSERT INTO olibdb VALUES('o','name',1,'x','(%)->Symbol','dBasicOperator',NULL,'\spad{name(op)} returns the name of \spad{op}.');
INSERT INTO olibdb VALUES('o','namedBranch',2,'n','(List(%),List(String))->%','dSceneNamedPoints(PT)',NULL,'\spad{namedBranch(chin,{} nmin)} constructs a branch in the tree structure');
INSERT INTO olibdb VALUES('o','namedPoints',2,'n','(List(PT),List(String))->%','dSceneNamedPoints(PT)',NULL,'\spad{namedPoints(ptin,{} nmin)} constructs a list of named points.');
INSERT INTO olibdb VALUES('o','namedPoints',2,'n','(List(Scene(PT)),List(String))->%','dSceneNamedPoints(PT)',NULL,'\spad{namedPoints(scin,{} nmin)} constructs a list of named nodes.');
INSERT INTO olibdb VALUES('o','nand',2,'n','(S,S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nand',2,'x','(%,%)->%','cBitAggregate',NULL,'\spad{nand(a,{} b)} returns the logical {\em nand} of bit aggregates \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','nand',2,'x','(%,%)->%','dBoolean',NULL,'\spad{nand(a,{} b)} returns the logical negation of \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','nary?',1,'x','(%)->Boolean','dBasicOperator',NULL,'\spad{nary?(op)} tests if \spad{op} has arbitrary arity.');
INSERT INTO olibdb VALUES('o','nary',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{nary(s,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats each argument according to \spad{hh}. All resulting boxes will be horizontally concatenated with \spad{box s} inbetween. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','nary',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{nary(s,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats each argument according to \spad{hh}. All resulting boxes will be horizontally concatenated with \spad{box s} inbetween. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','naryPlus',4,'n','(String,String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{nary(plus,{} minus,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats each argument according to \spad{hh}. All resulting boxes will be horizontally concatenated with \spad{box minus} or \spad{box plus} inbetween depending on whether the respective argument starts with a unary \spad{minus} or not. Outer parentheses are added if \spad{p < prec}. This is a special handler that treats the case that a sum is represented as a nary expression that contains unary subexpressions that are unary \spad{minus} expressions. This handler transforms something like (+ a (- \spad{b})) into a - \spad{b}.');
INSERT INTO olibdb VALUES('o','naryPlus',4,'n','(String,String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{nary(plus,{} minus,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats each argument according to \spad{hh}. All resulting boxes will be horizontally concatenated with \spad{box minus} or \spad{box plus} inbetween depending on whether the respective argument starts with a unary \spad{minus} or not. Outer parentheses are added if \spad{p < prec}. This is a special handler that treats the case that a sum is represented as a nary expression that contains unary subexpressions that are unary \spad{minus} expressions. This handler transforms something like (+ a (- \spad{b})) into a - \spad{b}.');
INSERT INTO olibdb VALUES('o','ncDetSys',1,'n','(List(JetBundleExpression(JB1)))->List(JetBundleExpression(JetBundleSymAna(JB1,xi,eta)))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{ncDetSys(sys)} computes the determining system for generators of conditional symmetries of \spad{sys}. It makes the same assumptions as \spad{detSys}.');
INSERT INTO olibdb VALUES('o','ncDetSys',2,'n','(List(JetBundleExpression(JB1)),JetVectorField(JB1,JetBundleExpression(JB1)))->List(JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{ncDetSys(sys,{} vf)} computes the determining system for generators of conditional symmetries of \spad{sys} with a given ansatz for the vector fields.');
INSERT INTO olibdb VALUES('o','ncDetSys',3,'n','(List(JetBundleExpression(JB1)),List(JB1),JetVectorField(JB1,JetBundleExpression(JB1)))->List(JetBundleExpression(JB1))','pSymmetryAnalysis(JB1,xi,eta)',NULL,'\spad{ncDetSys(sys,{} sjb,{} vf)} computes the determining system for generators of conditional symmetries of \spad{sys}. The meaning of the further arguments is the same as in \spad{detSys}.');
INSERT INTO olibdb VALUES('o','ncols',1,'n','(%)->NonNegativeInteger','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{ncols(p)} returns the number of columns.');
INSERT INTO olibdb VALUES('o','ncols',1,'n','(%)->NonNegativeInteger','dSparseEchelonMatrix(C,D)',NULL,'\spad{ncols(A)} returns the number of columns of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','ncols',1,'n','(S)->NonNegativeInteger','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ncols',1,'x','(%)->NonNegativeInteger','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{ncols(m)} returns the number of columns in the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','ncols',1,'x','(%)->NonNegativeInteger','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{ncols(m)} returns the number of columns in the array \spad{m}');
INSERT INTO olibdb VALUES('o','negative?',1,'n','(S)->Boolean','xOrderedRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','negative?',1,'x','(%)->Boolean','cIntervalCategory(R)',NULL,'\spad{negative?(u)} returns \spad{true} if every element of \spad{u} is negative,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','negative?',1,'x','(%)->Boolean','cOrderedRing',NULL,'\spad{negative?(x)} tests whether \spad{x} is strictly less than 0.');
INSERT INTO olibdb VALUES('o','negative?',2,'n','(ThePols,S)->Boolean','xRealRootCharacterizationCategory&(S,TheField,ThePols)',NULL,NULL);
INSERT INTO olibdb VALUES('o','negative?',2,'x','(ThePols,%)->Boolean','cRealRootCharacterizationCategory(TheField,ThePols)',NULL,'\spad{negative?(pol,{} aRoot)} answers if \spad{pol} interpreted as \spad{aRoot} is negative');
INSERT INTO olibdb VALUES('o','nelem',1,'n','(%)->NonNegativeInteger','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{nelem(p)} returns the number of elements.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dFormatter(F)',NULL,'\spad{new()} create a new,{} empty object with defaultPrologue(\spad{"}) and defaultEpilogue(\spad{"}). Use \spadfun{setPrologue!},{} \spadfun{setFormat!} and \spadfun{setEpilogue!} to set the various components of this object.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dHashState',NULL,'\spad{new()} return a new HashState.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dOperatorHandlers(HANDLER)',NULL,'\spad{new()} creates an empty structure of handlers.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dPatternMatchListResult(R,S,L)',NULL,'\spad{new()} returns a new empty match result.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dPatternMatchResult(R,S)',NULL,'\spad{new()} returns a new empty match result.');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dSubSpaceComponentProperty',NULL,'\spad{new()} \undocumented');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dSubSpace(n,R)',NULL,'\spad{new()} \undocumented');
INSERT INTO olibdb VALUES('o','new',0,'n','()->%','dTexFormat',NULL,'\spad{new()} create a new,{} empty object. Use \spadfun{setPrologue!},{} \spadfun{setTex!} and \spadfun{setEpilogue!} to set the various components of this object.');
INSERT INTO olibdb VALUES('o','new',0,'x','()->%','dSymbol',NULL,'\spad{new()} returns a new symbol whose name starts with \%.');
INSERT INTO olibdb VALUES('o','new',1,'n','(F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{new(c)} creates a constant element.');
INSERT INTO olibdb VALUES('o','new',1,'x','(%)->%','dSymbol',NULL,'\spad{new(s)} returns a new symbol whose name starts with \%\spad{s}.');
INSERT INTO olibdb VALUES('o','new',2,'n','(FreeMonoid(VAR),F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{new(m,{}c)} creates a monomial element with coefficient \spad{c}.');
INSERT INTO olibdb VALUES('o','new',2,'n','(LinearMultivariateMatrixPencil(F),List(FreeMonoid(VAR)))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{new(lp,{} lst)} creates an element by the linear multivariate matrix pencil \spad{lp} and the list of monomials \spad{lst}.');
INSERT INTO olibdb VALUES('o','new',2,'n','(List(C),Integer)->%','dSparseEchelonMatrix(C,D)',NULL,'\spad{new(inds,{} nrows)} generates a new matrix with \spad{nrows} rows and columns enumerated by the indices \spad{inds}. The matrix is empty,{} \spadignore{i.e.} the zero matrix.');
INSERT INTO olibdb VALUES('o','new',2,'n','(NonNegativeInteger,S)->A','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','new',2,'x','(NonNegativeInteger,S)->%','cLinearAggregate(S)',NULL,'\spad{new(n,{} x)} returns a new aggregate of size \spad{n} all of whose entries are \spad{x}.');
INSERT INTO olibdb VALUES('o','new',3,'x','(NonNegativeInteger,NonNegativeInteger,R)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{new(m,{} n,{} r)} is an \spad{m}-by-\spad{n} array all of whose entries are \spad{r}');
INSERT INTO olibdb VALUES('o','new',3,'x','(String,String,String)->%','cFileNameCategory',NULL,'\spad{new(d,{} pref,{} e)} constructs the name of a new writable file with \spad{d} as its directory,{} \spad{pref} as a prefix of its name and \spad{e} as its extension. When \spad{d} or \spad{t} is the empty string,{} a default is used. An error occurs if a new file cannot be written in the given directory.');
INSERT INTO olibdb VALUES('o','newFortranTempVar',0,'n','()->Symbol','pFortranCodeTools',NULL,'\spad{newFortranTempVar()} creates new name for temporary variable and puts it in TheSymbolTable');
INSERT INTO olibdb VALUES('o','newGreek',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{newGreek()} returns the next greek symbol.');
INSERT INTO olibdb VALUES('o','newline',0,'x','()->%','dCharacter',NULL,'\spad{newline()} provides the newline character.');
INSERT INTO olibdb VALUES('o','newLine',0,'x','()->String','pDisplayPackage',NULL,'\spad{newLine()} sends a new line command to output.');
INSERT INTO olibdb VALUES('o','newReduc',1,'n','(Integer)->Void','pFunctionSpaceReduce(R,F)',NULL,'\spad{newReduc(n)} empties reduction state. \spad{n} is size of random integers to use during next reduction.');
INSERT INTO olibdb VALUES('o','newSubProgram',1,'n','(Symbol)->Void','dTheSymbolTable',NULL,'\spad{newSubProgram(f)} asserts that from now on type declarations are part of subprogram \spad{f}.');
INSERT INTO olibdb VALUES('o','newton',1,'n','(List(F))->SparseUnivariatePolynomial(F)','pNewtonInterpolation(F)',NULL,'\spad{newton}(\spad{l}) returns the interpolating polynomial for the values \spad{l},{} where the \spad{x}-coordinates are assumed to be [1,{} 2,{} 3,{} ...,{} \spad{n}] and the coefficients of the interpolating polynomial are known to be in the domain \spad{F}. \spad{I}.\spad{e}.,{} it is a very streamlined version for a special case of interpolation.');
INSERT INTO olibdb VALUES('o','newTypeLists',1,'n','(%)->SExpression','dSymbolTable',NULL,'\spad{newTypeLists(x)} \undocumented');
INSERT INTO olibdb VALUES('o','next',1,'x','(%)->%','cDoublyLinkedAggregate(S)',NULL,'\spad{next(l)} returns the doubly-linked aggregate beginning with its next element. Error: if \spad{l} has no next element. Note: \spad{next(l) = rest(l)} and \spad{previous(next(l)) = l}.');
INSERT INTO olibdb VALUES('o','nextColeman',3,'x','(List(Integer),List(Integer),Matrix(Integer))->Matrix(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{nextColeman(alpha,{} beta,{} C)} generates the next Coleman matrix of column sums {\em alpha} and row sums {\em beta} according to the lexicographical order from bottom-to-top. The first Coleman matrix is achieved by {\em C=new(1,{} 1,{} 0)}. Also,{} {\em new(1,{} 1,{} 0)} indicates that \spad{C} is the last Coleman matrix.');
INSERT INTO olibdb VALUES('o','nextIrreduciblePoly',1,'n','(SparseUnivariatePolynomial(GF))->Union(SparseUnivariatePolynomial(GF),failed)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nextIrreduciblePoly(f)} yields the next monic irreducible polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or failed if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. \spad{lexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','nextItem',1,'n','(A)->Union(A,failed)','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nextItem',1,'n','(S)->Union(S,failed)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nextItem',1,'n','(S)->Union(S,failed)','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nextItem',1,'n','(S)->Union(S,failed)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nextItem',1,'x','(%)->Union(%,failed)','cStepThrough',NULL,'\spad{nextItem(x)} returns the next item,{} or failed if domain is exhausted.');
INSERT INTO olibdb VALUES('o','nextLatticePermutation',3,'x','(List(Integer),List(Integer),Boolean)->List(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{nextLatticePermutation(lambda,{} lattP,{} constructNotFirst)} generates the lattice permutation according to the proper partition {\em lambda} succeeding the lattice permutation {\em lattP} in lexicographical order as long as {\em constructNotFirst} is \spad{true}. If {\em constructNotFirst} is \spad{false},{} the first lattice permutation is returned. The result {\em []} indicates that {\em lattP} has no successor.');
INSERT INTO olibdb VALUES('o','nextNormalPoly',1,'n','(SparseUnivariatePolynomial(GF))->Union(SparseUnivariatePolynomial(GF),failed)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nextNormalPoly(f)} yields the next normal polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or failed if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. \spad{nlexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','nextNormalPrimitivePoly',1,'n','(SparseUnivariatePolynomial(GF))->Union(SparseUnivariatePolynomial(GF),failed)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nextNormalPrimitivePoly(f)} yields the next normal primitive polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or failed if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. \spad{cnlexSmaller?} is used as ordering predicate. This operation is equivalent to nextPrimitiveNormalPoly(\spad{f}).');
INSERT INTO olibdb VALUES('o','nextPartition',3,'x','(List(Integer),Vector(Integer),Integer)->Vector(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{nextPartition(gamma,{} part,{} number)} generates the partition of {\em number} which follows {\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\em gamma}. the first partition is achieved by {\em part=[]}. Also,{} {\em []} indicates that {\em part} is the last partition.');
INSERT INTO olibdb VALUES('o','nextPartition',3,'x','(Vector(Integer),Vector(Integer),Integer)->Vector(Integer)','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{nextPartition(gamma,{} part,{} number)} generates the partition of {\em number} which follows {\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\em gamma}. The first partition is achieved by {\em part=[]}. Also,{} {\em []} indicates that {\em part} is the last partition.');
INSERT INTO olibdb VALUES('o','nextPrime',1,'x','(I)->I','pIntegerPrimesPackage(I)',NULL,'\spad{nextPrime(n)} returns the smallest prime strictly larger than \spad{n}');
INSERT INTO olibdb VALUES('o','nextPrimitiveNormalPoly',1,'n','(SparseUnivariatePolynomial(GF))->Union(SparseUnivariatePolynomial(GF),failed)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nextPrimitiveNormalPoly(f)} yields the next primitive normal polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or failed if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. \spad{cnlexSmaller?} is used as ordering predicate. This operation is equivalent to nextNormalPrimitivePoly(\spad{f}).');
INSERT INTO olibdb VALUES('o','nextPrimitivePoly',1,'n','(SparseUnivariatePolynomial(GF))->Union(SparseUnivariatePolynomial(GF),failed)','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nextPrimitivePoly(f)} yields the next primitive polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or failed if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. \spad{clexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','next_sousResultant2',4,'n','(polR,polR,polR,R)->polR','pPseudoRemainderSequence(R,polR)',NULL,'\spad{next_sousResultant2(P,{} Q,{} Z,{} s)} returns the subresultant \spad{S_{e-1}} where \spad{P ~ S_d,{} Q = S_{d-1},{} Z = S_e,{} s = lc(S_d)}');
INSERT INTO olibdb VALUES('o','nextSublist',2,'n','(Integer,Integer)->List(List(Integer))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{nextSublist(n,{} k)} returns a list of \spad{k}-subsets of {1,{} ...,{} \spad{n}}.');
INSERT INTO olibdb VALUES('o','next_subResultant2',4,'x','(%,%,%,%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{next_subResultant2(p,{} q,{} z,{} s)} is the multivariate version of the operation \spadopFrom{\spad{next_sousResultant2}}{PseudoRemainderSequence} from the \spadtype{PseudoRemainderSequence} constructor.');
INSERT INTO olibdb VALUES('o','nextSubsetGray',2,'n','(Vector(Vector(Integer)),PositiveInteger)->Vector(Vector(Integer))','pGrayCode',NULL,'\spad{nextSubsetGray(ww,{} n)} returns a vector {\em vv} whose components have the following meanings: \begin{items} \item {\em vv.1}: a vector of length \spad{n} whose entries are 0 or 1. This \indented{3}{can be interpreted as a code for a subset of the set 1,{} ...,{} \spad{n};} \indented{3}{{\em vv.1} differs from {\em ww.1} by exactly one entry;} \item {\em vv.2.1} is the number of the entry of {\em vv.1} which \indented{3}{will be changed next time;} \item {\em vv.2.1 = n+1} means that {\em vv.1} is the last subset; \indented{3}{trying to compute nextSubsetGray(\spad{vv}) if {\em vv.2.1 = n+1}} \indented{3}{will produce an error!} \end{items} The other components of {\em vv.2} are needed to compute nextSubsetGray efficiently. Note: this is an implementation of [Williamson,{} Topic II,{} 3.54,{} \spad{p}. 112] for the special case {\em r1 = r2 = ... = rn = 2}; Note: nextSubsetGray produces a side-effect,{} \spadignore{i.e.} {\em nextSubsetGray(vv)} and {\em vv := nextSubsetGray(vv)} will have the same effect.');
INSERT INTO olibdb VALUES('o','nilFactor',2,'x','(R,NonNegativeInteger)->%','dFactored(R)',NULL,'\spad{nilFactor(base,{} exponent)} creates a factored object with a single factor with no information about the kind of \spad{base} (flag = nil).');
INSERT INTO olibdb VALUES('o','nlde',1,'n','(Stream(Stream(A)))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Algebra(Fraction(Integer)))','\spad{nlde(u)} solves a first order non-linear differential equation described by \spad{u} of the form \spad{[[b<0,{} 0>,{} b<0,{} 1>,{} ...],{} [b<1,{} 0>,{} b<1,{} 1>,{} .],{} ...]}. the differential equation has the form \spad{y'' = sum(i=0 to infinity,{} j=0 to infinity,{} b<i,{} j>*(x^i)*(y^j))}.');
INSERT INTO olibdb VALUES('o','nlexSmaller?',2,'n','(SparseUnivariatePolynomial(GF),SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{nlexSmaller?(f,{} g)} compares monic \spad{f} and \spad{g} of the same degree \spad{n} in the following order. Error: if \spad{f} or \spad{g} is not monic or if \spad{f} and \spad{g} have different degrees or if common degree is 0. \spad{f < g} if the coefficient of the term of degree {\em n-1} of \spad{f} is zero and than that for \spad{g} is nonzero. Also,{} \spad{f < g} if both coefficients are nonzero and {\em lookup} of the coefficient of \spad{f} is less than that for \spad{g}. In case those coefficients are equal,{} then \spad{lexSmaller?} is used as ordering predicate.');
INSERT INTO olibdb VALUES('o','node?',2,'n','(A,A)->Boolean','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','node?',2,'n','(A,A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','node?',2,'n','(A,A)->Boolean','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','node?',2,'x','(%,%)->Boolean','cRecursiveAggregate(S)','has(S,BasicType)','\spad{node?(u,{} v)} tests if node \spad{u} is contained in node \spad{v} (either as a child,{} a child of a child,{} etc.).');
INSERT INTO olibdb VALUES('o','node',3,'x','(%,S,%)->%','cBinaryTreeCategory(S)',NULL,'\spad{node(l,{} v,{} r)} creates a binary tree with value \spad{v},{} left subtree \spad{l},{} and right subtree \spad{r}.');
INSERT INTO olibdb VALUES('o','nodeFromArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeFromArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeFromArrow',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{nodeFromArrow(s,{} a)} returns index of all nodes with a direct arrow leading in to arrow ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','nodeFromNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeFromNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeFromNode',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{nodeFromNode(s,{} a)} gives list of all nodes with a direct arrow leading in to node ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','nodeOf?',2,'n','(SplittingNode(V,C),%)->Boolean','dSplittingTree(V,C)',NULL,'\spad{nodeOf?(s,{} a)} returns \spad{true} iff some node of \spad{a} is equal to \spad{s}');
INSERT INTO olibdb VALUES('o','nodes',1,'n','(A)->List(A)','xBinaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodes',1,'n','(A)->List(A)','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodes',1,'n','(A)->List(A)','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodes',1,'n','(A)->List(A)','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodes',1,'x','(%)->List(%)','cRecursiveAggregate(S)',NULL,'\spad{nodes(u)} returns a list of all of the nodes of aggregate \spad{u}.');
INSERT INTO olibdb VALUES('o','nodeToArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeToArrow',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeToArrow',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{nodeToArrow(s,{} a)} returns index of all nodes with a direct arrow leading out of arrow ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','nodeToNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeToNode',2,'n','(A,NonNegativeInteger)->List(NonNegativeInteger)','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nodeToNode',2,'n','(%,NonNegativeInteger)->List(NonNegativeInteger)','cFiniteGraph(S)',NULL,'\spad{nodeToNode(s,{} a)} gives list of all nodes with a direct arrow leading out of node ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','noKaratsuba',2,'x','(U,U)->U','pUnivariatePolynomialMultiplicationPackage(R,U)',NULL,'\spad{noKaratsuba(a,{} b)} returns \spad{a*b} without using Karatsuba\spad{''s} trick at all.');
INSERT INTO olibdb VALUES('o','noLinearFactor?',1,'n','(UP)->Boolean','pBrillhartTests(UP)',NULL,'\spad{noLinearFactor?(p)} returns \spad{true} if \spad{p} can be shown to have no linear factor by a theorem of Lehmer,{} \spad{false} else. \spad{I} insist on the fact that \spad{false} does not mean that \spad{p} has a linear factor.');
INSERT INTO olibdb VALUES('o','noncommutativeJordanAlgebra?',0,'n','()->Boolean','xFiniteRankNonAssociativeAlgebra&(S,R)',NULL,'\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.');
INSERT INTO olibdb VALUES('o','noncommutativeJordanAlgebra?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.');
INSERT INTO olibdb VALUES('o','nonQsign',1,'n','(R)->Union(Integer,failed)','pToolsForSign(R)',NULL,'\spad{nonQsign(r)} \undocumented');
INSERT INTO olibdb VALUES('o','nonSingularModel',1,'n','(Symbol)->List(Polynomial(F))','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{nonSingularModel(u)} returns the equations in \spad{u1},{} ...,{} un of an affine non-singular model for the curve.');
INSERT INTO olibdb VALUES('o','nonSingularModel',1,'x','(Symbol)->List(Polynomial(F))','cFunctionFieldCategory(F,UP,UPUP)','has(F,Field)','\spad{nonSingularModel(u)} returns the equations in \spad{u1},{} ...,{} un of an affine non-singular model for the curve.');
INSERT INTO olibdb VALUES('o','nor',2,'n','(S,S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nor',2,'x','(%,%)->%','cBitAggregate',NULL,'\spad{nor(a,{} b)} returns the logical {\em nor} of bit aggregates \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','nor',2,'x','(%,%)->%','dBoolean',NULL,'\spad{nor(a,{} b)} returns the logical negation of \spad{a} or \spad{b}.');
INSERT INTO olibdb VALUES('o','norm',1,'n','(%)->F','dFractionalIdealAsModule(R,F,UP,A,ibasis)',NULL,'\spad{norm(f)} returns the norm of the module \spad{f}.');
INSERT INTO olibdb VALUES('o','norm',1,'n','(%)->F','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{norm(I)} returns the norm of the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->F','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->R','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->R','xMonogenicAlgebra&(S,R,UP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->R','xOctonionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->R','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(S)->S','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',1,'n','(UP)->R','pComplexRootFindingPackage(R,UP)',NULL,'\spad{norm(p)} determines sum of absolute values of coefficients Note: this function depends on \spadfunFrom{abs}{Complex}.');
INSERT INTO olibdb VALUES('o','norm',1,'x','(%)->%','cRealNumberSystem',NULL,'\spad{norm x} returns the same as absolute value.');
INSERT INTO olibdb VALUES('o','norm',1,'x','(PolE)->PolR','pNormInMonogenicAlgebra(R,PolR,E,PolE)',NULL,'\spad{norm q} returns the norm of \spad{q},{} \spadignore{i.e.} the product of all the conjugates of \spad{q}.');
INSERT INTO olibdb VALUES('o','norm',1,'x','(%)->R','cComplexCategory(R)',NULL,'\spad{norm(x)} returns \spad{x} * conjugate(\spad{x})');
INSERT INTO olibdb VALUES('o','norm',1,'x','(%)->R','cFiniteRankAlgebra(R,UP)',NULL,'\spad{norm(a)} returns the determinant of the regular representation of \spad{a} with respect to any basis.');
INSERT INTO olibdb VALUES('o','norm',1,'x','(%)->R','cOctonionCategory(R)',NULL,'\spad{norm(o)} returns the norm of an octonion,{} equal to the sum of the squares of its coefficients.');
INSERT INTO olibdb VALUES('o','norm',1,'x','(%)->R','cQuaternionCategory(R)',NULL,'\spad{norm(q)} computes the norm of \spad{q} (the sum of the squares of the components).');
INSERT INTO olibdb VALUES('o','norm',2,'n','(S,PositiveInteger)->S','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','norm',2,'n','(UP,PositiveInteger)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{norm(f,{} p)} returns the \spad{lp} norm of the polynomial \spad{f}.');
INSERT INTO olibdb VALUES('o','norm',2,'n','(Vector(GF),PositiveInteger)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{norm(x,{} n)} \undocumented{} See \spadfunFrom{norm}{FiniteAlgebraicExtensionField}');
INSERT INTO olibdb VALUES('o','norm',2,'x','(%,Kernel(%))->%','dAlgebraicNumber',NULL,'\spad{norm(f,{} k)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernel \spad{k}');
INSERT INTO olibdb VALUES('o','norm',2,'x','(%,List(Kernel(%)))->%','dAlgebraicNumber',NULL,'\spad{norm(f,{} l)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernels \spad{l}');
INSERT INTO olibdb VALUES('o','norm',2,'x','(%,PositiveInteger)->%','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{norm(a,{} d)} computes the norm of \spad{a} with respect to the intermediate field of extension degree \spad{d} over the ground field \spad{F}. Error: if \spad{d} does not divide the extension degree \spad{n} of \spad{\%}. Note: norm(a,{} \spad{d}) = reduce(*,{} [a^(\spad{q^}(d*i)) for \spad{i} in 0..\spad{n/d}]) where \spad{q} is size of \spad{F}.');
INSERT INTO olibdb VALUES('o','norm',2,'x','(SparseUnivariatePolynomial(%),Kernel(%))->SparseUnivariatePolynomial(%)','dAlgebraicNumber',NULL,'\spad{norm(p,{} k)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernel \spad{k}');
INSERT INTO olibdb VALUES('o','norm',2,'x','(SparseUnivariatePolynomial(%),List(Kernel(%)))->SparseUnivariatePolynomial(%)','dAlgebraicNumber',NULL,'\spad{norm(p,{} l)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernels \spad{l}');
INSERT INTO olibdb VALUES('o','normal01',0,'n','()->Float','pRandomFloatDistributions',NULL,'\spad{normal01()} \undocumented');
INSERT INTO olibdb VALUES('o','normal?',1,'n','(S)->Boolean','xFiniteAlgebraicExtensionField&(S,F)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normal?',1,'n','(SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{normal?(f)} tests whether the polynomial \spad{f} over a finite field is normal,{} \spadignore{i.e.} its roots are linearly independent over the field.');
INSERT INTO olibdb VALUES('o','normal?',1,'n','(Vector(GF))->Boolean','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{normal?(x)} \undocumented{} See \spadfunFrom{normal?}{FiniteAlgebraicExtensionField}');
INSERT INTO olibdb VALUES('o','normal?',1,'x','(%)->Boolean','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{normal?(a)} tests whether the element \spad{a} is normal over the ground field \spad{F},{} \spadignore{i.e.} \spad{a^(q^i),{} 0 <= i <= extensionDegree()-1} is an \spad{F}-basis,{} where \spad{q = size()\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39.');
INSERT INTO olibdb VALUES('o','normal',2,'n','(Float,Float)->()->Float','pRandomFloatDistributions',NULL,'\spad{normal(f,{} g)} \undocumented');
INSERT INTO olibdb VALUES('o','normalALS',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{normalALS(f)} removes a scalar first row of an (extended) ALS.');
INSERT INTO olibdb VALUES('o','normalDenom',2,'n','(Fraction(UP),(UP)->UP)->UP','pMonomialExtensionTools(F,UP)',NULL,'\spad{normalDenom(f,{} D)} returns the product of all the normal factors of \spad{denom(f)}. \spad{D} is the derivation to use.');
INSERT INTO olibdb VALUES('o','normalDeriv',2,'n','(SparseUnivariatePolynomial(P),Integer)->SparseUnivariatePolynomial(P)','pFactoringUtilities(E,OV,R,P)',NULL,'\spad{normalDeriv(poly,{} i)} computes the \spad{i}th derivative of \spad{poly} divided by i!.');
INSERT INTO olibdb VALUES('o','normalElement',0,'x','()->%','cFiniteAlgebraicExtensionField(F)','has(F,Finite)','\spad{normalElement()} returns a element,{} normal over the ground field \spad{F},{} \spadignore{i.e.} \spad{a^(q^i),{} 0 <= i < extensionDegree()} is an \spad{F}-basis,{} where \spad{q = size()\$F}. At the first call,{} the element is computed by \spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls,{} the element is retrieved by referencing the global variable.');
INSERT INTO olibdb VALUES('o','normalElement',1,'n','(PositiveInteger)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{normalElement(n)} \undocumented{} See \spadfunFrom{normalElement}{FiniteAlgebraicExtensionField}');
INSERT INTO olibdb VALUES('o','normalForm',2,'x','(Dpol,List(Dpol))->Dpol','pGroebnerPackage(Dom,Expon,Dpol)','has(Dom,Field)','\spad{normalForm(poly,{} gb)} reduces the polynomial \spad{poly} modulo the precomputed groebner basis \spad{gb} giving a canonical representative of the residue class.');
INSERT INTO olibdb VALUES('o','normalForm',3,'n','(Matrix(K),Automorphism(K),(K)->K)->Record(R:Matrix(K),A:Matrix(K),Ainv:Matrix(K))','pPseudoLinearNormalForm(K)',NULL,'\spad{normalForm(M,{} sig,{} der)} returns \spad{[R,{} A,{} A^{-1}]} such that the pseudo-linear operator whose matrix in the basis \spad{y} is \spad{M} had matrix \spad{R} in the basis \spad{z = A y}. \spad{der} is a \spad{sig}-derivation.');
INSERT INTO olibdb VALUES('o','normalise',1,'x','(Matrix(Expression(Integer)))->Matrix(Expression(Integer))','pRadicalEigenPackage',NULL,'\spad{normalise(v)} returns the column vector \spad{v} divided by its euclidean norm; when possible,{} the vector \spad{v} is expressed in terms of radicals.');
INSERT INTO olibdb VALUES('o','normalisePoint',1,'n','(%)->%','dSConformal(n)',NULL,'normalised point has scalar value of one,{} if this is not the case then scale values');
INSERT INTO olibdb VALUES('o','normalize!',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{normalize!(f)} rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one. The right hand side is normalized by normalizeRHS! and the non-zero entry is in the last row of the corresponding block.');
INSERT INTO olibdb VALUES('o','normalize',1,'x','(%)->%','dFloat',NULL,'\spad{normalize(x)} normalizes \spad{x} at current precision.');
INSERT INTO olibdb VALUES('o','normalize',1,'x','(F)->F','pElementaryFunctionStructurePackage(R,F)',NULL,'\spad{normalize(f)} rewrites \spad{f} using the least possible number of real algebraically independent kernels.');
INSERT INTO olibdb VALUES('o','normalize',1,'x','(List(F))->List(F)','pElementaryFunctionStructurePackage(R,F)',NULL,'\spad{normalize(lf)} is normalize(\spad{lf},{} [])');
INSERT INTO olibdb VALUES('o','normalize',2,'x','(F,Symbol)->F','pElementaryFunctionStructurePackage(R,F)',NULL,'\spad{normalize(f,{} x)} is normalize([\spad{f}],{} [\spad{x}])');
INSERT INTO olibdb VALUES('o','normalize',2,'x','(List(F),List(Symbol))->List(F)','pElementaryFunctionStructurePackage(R,F)',NULL,'\spad{normalize([f1,{} ...,{} fn],{} lx)} rewrites \spad{f1,{} ...,{} fn} using the least possible number of real algebraically independent kernels. Additionally,{} it tries to ensure that any expression in resulting kernels which syntactically depends on a variable \spad{x} from \spad{lx} has nonzero derivative with respect to \spad{x}.');
INSERT INTO olibdb VALUES('o','normalize',2,'x','(P,TS)->List(Record(val:P,tower:TS))','pNormalizationPackage(R,E,V,P,TS)',NULL,'\spad{normalize(p,{} ts)} normalizes \spad{p} \spad{w}.\spad{r}.\spad{t} \spad{ts}.');
INSERT INTO olibdb VALUES('o','normalizeAtInfinity',1,'n','(Vector(S))->Vector(S)','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normalizeAtInfinity',1,'x','(Vector(%))->Vector(%)','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{normalizeAtInfinity(v)} makes \spad{v} normal at infinity.');
INSERT INTO olibdb VALUES('o','normalized?',1,'n','(S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normalized?',1,'x','(%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{normalized?(ts)} returns \spad{true} iff for every \spad{p} in \spad{ts} we have \spad{normalized?(p,{} us)} where \spad{us} is \spad{collectUnder(ts,{} mvar(p))}.');
INSERT INTO olibdb VALUES('o','normalized?',2,'n','(P,S)->Boolean','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normalized?',2,'n','(S,List(S))->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normalized?',2,'n','(S,S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','normalized?',2,'x','(%,%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{normalized?(a,{} b)} returns \spad{true} iff \spad{a} and its iterated initials have degree zero \spad{w}.\spad{r}.\spad{t}. the main variable of \spad{b}');
INSERT INTO olibdb VALUES('o','normalized?',2,'x','(%,List(%))->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{normalized?(q,{} lp)} returns \spad{true} iff \spad{normalized?(q,{} p)} holds for every \spad{p} in \spad{lp}.');
INSERT INTO olibdb VALUES('o','normalized?',2,'x','(P,%)->Boolean','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{normalized?(p,{} ts)} returns \spad{true} iff \spad{p} and all its iterated initials have degree zero \spad{w}.\spad{r}.\spad{t}. the main variables of the polynomials of \spad{ts}');
INSERT INTO olibdb VALUES('o','normalizedAssociate',2,'x','(P,TS)->P','pNormalizationPackage(R,E,V,P,TS)',NULL,'\spad{normalizedAssociate(p,{} ts)} returns a normalized polynomial \spad{n} \spad{w}.\spad{r}.\spad{t}. \spad{ts} such that \spad{n} and \spad{p} are associates \spad{w}.\spad{r}.\spad{t} \spad{ts} and assuming that \spad{p} is invertible \spad{w}.\spad{r}.\spad{t} \spad{ts}.');
INSERT INTO olibdb VALUES('o','normalizedDivide',2,'n','(R,R)->Record(quotient:R,remainder:R)','pModularHermitianRowReduction(R)',NULL,'\spad{normalizedDivide(n,{} d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \spadignore{e.g.} positive remainders');
INSERT INTO olibdb VALUES('o','normalizedDivide',2,'x','(R,R)->Record(quotient:R,remainder:R)','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,EuclideanDomain)','\spad{normalizedDivide(n,{} d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \spadignore{e.g.} positive remainders');
INSERT INTO olibdb VALUES('o','normalizeDIAG!',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{normalizeDIAG!(f)} rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one.');
INSERT INTO olibdb VALUES('o','normalizeIfCan',1,'n','(ST)->ST','pLazardSetSolvingPackage(R,E,V,P,TS,ST)',NULL,'\spad{normalizeIfCan(ts)} returns \spad{ts} in an normalized shape if \spad{ts} is zero-dimensional.');
INSERT INTO olibdb VALUES('o','normalizePLS!',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{normalizePLS!(f)} scales and rearranges rows and columns of the system matrix such that the constant part of the system matrix is the identity matrix (possibly of smaller size).');
INSERT INTO olibdb VALUES('o','normalizeRHS!',1,'n','(%)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{normalizeRHS!(f)} eliminates non-zero entries in the right hand side of ALS with respect of the non-zero entry with the highest index.');
INSERT INTO olibdb VALUES('o','normDeriv2',2,'n','(SparseUnivariatePolynomial(R),Integer)->SparseUnivariatePolynomial(R)','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{normDeriv2 should} be local');
INSERT INTO olibdb VALUES('o','normFactors',1,'n','(ExtP)->List(ExtP)','pNormRetractPackage(F,ExtF,SUEx,ExtP,n)',NULL,'\spad{normFactors(x)} \undocumented');
INSERT INTO olibdb VALUES('o','normInvertible?',2,'x','(P,TS)->List(Record(val:Boolean,tower:TS))','pNormalizationPackage(R,E,V,P,TS)',NULL,'\spad{normInvertible?(p,{} ts)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','Not',1,'n','(%)->%','dIndexedBits(mn)',NULL,'\spad{Not(n)} returns the bit-by-bit logical {\em Not} of \spad{n}.');
INSERT INTO olibdb VALUES('o','not',1,'n','(%)->%','dOutputForm',NULL,'\spad{not f} creates the equivalent prefix form.');
INSERT INTO olibdb VALUES('o','NOT',1,'n','(%)->%','dSwitch',NULL,'\spad{NOT(x)} returns the \spadtype{Switch} expression representing \spad{\~~x}.');
INSERT INTO olibdb VALUES('o','not',1,'n','(S)->S','xBitAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','NOT',1,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{NOT(x)} returns the \spadtype{Switch} expression representing \spad{\~~x}.');
INSERT INTO olibdb VALUES('o','not',1,'x','(%)->%','cBitAggregate',NULL,'\spad{not(b)} returns the logical {\em not} of bit aggregate \spad{b}.');
INSERT INTO olibdb VALUES('o','not',1,'x','(%)->%','dBoolean',NULL,'\spad{not n} returns the negation of \spad{n}.');
INSERT INTO olibdb VALUES('o','not',1,'x','(%)->%','dSingleInteger',NULL,'\spad{not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.');
INSERT INTO olibdb VALUES('o','Not',1,'x','(%)->%','dSingleInteger',NULL,'\spad{Not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.');
INSERT INTO olibdb VALUES('o','notelem',1,'n','(%)->List(Record(integrand:F,intvar:F))','dIntegrationResult(F)',NULL,'\spad{notelem(ir)} returns the non-elementary part of an integration result');
INSERT INTO olibdb VALUES('o','nothing',0,'n','()->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{nothing()} returns a handler \spad{h} such that \spad{h(prec,{} args)} returns an empty box. This corresponds to NOTHING in \spad{OutputForm}.');
INSERT INTO olibdb VALUES('o','nothing',0,'n','()->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{nothing()} returns a handler \spad{h} such that \spad{h(prec,{} args)} returns an empty box. This corresponds to NOTHING in \spad{OutputForm}.');
INSERT INTO olibdb VALUES('o','npcoef',3,'n','(SparseUnivariatePolynomial(P),List(BP),List(P))->Record(deter:List(SparseUnivariatePolynomial(P)),dterm:List(List(Record(expt:NonNegativeInteger,pcoef:P))),nfacts:List(BP),nlead:List(P))','pNPCoef(BP,E,OV,R,P)',NULL,'\spad{npcoef(p,{} lmf,{} lcf)} tries to determine some coefficients of factors of \spad{p} assuming that \spad{lcf} gives \spad{true} leading coefficients of the factors and that sparsity pattern of modular factors \spad{lmf} is the same as sparsity pattern of \spad{true} factors. If \spad{res} is the result,{} then \spad{res.deter} gives fully determined factors,{} \spad{res.dterm} gives determined terms of partially determinaed factors,{} \spad{res.nfacts} and \spad{res.nlead} give modular factors and leading coefficients corresponding to undetermined factors.');
INSERT INTO olibdb VALUES('o','nrows',1,'n','(%)->NonNegativeInteger','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{nrows(p)} returns the number of rows.');
INSERT INTO olibdb VALUES('o','nrows',1,'n','(%)->NonNegativeInteger','dSparseEchelonMatrix(C,D)',NULL,'\spad{nrows(A)} returns the number of rows of the matrix \spad{A}.');
INSERT INTO olibdb VALUES('o','nrows',1,'n','(S)->NonNegativeInteger','xRectangularMatrixCategory&(S,m,n,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nrows',1,'x','(%)->NonNegativeInteger','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{nrows(m)} returns the number of rows in the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nrows',1,'x','(%)->NonNegativeInteger','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{nrows(m)} returns the number of rows in the array \spad{m}');
INSERT INTO olibdb VALUES('o','nsqfree',3,'n','(SparseUnivariatePolynomial(P),List(OV),List(List(R)))->Record(unitPart:P,suPart:List(Record(factor:SparseUnivariatePolynomial(P),exponent:NonNegativeInteger)))','pMultivariateSquareFree(E,OV,R,P)',NULL,'\spad{nsqfree should} be local');
INSERT INTO olibdb VALUES('o','nthExpon',2,'n','(%,Integer)->E','dListMonoidOps(S,E,un)',NULL,'\spad{nthExpon(l,{} n)} returns the exponent of the n^th monomial of \spad{l}.');
INSERT INTO olibdb VALUES('o','nthExpon',2,'n','(%,Integer)->Integer','dFreeGroup(S)',NULL,'\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \spad{x}.');
INSERT INTO olibdb VALUES('o','nthExpon',2,'n','(%,Integer)->NonNegativeInteger','dFreeMonoid(S)',NULL,'\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \spad{x}.');
INSERT INTO olibdb VALUES('o','nthFactor',2,'n','(%,Integer)->S','dFreeGroup(S)',NULL,'\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \spad{x}.');
INSERT INTO olibdb VALUES('o','nthFactor',2,'n','(%,Integer)->S','dFreeMonoid(S)',NULL,'\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \spad{x}.');
INSERT INTO olibdb VALUES('o','nthFactor',2,'n','(%,Integer)->S','dListMonoidOps(S,E,un)',NULL,'\spad{nthFactor(l,{} n)} returns the factor of the n^th monomial of \spad{l}.');
INSERT INTO olibdb VALUES('o','nthr',2,'n','(P,NonNegativeInteger)->Record(exponent:NonNegativeInteger,coef:P,radicand:List(P))','pPolynomialRoots(E,V,R,P,F)',NULL,'\spad{nthr(p,{} n)} should be local but conditional');
INSERT INTO olibdb VALUES('o','nthRoot',2,'n','(Factored(M),NonNegativeInteger)->Record(exponent:NonNegativeInteger,coef:M,radicand:List(M))','pFactoredFunctions(M)',NULL,'\spad{nthRoot(f,{} n)} returns \spad{(p,{} r,{} [r1,{} ...,{} rm])} such that the \spad{n}th-root of \spad{f} is equal to \spad{r * \spad{p}th-root(r1 * ... * rm)},{} where \spad{r1},{} ...,{} \spad{rm} are distinct factors of \spad{f},{} each of which has an exponent smaller than \spad{p} in \spad{f}.');
INSERT INTO olibdb VALUES('o','nthRoot',2,'n','(S,Integer)->S','xRadicalCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nthRoot',2,'n','(S,Integer)->S','xRealClosedField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','nthRoot',2,'x','(%,Integer)->%','cRadicalCategory',NULL,'\spad{nthRoot(x,{} n)} returns the \spad{n}th root of \spad{x}.');
INSERT INTO olibdb VALUES('o','nthRoot',3,'n','(Integer,(Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'Format square roots and \spad{n}th roots. \spad{nthRoot(p,{} h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats the first argument according to \spad{h1}. If there is no second argument,{} then the \spad{n}th root is a square root and formatted accordingly. Otherwise the second argument is formatted by \spad{h2}. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','nthRootIfCan',2,'x','(K,NonNegativeInteger)->Union(K,failed)','cPartialTranscendentalFunctions(K)',NULL,'\spad{nthRootIfCan(z,{} n)} returns the \spad{n}th root of \spad{z} if possible,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','Nu',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Nu()} returns symbol for capital greek letter nu.');
INSERT INTO olibdb VALUES('o','nu',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{nu()} returns symbol for small greek letter nu.');
INSERT INTO olibdb VALUES('o','Nul',1,'n','(NonNegativeInteger)->%','dExtAlgBasis',NULL,'\spad{Nul()} gives the basis element 1 for the algebra generated by \spad{n} generators.');
INSERT INTO olibdb VALUES('o','null?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{null?(s)} is \spad{true} if \spad{s} is the \spad{S}-expression ().');
INSERT INTO olibdb VALUES('o','nullary',1,'x','(A)->()->A','pMappingPackage1(A)',NULL,'\spad{nullary A} changes its argument into a \indented{1}{nullary function.}');
INSERT INTO olibdb VALUES('o','nullary?',1,'x','(%)->Boolean','dBasicOperator',NULL,'\spad{nullary?(op)} tests if \spad{op} is nullary.');
INSERT INTO olibdb VALUES('o','nullBoundary',0,'n','()->%','dSBoundary(PT)',NULL,'\spad{nullBoundary()} constructs a null boundary,{} for example,{} when the boundary of a material node is requested.');
INSERT INTO olibdb VALUES('o','nullity',1,'n','(M)->NonNegativeInteger','pInnerMatrixLinearAlgebraFunctions(R,Row,Col,M)',NULL,'\spad{nullity(m)} returns the mullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullity',1,'x','(M)->NonNegativeInteger','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,IntegralDomain)','\spad{nullity(m)} returns the mullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullity',1,'x','(%)->NonNegativeInteger','cMatrixCategory(R,Row,Col)','has(R,IntegralDomain)','\spad{nullity(m)} returns the nullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullity',1,'x','(%)->NonNegativeInteger','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,IntegralDomain)','\spad{nullity(m)} returns the nullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'n','(Matrix(R))->%','dVectorSpaceBasis(R)',NULL,'\spad{nullSpace M} builds a basis of the kernel of the linear transformation defined by the matrix \spad{M}. This function calls the function \spad{nullSpace} from the \spad{Matrix} domain. Only the signature changes.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'n','(M)->List(Col)','pInnerMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(Col,shallowlyMutable)','\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'n','(M)->List(Col)','pInnerMatrixQuotientFieldFunctions(R,Row,Col,M,QF,Row2,Col2,M2)','has(Col2,shallowlyMutable)','\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'x','(%)->List(Col)','cMatrixCategory(R,Row,Col)','has(R,IntegralDomain)','\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'x','(%)->List(Col)','cRectangularMatrixCategory(m,n,R,Row,Col)','has(R,IntegralDomain)','\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpace',1,'x','(M)->List(Col)','pMatrixLinearAlgebraFunctions(R,Row,Col,M)','has(R,IntegralDomain)','\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','nullSpaceOverConstants',2,'n','(Matrix(F),List((F)->F))->List(Vector(F))','pConstantLinearDependence(R,F)',NULL,'\spad{nullSpaceOverConstants(A,{} ld)} returns basis of the homogeneous system \spad{A*vc = 0} where \spad{vc} is a vector of constants.');
INSERT INTO olibdb VALUES('o','number?',1,'x','(%)->Boolean','dExpression(R)','has(R,IntegralDomain)','\spad{number?(f)} tests if \spad{f} is rational');
INSERT INTO olibdb VALUES('o','numberOfChildren',1,'n','(%)->NonNegativeInteger','dSubSpace(n,R)',NULL,'\spad{numberOfChildren(x)} \undocumented');
INSERT INTO olibdb VALUES('o','numberOfComponents',0,'n','()->NonNegativeInteger','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,'\spad{numberOfComponents()} returns the number of absolutely irreducible components.');
INSERT INTO olibdb VALUES('o','numberOfComponents',0,'x','()->NonNegativeInteger','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{numberOfComponents()} returns the number of absolutely irreducible components.');
INSERT INTO olibdb VALUES('o','numberOfComponents',1,'x','(%)->NonNegativeInteger','cThreeSpaceCategory(R)',NULL,'\spad{numberOfComponents(s)} returns the number of distinct object components in the indicated \spadtype{ThreeSpace},{} \spad{s},{} such as points,{} curves,{} polygons,{} and constructs.');
INSERT INTO olibdb VALUES('o','numberOfComposites',1,'x','(%)->NonNegativeInteger','cThreeSpaceCategory(R)',NULL,'\spad{numberOfComposites(s)} returns the number of supercomponents,{} or composites,{} in the \spadtype{ThreeSpace},{} \spad{s}; Composites are arbitrary groupings of otherwise distinct and unrelated components; A \spadtype{ThreeSpace} need not have any composites defined at all and,{} outside of the requirement that no component can belong to more than one composite at a time,{} the definition and interpretation of composites are unrestricted.');
INSERT INTO olibdb VALUES('o','numberOfComputedEntries',1,'x','(%)->NonNegativeInteger','cLazyStreamAggregate(S)',NULL,'\spad{numberOfComputedEntries(st)} returns the number of explicitly computed entries of stream \spad{st} which exist immediately prior to the time this function is called.');
INSERT INTO olibdb VALUES('o','numberOfCycles',1,'x','(%)->NonNegativeInteger','dPermutation(S)',NULL,'\spad{numberOfCycles(p)} returns the number of non-trivial cycles of the permutation \spad{p}.');
INSERT INTO olibdb VALUES('o','numberOfDivisors',1,'x','(Integer)->Integer','pIntegerNumberTheoryFunctions',NULL,'\spad{numberOfDivisors(n)} returns the number of integers between 1 and \spad{n} (inclusive) which divide \spad{n}. The number of divisors of \spad{n} is often denoted by \spad{tau(n)}.');
INSERT INTO olibdb VALUES('o','numberOfFactors',1,'n','(List(Record(factor:UP,degree:Integer)))->NonNegativeInteger','pGaloisGroupFactorizer(UP)',NULL,'\spad{numberOfFactors(ddfactorization)} returns the number of factors of the polynomial \spad{f} modulo \spad{p} where \spad{ddfactorization} is the distinct degree factorization of \spad{f} computed by modular factorization package for some prime \spad{p}.');
INSERT INTO olibdb VALUES('o','numberOfFactors',1,'x','(%)->NonNegativeInteger','dFactored(R)',NULL,'\spad{numberOfFactors(u)} returns the number of factors in \spadvar{\spad{u}}.');
INSERT INTO olibdb VALUES('o','numberOfFractionalTerms',1,'x','(%)->Integer','dPartialFraction(R)',NULL,'\spad{numberOfFractionalTerms(p)} computes the number of fractional terms in \spad{p}. This returns 0 if there is no fractional part.');
INSERT INTO olibdb VALUES('o','numberOfHues',0,'x','()->PositiveInteger','dColor',NULL,'\spad{numberOfHues()} returns the number of total hues,{} set in totalHues.');
INSERT INTO olibdb VALUES('o','numberOfImproperPartitions',2,'x','(Integer,Integer)->Integer','pSymmetricGroupCombinatoricFunctions',NULL,'\spad{numberOfImproperPartitions(n,{} m)} computes the number of partitions of the nonnegative integer \spad{n} in \spad{m} nonnegative parts with regarding the order (improper partitions). Example: {\em numberOfImproperPartitions (3,{} 3)} is 10,{} since {\em [0,{} 0,{} 3],{} [0,{} 1,{} 2],{} [0,{} 2,{} 1],{} [0,{} 3,{} 0],{} [1,{} 0,{} 2],{} [1,{} 1,{} 1],{} [1,{} 2,{} 0],{} [2,{} 0,{} 1],{} [2,{} 1,{} 0],{} [3,{} 0,{} 0]} are the possibilities. Note: this operation has a recursive implementation.');
INSERT INTO olibdb VALUES('o','numberOfIrreduciblePoly',1,'n','(PositiveInteger)->PositiveInteger','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{numberOfIrreduciblePoly(n)}\$FFPOLY(\spad{GF}) yields the number of monic irreducible univariate polynomials of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','numberOfMonomials',1,'x','(%)->NonNegativeInteger','cIndexedDirectProductCategory(A,S)',NULL,'\spad{numberOfMonomials(x)} returns the number of monomials of \spad{x}.');
INSERT INTO olibdb VALUES('o','numberOfNormalPoly',1,'n','(PositiveInteger)->PositiveInteger','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{numberOfNormalPoly(n)}\$FFPOLY(\spad{GF}) yields the number of normal polynomials of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','numberOfPrimes',1,'n','(OutputForm)->Integer','cFormatterCategory',NULL,'\spad{numberOfPrimes(e)} counts the number of commas in \spad{e} and returns it. If \spad{s} does not only contain commas,{} but has a parenthesis at the beginning and the end of the string,{} then the part between the parentheses is interpreted as a roman numeral and translated into an integer. For any other format the function returns \spad{-1}.');
INSERT INTO olibdb VALUES('o','numberOfPrimes',1,'n','(OutputForm)->Integer','xFormatterCategory&(S)',NULL,'\spad{numberOfPrimes(e)} counts the number of commas in \spad{e} and returns it. If \spad{s} does not only contain commas,{} but has a parenthesis at the beginning and the end of the string,{} then the part between the parentheses is interpreted as a roman numeral and translated into an integer. For any other format the function returns \spad{-1}.');
INSERT INTO olibdb VALUES('o','numberOfPrimitivePoly',1,'n','(PositiveInteger)->PositiveInteger','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{numberOfPrimitivePoly(n)}\$FFPOLY(\spad{GF}) yields the number of primitive polynomials of degree \spad{n} over the finite field {\em GF}.');
INSERT INTO olibdb VALUES('o','numberOfVariables',2,'x','(List(P),List(TS))->NonNegativeInteger','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numberOfVariables',2,'x','(List(P),List(TS))->NonNegativeInteger','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numDepVar',0,'n','()->PositiveInteger','cJetBundleCategory',NULL,'\spad{numDepVar} returns the number of dependent variables.');
INSERT INTO olibdb VALUES('o','numDepVar',0,'n','()->PositiveInteger','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numDepVar',0,'n','()->PositiveInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numer',1,'n','(%)->A','dLocalAlgebra(A,R)',NULL,'\spad{numer x} returns the numerator of \spad{x}.');
INSERT INTO olibdb VALUES('o','numer',1,'n','(%)->M','dLocalize(M,R)',NULL,'\spad{numer x} returns the numerator of \spad{x}.');
INSERT INTO olibdb VALUES('o','numer',1,'n','(%)->Vector(A)','dFractionalIdeal(R,F,UP,A)',NULL,'\spad{numer(1/d * (f1,{} ...,{} fn))} = the vector \spad{[f1,{} ...,{} fn]}.');
INSERT INTO olibdb VALUES('o','numer',1,'x','(%)->S','cQuotientFieldCategory(S)',NULL,'\spad{numer(x)} returns the numerator of the fraction \spad{x}.');
INSERT INTO olibdb VALUES('o','numer',1,'x','(%)->SparseMultivariatePolynomial(Integer,Kernel(%))','dAlgebraicNumber',NULL,'\spad{numer(f)} returns the numerator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.');
INSERT INTO olibdb VALUES('o','numer',1,'x','(%)->SparseMultivariatePolynomial(R,K)','cFunctionSpace2(R,K)','has(R,Ring)','\spad{numer(f)} returns the numerator of \spad{f} viewed as a polynomial in the kernels over \spad{R} if \spad{R} is an integral domain. If not,{} then numer(\spad{f}) = \spad{f} viewed as a polynomial in the kernels over \spad{R}.');
INSERT INTO olibdb VALUES('o','numerator',1,'n','(A)->A','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numerator',1,'n','(%)->%','cJetBundleFunctionCategory(JB)',NULL,'\spad{numerator(f)} yields the numerator of \spad{f}.');
INSERT INTO olibdb VALUES('o','numerator',1,'n','(S)->S','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numerator',1,'x','(%)->%','cFunctionSpace2(R,K)','has(R,Ring)','\spad{numerator(f)} returns the numerator of \spad{f} converted to \%.');
INSERT INTO olibdb VALUES('o','numerator',1,'x','(%)->%','cQuotientFieldCategory(S)',NULL,'\spad{numerator(x)} is the numerator of the fraction \spad{x} converted to \%.');
INSERT INTO olibdb VALUES('o','numerators',1,'x','(%)->Stream(R)','dContinuedFraction(R)',NULL,'\spad{numerators(x)} returns the stream of numerators of the approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.');
INSERT INTO olibdb VALUES('o','numeric',1,'x','(Expression(S))->Float','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{numeric(x)} returns a real approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','numeric',1,'x','(Fraction(Polynomial(S)))->Float','pNumeric(S)','has(S,IntegralDomain)','\spad{numeric(x)} returns a real approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','numeric',1,'x','(Polynomial(S))->Float','pNumeric(S)','has(S,Ring)','\spad{numeric(x)} returns a real approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','numeric',1,'x','(S)->Float','pNumeric(S)',NULL,'\spad{numeric(x)} returns a real approximation of \spad{x}.');
INSERT INTO olibdb VALUES('o','numeric',2,'x','(Expression(S),PositiveInteger)->Float','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','numeric',2,'x','(Fraction(Polynomial(S)),PositiveInteger)->Float','pNumeric(S)','has(S,IntegralDomain)','\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','numeric',2,'x','(Polynomial(S),PositiveInteger)->Float','pNumeric(S)','has(S,Ring)','\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','numeric',2,'x','(S,PositiveInteger)->Float','pNumeric(S)',NULL,'\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.');
INSERT INTO olibdb VALUES('o','numericIfCan',1,'x','(Expression(S))->Union(Float,failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numericIfCan',1,'x','(Fraction(Polynomial(S)))->Union(Float,failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numericIfCan',1,'x','(Polynomial(S))->Union(Float,failed)','pNumeric(S)','has(S,Ring)','\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numericIfCan',2,'x','(Expression(S),PositiveInteger)->Union(Float,failed)','pNumeric(S)','AND(has(S,IntegralDomain),has(S,OrderedSet))','\spad{numericIfCan(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numericIfCan',2,'x','(Fraction(Polynomial(S)),PositiveInteger)->Union(Float,failed)','pNumeric(S)','has(S,IntegralDomain)','\spad{numericIfCan(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numericIfCan',2,'x','(Polynomial(S),PositiveInteger)->Union(Float,failed)','pNumeric(S)','has(S,Ring)','\spad{numericIfCan(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or failed if \spad{x} is not a constant.');
INSERT INTO olibdb VALUES('o','numerJP',1,'n','(%)->SparseMultivariatePolynomial(Expression(Integer),JB)','dJetBundleExpression(JB)',NULL,'\spad{numerJP(f)} writes \spad{f} as polynomial over \spad{JB}.');
INSERT INTO olibdb VALUES('o','numFunEvals',0,'n','()->Integer','dPlot',NULL,'\spad{numFunEvals()} returns the number of points computed');
INSERT INTO olibdb VALUES('o','numFunEvals3D',0,'n','()->Integer','dPlot3D',NULL,'\spad{numFunEvals3D()} returns the number of points computed.');
INSERT INTO olibdb VALUES('o','numIndVar',0,'n','()->PositiveInteger','cJetBundleCategory',NULL,'\spad{numIndVar} returns the number of independent variables.');
INSERT INTO olibdb VALUES('o','numIndVar',0,'n','()->PositiveInteger','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','numIndVar',0,'n','()->PositiveInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','obj',1,'x','(%)->None','dAny',NULL,'\spad{obj(a)} essentially returns the original object that was converted to \spadtype{Any} except that the type is forced to be \spadtype{None}.');
INSERT INTO olibdb VALUES('o','objectOf',1,'x','(%)->OutputForm','dAny',NULL,'\spad{objectOf(a)} returns a printable form of the original object that was converted to \spadtype{Any}.');
INSERT INTO olibdb VALUES('o','objects',1,'x','(%)->Record(points:NonNegativeInteger,curves:NonNegativeInteger,polygons:NonNegativeInteger,constructs:NonNegativeInteger)','cThreeSpaceCategory(R)',NULL,'\spad{objects(s)} returns the \spadtype{ThreeSpace},{} \spad{s},{} in the form of a 3D object record containing information on the number of points,{} curves,{} polygons and constructs comprising the \spadtype{ThreeSpace}..');
INSERT INTO olibdb VALUES('o','objectToIndex',2,'n','(A,S)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','objectToIndex',2,'n','(%,S)->NonNegativeInteger','cPoset(S)',NULL,'\spad{objectToIndex returns} the index of a given object.');
INSERT INTO olibdb VALUES('o','oblateSpheroidal',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{oblateSpheroidal(a)} transforms from oblate spheroidal coordinates to Cartesian coordinates: \spad{oblateSpheroidal(a)} is a function which will map the point \spad{(\spad{xi},{} eta,{} phi)} to \spad{x = a*sinh(\spad{xi})*sin(eta)*cos(phi)},{} \spad{y = a*sinh(\spad{xi})*sin(eta)*sin(phi)},{} \spad{z = a*cosh(\spad{xi})*cos(eta)}.');
INSERT INTO olibdb VALUES('o','octon',2,'x','(Quaternion(R),Quaternion(R))->%','dOctonion(R)',NULL,'\spad{octon(qe,{} qE)} constructs an octonion from two quaternions using the relation {\em O = Q + QE}.');
INSERT INTO olibdb VALUES('o','octon',8,'x','(R,R,R,R,R,R,R,R)->%','cOctonionCategory(R)',NULL,'\spad{octon(re,{} \spad{ri},{} rj,{} rk,{} rE,{} rI,{} rJ,{} rK)} constructs an octonion from scalars.');
INSERT INTO olibdb VALUES('o','odd?',1,'n','(S)->Boolean','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','odd?',1,'x','(%)->Boolean','cExpressionSpace2(K)','has(%,RetractableTo(Integer))','\spad{odd? x} is \spad{true} if \spad{x} is an odd integer.');
INSERT INTO olibdb VALUES('o','odd?',1,'x','(%)->Boolean','cIntegerNumberSystem',NULL,'\spad{odd?(n)} returns \spad{true} if and only if \spad{n} is odd.');
INSERT INTO olibdb VALUES('o','odd?',1,'x','(%)->Boolean','dPermutation(S)',NULL,'\spad{odd?(p)} returns \spad{true} if and only if \spad{p} is an odd permutation \spadignore{i.e.} {\em sign(p)} is {\em -1}.');
INSERT INTO olibdb VALUES('o','oddInfiniteProduct',1,'x','(UTS)->UTS','pInfiniteLambertProduct(Coef,UTS)',NULL,'\spad{oddInfiniteProduct(f(x))} computes \spad{product(n=1,{} 3,{} 5...,{} f(x^n))}. The series \spad{f(x)} should have constant coefficient 1.');
INSERT INTO olibdb VALUES('o','oddintegers',1,'n','(Integer)->Stream(Integer)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{oddintegers(n)} returns \spad{[n,{} n+2,{} n+4,{} ...]}.');
INSERT INTO olibdb VALUES('o','oddlambert',1,'n','(%)->%','dUnivariateFormalPowerSeries(Coef)',NULL,NULL);
INSERT INTO olibdb VALUES('o','oddlambert',1,'n','(%)->%','dUnivariateTaylorSeries(Coef,var,cen)',NULL,'\spad{oddlambert(f(x))} returns \spad{f(x) + f(x^3) + f(x^5) + ...}. \indented{1}{\spad{f(x)} should have a zero constant coefficient.} \indented{1}{This function is used for computing infinite products.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n=1..infinity,{} f(x^(2*n-1)))=exp(oddlambert(log(f(x))))}.}');
INSERT INTO olibdb VALUES('o','oddlambert',1,'n','(Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{oddlambert(st)} computes \spad{f(x) + f(x^3) + f(x^5) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f}(\spad{x}) is a power series with constant coefficient 1 then \spad{prod(f(x^(2*n-1)),{} n=1..infinity) = exp(oddlambert(log(f(x))))}.');
INSERT INTO olibdb VALUES('o','odd_partitions',1,'x','(Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{odd_partitions(n)} is the stream of all partitions \indented{1}{of \spad{n} into odd numbers.}');
INSERT INTO olibdb VALUES('o','odd_partitions',3,'x','(Integer,Integer,Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{odd_partitions(p,{} l,{} n)} is the stream of partitions \indented{1}{of \spad{n} into odd numbers whose number of parts is no greater than \spad{p}} \indented{1}{and whose largest part is no greater than \spad{l}.}');
INSERT INTO olibdb VALUES('o','ode1',2,'n','((UTS)->UTS,Coef)->UTS','pUnivariateTaylorSeriesODESolver(Coef,UTS)',NULL,'\spad{ode1(f,{} c)} is the solution to \spad{y'' = f(y)} such that \spad{y(a) = c}.');
INSERT INTO olibdb VALUES('o','ode2',3,'n','((UTS,UTS)->UTS,Coef,Coef)->UTS','pUnivariateTaylorSeriesODESolver(Coef,UTS)',NULL,'\spad{ode2(f,{} c0,{} c1)} is the solution to \spad{y'''' = f(y,{} y'')} such that \spad{y(a) = c0} and \spad{y''(a) = c1}.');
INSERT INTO olibdb VALUES('o','ode',2,'n','((List(UTS))->UTS,List(Coef))->UTS','pUnivariateTaylorSeriesODESolver(Coef,UTS)',NULL,'\spad{ode(f,{} cl)} is the solution to \spad{y<n>=f(y,{} y'',{} ..,{} y<n-1>)} such that \spad{y<i>(a) = cl.(i+1)} for \spad{i} in 0..(\spad{n} - 1).');
INSERT INTO olibdb VALUES('o','OMbindTCP',2,'x','(%,SingleInteger)->Boolean','dOpenMathConnection',NULL,'\spad{OMbindTCP}');
INSERT INTO olibdb VALUES('o','OMclose',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMclose(dev)} closes \spad{dev},{} flushing output if necessary.');
INSERT INTO olibdb VALUES('o','OMcloseConn',1,'x','(%)->Void','dOpenMathConnection',NULL,'\spad{OMcloseConn}');
INSERT INTO olibdb VALUES('o','OMconnectTCP',3,'x','(%,String,SingleInteger)->Boolean','dOpenMathConnection',NULL,'\spad{OMconnectTCP}');
INSERT INTO olibdb VALUES('o','OMconnInDevice',1,'x','(%)->OpenMathDevice','dOpenMathConnection',NULL,'\spad{OMconnInDevice : }');
INSERT INTO olibdb VALUES('o','OMconnOutDevice',1,'x','(%)->OpenMathDevice','dOpenMathConnection',NULL,'\spad{OMconnOutDevice : }');
INSERT INTO olibdb VALUES('o','omega',0,'n','()->%','dSmallOrdinal',NULL,'\spad{omega()} is the first infinite ordinal');
INSERT INTO olibdb VALUES('o','Omega',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Omega()} returns symbol for capital greek letter omega.');
INSERT INTO olibdb VALUES('o','omega',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{omega()} returns symbol for small greek letter omega.');
INSERT INTO olibdb VALUES('o','omegapower',1,'n','(%)->%','dSmallOrdinal',NULL,'\spad{omegapower(p)} returns omega^p');
INSERT INTO olibdb VALUES('o','OMencodingBinary',0,'x','()->%','dOpenMathEncoding',NULL,'\spad{OMencodingBinary()} is the constant for the OpenMath binary encoding.');
INSERT INTO olibdb VALUES('o','OMencodingSGML',0,'x','()->%','dOpenMathEncoding',NULL,'\spad{OMencodingSGML()} is the constant for the deprecated OpenMath SGML encoding.');
INSERT INTO olibdb VALUES('o','OMencodingUnknown',0,'x','()->%','dOpenMathEncoding',NULL,'\spad{OMencodingUnknown()} is the constant for unknown encoding types. If this is used on an input device,{} the encoding will be autodetected. It is invalid to use it on an output device.');
INSERT INTO olibdb VALUES('o','OMencodingXML',0,'x','()->%','dOpenMathEncoding',NULL,'\spad{OMencodingXML()} is the constant for the OpenMath \spad{XML} encoding.');
INSERT INTO olibdb VALUES('o','omError',2,'x','(OpenMathErrorKind,List(Symbol))->%','dOpenMathError',NULL,'\spad{omError(k,{} l)} creates an instance of OpenMathError.');
INSERT INTO olibdb VALUES('o','OMgetApp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetApp(dev)} reads a begin application token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetAtp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetAtp(dev)} reads a begin attribute pair token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetAttr',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetAttr(dev)} reads a begin attribute token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetBind',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetBind(dev)} reads a begin binder token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetBVar',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetBVar(dev)} reads a begin bound variable list token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndApp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndApp(dev)} reads an end application token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndAtp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndAtp(dev)} reads an end attribute pair token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndAttr',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndAttr(dev)} reads an end attribute token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndBind',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndBind(dev)} reads an end binder token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndBVar',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndBVar(dev)} reads an end bound variable list token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndError',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndError(dev)} reads an end error token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetEndObject',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetEndObject(dev)} reads an end object token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetError',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetError(dev)} reads a begin error token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetFloat',1,'x','(%)->DoubleFloat','dOpenMathDevice',NULL,'\spad{OMgetFloat(dev)} reads a float from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetInteger',1,'x','(%)->Integer','dOpenMathDevice',NULL,'\spad{OMgetInteger(dev)} reads an integer from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetObject',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMgetObject(dev)} reads a begin object token from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetString',1,'x','(%)->String','dOpenMathDevice',NULL,'\spad{OMgetString(dev)} reads a string from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetSymbol',1,'x','(%)->Record(cd:String,name:String)','dOpenMathDevice',NULL,'\spad{OMgetSymbol(dev)} reads a symbol from \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetType',1,'x','(%)->Symbol','dOpenMathDevice',NULL,'\spad{OMgetType(dev)} returns the type of the next object on \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMgetVariable',1,'x','(%)->Symbol','dOpenMathDevice',NULL,'\spad{OMgetVariable(dev)} reads a variable from \spad{dev}.');
INSERT INTO olibdb VALUES('o','Omicron',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Omicron()} returns symbol for capital greek letter omicron.');
INSERT INTO olibdb VALUES('o','omicron',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{omicron()} returns symbol for small greek letter omicron.');
INSERT INTO olibdb VALUES('o','OMlistCDs',0,'x','()->List(String)','pOpenMathPackage',NULL,'\spad{OMlistCDs()} lists all the \spad{CDs} supported by FriCAS.');
INSERT INTO olibdb VALUES('o','OMlistSymbols',1,'x','(String)->List(String)','pOpenMathPackage',NULL,'\spad{OMlistSymbols(cd)} lists all the symbols in \spad{cd}.');
INSERT INTO olibdb VALUES('o','OMmakeConn',1,'x','(SingleInteger)->%','dOpenMathConnection',NULL,'\spad{OMmakeConn}');
INSERT INTO olibdb VALUES('o','OMopenFile',3,'x','(String,String,OpenMathEncoding)->%','dOpenMathDevice',NULL,'\spad{OMopenFile(f,{} mode,{} enc)} opens file \spad{f} for reading or writing OpenMath objects (depending on \spad{mode} which can be \spad{r},{} \spad{w} or a for read,{} write and append respectively),{} in the encoding \spad{enc}.');
INSERT INTO olibdb VALUES('o','OMopenString',2,'x','(String,OpenMathEncoding)->%','dOpenMathDevice',NULL,'\spad{OMopenString(s,{} mode)} opens the string \spad{s} for reading or writing OpenMath objects in encoding \spad{enc}.');
INSERT INTO olibdb VALUES('o','OMParseError?',1,'x','(%)->Boolean','dOpenMathErrorKind',NULL,'\spad{OMParseError?(u)} tests whether \spad{u} is an OpenMath parsing error.');
INSERT INTO olibdb VALUES('o','OMputApp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputApp(dev)} writes a begin application token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputAtp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputAtp(dev)} writes a begin attribute pair token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputAttr',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputAttr(dev)} writes a begin attribute token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputBind',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputBind(dev)} writes a begin binder token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputBVar',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputBVar(dev)} writes a begin bound variable list token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndApp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndApp(dev)} writes an end application token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndAtp',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndAtp(dev)} writes an end attribute pair token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndAttr',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndAttr(dev)} writes an end attribute token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndBind',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndBind(dev)} writes an end binder token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndBVar',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndBVar(dev)} writes an end bound variable list token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndError',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndError(dev)} writes an end error token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputEndObject',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputEndObject(dev)} writes an end object token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputError',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputError(dev)} writes a begin error token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputFloat',2,'x','(%,DoubleFloat)->Void','dOpenMathDevice',NULL,'\spad{OMputFloat(dev,{} i)} writes the float \spad{i} to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputInteger',2,'x','(%,Integer)->Void','dOpenMathDevice',NULL,'\spad{OMputInteger(dev,{} i)} writes the integer \spad{i} to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputObject',1,'x','(%)->Void','dOpenMathDevice',NULL,'\spad{OMputObject(dev)} writes a begin object token to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputString',2,'x','(%,String)->Void','dOpenMathDevice',NULL,'\spad{OMputString(dev,{} i)} writes the string \spad{i} to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputSymbol',3,'x','(%,String,String)->Void','dOpenMathDevice',NULL,'\spad{OMputSymbol(dev,{} cd,{} s)} writes the symbol \spad{s} from \spad{CD} \spad{cd} to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMputVariable',2,'x','(%,Symbol)->Void','dOpenMathDevice',NULL,'\spad{OMputVariable(dev,{} i)} writes the variable \spad{i} to \spad{dev}.');
INSERT INTO olibdb VALUES('o','OMread',1,'x','(OpenMathDevice)->Any','pOpenMathPackage',NULL,'\spad{OMread(dev)} reads an OpenMath object from \spad{dev} and passes it to FriCAS.');
INSERT INTO olibdb VALUES('o','OMReadError?',1,'x','(%)->Boolean','dOpenMathErrorKind',NULL,'\spad{OMReadError?(u)} tests whether \spad{u} is an OpenMath read error.');
INSERT INTO olibdb VALUES('o','OMreadFile',1,'x','(String)->Any','pOpenMathPackage',NULL,'\spad{OMreadFile(f)} reads an OpenMath object from \spad{f} and passes it to FriCAS.');
INSERT INTO olibdb VALUES('o','OMreadStr',1,'x','(String)->Any','pOpenMathPackage',NULL,'\spad{OMreadStr(f)} reads an OpenMath object from \spad{f} and passes it to FriCAS.');
INSERT INTO olibdb VALUES('o','OMreceive',1,'x','(OpenMathConnection)->Any','pOpenMathServerPackage',NULL,'\spad{OMreceive(c)} reads an OpenMath object from connection \spad{c} and returns the appropriate FriCAS object.');
INSERT INTO olibdb VALUES('o','OMsend',2,'x','(OpenMathConnection,Any)->Void','pOpenMathServerPackage',NULL,'\spad{OMsend(c,{} u)} attempts to output \spad{u} on \spad{c} in OpenMath.');
INSERT INTO olibdb VALUES('o','OMserve',2,'x','(SingleInteger,SingleInteger)->Void','pOpenMathServerPackage',NULL,'\spad{OMserve(portnum,{} timeout)} puts FriCAS into server mode on port number \spad{portnum}. The parameter \spad{timeout} specifies the timeout period for the connection.');
INSERT INTO olibdb VALUES('o','OMsetEncoding',2,'x','(%,OpenMathEncoding)->Void','dOpenMathDevice',NULL,'\spad{OMsetEncoding(dev,{} enc)} sets the encoding used for reading or writing OpenMath objects to or from \spad{dev} to \spad{enc}.');
INSERT INTO olibdb VALUES('o','OMsupportsCD?',1,'x','(String)->Boolean','pOpenMathPackage',NULL,'\spad{OMsupportsCD?(cd)} returns \spad{true} if FriCAS supports \spad{cd},{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','OMsupportsSymbol?',2,'x','(String,String)->Boolean','pOpenMathPackage',NULL,'\spad{OMsupportsSymbol?(s,{} cd)} returns \spad{true} if FriCAS supports symbol \spad{s} from \spad{CD} \spad{cd},{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','OMunhandledSymbol',2,'x','(String,String)->Exit','pOpenMathPackage',NULL,'\spad{OMunhandledSymbol(s,{} cd)} raises an error if FriCAS reads a symbol which it is unable to handle. Note that this is different from an unexpected symbol.');
INSERT INTO olibdb VALUES('o','OMUnknownCD?',1,'x','(%)->Boolean','dOpenMathErrorKind',NULL,'\spad{OMUnknownCD?(u)} tests whether \spad{u} is an OpenMath unknown \spad{CD} error.');
INSERT INTO olibdb VALUES('o','OMUnknownSymbol?',1,'x','(%)->Boolean','dOpenMathErrorKind',NULL,'\spad{OMUnknownSymbol?(u)} tests whether \spad{u} is an OpenMath unknown symbol error.');
INSERT INTO olibdb VALUES('o','OMwrite',1,'n','(S)->String','xOpenMath&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',1,'x','(Expression(R))->String','pExpressionToOpenMath(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',1,'x','(%)->String','cOpenMath',NULL,'\spad{OMwrite(u)} returns the OpenMath \spad{XML} encoding of \spad{u} as a complete OpenMath object.');
INSERT INTO olibdb VALUES('o','OMwrite',2,'n','(OpenMathDevice,S)->Void','xOpenMath&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',2,'n','(S,Boolean)->String','xOpenMath&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',2,'x','(%,Boolean)->String','cOpenMath',NULL,'\spad{OMwrite(u,{} true)} returns the OpenMath \spad{XML} encoding of \spad{u} as a complete OpenMath object; OMwrite(\spad{u},{} \spad{false}) returns the OpenMath \spad{XML} encoding of \spad{u} as an OpenMath fragment.');
INSERT INTO olibdb VALUES('o','OMwrite',2,'x','(Expression(R),Boolean)->String','pExpressionToOpenMath(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',2,'x','(OpenMathDevice,Expression(R))->Void','pExpressionToOpenMath(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',2,'x','(OpenMathDevice,%)->Void','cOpenMath',NULL,'\spad{OMwrite(dev,{} u)} writes the OpenMath form of \spad{u} to the OpenMath device \spad{dev} as a complete OpenMath object.');
INSERT INTO olibdb VALUES('o','OMwrite',3,'n','(OpenMathDevice,S,Boolean)->Void','xOpenMath&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','OMwrite',3,'x','(OpenMathDevice,%,Boolean)->Void','cOpenMath',NULL,'\spad{OMwrite(dev,{} u,{} true)} writes the OpenMath form of \spad{u} to the OpenMath device \spad{dev} as a complete OpenMath object; OMwrite(\spad{dev},{} \spad{u},{} \spad{false}) writes the object as an OpenMath fragment.');
INSERT INTO olibdb VALUES('o','OMwrite',3,'x','(OpenMathDevice,Expression(R),Boolean)->Void','pExpressionToOpenMath(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','one?',1,'n','(%)->Boolean','cJetBundleCategory',NULL,'\spad{one?(jv)} checks whether the jet variables \spad{jv} is the special variable 1.');
INSERT INTO olibdb VALUES('o','one',1,'n','(List(GuessOption))->Boolean','dGuessOptionFunctions0',NULL,'\spad{one returns} whether we need only one solution,{} default being \spad{true}.');
INSERT INTO olibdb VALUES('o','one?',1,'n','(S)->Boolean','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','one?',1,'n','(S)->Boolean','xMagmaWithUnit&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','one?',1,'n','(S)->Boolean','xQuaternionCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','one?',1,'x','(%)->Boolean','cMagmaWithUnit',NULL,'\spad{one?(a)} tests whether \spad{a} is the unit 1.');
INSERT INTO olibdb VALUES('o','one',1,'x','(Boolean)->%','dGuessOption',NULL,'\spad{one(d)} specifies whether we are happy with one solution. This option is expressed in the form \spad{one == d}.');
INSERT INTO olibdb VALUES('o','one?',1,'x','(%)->Boolean','dPolynomialIdeal(F,Expon,VarSet,DPoly)',NULL,'\spad{one?(I)} tests whether the ideal \spad{I} is the unit ideal,{} \spadignore{i.e.} contains 1.');
INSERT INTO olibdb VALUES('o','oneDimensionalArray',1,'x','(List(S))->%','dOneDimensionalArray(S)',NULL,'\spad{oneDimensionalArray(l)} creates an array from a list of elements \spad{l}');
INSERT INTO olibdb VALUES('o','oneDimensionalArray',2,'x','(NonNegativeInteger,S)->%','dOneDimensionalArray(S)',NULL,'\spad{oneDimensionalArray(n,{} s)} creates an array from \spad{n} copies of element \spad{s}');
INSERT INTO olibdb VALUES('o','oneSkeleton',1,'n','(%)->DirectedGraph(NonNegativeInteger)','dFiniteSimplicialComplex(VS)',NULL,'generates graph AKA 1-skeleton');
INSERT INTO olibdb VALUES('o','oneSkeleton',1,'n','(%)->UndirectedGraph(NonNegativeInteger)','dDeltaComplex(VS)',NULL,'generates graph AKA 1-skeleton');
INSERT INTO olibdb VALUES('o','open?',1,'n','(%)->Boolean','dTubePlot(Curve)',NULL,'\spad{open?(t)} tests whether the given tube plot \spad{t} is open.');
INSERT INTO olibdb VALUES('o','open',1,'x','(Name)->%','cFileCategory(Name,S)',NULL,'\spad{open(s)} returns the file \spad{s} open for input.');
INSERT INTO olibdb VALUES('o','open',2,'n','(FileName,String)->%','dBasicFile',NULL,'\spad{open opens} the file.');
INSERT INTO olibdb VALUES('o','open',2,'n','(FileName,String)->%','dBasicKeyedAccessFile',NULL,'\spad{open opens} the keyed access file.');
INSERT INTO olibdb VALUES('o','open',2,'x','(Name,String)->%','cFileCategory(Name,S)',NULL,'\spad{open(s,{} mode)} returns a file \spad{s} open for operation in the indicated mode: input or output.');
INSERT INTO olibdb VALUES('o','operation',1,'n','(%)->Union(Null:null,Assignment:assignment,Conditional:conditional,Return:return,Block:block,Comment:comment,Call:call,For:for,While:while,Repeat:repeat,Goto:goto,Continue:continue,ArrayAssignment:arrayAssignment,Save:save,Stop:stop,Common:common,Print:print)','dFortranCode',NULL,'\spad{operation(f)} returns the name of the operation represented by \spad{f}.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','pAlgebraicFunction(R,F)',NULL,'\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}. Error: if \spad{op} is not an algebraic operator,{} that is,{} an \spad{n}th root or implicit algebraic operator.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','pCombinatorialFunction(R,F)',NULL,'\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}; error if \spad{op} is not a combinatorial operator.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','pElementaryFunction(R,F)',NULL,'\spad{operator(p)} returns an elementary operator with the same symbol as \spad{p}');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','pFunctionalSpecialFunction(R,F)',NULL,'\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}; error if \spad{op} is not a special function operator.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','pLiouvillianFunction(R,F)',NULL,'\spad{operator(op)} returns the Liouvillian operator based on \spad{op}');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','xExpressionSpace2&(S,K)',NULL,'\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \%.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(BasicOperator)->BasicOperator','xFunctionSpace2&(S,R,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','operator',1,'n','(%)->BasicOperator','cKernelCategory(S)',NULL,'\spad{operator(op(a1,{} ...,{} an))} returns the operator op.');
INSERT INTO olibdb VALUES('o','operator',1,'n','(OutputForm)->OutputForm','pOutputFormTools',NULL,'\spad{operator(f)} gives operator (head) of form \spad{f}. Valid only when atom?(\spad{f}) is \spad{false}');
INSERT INTO olibdb VALUES('o','operator',1,'n','(Symbol)->BasicOperator','pCommonOperators',NULL,'\spad{operator(s)} returns an operator with name \spad{s},{} with the appropriate semantics if \spad{s} is known. If \spad{s} is not known,{} the result has no semantics.');
INSERT INTO olibdb VALUES('o','operator',1,'x','(BasicOperator)->BasicOperator','cExpressionSpace2(K)',NULL,'\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \%.');
INSERT INTO olibdb VALUES('o','operator',1,'x','(Symbol)->%','dBasicOperator',NULL,'\spad{operator(f)} makes \spad{f} into an operator with arbitrary arity.');
INSERT INTO olibdb VALUES('o','operator',2,'x','(Symbol,NonNegativeInteger)->%','dBasicOperator',NULL,'\spad{operator(f,{} n)} makes \spad{f} into an \spad{n}-ary operator.');
INSERT INTO olibdb VALUES('o','operatorHandlers',0,'n','()->OperatorHandlers((Integer,List(OutputForm))->OutputBox)','cFormatterCategory',NULL,'\spad{operatorHandlers()} returns an internal data structure that is used for the selection of respective handlers.');
INSERT INTO olibdb VALUES('o','operatorHandlers',0,'n','()->OperatorHandlers((Integer,List(OutputForm))->OutputBox)','dFormatter(F)',NULL,'\spad{operatorHandlers()} returns an internal data structure that is used for the selection of respective handlers.');
INSERT INTO olibdb VALUES('o','operators',1,'n','(S)->List(BasicOperator)','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','operators',1,'x','(%)->List(BasicOperator)','cExpressionSpace2(K)',NULL,'\spad{operators(f)} returns all the basic operators appearing in \spad{f},{} no matter what their levels are.');
INSERT INTO olibdb VALUES('o','opeval',2,'n','(BasicOperator,R)->R','dOperator(R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','opeval',2,'x','(BasicOperator,M)->M','dModuleOperator(R,M)',NULL,'\spad{opeval should} be local but conditional');
INSERT INTO olibdb VALUES('o','opposite',1,'n','(A)->A','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','opposite',1,'n','(%)->%','cPoset(S)',NULL,'\spad{opposite(s)} constructs the opposite in the category theory sense of reversing all the arrows.');
INSERT INTO olibdb VALUES('o','opposite?',2,'n','(S,S)->Boolean','xAbelianGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','opposite?',2,'n','(S,S)->Boolean','xAbelianMonoid&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','opposite?',2,'x','(%,%)->Boolean','cAbelianMonoid',NULL,'\spad{opposite?(x,{}y)} holds if the sum of \spad{x} and \spad{y} is \spad{0}.');
INSERT INTO olibdb VALUES('o','option',2,'n','(List(DrawOption),Symbol)->Union(S,failed)','pDrawOptionFunctions1(S)',NULL,'\spad{option(l,{} s)} determines whether the indicated drawing option,{} \spad{s},{} is contained in the list of drawing options,{} \spad{l},{} which is defined by the draw command.');
INSERT INTO olibdb VALUES('o','option?',2,'x','(List(%),Symbol)->Boolean','dDrawOption',NULL,'\spad{option?()} is not to be used at the top level; option? internally returns \spad{true} for drawing options which are indicated in a draw command,{} or \spad{false} for those which are not.');
INSERT INTO olibdb VALUES('o','option',2,'x','(List(%),Symbol)->Union(Any,failed)','dDrawOption',NULL,'\spad{option()} is not to be used at the top level; option determines internally which drawing options are indicated in a draw command.');
INSERT INTO olibdb VALUES('o','option',2,'x','(List(%),Symbol)->Union(Any,failed)','dGuessOption',NULL,'\spad{option(l,{} option)} returns which options are given.');
INSERT INTO olibdb VALUES('o','optional?',1,'n','(%)->Boolean','dPattern(R)',NULL,'\spad{optional?(p)} tests if \spad{p} is a single matching variable which can match an identity.');
INSERT INTO olibdb VALUES('o','optional',1,'x','(F)->F','pFunctionSpaceAssertions(R,F)',NULL,'\spad{optional(x)} tells the pattern matcher that \spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation). Error: if \spad{x} is not a symbol.');
INSERT INTO olibdb VALUES('o','optional',1,'x','(Symbol)->Expression(Integer)','pPatternMatchAssertions',NULL,'\spad{optional(x)} tells the pattern matcher that \spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation).');
INSERT INTO olibdb VALUES('o','options',1,'n','(%)->List(DrawOption)','dTwoDimensionalViewport',NULL,'\spad{options(v)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and returns a list containing the draw options from the domain \spadtype{DrawOption} for \spad{v}.');
INSERT INTO olibdb VALUES('o','options',1,'x','(%)->List(DrawOption)','dThreeDimensionalViewport',NULL,'\spad{options(v)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport} and returns a list of all the draw options from the domain \spad{DrawOption} which are being used by \spad{v}.');
INSERT INTO olibdb VALUES('o','options',2,'n','(%,List(DrawOption))->%','dTwoDimensionalViewport',NULL,'\spad{options(v,{} lopt)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and returns \spad{v} with it\spad{''s} draw options modified to be those which are indicated in the given list,{} \spad{lopt} of domain \spadtype{DrawOption}.');
INSERT INTO olibdb VALUES('o','options',2,'x','(%,List(DrawOption))->%','dThreeDimensionalViewport',NULL,'\spad{options(v,{} lopt)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport} and sets the draw options being used by \spad{v} to those indicated in the list,{} \spad{lopt},{} which is a list of options from the domain \spad{DrawOption}.');
INSERT INTO olibdb VALUES('o','optpair',1,'n','(List(%))->Union(List(%),failed)','dPattern(R)',NULL,'\spad{optpair(l)} returns \spad{l} has the form \spad{[a,{} b]} and a is optional,{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','opType',1,'n','(%)->Symbol','dILogic',NULL,'if this is a compound op then opType returns the type of that op: IMPLY::Symbol =implies AND::Symbol=/\ OR::Symbol=\spad{\/} NOT::Symbol=~ OTHER::Symbol=not compound op');
INSERT INTO olibdb VALUES('o','opType',1,'n','(%)->Symbol','dLatticeJoinOfMeets',NULL,'if this is a compound op then opType returns the type of that op: IMPLY::Symbol =implies AND::Symbol=/\ OR::Symbol=\spad{\/} NOT::Symbol=~ OTHER::Symbol=not compound op');
INSERT INTO olibdb VALUES('o','opType',1,'n','(%)->Symbol','dLatticeMeetOfJoins',NULL,'if this is a compound op then opType returns the type of that op: IMPLY::Symbol =implies AND::Symbol=/\ OR::Symbol=\spad{\/} NOT::Symbol=~ OTHER::Symbol=not compound op');
INSERT INTO olibdb VALUES('o','Or',2,'n','(%,%)->%','dIndexedBits(mn)',NULL,'\spad{Or(n,{} m)} returns the bit-by-bit logical {\em Or} of \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','or',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f or g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','OR',2,'n','(Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%),Union(I:Expression(Integer),F:Expression(Float),CF:Expression(Complex(Float)),switch:%))->%','dSwitch',NULL,'\spad{OR(x,{} y)} returns the \spadtype{Switch} expression representing \spad{x or y}.');
INSERT INTO olibdb VALUES('o','or',2,'x','(%,%)->%','cBitAggregate',NULL,'\spad{a or b} returns the logical {\em or} of bit aggregates \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','or',2,'x','(%,%)->%','dBoolean',NULL,'\spad{a or b} returns the logical inclusive {\em or} of Boolean \spad{a} and \spad{b}.');
INSERT INTO olibdb VALUES('o','Or',2,'x','(%,%)->%','dSingleInteger',NULL,'\spad{Or(n,{} m)} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.');
INSERT INTO olibdb VALUES('o','orbit',2,'x','(%,List(S))->Set(List(S))','dPermutationGroup(S)',NULL,'\spad{orbit(gp,{} ls)} returns the orbit of the ordered list {\em ls} under the group {\em gp}. Note: return type is \spad{L} \spad{L} \spad{S} temporarily because FSET \spad{L} \spad{S} has an error.');
INSERT INTO olibdb VALUES('o','orbit',2,'x','(%,Set(S))->Set(Set(S))','dPermutationGroup(S)',NULL,'\spad{orbit(gp,{} els)} returns the orbit of the unordered set {\em els} under the group {\em gp}.');
INSERT INTO olibdb VALUES('o','orbit',2,'x','(%,S)->Set(S)','cPermutationCategory(S)',NULL,'\spad{orbit(p,{} el)} returns the orbit of {\em el} under the permutation \spad{p},{} \spadignore{i.e.} the set which is given by applications of the powers of \spad{p} to {\em el}.');
INSERT INTO olibdb VALUES('o','orbit',2,'x','(%,S)->Set(S)','dPermutationGroup(S)',NULL,'\spad{orbit(gp,{} el)} returns the orbit of the element {\em el} under the group {\em gp},{} \spadignore{i.e.} the set of all points gained by applying each group element to {\em el}.');
INSERT INTO olibdb VALUES('o','orbits',1,'x','(%)->Set(Set(S))','dPermutationGroup(S)',NULL,'\spad{orbits(gp)} returns the orbits of the group {\em gp},{} \spadignore{i.e.} it partitions the (finite) of all moved points.');
INSERT INTO olibdb VALUES('o','ord',1,'x','(%)->Integer','dCharacter',NULL,'\spad{ord(c)} provides an integral code corresponding to the character \spad{c}. It is always \spad{true} that \spad{char ord c = c}.');
INSERT INTO olibdb VALUES('o','order',1,'n','(A)->NonNegativeInteger','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'n','(FiniteDivisor(Fraction(Integer),UP,UPUP,R))->Union(NonNegativeInteger,failed)','pPointsOfFiniteOrderRational(UP,UPUP,R)',NULL,'\spad{order(f)} \undocumented');
INSERT INTO olibdb VALUES('o','order',1,'n','(FiniteDivisor(F,UP,UPUP,R))->NonNegativeInteger','pFindOrderFinite(F,UP,UPUP,R)',NULL,'\spad{order(x)} \undocumented');
INSERT INTO olibdb VALUES('o','order',1,'n','(FiniteDivisor(F,UP,UPUP,R))->Union(NonNegativeInteger,failed)','pPointsOfFiniteOrder(R0,F,UP,UPUP,R)',NULL,'\spad{order(fd)} returns order of divisor \spad{fd} or \spad{failed} if \spad{fd} is not of finite order.');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->Integer','cFiniteGroup',NULL,'\spad{order(x)} computes the order of the element \$\spad{x}\$.');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->Integer','dLaurentPolynomial(R,UP)',NULL,'\spad{order(x)} \undocumented');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->NonNegativeInteger','cFacetCategory',NULL,'number of vertices');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->NonNegativeInteger','cJetBundleCategory',NULL,'\spad{order(jv)} yields the order of the jet variable \spad{jv} (Order as derivative).');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->NonNegativeInteger','cJetBundleFunctionCategory(JB)',NULL,'\spad{order(f)} gives highest order of the jet variables effectively occurring in \spad{f}.');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->NonNegativeInteger','dInnerTaylorSeries(Coef)',NULL,'\spad{order(x)} returns the order of a power series \spad{x},{} \indented{1}{\spadignore{i.e.} the degree of the first non-zero term of the series.}');
INSERT INTO olibdb VALUES('o','order',1,'n','(%)->NonNegativeInteger','dJetDifferentialEquation(JB,D)',NULL,'\spad{order(de)} yields the order of the differential equation \spad{de}.');
INSERT INTO olibdb VALUES('o','order',1,'n','(S)->Integer','xFiniteGroup&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'n','(S)->NonNegativeInteger','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'n','(S)->NonNegativeInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'n','(S)->OnePointCompletion(PositiveInteger)','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'n','(S)->PositiveInteger','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->Expon','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{order(f)} is the degree of the lowest order non-zero term in \spad{f}. This will result in an infinite loop if \spad{f} has no non-zero terms.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->Integer','cFloatingPointSystem',NULL,'\spad{order x} is the order of magnitude of \spad{x}. Note: \spad{base ^ order x <= |x| < base ^ (1 + order x)}.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->NonNegativeInteger','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{order(p)} returns the order of the differential polynomial \spad{p},{} which is the maximum number of differentiations of a differential indeterminate,{} among all those appearing in \spad{p}.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->NonNegativeInteger','cDifferentialVariableCategory(S)',NULL,'\spad{order(v)} returns \spad{n} if \spad{v} is the \spad{n}-th derivative of any differential indeterminate.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->NonNegativeInteger','cPAdicIntegerCategory(p)',NULL,'\spad{order(x)} returns the exponent of the highest power of \spad{p} dividing \spad{x}.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->NonNegativeInteger','dPermutationGroup(S)',NULL,'\spad{order(gp)} returns the order of the group {\em gp}.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->NonNegativeInteger','dPermutation(S)',NULL,'\spad{order(p)} returns the order of a permutation \spad{p} as a group element.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->OnePointCompletion(PositiveInteger)','cFieldOfPrimeCharacteristic',NULL,'\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \spad{a} is 0.');
INSERT INTO olibdb VALUES('o','order',1,'x','(%)->PositiveInteger','cFiniteFieldCategory',NULL,'\spad{order(b)} computes the order of an element \spad{b} in the multiplicative group of the field. Error: if \spad{b} equals 0.');
INSERT INTO olibdb VALUES('o','order',2,'n','(A,S)->NonNegativeInteger','xDifferentialPolynomialCategory&(A,R,S,V,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',2,'n','(%,NonNegativeInteger)->NonNegativeInteger','dInnerTaylorSeries(Coef)',NULL,'\spad{order(x,{} n)} returns the minimum of \spad{n} and the order of \spad{x}.');
INSERT INTO olibdb VALUES('o','order',2,'n','(S,S)->NonNegativeInteger','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','order',2,'x','(%,Expon)->Expon','cUnivariatePowerSeriesCategory(Coef,Expon)',NULL,'\spad{order(f,{} n) = min(m,{} n)},{} where \spad{m} is the degree of the lowest order non-zero term in \spad{f}.');
INSERT INTO olibdb VALUES('o','order',2,'x','(%,%)->NonNegativeInteger','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{order(p,{} q)} returns the largest \spad{n} such that \spad{q^n} divides polynomial \spad{p} \spadignore{i.e.} the order of \spad{p(x)} at \spad{q(x)=0}.');
INSERT INTO olibdb VALUES('o','order',2,'x','(%,S)->NonNegativeInteger','cDifferentialPolynomialCategory(R,S,V,E)',NULL,'\spad{order(p,{} s)} returns the order of the differential polynomial \spad{p} in differential indeterminate \spad{s}.');
INSERT INTO olibdb VALUES('o','order',2,'x','(%,Var)->NonNegativeInteger','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{order(f,{} x)} returns the order of \spad{f} viewed as a series in \spad{x} may result in an infinite loop if \spad{f} has no non-zero terms.');
INSERT INTO olibdb VALUES('o','order',3,'n','(FiniteDivisor(F1,UP,UPUP,R),UPUP,(F1)->F2)->NonNegativeInteger','pReducedDivisor(F1,UP,UPUP,R,F2)',NULL,'\spad{order(f,{} u,{} g)} \undocumented');
INSERT INTO olibdb VALUES('o','order',3,'x','(%,Var,NonNegativeInteger)->NonNegativeInteger','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{order(f,{} x,{} n)} returns \spad{min(n,{} order(f,{} x))}.');
INSERT INTO olibdb VALUES('o','orderDim',3,'n','(List(%),SparseEchelonMatrix(JB,%),NonNegativeInteger)->NonNegativeInteger','cJetBundleFunctionCategory(JB)',NULL,'\spad{orderDim(sys,{} jm,{} q)} computes the dimension of the manifold described by the system \spad{sys} with Jacobi matrix \spad{jm} in the jet bundle of order \spad{q} over the jet bundle of order \spad{q-1}.');
INSERT INTO olibdb VALUES('o','orderDim',3,'n','(List(S),SparseEchelonMatrix(JB,S),NonNegativeInteger)->NonNegativeInteger','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','ordinalAdd',2,'n','(%,%)->%','dSmallOrdinal',NULL,'\spad{ordinalAdd(o1,{} o2)} returns sum of \spad{o1} and \spad{o2} as ordered sets');
INSERT INTO olibdb VALUES('o','ordinalMul',2,'n','(%,%)->%','dSmallOrdinal',NULL,'\spad{ordinalMul(o1,{} o2)} returns product of \spad{o1} and \spad{o2} as ordered sets');
INSERT INTO olibdb VALUES('o','ordinalPower',2,'n','(%,%)->%','dSmallOrdinal',NULL,'\spad{ordinalPower(o1,{} o2)} returns \spad{o1} to power \spad{o2},{} where power is inductively defined using successive ordinal multiplication from the left');
INSERT INTO olibdb VALUES('o','orientedFacet',2,'n','(Integer,List(NonNegativeInteger))->%','dOrientedFacet',NULL,'Constructor for oriented facet oriented facet is always stored in vertex order orientation is calculated by the number of edges that have to be flipped to put it in order.');
INSERT INTO olibdb VALUES('o','orientedFacet',2,'n','(Integer,OrientedFacet)->%','dOrientedFacet',NULL,'Copy constructor which can change mul');
INSERT INTO olibdb VALUES('o','orientedFacetIfCan',1,'n','(List(%))->Union(%,failed)','dOrientedFacet',NULL,'Constructor for oriented face from its boundary. This is like filling-in the boundary,{} in that sense it is the inverse of ''boundary''. May fail,{} for instance in ''implied'' loops,{} where both ends of an edge are the same point. Also similar cases for higher order facets.');
INSERT INTO olibdb VALUES('o','orientedFacetSigned',1,'n','(List(Integer))->%','dOrientedFacet',NULL,'Constructor for oriented face which removes duplicates If the face is positive then we expect the sequence to be: + - + - ...');
INSERT INTO olibdb VALUES('o','orientedFacetUnsigned',1,'n','(List(Integer))->%','dOrientedFacet',NULL,'Constructor for oriented face which removes duplicates and ignores orientation');
INSERT INTO olibdb VALUES('o','orthogonalConvolution',2,'n','(%,%)->%','cDistributionCategory(R)',NULL,'\spad{orthogonalConvolution(x,{} y)} returns the orthogonal convolution of the distributions \spad{x} and \spad{y}');
INSERT INTO olibdb VALUES('o','orthogonalPolynomials',1,'n','(%)->Stream(SparseUnivariatePolynomial(Fraction(R)))','cDistributionCategory(R)','AND(has(R,IntegralDomain),not(has(R,Field)))','\spad{orthogonalPolynomials(x)} returns the stream of orthogonal polynomials.');
INSERT INTO olibdb VALUES('o','orthogonalPolynomials',1,'n','(%)->Stream(SparseUnivariatePolynomial(R))','cDistributionCategory(R)','has(R,Field)','\spad{orthogonalPolynomials(x)} returns the stream of orthogonal polynomials.');
INSERT INTO olibdb VALUES('o','orthonormalBasis',1,'x','(Matrix(Fraction(Polynomial(Integer))))->List(Matrix(Expression(Integer)))','pRadicalEigenPackage',NULL,'\spad{orthonormalBasis(m)} returns the orthogonal matrix \spad{b} such that \spad{b*m*(inverse b)} is diagonal. Error: if \spad{m} is not a symmetric matrix.');
INSERT INTO olibdb VALUES('o','outDegree',2,'n','(A,NonNegativeInteger)->NonNegativeInteger','xFiniteGraph&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','outDegree',2,'n','(A,NonNegativeInteger)->NonNegativeInteger','xPoset&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','outDegree',2,'n','(%,NonNegativeInteger)->NonNegativeInteger','cFiniteGraph(S)',NULL,'\spad{outDegree(s,{} a)} gives the number of arrows leading out of node ''a'' in graph \spad{''s''}');
INSERT INTO olibdb VALUES('o','outerProduct',2,'n','(S,S)->Matrix(R)','xVectorCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','outerProduct',2,'x','(%,%)->Matrix(R)','cVectorCategory(R)','has(R,Ring)','\spad{outerProduct(u,{} v)} constructs the matrix whose (\spad{i},{} \spad{j})\spad{''}th element is \spad{u}(\spad{i})\spad{*v}(\spad{j}).');
INSERT INTO olibdb VALUES('o','outlineRender',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{outlineRender(v,{} s)} displays the polygon outline showing either triangularized surface or a quadrilateral surface outline depending on the whether the \spadfun{diagonals} function has been set,{} for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is on,{} or does not display the polygon outline if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','output',1,'x','(OutputForm)->Void','pOutputPackage',NULL,'\spad{output(x)} displays the output form \spad{x} on the');
INSERT INTO olibdb VALUES('o','output',1,'x','(String)->Void','pOutputPackage',NULL,'\spad{output(s)} displays the string \spad{s} on the');
INSERT INTO olibdb VALUES('o','output',2,'x','(String,OutputForm)->Void','pOutputPackage',NULL,'\spad{output(s,{} x)} displays the string \spad{s} followed by the form \spad{x} on the');
INSERT INTO olibdb VALUES('o','outputArgs',4,'x','(String,String,P,TS)->Void','pNormalizationPackage(R,E,V,P,TS)',NULL,'\spad{outputArgs(s1,{} s2,{} p,{} ts)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','outputAsFortran',1,'n','(%)->Void','cFortranProgramCategory',NULL,'\spad{outputAsFortran(u)} translates \spad{u} into a legal FORTRAN subprogram.');
INSERT INTO olibdb VALUES('o','outputAsFortran',1,'x','(List(OutputForm))->Void','pSpecialOutputPackage',NULL,'\spad{outputAsFortran(l)} sends (for each expression in the list \spad{l}) output in FORTRAN format to the destination defined by \spadsys{)set output fortran}.');
INSERT INTO olibdb VALUES('o','outputAsFortran',1,'x','(OutputForm)->Void','pSpecialOutputPackage',NULL,'\spad{outputAsFortran(o)} sends output \spad{o} in FORTRAN format.');
INSERT INTO olibdb VALUES('o','outputAsFortran',2,'x','(String,OutputForm)->Void','pSpecialOutputPackage',NULL,'\spad{outputAsFortran(v,{} o)} sends output \spad{v} = \spad{o} in FORTRAN format to the destination defined by \spadsys{)set output fortran}.');
INSERT INTO olibdb VALUES('o','outputAsMathML',1,'x','(List(OutputForm))->Void','pSpecialOutputPackage',NULL,'\spad{outputAsMathML(l)} sends (for each expression in the list \spad{l}) output in MathML format to the destination as defined by \spadsys{)set output mathml}.');
INSERT INTO olibdb VALUES('o','outputAsMathML',1,'x','(OutputForm)->Void','pSpecialOutputPackage',NULL,'\spad{outputAsMathML(o)} sends output \spad{o} in MathML format to the destination as defined by \spadsys{)set output mathml}.');
INSERT INTO olibdb VALUES('o','outputAsTex',1,'x','(List(OutputForm))->Void','pSpecialOutputPackage',NULL,'\spad{outputAsTex(l)} sends (for each expression in the list \spad{l}) output in Tex format to the destination as defined by \spadsys{)set output tex}.');
INSERT INTO olibdb VALUES('o','outputAsTex',1,'x','(OutputForm)->Void','pSpecialOutputPackage',NULL,'\spad{outputAsTex(o)} sends output \spad{o} in Tex format to the destination defined by \spadsys{)set output tex}.');
INSERT INTO olibdb VALUES('o','outputFixed',0,'x','()->Void','dFloat',NULL,'\spad{outputFixed()} sets the output mode to fixed point notation; the output will contain a decimal point.');
INSERT INTO olibdb VALUES('o','outputFixed',1,'x','(NonNegativeInteger)->Void','dFloat',NULL,'\spad{outputFixed(n)} sets the output mode to fixed point notation,{} with \spad{n} digits displayed after the decimal point.');
INSERT INTO olibdb VALUES('o','outputFloating',0,'x','()->Void','dFloat',NULL,'\spad{outputFloating()} sets the output mode to floating (scientific) notation,{} \spadignore{i.e.} \spad{mantissa * 10 exponent} is displayed as \spad{0.mantissa E exponent}.');
INSERT INTO olibdb VALUES('o','outputFloating',1,'x','(NonNegativeInteger)->Void','dFloat',NULL,'\spad{outputFloating(n)} sets the output mode to floating (scientific) notation with \spad{n} significant digits displayed after the decimal point.');
INSERT INTO olibdb VALUES('o','outputForm',1,'n','(Integer)->%','dOutputForm',NULL,'\spad{outputForm(n)} creates a form for an integer.');
INSERT INTO olibdb VALUES('o','outputForm',1,'n','(String)->%','dOutputForm',NULL,'\spad{outputForm(s)} creates a form for a string.');
INSERT INTO olibdb VALUES('o','outputForm',1,'n','(Symbol)->%','dOutputForm',NULL,'\spad{outputForm(s)} creates a form for a symbol.');
INSERT INTO olibdb VALUES('o','outputForm',2,'n','(%,OutputForm)->OutputForm','dSparseUnivariatePolynomial(R)',NULL,'\spad{outputForm(p,{} var)} converts the SparseUnivariatePolynomial \spad{p} to an output form (see \spadtype{OutputForm}) printed as a polynomial in the output form \spad{var}.');
INSERT INTO olibdb VALUES('o','outputForm',2,'n','(%,OutputForm)->OutputForm','dSparseUnivariateSkewPolynomial(R,sigma,delta)',NULL,'\spad{outputForm(p,{} x)} returns the output form of \spad{p} using \spad{x} for the otherwise anonymous variable.');
INSERT INTO olibdb VALUES('o','outputForm',4,'n','(%,(OutputForm,OutputForm)->OutputForm,(OutputForm,OutputForm)->OutputForm,Integer)->OutputForm','dListMonoidOps(S,E,un)',NULL,'\spad{outputForm(l,{} fop,{} fexp,{} unit)} converts the monoid element represented by \spad{l} to an \spadtype{OutputForm}. Argument unit is the output form for the \spadignore{unit} of the monoid (\spadignore{e.g.} 0 or 1),{} \spad{fop(a,{} b)} is the output form for the monoid operation applied to \spad{a} and \spad{b} (\spadignore{e.g.} \spad{a + b},{} \spad{a * b},{} \spad{ab}),{} and \spad{fexp(a,{} n)} is the output form for the exponentiation operation applied to \spad{a} and \spad{n} (\spadignore{e.g.} \spad{n a},{} \spad{n * a},{} \spad{a ^ n},{} \spad{a\^n}).');
INSERT INTO olibdb VALUES('o','outputGeneral',0,'x','()->Void','dFloat',NULL,'\spad{outputGeneral()} sets the output mode (default mode) to general notation; numbers will be displayed in either fixed or floating (scientific) notation depending on the magnitude.');
INSERT INTO olibdb VALUES('o','outputGeneral',1,'x','(NonNegativeInteger)->Void','dFloat',NULL,'\spad{outputGeneral(n)} sets the output mode to general notation with \spad{n} significant digits displayed.');
INSERT INTO olibdb VALUES('o','outputList',1,'x','(List(Any))->Void','pOutputPackage',NULL,'\spad{outputList(l)} displays the concatenated components of the list \spad{l} on the');
INSERT INTO olibdb VALUES('o','outputSpacing',1,'x','(NonNegativeInteger)->NonNegativeInteger','dFloat',NULL,'\spad{outputSpacing(n)} inserts an underscore after \spad{n} (default 10) digits on output; outputSpacing(0) means no underscores are inserted. Returns old setting.');
INSERT INTO olibdb VALUES('o','outputVRML',2,'n','(%,TextFile)->Void','dXmlAttribute',NULL,'\spad{outputVRML(rp,{} f1)} writes the attribute as \spad{VRML2}. \spad{VRML2} is not \spad{xml} but it has the same semantics and node names as \spad{X3D} but a different syntax so it makes sense to create an \spad{XML} structure and then format the output differently.');
INSERT INTO olibdb VALUES('o','outputVRML',2,'n','(%,TextFile)->Void','dXmlElement',NULL,'\spad{outputVRML(rp,{} f1)} writes the element as \spad{VRML2}. \spad{VRML2} is not \spad{xml} but it has the same semantics and node names as \spad{X3D} but a different syntax so it makes sense to create an \spad{XML} structure and then format the output differently.');
INSERT INTO olibdb VALUES('o','over',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{over(f,{} g)} creates a form for the vertical fraction of \spad{f} over \spad{g}.');
INSERT INTO olibdb VALUES('o','overbar',1,'n','(%)->%','dOutputForm',NULL,'\spad{overbar(f)} creates the form \spad{f} with an overbar.');
INSERT INTO olibdb VALUES('o','overbar',2,'n','(Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{overbar(p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats arguments via \spad{hh(p,{} args)} and then draws a bar over the resulting box. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','overlabel',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{overlabel(x,{}f)} creates the form \spad{f} with \spad{x} overbar over the top.');
INSERT INTO olibdb VALUES('o','overlap',2,'n','(%,%)->Record(lm:%,mm:%,rm:%)','dFreeMonoid(S)',NULL,'\spad{overlap(x,{} y)} returns \spad{[l,{} m,{} r]} such that \spad{x = l * m},{} \spad{y = m * r} and \spad{l} and \spad{r} have no overlap,{} \spadignore{i.e.} \spad{overlap(l,{} r) = [l,{} 1,{} r]}.');
INSERT INTO olibdb VALUES('o','overset?',2,'n','(List(GR),List(List(GR)))->Boolean','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{overset?(s,{} sl)} returns \spad{true} if \spad{s} properly a sublist of a member of \spad{sl}; otherwise it returns \spad{false}');
INSERT INTO olibdb VALUES('o','P',1,'n','(List(NonNegativeInteger))->%','cJetBundleCategory',NULL,'\spad{P(ind)} generates the derivative of the only dependent variable \spad{wrt} the index \spad{ind}.');
INSERT INTO olibdb VALUES('o','P',1,'n','(List(NonNegativeInteger))->%','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(List(NonNegativeInteger))->S','xJetBundleBaseFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(List(NonNegativeInteger))->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(List(NonNegativeInteger))->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(NonNegativeInteger)->%','cJetBundleCategory',NULL,'\spad{P(i)} generates the \spad{i}\spad{-}th derivative of the only dependent variable \spad{wrt} the only independent variable.');
INSERT INTO olibdb VALUES('o','P',1,'n','(NonNegativeInteger)->%','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(NonNegativeInteger)->S','xJetBundleBaseFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(NonNegativeInteger)->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',1,'n','(NonNegativeInteger)->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,List(NonNegativeInteger))->%','cJetBundleCategory',NULL,'\spad{P(i,{} ind)} generates the derivative of the \spad{i}\spad{-}th dependent variable \spad{wrt} the index \spad{ind}. Whether \spad{ind} is interpreted as multi-index or as repeated index depends on the chosen notation.');
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,List(NonNegativeInteger))->%','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,List(NonNegativeInteger))->S','xJetBundleBaseFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,List(NonNegativeInteger))->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,List(NonNegativeInteger))->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,NonNegativeInteger)->%','cJetBundleCategory',NULL,'\spad{P(i,{} j)} generates the \spad{j}\spad{-}th derivative of the \spad{i}\spad{-}th independent variable \spad{wrt} the only independent variable.');
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,NonNegativeInteger)->%','cJetBundleFunctionCategory(JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,NonNegativeInteger)->S','xJetBundleBaseFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,NonNegativeInteger)->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','P',2,'n','(PositiveInteger,NonNegativeInteger)->S','xJetBundleFunctionCategory&(S,JB)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pack!',1,'x','(%)->%','dKeyedAccessFile(Entry)',NULL,'\spad{pack!(f)} reorganizes the file \spad{f} on disk to recover unused space.');
INSERT INTO olibdb VALUES('o','pack!',1,'x','(%)->%','dLibrary',NULL,'\spad{pack!(f)} reorganizes the file \spad{f} on disk to recover unused space.');
INSERT INTO olibdb VALUES('o','packageCall',1,'n','(Symbol)->InputForm','pInputFormFunctions1(R)',NULL,'\spad{packageCall(f)} returns the input form corresponding to \spad{f}\$\spad{R}.');
INSERT INTO olibdb VALUES('o','packageCall',2,'n','(Symbol,List(InputForm))->InputForm','pInputFormFunctions1(R)',NULL,'\spad{packageCall(f,{} l)} returns the input form corresponding to \spad{f}(\spad{l}.1,{} \spad{l}.2,{} ...)\$\spad{R}.');
INSERT INTO olibdb VALUES('o','pack_exps0',4,'n','(SortedExponentVector,List(Integer),Integer,Integer)->Void','dModularAlgebraicGcdTools3',NULL,'\spad{pack_exps0(exps,{} sizes,{} ns,{} start)} is used by pack_exps.');
INSERT INTO olibdb VALUES('o','pack_exps',3,'n','(Integer,Integer,MD)->SortedExponentVector','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{pack_exps(d,{} s,{} m)} produces vector of exponents up to degree \spad{d}. \spad{s} is size (degree) of algebraic extension. Use together with \spad{repack1}.');
INSERT INTO olibdb VALUES('o','pack_modulus',3,'n','(List(MP),List(Symbol),Integer)->Union(MD,failed)','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{pack_modulus(lp,{} ls,{} p)} converts \spad{lp},{} \spad{ls} and prime \spad{p} which together describe algebraic extension to packed representation.');
INSERT INTO olibdb VALUES('o','pad',4,'n','(NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->(%)->%','dOutputBox',NULL,'\spad{pad(t,{} b,{} l,{} r)(box)} returns a new box that is padded by \spad{t} empty lines at the top,{} \spad{b} empty lines at the bottom,{} \spad{l} space characters at the left,{} \spad{r} space characters at the right. If \spad{w},{} \spad{h},{} \spad{d} are the width,{} height and depth of box then the resulting box will have width l+w+r and height \spad{t+h} and depth \spad{d+b}.');
INSERT INTO olibdb VALUES('o','pade',3,'x','(NonNegativeInteger,NonNegativeInteger,UnivariateTaylorSeries(R,x,pt))->Union(Fraction(UnivariatePolynomial(x,R)),failed)','pPadeApproximantPackage(R,x,pt)',NULL,'\spad{pade(nd,{} dd,{} s)} computes the quotient of polynomials (if it exists) with numerator degree at most \spad{nd} and denominator degree at most \spad{dd} which matches the series \spad{s} to order \spad{nd + dd}.');
INSERT INTO olibdb VALUES('o','pade',4,'n','(NonNegativeInteger,NonNegativeInteger,PS,PS)->Union(Fraction(UP),failed)','pPadeApproximants(R,PS,UP)',NULL,'\spad{pade(nd,{} dd,{} ns,{} ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).');
INSERT INTO olibdb VALUES('o','pade',4,'x','(NonNegativeInteger,NonNegativeInteger,UnivariateTaylorSeries(R,x,pt),UnivariateTaylorSeries(R,x,pt))->Union(Fraction(UnivariatePolynomial(x,R)),failed)','pPadeApproximantPackage(R,x,pt)',NULL,'\spad{pade(nd,{} dd,{} ns,{} ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).');
INSERT INTO olibdb VALUES('o','padecf',4,'n','(NonNegativeInteger,NonNegativeInteger,PS,PS)->Union(ContinuedFraction(UP),failed)','pPadeApproximants(R,PS,UP)',NULL,'\spad{padecf(nd,{} dd,{} ns,{} ds)} computes the approximant as a continued fraction of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).');
INSERT INTO olibdb VALUES('o','padicallyExpand',2,'x','(R,R)->SparseUnivariatePolynomial(R)','dPartialFraction(R)',NULL,'\spad{padicallyExpand(p,{} x)} is a utility function that expands the second argument \spad{x} \spad{');
INSERT INTO olibdb VALUES('o','padicFraction',1,'x','(%)->%','dPartialFraction(R)',NULL,'\spad{padicFraction(q)} expands the fraction \spad{p}-adically in the primes \spad{p} in the denominator of \spad{q}. For example,{} \spad{padicFraction(3/(2^2)) = 1/2 + 1/(2^2)}. Use \spadfunFrom{compactFraction}{PartialFraction} to return to compact form.');
INSERT INTO olibdb VALUES('o','pair?',1,'x','(%)->Boolean','cSExpressionCategory(Str,Sym,Int,Flt)',NULL,'\spad{pair?(s)} is \spad{true} if \spad{s} has is a non-null Lisp list.');
INSERT INTO olibdb VALUES('o','palgint0',5,'n','(F,Kernel(F),Kernel(F),F,SparseUnivariatePolynomial(F))->IntegrationResult(F)','pGenusZeroIntegration(R,F,L)',NULL,'\spad{palgint0(f,{} x,{} y,{} d,{} p)} returns the integral of \spad{f(x,{} y)dx} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2 y(x)\^2 = P(x)}.');
INSERT INTO olibdb VALUES('o','palgint0',7,'n','(F,Kernel(F),Kernel(F),Kernel(F),F,Fraction(SparseUnivariatePolynomial(F)),F)->IntegrationResult(F)','pGenusZeroIntegration(R,F,L)',NULL,'\spad{palgint0(f,{} x,{} y,{} z,{} t,{} c)} returns the integral of \spad{f(x,{} y)dx} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{x = eval(t,{} z,{} ry)} and \spad{c = d/dz t}; \spad{r} is rational function of \spad{x},{} \spad{c} and \spad{t} are rational functions of \spad{z}. Argument \spad{z} is a dummy variable not appearing in \spad{f(x,{} y)}.');
INSERT INTO olibdb VALUES('o','palgint',3,'n','(F,Kernel(F),Kernel(F))->IntegrationResult(F)','pPureAlgebraicIntegration(R,F,L)',NULL,'\spad{palgint(f,{} x,{} y)} returns the integral of \spad{f(x,{} y)dx} where \spad{y} is an algebraic function of \spad{x}.');
INSERT INTO olibdb VALUES('o','palgintegrate',3,'n','(R,F,(UP)->UP)->Record(result1:IntegrationResult(R),result2:F)','pAlgebraicIntegrate(R0,F,UP,UPUP,R)',NULL,'\spad{palgintegrate(f,{} x,{} d)} integrates \spad{f} with respect to the derivation \spad{d}. Argument \spad{f} must be a pure algebraic function.');
INSERT INTO olibdb VALUES('o','palgLODE0',6,'n','(L,F,Kernel(F),Kernel(F),F,SparseUnivariatePolynomial(F))->Record(particular:Union(F,failed),basis:List(F))','pGenusZeroIntegration(R,F,L)','has(L,LinearOrdinaryDifferentialOperatorCategory(F))','\spad{palgLODE0(op,{} g,{} x,{} y,{} d,{} p)} returns the solution of \spad{op f = g}. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2y(x)\^2 = P(x)}.');
INSERT INTO olibdb VALUES('o','palgLODE0',8,'n','(L,F,Kernel(F),Kernel(F),Kernel(F),F,Fraction(SparseUnivariatePolynomial(F)),F)->Record(particular:Union(F,failed),basis:List(F))','pGenusZeroIntegration(R,F,L)','has(L,LinearOrdinaryDifferentialOperatorCategory(F))','\spad{palgLODE0(op,{} g,{} x,{} y,{} z,{} t,{} c)} returns the solution of \spad{op f = g}. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{x = eval(t,{} z,{} ry)} and \spad{c = d/dz t}; \spad{r} is rational function of \spad{x},{} \spad{c} and \spad{t} are rational functions of \spad{z}.');
INSERT INTO olibdb VALUES('o','palgLODE',5,'n','(L,F,Kernel(F),Kernel(F),Symbol)->Record(particular:Union(F,failed),basis:List(F))','pPureAlgebraicIntegration(R,F,L)','has(L,LinearOrdinaryDifferentialOperatorCategory(F))','\spad{palgLODE(op,{} g,{} kx,{} y,{} x)} returns the solution of \spad{op f = g}. \spad{y} is an algebraic function of \spad{x}.');
INSERT INTO olibdb VALUES('o','palgRDE0',7,'n','(F,F,Kernel(F),Kernel(F),(F,F,Symbol)->Union(F,failed),F,SparseUnivariatePolynomial(F))->Union(F,failed)','pGenusZeroIntegration(R,F,L)',NULL,'\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} d,{} p)} returns a function \spad{z(x,{} y)} such that \spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \spad{z} exists,{} and failed otherwise. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2y(x)\^2 = P(x)}. Argument \spad{foo},{} called by \spad{foo(a,{} b,{} x)},{} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}.');
INSERT INTO olibdb VALUES('o','palgRDE0',9,'n','(F,F,Kernel(F),Kernel(F),(F,F,Symbol)->Union(F,failed),Kernel(F),F,Fraction(SparseUnivariatePolynomial(F)),F)->Union(F,failed)','pGenusZeroIntegration(R,F,L)',NULL,'\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} t,{} c)} returns a function \spad{z(x,{} y)} such that \spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \spad{z} exists,{} and failed otherwise. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{x = eval(t,{} z,{} ry)} and \spad{c = d/dz t}; \spad{r} is rational function of \spad{x},{} \spad{c} and \spad{t} are rational functions of \spad{z}. Argument \spad{foo},{} called by \spad{foo(a,{} b,{} x)},{} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}.');
INSERT INTO olibdb VALUES('o','palgRDE',6,'n','(F,F,F,Kernel(F),Kernel(F),(F,F,Symbol)->Union(F,failed))->Union(F,failed)','pPureAlgebraicIntegration(R,F,L)',NULL,'\spad{palgRDE(nfp,{} f,{} g,{} x,{} y,{} foo)} returns a function \spad{z(x,{} y)} such that \spad{dz/dx + n * df/dx z(x,{} y) = g(x,{} y)} if such a \spad{z} exists,{} failed otherwise; \spad{y} is an algebraic function of \spad{x}; \spad{foo(a,{} b,{} x)} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}. \spad{nfp} is \spad{n * df/dx}.');
INSERT INTO olibdb VALUES('o','parabolic',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{parabolic(pt)} transforms \spad{pt} from parabolic coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{} v)} to \spad{x = 1/2*(u^2 - v^2)},{} \spad{y = u*v}.');
INSERT INTO olibdb VALUES('o','parabolicCylindrical',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{parabolicCylindrical(pt)} transforms \spad{pt} from parabolic cylindrical coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{} v,{} z)} to \spad{x = 1/2*(u^2 - v^2)},{} \spad{y = u*v},{} \spad{z}.');
INSERT INTO olibdb VALUES('o','paraboloidal',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{paraboloidal(pt)} transforms \spad{pt} from paraboloidal coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{} v,{} phi)} to \spad{x = u*v*cos(phi)},{} \spad{y = u*v*sin(phi)},{} \spad{z = 1/2 * (u^2 - v^2)}.');
INSERT INTO olibdb VALUES('o','parallel',2,'n','(%,%)->DoubleFloat','cSPointCategory',NULL,'\spad{parallel(x,{} y)} returns the length of the parallel component of two vectors. In the case of Euclidean space this is the dot product of two vectors. We use this function to test the colinearity');
INSERT INTO olibdb VALUES('o','parametersOf',1,'n','(%)->List(Symbol)','dSymbolTable',NULL,'\spad{parametersOf(tab)} returns a list of all the symbols declared in \spad{tab}');
INSERT INTO olibdb VALUES('o','parametric?',1,'n','(%)->Boolean','dPlot',NULL,'\spad{parametric? determines} whether it is a parametric plot?');
INSERT INTO olibdb VALUES('o','param_LODE',4,'n','(List(F),List(F),Kernel(F),Kernel(F))->Record(particular:List(Record(ratpart:F,coeffs:Vector(F))),basis:List(F))','pPureAlgebraicIntegration(R,F,L)',NULL,'\spad{param_LODE(eq,{} lg,{} x,{} y)}');
INSERT INTO olibdb VALUES('o','param_rde2',6,'n','(F,List(F),Symbol,List(Kernel(F)),(List(Kernel(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F))),(List(Kernel(F)),List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer)))))->List(Record(ratpart:F,coeffs:Vector(F)))','pParametricRischDE(R,F)',NULL,'\spad{param_rde2(fp,{} lg,{} x,{} lk,{} ext,{} logi)} finds basis of solution to the equation dy/dx + \spad{fp} \spad{y} + \spad{c1} \spad{g1} + ... \spad{cn} \spad{gn} = 0 where \spad{y} is in field generated by \spad{lk} and \spad{ci} are constants.');
INSERT INTO olibdb VALUES('o','param_RDE',4,'n','(F,List(F),Kernel(F),Kernel(F))->Record(particular:List(Record(ratpart:F,coeffs:Vector(F))),basis:List(F))','pPureAlgebraicIntegration(R,F,L)',NULL,'\spad{param_RDE(fp,{} lg,{} x,{} y)}');
INSERT INTO olibdb VALUES('o','param_rde',7,'n','(Integer,F,List(F),Symbol,List(Kernel(F)),(List(Kernel(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F))),(List(Kernel(F)),List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer)))))->List(Record(ratpart:F,coeffs:Vector(F)))','pParametricRischDE(R,F)',NULL,'\spad{param_rde(n,{} f,{} lg,{} x,{} lk,{} ext,{} logi)} finds basis of solution to the equation dy/dx + \spad{n} df/dx \spad{y} + \spad{c1} \spad{g1} + ... \spad{cn} \spad{gn} = 0 where \spad{y} is in field generated by \spad{lk} and \spad{ci} are constants.');
INSERT INTO olibdb VALUES('o','param_rde',8,'n','(Integer,F,F,List(F),Symbol,List(Kernel(F)),(List(Kernel(F)),List(F))->List(Record(ratpart:F,coeffs:Vector(F))),(List(Kernel(F)),List(F))->Record(logands:List(F),basis:List(Vector(Fraction(Integer)))))->Record(particular:Union(Record(ratpart:F,coeffs:Vector(F)),failed),basis:List(Record(ratpart:F,coeffs:Vector(F))))','pParametricRischDE(R,F)',NULL,'\spad{param_rde(n,{} f,{} h,{} lg,{} x,{} lk,{} ext,{} logi)} finds a particular solution and basis of solutions to homogeneous equation for equation dy/dx + \spad{n} df/dx \spad{y} + \spad{c1} \spad{g1} + ... \spad{cn} \spad{gn} = \spad{h} where \spad{y} is in field generated by \spad{lk} and \spad{ci} are constants.');
INSERT INTO olibdb VALUES('o','ParCond',2,'n','(Matrix(GR),NonNegativeInteger)->List(Record(det:GR,rows:List(Integer),cols:List(Integer)))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{ParCond(m,{} k)} returns the list of all \spad{k} by \spad{k} subdeterminants in the matrix \spad{m}');
INSERT INTO olibdb VALUES('o','ParCondList',2,'n','(Matrix(GR),NonNegativeInteger)->List(Record(rank:NonNegativeInteger,eqns:List(Record(det:GR,rows:List(Integer),cols:List(Integer))),fgb:List(GR)))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{ParCondList(c,{} r)} computes a list of subdeterminants of each rank \spad{>=} \spad{r} of the matrix \spad{c} and returns a groebner basis for the ideal they generate');
INSERT INTO olibdb VALUES('o','paren',1,'n','(%)->%','dOutputForm',NULL,'\spad{paren(f)} creates the form enclosing \spad{f} in parentheses.');
INSERT INTO olibdb VALUES('o','paren',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{paren(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in parentheses.');
INSERT INTO olibdb VALUES('o','paren',1,'n','(S)->S','xExpressionSpace2&(S,K)',NULL,NULL);
INSERT INTO olibdb VALUES('o','paren',1,'x','(%)->%','cExpressionSpace2(K)',NULL,'\spad{paren(f)} returns (\spad{f}). This prevents \spad{f} from being evaluated when operators are applied to it. For example,{} \spad{log(1)} returns 0,{} but \spad{log(paren 1)} returns the formal kernel log((1)).');
INSERT INTO olibdb VALUES('o','parent',1,'n','(%)->%','dSubSpace(n,R)',NULL,'\spad{parent(s)} returns the subspace which is the parent of the indicated 3 dimensional subspace \spad{s}. If \spad{s} is the top level subspace an error message is returned.');
INSERT INTO olibdb VALUES('o','parenthesize',3,'n','(String,String,OutputBox)->OutputBox','cFormatterCategory',NULL,'\spad{parenthesize(lb,{} rb,{} bx)} returns the box \spad{bx} with left and right brackets (\spad{lb} and \spad{rb}) around it.');
INSERT INTO olibdb VALUES('o','parenthesizeIf',2,'n','(Boolean,OutputBox)->OutputBox','cFormatterCategory',NULL,'\spad{parenthesizeIf(paren?,{} bx)} returns parentheses (of appropriate size if \spad{paren?} is \spad{true}. Otherwise,{} \spad{bx} is returned.');
INSERT INTO olibdb VALUES('o','parenthesizeIf',2,'n','(Boolean,OutputBox)->OutputBox','xFormatterCategory&(S)',NULL,'\spad{parenthesizeIf(paren?,{} bx)} returns parentheses (of appropriate size if \spad{paren?} is \spad{true}. Otherwise,{} \spad{bx} is returned.');
INSERT INTO olibdb VALUES('o','parse',1,'n','(String)->%','dInputForm',NULL,'\spad{parse(s)} is the inverse of unparse. It parses a string to InputForm');
INSERT INTO olibdb VALUES('o','parseIL',1,'n','(String)->%','dILogic',NULL,'Constructs intuitionistic logic terms from a string notation assumes format like this: <term> : \spad{:=} var | <term>/\spad{\<}term> | <term>\spad{\/}<term> | \indented{11}{<term>-><term> | (<term>)}');
INSERT INTO olibdb VALUES('o','parseIL2',2,'n','(String,NonNegativeInteger)->Record(rft:%,pout:NonNegativeInteger)','dILogic',NULL,'Constructs intuitionistic logic terms from a string notation assumes format like this: <term2> : \spad{:=} var | (<term>) <term> : \spad{:=} var | <term>/\spad{\<}term> | <term>\spad{\/}<term> | \indented{11}{<term>-><term> | (<term>)}');
INSERT INTO olibdb VALUES('o','parseILTerm',2,'n','(String,NonNegativeInteger)->Record(rft:%,pout:NonNegativeInteger)','dILogic',NULL,'parseTerm is used by parseIL. It would rarely be called externally but it is here to allow it to call parseIL that is to allow circular calls');
INSERT INTO olibdb VALUES('o','parse_integer',1,'n','(String)->Integer','pScanningUtilities',NULL,'\spad{parse_integer(s)} converts string of digits \spad{s} into integer');
INSERT INTO olibdb VALUES('o','parseLambda',1,'n','(String)->%','dLambda(UT)',NULL,'Constructs nested lambda terms from a string notation assumes format like this: <term> : \spad{:=} \spad{\} var .<term> | \spad{n} | <term><term> | (<term>) where: \\ = lambda (\spad{I} would like to use unicode lambda symbol but \indented{12}{\spad{I} would also like to keep maximum compatibility} \indented{12}{with non-unicode versions of Lisp)} \spad{n} = De Bruijn index which is a integer where,{} 1=inside inner \indented{12}{lambda term,{} 2= next outer lambda term,{} 3= next} \indented{12}{outer and so on.} brackets can be used around whole terms.');
INSERT INTO olibdb VALUES('o','parseSki',1,'n','(String)->%','dSKICombinators(UT)',NULL,'Constructs combinators from a string');
INSERT INTO olibdb VALUES('o','parseTerm',2,'n','(String,NonNegativeInteger)->Record(rft:%,pout:NonNegativeInteger)','dLambda(UT)',NULL,'parseTerm is used by parseLambda. It would rarely be called externally but it is here to allow it to call parseLambda that is to allow circular calls');
INSERT INTO olibdb VALUES('o','parseTerm',2,'n','(String,NonNegativeInteger)->Record(rft:%,pout:NonNegativeInteger)','dSKICombinators(UT)',NULL,'parseTerm is used by parseSki. It would rarely be called externally but it is here to allow it to call parseSki that is to allow circular calls');
INSERT INTO olibdb VALUES('o','parseVar',1,'n','(String)->%','cVarCat',NULL,'construct a variable by parsing a string');
INSERT INTO olibdb VALUES('o','parseVarTerm',2,'n','(String,NonNegativeInteger)->Record(rft:%,pout:NonNegativeInteger)','cVarCat',NULL,'construct a variable by parsing a string pin is index to string at start of parse pout is index to string at end of parse');
INSERT INTO olibdb VALUES('o','partial',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{partial()} returns symbol for partial derivative.');
INSERT INTO olibdb VALUES('o','partialDenominators',1,'x','(%)->Stream(R)','dContinuedFraction(R)',NULL,'\spad{partialDenominators(x)} extracts the denominators in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \spad{partialDenominators(x) = [b1,{} b2,{} b3,{} ...]}.');
INSERT INTO olibdb VALUES('o','partialFraction',1,'x','(Fraction(R))->%','dPartialFraction(R)','has(R,UniqueFactorizationDomain)','\spad{partialFraction(f)} is a user friendly interface for partial fractions when \spad{f} is a fraction of UniqueFactorizationDomain.');
INSERT INTO olibdb VALUES('o','partialFraction',2,'x','(Fraction(Polynomial(R)),Symbol)->Any','pPartialFractionPackage(R)',NULL,'\spad{partialFraction(rf,{} var)} returns the partial fraction decomposition of the rational function \spad{rf} with respect to the variable var.');
INSERT INTO olibdb VALUES('o','partialFraction',2,'x','(R,Factored(R))->%','dPartialFraction(R)',NULL,'\spad{partialFraction(numer,{} denom)} is the main function for constructing partial fractions. The second argument is the denominator and should be factored.');
INSERT INTO olibdb VALUES('o','partialFraction',3,'x','(Polynomial(R),Factored(Polynomial(R)),Symbol)->Any','pPartialFractionPackage(R)',NULL,'\spad{partialFraction(num,{} facdenom,{} var)} returns the partial fraction decomposition of the rational function whose numerator is \spad{num} and whose factored denominator is \spad{facdenom} with respect to the variable var.');
INSERT INTO olibdb VALUES('o','partialNumerators',1,'x','(%)->Stream(R)','dContinuedFraction(R)',NULL,'\spad{partialNumerators(x)} extracts the numerators in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \spad{partialNumerators(x) = [a1,{} a2,{} a3,{} ...]}.');
INSERT INTO olibdb VALUES('o','partialQuotients',1,'x','(%)->Stream(R)','dContinuedFraction(R)',NULL,'\spad{partialQuotients(x)} extracts the partial quotients in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{} a2,{} a3,{} ...],{} [b1,{} b2,{} b3,{} ...])},{} then \spad{partialQuotients(x) = [b0,{} b1,{} b2,{} b3,{} ...]}.');
INSERT INTO olibdb VALUES('o','particularSolution',1,'n','(UP)->F','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{particularSolution(u)} \undocumented');
INSERT INTO olibdb VALUES('o','particularSolution',2,'n','(Matrix(R),Vector(R))->Union(Vector(Fraction(S)),failed)','pLinearDependence(S,R)','NOT(has(S,Field))','\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such \spad{ci}\spad{''s} exist in the quotient field of \spad{S}.');
INSERT INTO olibdb VALUES('o','particularSolution',2,'n','(Matrix(R),Vector(R))->Union(Vector(S),failed)','pLinearDependence(S,R)','has(S,Field)','\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such \spad{ci}\spad{''s} exist in \spad{S}.');
INSERT INTO olibdb VALUES('o','particularSolution',2,'n','(Vector(R),R)->Union(Vector(Fraction(S)),failed)','pLinearDependence(S,R)','NOT(has(S,Field))','\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such \spad{ci}\spad{''s} exist in the quotient field of \spad{S}.');
INSERT INTO olibdb VALUES('o','particularSolution',2,'n','(Vector(R),R)->Union(Vector(S),failed)','pLinearDependence(S,R)','has(S,Field)','\spad{particularSolution([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such \spad{ci}\spad{''s} exist in \spad{S}.');
INSERT INTO olibdb VALUES('o','particularSolution',2,'x','(Matrix(F),Vector(F))->Union(Vector(F),failed)','pLinearSystemMatrixPackage1(F)',NULL,'\spad{particularSolution(A,{} B)} finds a particular solution of the linear system \spad{AX = B}.');
INSERT INTO olibdb VALUES('o','particularSolution',2,'x','(M,Col)->Union(Col,failed)','pLinearSystemMatrixPackage(F,Row,Col,M)',NULL,'\spad{particularSolution(A,{} B)} finds a particular solution of the linear system \spad{AX = B}.');
INSERT INTO olibdb VALUES('o','particularSolution',4,'n','(LODO,F,List(F),(F)->F)->Union(F,failed)','pODETools(F,LODO)',NULL,'\spad{particularSolution(op,{} g,{} [f1,{} ...,{} fm],{} I)} returns a particular solution \spad{h} of the equation \spad{op y = g} where \spad{[f1,{} ...,{} fm]} are linearly independent and \spad{op(\spad{fi})=0}. The value failed is returned if no particular solution is found. Note: the method of variations of parameters is used.');
INSERT INTO olibdb VALUES('o','particularSolutionOverConstants',3,'n','(Matrix(F),Vector(F),List((F)->F))->Union(Vector(F),failed)','pConstantLinearDependence(R,F)',NULL,'\spad{solveLinearlyOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such rational numbers \spad{ci}\spad{''s} exist.');
INSERT INTO olibdb VALUES('o','particularSolutionOverConstants',3,'n','(Vector(F),F,List((F)->F))->Union(Vector(F),failed)','pConstantLinearDependence(R,F)',NULL,'\spad{particularSolutionOverConstants([v1,{} ...,{} vn],{} u,{} ld)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such constants numbers \spad{ci}\spad{''s} exist.');
INSERT INTO olibdb VALUES('o','particularSolutionOverQ',2,'x','(Matrix(R),Vector(R))->Union(Vector(Fraction(Integer)),failed)','pIntegerLinearDependence(R)',NULL,'\spad{solveLinearlyOverQ([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such rational numbers \spad{ci}\spad{''s} exist.');
INSERT INTO olibdb VALUES('o','particularSolutionOverQ',2,'x','(Vector(R),R)->Union(Vector(Fraction(Integer)),failed)','pIntegerLinearDependence(R)',NULL,'\spad{particularSolutionOverQ([v1,{} ...,{} vn],{} u)} returns \spad{[c1,{} ...,{} cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} failed if no such rational numbers \spad{ci}\spad{''s} exist.');
INSERT INTO olibdb VALUES('o','partition',1,'n','(List(Integer))->%','dPartition',NULL,'\spad{partition(\spad{li})} converts a list of integers \spad{li} to a partition');
INSERT INTO olibdb VALUES('o','partition',1,'x','(I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{partition(n)} returns the number of partitions of the integer \spad{n}. This is the number of distinct ways that \spad{n} can be written as a sum of positive integers.');
INSERT INTO olibdb VALUES('o','partitions',1,'x','(Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{partitions(n)} is the stream of all partitions of \spad{n}.');
INSERT INTO olibdb VALUES('o','partitions',2,'x','(Integer,Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{partitions(p,{} l)} is the stream of all \indented{1}{partitions whose number of} \indented{1}{parts and largest part are no greater than \spad{p} and \spad{l}.}');
INSERT INTO olibdb VALUES('o','partitions',3,'x','(Integer,Integer,Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{partitions(p,{} l,{} n)} is the stream of partitions \indented{1}{of \spad{n} whose number of parts is no greater than \spad{p}} \indented{1}{and whose largest part is no greater than \spad{l}.}');
INSERT INTO olibdb VALUES('o','parts',1,'n','(A)->List(S)','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','parts',1,'n','(A)->List(S)','xRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','parts',1,'n','(S)->List(Entry)','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','parts',1,'n','(S)->List(Record(key:Key,entry:Entry))','xTableAggregate&(S,Key,Entry)',NULL,NULL);
INSERT INTO olibdb VALUES('o','parts',1,'n','(S)->List(R)','xTwoDimensionalArrayCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','parts',1,'x','(%)->List(R)','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{parts(m)} returns a list of the elements of \spad{m} in row major order');
INSERT INTO olibdb VALUES('o','parts',1,'x','(%)->List(S)','cHomogeneousAggregate(S)','has(%,finiteAggregate)','\spad{parts(u)} returns a list of the consecutive elements of \spad{u}. For finite collections,{} \spad{construct(parts(u)) = u}.');
INSERT INTO olibdb VALUES('o','pascalTriangle',2,'n','(NonNegativeInteger,Integer)->R','pGaloisGroupUtilities(R)',NULL,'\spad{pascalTriangle(n,{} r)} returns the binomial coefficient \spad{C(n,{} r)=n!/(r! (n-r)!)} and stores it in a table to prevent recomputation.');
INSERT INTO olibdb VALUES('o','pastel',1,'x','(Color)->%','dPalette',NULL,'\spad{pastel(c)} sets the shade of a hue,{} \spad{c},{} above bright,{} but below light.');
INSERT INTO olibdb VALUES('o','pa_to_sup',1,'n','(PrimitiveArray(K))->SparseUnivariatePolynomial(K)','pVectorPolynomialOperationsF(K)',NULL,'\spad{pa_to_sup(v)} converts vector of coefficients to a polynomial');
INSERT INTO olibdb VALUES('o','pa_to_sup',1,'n','(PrimitiveArray(PrimeField(p)))->SparseUnivariatePolynomial(Integer)','pVectorPolynomialOperationsP(p)',NULL,'\spad{pa_to_sup(v)} converts vector of coefficients to a polynomial');
INSERT INTO olibdb VALUES('o','pa_to_sup',1,'n','(U32Vector)->SparseUnivariatePolynomial(Integer)','pU32VectorPolynomialOperations',NULL,'\spad{pa_to_sup(v)} converts vector of coefficients to a polynomial');
INSERT INTO olibdb VALUES('o','pattern',1,'x','(%)->Pattern(Base)','dRewriteRule(Base,R,F)',NULL,'\spad{pattern(r)} returns the pattern corresponding to the left hand side of the rule \spad{r}.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(A,Pattern(Float),PatternMatchResult(Float,A))->PatternMatchResult(Float,A)','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(A,Pattern(Integer),PatternMatchResult(Integer,A))->PatternMatchResult(Integer,A)','xQuotientFieldCategory&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(A,Pattern(S),PatternMatchResult(S,B))->PatternMatchResult(S,B)','pPatternMatchPushDown(S,A,B)',NULL,'\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches. Note: this function handles type towers by changing the predicates and calling the matching function provided by \spad{A}.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(CS,Pattern(R),PatternMatchResult(R,CS))->PatternMatchResult(R,CS)','pComplexPatternMatch(R,S,CS)','has(Polynomial(S),PatternMatchable(R))','\spad{patternMatch(cexpr,{} pat,{} res)} matches the pattern \spad{pat} to the complex expression \spad{cexpr}. res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(F,Pattern(S),PatternMatchResult(S,F))->PatternMatchResult(S,F)','pPatternMatchFunctionSpace(S,R,F)',NULL,'\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(I,Pattern(Integer),PatternMatchResult(Integer,I))->PatternMatchResult(Integer,I)','pPatternMatchIntegerNumberSystem(I)',NULL,'\spad{patternMatch(n,{} pat,{} res)} matches the pattern \spad{pat} to the integer \spad{n}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(Kernel(E),Pattern(S),PatternMatchResult(S,E))->PatternMatchResult(S,E)','pPatternMatchKernel(S,E)',NULL,'\spad{patternMatch(f(e1,{} ...,{} en),{} pat,{} res)} matches the pattern \spad{pat} to \spad{f(e1,{} ...,{} en)}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(L,Pattern(S),PatternMatchListResult(S,R,L))->PatternMatchListResult(S,R,L)','pPatternMatchListAggregate(S,R,L)',NULL,'\spad{patternMatch(l,{} pat,{} res)} matches the pattern \spad{pat} to the list \spad{l}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(P,Pattern(S),PatternMatchResult(S,P))->PatternMatchResult(S,P)','pPatternMatchPolynomialCategory(S,E,V,R,P)','has(V,PatternMatchable(S))','\spad{patternMatch(p,{} pat,{} res)} matches the pattern \spad{pat} to the polynomial \spad{p}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(Q,Pattern(S),PatternMatchResult(S,Q))->PatternMatchResult(S,Q)','pPatternMatchQuotientFieldCategory(S,R,Q)',NULL,'\spad{patternMatch(a/b,{} pat,{} res)} matches the pattern \spad{pat} to the quotient \spad{a/b}; res contains the variables of \spad{pat} which are already matched and their matches.');
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Float),PatternMatchResult(Float,S))->PatternMatchResult(Float,S)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Float),PatternMatchResult(Float,S))->PatternMatchResult(Float,S)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Float),PatternMatchResult(Float,S))->PatternMatchResult(Float,S)','xRealNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Integer),PatternMatchResult(Integer,S))->PatternMatchResult(Integer,S)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Integer),PatternMatchResult(Integer,S))->PatternMatchResult(Integer,S)','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(S,Pattern(Integer),PatternMatchResult(Integer,S))->PatternMatchResult(Integer,S)','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','patternMatch',3,'n','(Symbol,Pattern(S),PatternMatchResult(S,Symbol))->PatternMatchResult(S,Symbol)','pPatternMatchSymbol(S)',NULL,'\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches (necessary for recursion).');
INSERT INTO olibdb VALUES('o','patternMatch',3,'x','(%,Pattern(S),PatternMatchResult(S,%))->PatternMatchResult(S,%)','cPatternMatchable(S)',NULL,'\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}. res contains the variables of \spad{pat} which are already matched and their matches (necessary for recursion). Initially,{} res is just the result of \spadfun{new} which is an empty list of matches.');
INSERT INTO olibdb VALUES('o','patternMatch',4,'n','(P,Pattern(S),PatternMatchResult(S,P),(V,Pattern(S),PatternMatchResult(S,P))->PatternMatchResult(S,P))->PatternMatchResult(S,P)','pPatternMatchPolynomialCategory(S,E,V,R,P)',NULL,'\spad{patternMatch(p,{} pat,{} res,{} vmatch)} matches the pattern \spad{pat} to the polynomial \spad{p}. \spad{res} contains the variables of \spad{pat} which are already matched and their matches; vmatch is the matching function to use on the variables.');
INSERT INTO olibdb VALUES('o','patternMatch',5,'n','(List(P),List(Pattern(S)),(List(P))->P,PatternMatchResult(S,P),(P,Pattern(S),PatternMatchResult(S,P))->PatternMatchResult(S,P))->PatternMatchResult(S,P)','pPatternMatchTools(S,R,P)',NULL,'\spad{patternMatch(lsubj,{} lpat,{} op,{} res,{} match)} matches the list of patterns \spad{lpat} to the list of subjects \spad{lsubj},{} allowing for commutativity; \spad{op} is the operator such that \spad{op}(\spad{lpat}) should match \spad{op}(\spad{lsubj}) at the end,{} \spad{r} contains the previous matches,{} and match is a pattern-matching function on \spad{P}.');
INSERT INTO olibdb VALUES('o','patternMatchTimes',4,'n','(List(P),List(Pattern(S)),PatternMatchResult(S,P),(P,Pattern(S),PatternMatchResult(S,P))->PatternMatchResult(S,P))->PatternMatchResult(S,P)','pPatternMatchTools(S,R,P)',NULL,'\spad{patternMatchTimes(lsubj,{} lpat,{} res,{} match)} matches the product of patterns \spad{reduce(*,{} lpat)} to the product of subjects \spad{reduce(*,{} lsubj)}; \spad{r} contains the previous matches and match is a pattern-matching function on \spad{P}.');
INSERT INTO olibdb VALUES('o','patternVariable',4,'n','(Symbol,Boolean,Boolean,Boolean)->%','dPattern(R)',NULL,'\spad{patternVariable(x,{} c?,{} o?,{} m?)} creates a pattern variable \spad{x},{} which is constant if \spad{c? = true},{} optional if \spad{o? = true},{} and multiple if \spad{m? = true}.');
INSERT INTO olibdb VALUES('o','pdct',1,'n','(%)->Integer','dPartition',NULL,'\spad{pdct(a1^n1 a2^n2 ...)} returns \spad{n1! * a1^n1 * n2! * a2^n2 * ...}. This function is used in the package \spadtype{CycleIndicators}.');
INSERT INTO olibdb VALUES('o','pencil',1,'n','(%)->LinearMultivariateMatrixPencil(F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{pencil(f)} returns a pointer to the underlying pencil.');
INSERT INTO olibdb VALUES('o','perfectNthPower?',2,'x','(I,NonNegativeInteger)->Boolean','pIntegerRoots(I)',NULL,'\spad{perfectNthPower?(n,{} r)} returns \spad{true} if \spad{n} is an \spad{r}th power and \spad{false} otherwise');
INSERT INTO olibdb VALUES('o','perfectNthRoot',1,'x','(I)->Record(base:I,exponent:NonNegativeInteger)','pIntegerRoots(I)',NULL,'\spad{perfectNthRoot(n)} returns \spad{[x,{} r]},{} where \spad{n = x\^r} and \spad{r} is the largest integer such that \spad{n} is a perfect \spad{r}th power');
INSERT INTO olibdb VALUES('o','perfectNthRoot',2,'x','(I,NonNegativeInteger)->Union(I,failed)','pIntegerRoots(I)',NULL,'\spad{perfectNthRoot(n,{} r)} returns the \spad{r}th root of \spad{n} if \spad{n} is an \spad{r}th power and returns failed otherwise');
INSERT INTO olibdb VALUES('o','perfectSqrt',1,'x','(I)->Union(I,failed)','pIntegerRoots(I)',NULL,'\spad{perfectSqrt(n)} returns the square root of \spad{n} if \spad{n} is a perfect square and returns failed otherwise');
INSERT INTO olibdb VALUES('o','perfectSquare?',1,'x','(I)->Boolean','pIntegerRoots(I)',NULL,'\spad{perfectSquare?(n)} returns \spad{true} if \spad{n} is a perfect square and \spad{false} otherwise');
INSERT INTO olibdb VALUES('o','permanent',1,'x','(SquareMatrix(n,R))->R','pPermanent(n,R)',NULL,'\spad{permanent(x)} computes the permanent of a square matrix \spad{x}. The {\em permanent} is equivalent to the \spadfun{determinant} except that coefficients have no change of sign. This function is much more difficult to compute than the {\em determinant}. The formula used is by \spad{H}.\spad{J}. Ryser,{} improved by [Nijenhuis and Wilf,{} \spad{Ch}. 19]. Note: permanent(\spad{x}) choose one of three algorithms,{} depending on the underlying ring \spad{R} and on \spad{n},{} the number of rows (and columns) of \spad{x:} \begin{items} \item 1. if 2 has an inverse in \spad{R} we can use the algorithm of \indented{3}{[Nijenhuis and Wilf,{} \spad{ch}.19,{} \spad{p}.158]; if 2 has no inverse,{}} \indented{3}{some modifications are necessary:} \item 2. if {\em n > 6} and \spad{R} is an integral domain with characteristic \indented{3}{different from 2 (the algorithm works if and only 2 is not a} \indented{3}{zero-divisor of \spad{R} and {\em characteristic()\$R ~= 2},{}} \indented{3}{but how to check that for any given \spad{R} ?),{}} \indented{3}{the local function {\em permanent2} is called;} \item 3. else,{} the local function {\em permanent3} is called \indented{3}{(works for all commutative rings \spad{R}).} \end{items}');
INSERT INTO olibdb VALUES('o','perm_to_vec',3,'x','(List(S),Permutation(S),NonNegativeInteger)->Vector(NonNegativeInteger)','dPermutationGroup(S)',NULL,'\spad{perm_to_vec(supp,{} p,{} degree)} should be local but conditional');
INSERT INTO olibdb VALUES('o','permutation',2,'n','(F,F)->F','pCombinatorialFunction(R,F)',NULL,'\spad{permutation(n,{} r)} returns the number of permutations of \spad{n} objects taken \spad{r} at a time,{} \spadignore{i.e.} \spad{n!/}(\spad{n}-\spad{r})!.');
INSERT INTO olibdb VALUES('o','permutation',2,'n','(S,S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','permutation',2,'x','(%,%)->%','cCombinatorialFunctionCategory',NULL,'\spad{permutation(n,{} m)} returns the number of permutations of \spad{n} objects taken \spad{m} at a time. Note: \spad{permutation(n,{} m) = n!/(n-m)!}.');
INSERT INTO olibdb VALUES('o','permutation',2,'x','(I,I)->I','pIntegerCombinatoricFunctions(I)',NULL,'\spad{permutation(n)} returns \spad{!P(n,{} r) = n!/(n-r)!}. This is the number of permutations of \spad{n} objects taken \spad{r} at a time.');
INSERT INTO olibdb VALUES('o','permutationGroup',1,'x','(List(Permutation(S)))->%','dPermutationGroup(S)',NULL,'\spad{permutationGroup(ls)} coerces a list of permutations {\em ls} to the group generated by this list.');
INSERT INTO olibdb VALUES('o','permutationRepresentation',1,'n','(G)->Permutation(Integer)','pFiniteGroupPackage(G)',NULL,'\spad{permutationRepresentation(x)} returns the permutation induced by \spad{x} on \spad{enumerate()\$G}');
INSERT INTO olibdb VALUES('o','permutationRepresentation',1,'x','(List(Integer))->Matrix(Integer)','pRepresentationPackage1(R)',NULL,'\spad{permutationRepresentation(\spad{pi},{} n)} returns the matrix {\em (deltai,{} \spad{pi}(i))} (Kronecker delta) if the permutation {\em \spad{pi}} is in list notation and permutes {\em {1,{} 2,{} ...,{} n}}.');
INSERT INTO olibdb VALUES('o','permutationRepresentation',1,'x','(List(List(Integer)))->List(Matrix(Integer))','pRepresentationPackage1(R)',NULL,'\spad{permutationRepresentation([pi1,{} ...,{} pik],{} n)} returns the list of matrices {\em [(deltai,{} pi1(i)),{} ...,{} (deltai,{} pik(i))]} if the permutations {\em pi1},{} ...,{} {\em pik} are in list notation and are permuting {\em {1,{} 2,{} ...,{} n}}.');
INSERT INTO olibdb VALUES('o','permutationRepresentation',2,'x','(List(Permutation(Integer)),Integer)->List(Matrix(Integer))','pRepresentationPackage1(R)',NULL,'\spad{permutationRepresentation([pi1,{} ...,{} pik],{} n)} returns the list of matrices {\em [(deltai,{} pi1(i)),{} ...,{} (deltai,{} pik(i))]} (Kronecker delta) for the permutations {\em pi1,{} ...,{} pik} of {\em {1,{} 2,{} ...,{} n}}.');
INSERT INTO olibdb VALUES('o','permutationRepresentation',2,'x','(Permutation(Integer),Integer)->Matrix(Integer)','pRepresentationPackage1(R)',NULL,'\spad{permutationRepresentation(\spad{pi},{} n)} returns the matrix {\em (deltai,{} \spad{pi}(i))} (Kronecker delta) for a permutation {\em \spad{pi}} of {\em {1,{} 2,{} ...,{} n}}.');
INSERT INTO olibdb VALUES('o','permutations',1,'x','(Integer)->Stream(List(Integer))','pPartitionsAndPermutations',NULL,'\spad{permutations(n)} is the stream of permutations \indented{1}{formed from \spad{1,{} 2,{} 3,{} ...,{} n}.}');
INSERT INTO olibdb VALUES('o','perpendicular',2,'n','(%,%)->%','cSPointCategory',NULL,'\spad{perpendicular(x,{} y)} returns a vector perpendicular to the two vectors in the case of 3D Euclidean space this is the cross the product of two vectors. We use this function to compute orthogonal');
INSERT INTO olibdb VALUES('o','perspective',2,'x','(%,String)->Void','dThreeDimensionalViewport',NULL,'\spad{perspective(v,{}s)} displays the graph in perspective if \spad{s} is on,{} or does not display perspective if \spad{s} is off for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.');
INSERT INTO olibdb VALUES('o','Pfaffian',1,'n','(S)->R','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','Pfaffian',1,'x','(%)->R','cMatrixCategory(R,Row,Col)','has(R,CommutativeRing)','\spad{Pfaffian(m)} returns the Pfaffian of the matrix \spad{m}. Error: if the matrix is not antisymmetric.');
INSERT INTO olibdb VALUES('o','Pfaffian',1,'x','(%)->R','cSquareMatrixCategory(ndim,R,Row,Col)','has(R,CommutativeRing)','\spad{Pfaffian(m)} returns the Pfaffian of the matrix \spad{m}. Error: if the matrix is not antisymmetric.');
INSERT INTO olibdb VALUES('o','Phi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Phi()} returns symbol for capital greek letter phi.');
INSERT INTO olibdb VALUES('o','phi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{phi()} returns symbol for small greek letter phi.');
INSERT INTO olibdb VALUES('o','phiCoord',1,'n','(Point(R))->R','pPointPackage(R)',NULL,'\spad{phiCoord(pt)} returns the third element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical coordinate system.');
INSERT INTO olibdb VALUES('o','physicalLength',1,'n','(%)->NonNegativeInteger','dIndexedFlexibleArray(S,mn)',NULL,'\spad{physicalLength(x)} returns the number of elements \spad{x} can accommodate before growing');
INSERT INTO olibdb VALUES('o','physicalLength',1,'x','(%)->NonNegativeInteger','dFlexibleArray(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','physicalLength!',2,'n','(%,Integer)->%','dIndexedFlexibleArray(S,mn)',NULL,'\spad{physicalLength!(x,{} n)} changes the physical length of \spad{x} to be \spad{n} and returns the new array.');
INSERT INTO olibdb VALUES('o','physicalLength!',2,'x','(%,Integer)->%','dFlexibleArray(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pi',0,'n','()->%','dFortranExpression(basicSymbols,subscriptedSymbols,R)',NULL,'\spad{\spad{pi}(x)} represents the NAG Library function X01AAF which returns \indented{1}{an approximation to the value of \spad{pi}}');
INSERT INTO olibdb VALUES('o','pi',0,'n','()->F','pElementaryFunction(R,F)',NULL,'\spad{\spad{pi}()} returns the \spad{pi} operator');
INSERT INTO olibdb VALUES('o','pi',0,'n','()->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pi',0,'n','()->S','xTranscendentalFunctionCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','Pi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{\spad{Pi}()} returns symbol for capital greek letter \spad{pi}.');
INSERT INTO olibdb VALUES('o','pi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{\spad{pi}()} returns symbol for small greek letter \spad{pi}.');
INSERT INTO olibdb VALUES('o','pi',0,'x','()->%','cTranscendentalFunctionCategory',NULL,'\spad{\spad{pi}()} returns the constant \spad{pi}.');
INSERT INTO olibdb VALUES('o','pi',0,'x','()->%','dPiDomain',NULL,'\spad{\spad{pi}()} returns the symbolic \%\spad{pi}.');
INSERT INTO olibdb VALUES('o','pile',1,'n','((Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{pile()} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats args according to \spad{hh} and then puts them on top of each other left adjusted. The baseline corresponds to the baseline of the first argument.');
INSERT INTO olibdb VALUES('o','pile',1,'n','(List(%))->%','dOutputForm',NULL,'\spad{pile(l)} creates the form consisting of the elements of \spad{l} which displays as a pile,{} \spadignore{i.e.} the elements begin on a new line and are indented right to the same margin.');
INSERT INTO olibdb VALUES('o','pivot',2,'n','(%,Integer)->Record(Index:C,Entry:D)','dSparseEchelonMatrix(C,D)',NULL,'\spad{pivot(A,{} i)} returns the leading entry of the \spad{i}\spad{-}th row of the matrix \spad{A} together with its index.');
INSERT INTO olibdb VALUES('o','pivots',1,'n','(%)->Record(Indices:List(C),Entries:List(D))','dSparseEchelonMatrix(C,D)',NULL,'\spad{pivots(A)} returns all leading entries of the matrix \spad{A} together with their indices.');
INSERT INTO olibdb VALUES('o','plenaryPower',2,'n','(S,PositiveInteger)->S','xNonAssociativeAlgebra&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','plenaryPower',2,'x','(%,PositiveInteger)->%','cNonAssociativeAlgebra(R)',NULL,'\spad{plenaryPower(a,{} n)} is recursively defined to be \spad{plenaryPower(a,{} n-1)*plenaryPower(a,{} n-1)} for \spad{n>1} and \spad{a} for \spad{n=1}.');
INSERT INTO olibdb VALUES('o','pleskenSplit',2,'n','(UP,R)->Factored(UP)','pComplexRootFindingPackage(R,UP)',NULL,'\spad{pleskenSplit(poly,{} eps)} determines a start polynomial {\em start}\\ by using startPolynomial then it increases the exponent \spad{n} of {\em start ^ n mod poly} to get an approximate factor of {\em poly},{} in general of degree degree \spad{poly} \spad{-1}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough.');
INSERT INTO olibdb VALUES('o','pleskenSplit',3,'n','(UP,R,Boolean)->Factored(UP)','pComplexRootFindingPackage(R,UP)',NULL,'\spad{pleskenSplit(poly,{} eps,{} info)} determines a start polynomial {\em start} by using startPolynomial then it increases the exponent \spad{n} of {\em start ^ n mod poly} to get an approximate factor of {\em poly},{} in general of degree degree \spad{poly} \spad{-1}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough. If {\em info} is {\em true},{} then information messages are issued.');
INSERT INTO olibdb VALUES('o','plot',2,'n','((DoubleFloat)->DoubleFloat,Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot(f,{} a..b)} plots the function \spad{f(x)} on the interval \spad{[a,{} b]}.');
INSERT INTO olibdb VALUES('o','plot',2,'n','(List((DoubleFloat)->DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot([f1,{} ...,{} fm],{} a..b)} plots the functions \spad{y = f1(x)},{} ...,{} \spad{y = fm(x)} on the interval \spad{a..b}.');
INSERT INTO olibdb VALUES('o','plot',2,'n','(%,Segment(DoubleFloat))->%','dPlot3D',NULL,'\spad{plot(x,{} r)} \undocumented');
INSERT INTO olibdb VALUES('o','plot',2,'n','(%,Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot(x,{} r)} \undocumented');
INSERT INTO olibdb VALUES('o','plot',3,'n','((DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot(f,{} g,{} a..b)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{} b]}.');
INSERT INTO olibdb VALUES('o','plot',3,'n','((DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot(f,{} a..b,{} c..d)} plots the function \spad{f(x)} on the interval \spad{[a,{} b]}; \spad{y}-range of \spad{[c,{} d]} is noted in Plot object.');
INSERT INTO olibdb VALUES('o','plot',3,'n','(List((DoubleFloat)->DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot([f1,{} ...,{} fm],{} a..b,{} c..d)} plots the functions \spad{y = f1(x)},{} ...,{} \spad{y = fm(x)} on the interval \spad{a..b}; \spad{y}-range of \spad{[c,{} d]} is noted in Plot object.');
INSERT INTO olibdb VALUES('o','plot',3,'n','(S,Symbol,Segment(DoubleFloat))->Plot','pPlotFunctions1(S)',NULL,'\spad{plot(fcn,{} x,{} seg)} plots the graph of \spad{y = f(x)} on a interval');
INSERT INTO olibdb VALUES('o','plot',4,'n','(S,S,Symbol,Segment(DoubleFloat))->Plot','pPlotFunctions1(S)',NULL,'\spad{plot(f,{} g,{} t,{} seg)} plots the graph of \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over an interval.');
INSERT INTO olibdb VALUES('o','plot',5,'n','((DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat))->%','dPlot3D',NULL,'\spad{plot(f,{} g,{} h,{} a..b)} plots \spad{x} = \spad{f}(\spad{t}),{} \spad{y} = \spad{g}(\spad{t}),{} \spad{z} = \spad{h}(\spad{t}) as \spad{t} ranges over [a,{} \spad{b}].');
INSERT INTO olibdb VALUES('o','plot',5,'n','((DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plot(f,{} g,{} a..b,{} c..d,{} e..f)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{} b]}; \spad{x}-range of \spad{[c,{} d]} and \spad{y}-range of \spad{[e,{} f]} are noted in Plot object.');
INSERT INTO olibdb VALUES('o','plot',8,'n','((DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,(DoubleFloat)->DoubleFloat,Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot3D',NULL,'\spad{plot(f1,{} f2,{} f3,{} f4,{} x,{} y,{} z,{} w)} \undocumented');
INSERT INTO olibdb VALUES('o','plotPolar',1,'n','((DoubleFloat)->DoubleFloat)->%','dPlot',NULL,'\spad{plotPolar(f)} plots the polar curve \spad{r = f(theta)} as theta ranges over the interval \spad{[0,{} 2*\%\spad{pi}]}; this is the same as the parametric curve \spad{x = f(t) * cos(t)},{} \spad{y = f(t) * sin(t)}.');
INSERT INTO olibdb VALUES('o','plotPolar',2,'n','((DoubleFloat)->DoubleFloat,Segment(DoubleFloat))->%','dPlot',NULL,'\spad{plotPolar(f,{} a..b)} plots the polar curve \spad{r = f(theta)} as theta ranges over the interval \spad{[a,{} b]}; this is the same as the parametric curve \spad{x = f(t) * cos(t)},{} \spad{y = f(t) * sin(t)}.');
INSERT INTO olibdb VALUES('o','plotPolar',2,'n','(S,Symbol)->Plot','pPlotFunctions1(S)',NULL,'\spad{plotPolar(f,{} theta)} plots the graph of \spad{r = f(theta)} as theta ranges from 0 to 2 \spad{pi}');
INSERT INTO olibdb VALUES('o','plotPolar',3,'n','(S,Symbol,Segment(DoubleFloat))->Plot','pPlotFunctions1(S)',NULL,'\spad{plotPolar(f,{} theta,{} seg)} plots the graph of \spad{r = f(theta)} as \spad{theta} ranges over an interval');
INSERT INTO olibdb VALUES('o','plus',2,'n','(%,%)->%','dThreeDimensionalMatrix(R)','has(R,Ring)','\spad{plus(x,{} y)} adds two matrices,{} term by term we note that they must be the same size');
INSERT INTO olibdb VALUES('o','plus',2,'n','(Record(mantissa:Integer,exponent:Integer),Record(mantissa:Integer,exponent:Integer))->Record(mantissa:Integer,exponent:Integer)','pFloatingPointOperations',NULL,'\spad{plus(x,{} y)} computes \spad{x + y} with no rounding.');
INSERT INTO olibdb VALUES('o','plus!',3,'n','(Matrix(R),Matrix(R),Matrix(R))->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{plus!(c,{} a,{} b)} computes the matrix sum \spad{a + b} and stores the result in the matrix \spad{c}. Error: if \spad{a},{} \spad{b},{} and \spad{c} do not have the same dimensions.');
INSERT INTO olibdb VALUES('o','plus',3,'n','(Record(mantissa:Integer,exponent:Integer),Record(mantissa:Integer,exponent:Integer),PositiveInteger)->Record(mantissa:Integer,exponent:Integer)','pFloatElementaryFunctions',NULL,'\spad{plus(x,{} y,{} b)} computes approximation to \spad{x + y} accurate to at least \spad{b} bits.');
INSERT INTO olibdb VALUES('o','plusInfinity',0,'x','()->%','dOrderedCompletion(R)',NULL,'\spad{plusInfinity()} returns +infinity.');
INSERT INTO olibdb VALUES('o','plusInfinity',0,'x','()->OrderedCompletion(Integer)','pInfinity',NULL,'\spad{plusInfinity()} returns plusInfinity.');
INSERT INTO olibdb VALUES('o','Pm',2,'n','(PositiveInteger,List(NonNegativeInteger))->%','cJetBundleCategory',NULL,'\spad{Pm(i,{} ind)} is like \spad{P(i,{} ind)} but \spad{ind} is always a multi-index.');
INSERT INTO olibdb VALUES('o','pmintegrate',4,'n','(F,Symbol,OrderedCompletion(F),OrderedCompletion(F))->Union(F,failed)','pPatternMatchIntegration(R,F)','AND(has(R,ConvertibleTo(Pattern(Integer))),has(R,PatternMatchable(Integer)),has(F,SpecialFunctionCategory))','\spad{pmintegrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b} if it can be found by the built-in pattern matching rules.');
INSERT INTO olibdb VALUES('o','Pnan?',1,'n','(%)->Boolean','cSPointCategory',NULL,'\spad{Pnan?(p)} returns \spad{true} if any of its elements are not valid DoubleFloat values. Examples of invalid floating point numbers are when we have divided a given element by zero or taken sqrt of negative number at some stage? Note: we can still represent a point at infinity and we can represent points using complex numbers,{} but we do this using projective or conformal space or by using the appropriate instance of SPointCategory,{} not by using invalid floating point numbers.');
INSERT INTO olibdb VALUES('o','point?',1,'x','(%)->Boolean','cThreeSpaceCategory(R)',NULL,'\spad{point?(s)} queries whether the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single component which is a point and returns the boolean result.');
INSERT INTO olibdb VALUES('o','point',1,'x','(List(R))->%','cPointCategory(R)',NULL,'\spad{point(l)} returns a point category defined by a list \spad{l} of elements from the domain \spad{R}.');
INSERT INTO olibdb VALUES('o','point',1,'x','(Point(R))->%','cThreeSpaceCategory(R)',NULL,'\spad{point(p)} returns a \spadtype{ThreeSpace} object which is composed of one component,{} the point \spad{p}.');
INSERT INTO olibdb VALUES('o','point',1,'x','(%)->Point(R)','cThreeSpaceCategory(R)',NULL,'\spad{point(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of only a single point and if so,{} returns the point. An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','point',2,'x','(%,List(R))->%','cThreeSpaceCategory(R)',NULL,'\spad{point(s,{} [x,{} y,{} z])} adds a point component defined by a list of elements which are from the \spad{PointDomain(R)} to the \spadtype{ThreeSpace},{} \spad{s},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined.');
INSERT INTO olibdb VALUES('o','point',2,'x','(%,NonNegativeInteger)->%','cThreeSpaceCategory(R)',NULL,'\spad{point(s,{} i)} adds a point component which is placed into a component list of the \spadtype{ThreeSpace},{} \spad{s},{} at the index given by \spad{i}.');
INSERT INTO olibdb VALUES('o','point',2,'x','(%,Point(R))->%','cThreeSpaceCategory(R)',NULL,'\spad{point(s,{} p)} adds a point component defined by the point,{} \spad{p},{} specified as a list from \spad{List(R)},{} to the \spadtype{ThreeSpace},{} \spad{s},{} where \spad{R} is the \spadtype{Ring} over which the point is defined.');
INSERT INTO olibdb VALUES('o','point',3,'n','(%,Point(DoubleFloat),Palette)->Void','dGraphImage',NULL,'\spad{point(\spad{gi},{} pt,{} pal)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color is set to be the palette color \spad{pal},{} and whose line color and point size are determined by the default functions \spadfun{lineColorDefault} and \spadfun{pointSizeDefault}.');
INSERT INTO olibdb VALUES('o','point',4,'n','(DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat)->Point(DoubleFloat)','pTubePlotTools',NULL,'\spad{point(x1,{} x2,{} x3,{} c)} creates and returns a point from the three specified coordinates \spad{x1},{} \spad{x2},{} \spad{x3},{} and also a fourth coordinate,{} \spad{c},{} which is generally used to specify the color of the point.');
INSERT INTO olibdb VALUES('o','pointColor',1,'x','(Float)->%','dDrawOption',NULL,'\spad{pointColor(v)} specifies a color,{} \spad{v},{} for 2D graph points. This option is expressed in the form \spad{pointColor == v}.');
INSERT INTO olibdb VALUES('o','pointColor',1,'x','(Palette)->%','dDrawOption',NULL,'\spad{pointColor(p)} specifies a color index for 2D graph points from the spadcolors palette \spad{p}. This option is expressed in the form \spad{pointColor == p}.');
INSERT INTO olibdb VALUES('o','pointColorDefault',0,'x','()->Palette','pViewDefaultsPackage',NULL,'\spad{pointColorDefault()} returns the default color of points in a 2D viewport.');
INSERT INTO olibdb VALUES('o','pointColorDefault',1,'x','(Palette)->Palette','pViewDefaultsPackage',NULL,'\spad{pointColorDefault(p)} sets the default color of points in a 2D viewport to the palette \spad{p}.');
INSERT INTO olibdb VALUES('o','pointColorPalette',2,'n','(List(DrawOption),Palette)->Palette','pDrawOptionFunctions0',NULL,'\spad{pointColorPalette(l,{} p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{pointColorPalette}. If the option does not exist the value,{} \spad{p} is returned.');
INSERT INTO olibdb VALUES('o','pointData',1,'n','(%)->List(Point(R))','dSubSpace(n,R)',NULL,'\spad{pointData(s)} returns the list of points from the point data field of the 3 dimensional subspace \spad{s}.');
INSERT INTO olibdb VALUES('o','pointList',1,'n','(%)->List(PT)','dSceneIFS(PT)',NULL,'\spad{pointList(me)} returns points at vertices of this mesh.');
INSERT INTO olibdb VALUES('o','pointList',1,'x','(%)->List(S)','dPermutationGroup(S)',NULL,'\spad{pointList(gp)} should be local but conditional');
INSERT INTO olibdb VALUES('o','pointLists',1,'n','(%)->List(List(Point(DoubleFloat)))','dGraphImage',NULL,'\spad{pointLists(\spad{gi})} returns the list of lists of points which compose the given graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.');
INSERT INTO olibdb VALUES('o','pointPlot',2,'n','((DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat))->%','dPlot3D',NULL,'\spad{pointPlot(f,{} g,{} h,{} a..b)} plots \spad{x} = \spad{f}(\spad{t}),{} \spad{y} = \spad{g}(\spad{t}),{} \spad{z} = \spad{h}(\spad{t}) as \spad{t} ranges over [a,{} \spad{b}].');
INSERT INTO olibdb VALUES('o','pointPlot',2,'n','((DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{pointPlot(t +-> (f(t),{} g(t)),{} a..b)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{} b]}.');
INSERT INTO olibdb VALUES('o','pointPlot',4,'n','((DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot',NULL,'\spad{pointPlot(t +-> (f(t),{} g(t)),{} a..b,{} c..d,{} e..f)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{} b]}; \spad{x}-range of \spad{[c,{} d]} and \spad{y}-range of \spad{[e,{} f]} are noted in Plot object.');
INSERT INTO olibdb VALUES('o','pointPlot',5,'n','((DoubleFloat)->Point(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat),Segment(DoubleFloat))->%','dPlot3D',NULL,'\spad{pointPlot(f,{} x,{} y,{} z,{} w)} \undocumented');
INSERT INTO olibdb VALUES('o','points',3,'n','(%,PositiveInteger,String)->Void','dTwoDimensionalViewport',NULL,'\spad{points(v,{} n,{} s)} displays the points of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is on,{} or does not display the points if \spad{s} is off.');
INSERT INTO olibdb VALUES('o','pointSizeDefault',0,'x','()->PositiveInteger','pViewDefaultsPackage',NULL,'\spad{pointSizeDefault()} returns the default size of the points in a 2D viewport.');
INSERT INTO olibdb VALUES('o','pointSizeDefault',1,'x','(PositiveInteger)->PositiveInteger','pViewDefaultsPackage',NULL,'\spad{pointSizeDefault(i)} sets the default size of the points in a 2D viewport to \spad{i}.');
INSERT INTO olibdb VALUES('o','poisson',1,'n','(Fraction(Integer))->()->Integer','pRandomIntegerDistributions',NULL,'\spad{poisson(f)} \undocumented');
INSERT INTO olibdb VALUES('o','poissonDistribution',1,'x','(R)->Distribution(R)','pDistributionPackage(R)',NULL,'\spad{poissonDistribution(a)} produces a Poisson distribution of variance \spad{a}.');
INSERT INTO olibdb VALUES('o','pol',1,'n','(Vector(GF))->SparseUnivariatePolynomial(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{pol(v)} turns the vector \spad{[v0,{} ...,{} vn]} into the polynomial \spad{v0+v1*x+ ... + vn*x^n}.');
INSERT INTO olibdb VALUES('o','polar',1,'x','(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{polar(pt)} transforms \spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \spad{(r,{} theta)} to \spad{x = r * cos(theta)},{} \spad{y = r * sin(theta)}.');
INSERT INTO olibdb VALUES('o','polarCoordinates',1,'n','(S)->Record(r:R,phi:R)','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','polarCoordinates',1,'x','(%)->Record(r:R,phi:R)','cComplexCategory(R)','AND(has(R,RealNumberSystem),has(R,TranscendentalFunctionCategory))','\spad{polarCoordinates(x)} returns (\spad{r},{} phi) such that \spad{x} = \spad{r} * exp(\%\spad{i} * phi).');
INSERT INTO olibdb VALUES('o','polCase',3,'n','(Z,NonNegativeInteger,List(Z))->Boolean','pLeadingCoefDetermination(OV,E,Z,P)',NULL,'\spad{polCase(contprod,{} numFacts,{} evallcs)},{} where \spad{contprod} is the product of the content of the leading coefficient of the polynomial to be factored with the content of the evaluated polynomial,{} \spad{numFacts} is the number of factors of the leadingCoefficient,{} and evallcs is the list of the evaluated factors of the leadingCoefficient,{} returns \spad{true} if the factors of the leading Coefficient can be distributed with this valuation.');
INSERT INTO olibdb VALUES('o','pole?',1,'n','(%)->Boolean','dInnerTaylorSeries(Coef)',NULL,'\spad{pole?(x)} tests if the series \spad{x} has a pole. \indented{1}{Note: this is \spad{false} when \spad{x} is a Taylor series.}');
INSERT INTO olibdb VALUES('o','pole?',1,'x','(%)->Boolean','cPowerSeriesCategory(Coef,Expon,Var)',NULL,'\spad{pole?(f)} determines if the power series \spad{f} has a pole.');
INSERT INTO olibdb VALUES('o','PollardSmallFactor',1,'n','(I)->Union(I,failed)','pIntegerFactorizationPackage(I)',NULL,'\spad{PollardSmallFactor(n)} returns a factor of \spad{n} or failed if no one is found');
INSERT INTO olibdb VALUES('o','poly_factor',1,'n','(SparseUnivariatePolynomial(SparseMultivariatePolynomial(R,Kernel(F))))->Factored(SparseUnivariatePolynomial(SparseMultivariatePolynomial(R,Kernel(F))))','pExpressionFactorPolynomial(R,F)',NULL,'\spad{poly_factor(p)} should be local but conditional.');
INSERT INTO olibdb VALUES('o','polygamma',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{polygamma(x,{} y)} returns the polygamma function applied to \spad{x} and \spad{y}.');
INSERT INTO olibdb VALUES('o','polygamma',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{polygamma(k,{} x)} is the \spad{k-th} derivative of \spad{digamma(x)},{} (often written \spad{psi(k,{} x)} in the literature).');
INSERT INTO olibdb VALUES('o','polygamma',2,'x','(NonNegativeInteger,Complex(DoubleFloat))->Complex(DoubleFloat)','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','polygamma',2,'x','(NonNegativeInteger,DoubleFloat)->DoubleFloat','pDoubleFloatSpecialFunctions2',NULL,NULL);
INSERT INTO olibdb VALUES('o','polygon?',1,'x','(%)->Boolean','cThreeSpaceCategory(R)',NULL,'\spad{polygon?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} contains a single polygon component,{} or \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','polygon',1,'x','(List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{polygon([p0,{} p1,{} ...,{} pn])} creates a polygon defined by a list of points,{} \spad{p0} through \spad{pn},{} and returns a \spadtype{ThreeSpace} whose component is the polygon.');
INSERT INTO olibdb VALUES('o','polygon',1,'x','(%)->List(Point(R))','cThreeSpaceCategory(R)',NULL,'\spad{polygon(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single polygon component defined by a list of points,{} and if so,{} returns the list of points; An error is signaled otherwise.');
INSERT INTO olibdb VALUES('o','polygon',2,'x','(%,List(List(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{polygon(s,{} [[r0],{} [r1],{} ...,{} [rn]])} adds a polygon component defined by a list of points \spad{r0} through \spad{rn},{} which are lists of elements from the domain \spad{PointDomain(m,{} R)} to the \spadtype{ThreeSpace} \spad{s},{} where \spad{m} is the dimension of the points and \spad{R} is the \spadtype{Ring} over which the points are defined.');
INSERT INTO olibdb VALUES('o','polygon',2,'x','(%,List(Point(R)))->%','cThreeSpaceCategory(R)',NULL,'\spad{polygon(s,{} [p0,{} p1,{} ...,{} pn])} adds a polygon component defined by a list of points,{} \spad{p0} through \spad{pn},{} to the \spadtype{ThreeSpace} \spad{s}.');
INSERT INTO olibdb VALUES('o','poly_int',3,'n','(Fraction(SparseUnivariatePolynomial(F)),Kernel(F),Symbol)->Record(answer:Fraction(SparseUnivariatePolynomial(F)),logpart:Fraction(SparseUnivariatePolynomial(F)),ir:IntegrationResult(Fraction(SparseUnivariatePolynomial(F))))','pDenominatorIntegration(R,F)',NULL,'\spad{poly_int(f,{} k,{} x)} generates polylogarithms.');
INSERT INTO olibdb VALUES('o','polylog',2,'n','(F,F)->F','pFunctionalSpecialFunction(R,F)',NULL,'\spad{polylog(s,{} x)} is the polylogarithm of order \spad{s} at \spad{x}.');
INSERT INTO olibdb VALUES('o','polylog',2,'x','(%,%)->%','cSpecialFunctionCategory',NULL,'\spad{polylog(s,{} x)} is the polylogarithm of order \spad{s} at \spad{x}.');
INSERT INTO olibdb VALUES('o','polylog_int',6,'n','(F,Symbol,Kernel(F),NonNegativeInteger,List(Kernel(F)),F)->Union(Record(ratpart:F,coeff:F,prim:F),failed)','pParametricIntegration(R,F)',NULL,'\spad{polylog_int(f,{} x,{} k0,{} [k1,{} ...,{} kn],{} g)}');
INSERT INTO olibdb VALUES('o','polynomial?',1,'n','(%)->Boolean','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{polynomial?(f)} is the ALS in polynomial form?');
INSERT INTO olibdb VALUES('o','polynomial',1,'n','(%)->XDistributedPolynomial(VAR,F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{polynomial(f)} returns \spad{f} as XDPOLY (if possible)');
INSERT INTO olibdb VALUES('o','polynomial',2,'x','(%,NonNegativeInteger)->Polynomial(Coef)','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.');
INSERT INTO olibdb VALUES('o','polynomial',2,'x','(%,NonNegativeInteger)->Polynomial(Coef)','cUnivariateTaylorSeriesCategory(Coef)',NULL,'\spad{polynomial(f,{} k)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.');
INSERT INTO olibdb VALUES('o','polynomial',3,'x','(%,NonNegativeInteger,NonNegativeInteger)->Polynomial(Coef)','cMultivariateTaylorSeriesCategory(Coef,Var)',NULL,'\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.');
INSERT INTO olibdb VALUES('o','polynomial',3,'x','(%,NonNegativeInteger,NonNegativeInteger)->Polynomial(Coef)','cUnivariateTaylorSeriesCategory(Coef)',NULL,'\spad{polynomial(f,{} k1,{} k2)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.');
INSERT INTO olibdb VALUES('o','polyPart',1,'x','(%)->UP','dFullPartialFractionExpansion(F,UP)',NULL,'\spad{polyPart(f)} returns the polynomial part of \spad{f}.');
INSERT INTO olibdb VALUES('o','polyred',1,'n','(UPUP)->UPUP','pPointsOfFiniteOrderTools(UP,UPUP)',NULL,'\spad{polyred(u)} \undocumented');
INSERT INTO olibdb VALUES('o','polyRicDE',2,'n','(LinearOrdinaryDifferentialOperator2(UP,Fraction(UP)),(UP)->List(F))->List(Record(poly:UP,eq:LinearOrdinaryDifferentialOperator2(UP,Fraction(UP))))','pRationalRicDE(F,UP)',NULL,'\spad{polyRicDE(op,{} zeros)} returns \spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{} Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y = 0} must be one of the \spad{pi}\spad{''s} (up to the constant coefficient),{} in which case the equation for \spad{z = y e^{-int p}} is \spad{\spad{Li} z = 0}. \spad{zeros} is a zero finder in \spad{UP}.');
INSERT INTO olibdb VALUES('o','polyRicDE',2,'n','(L,(UP)->List(F))->List(Record(poly:UP,eq:L))','pPrimitiveRatRicDE(F,UP,L,LQ)',NULL,'\spad{polyRicDE(op,{} zeros)} returns \spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{} Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y=0} must be one of the \spad{pi}\spad{''s} (up to the constant coefficient),{} in which case the equation for \spad{z=y e^{-int p}} is \spad{\spad{Li} z =0}. \spad{zeros} is a zero finder in \spad{UP}.');
INSERT INTO olibdb VALUES('o','pomopo!',4,'n','(S,R,E,S)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pomopo!',4,'x','(%,R,E,%)->%','cFiniteAbelianMonoidRing(R,E)',NULL,'\spad{pomopo!(p1,{} r,{} e,{} p2)} returns \spad{p1 + monomial(r,{} e) * p2} and may use \spad{p1} as workspace. The constant \spad{r} is assumed to be nonzero.');
INSERT INTO olibdb VALUES('o','pop!',1,'x','(%)->S','cStackAggregate(S)',NULL,'\spad{pop!(s)} returns the top element \spad{x},{} destructively removing \spad{x} from \spad{s}. Note: Use \spad{top(s)} to obtain \spad{x} without removing it from \spad{s}. Error: if \spad{s} is empty.');
INSERT INTO olibdb VALUES('o','popFortranOutputStack',0,'n','()->Void','pFortranOutputStackPackage',NULL,'\spad{popFortranOutputStack()} pops the Fortran output stack');
INSERT INTO olibdb VALUES('o','posetL7',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a poset corresponding to an \spad{L7} lattice');
INSERT INTO olibdb VALUES('o','posetM5',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a poset corresponding to an \spad{M5} lattice');
INSERT INTO olibdb VALUES('o','posetN5',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a poset corresponding to an \spad{N5} lattice');
INSERT INTO olibdb VALUES('o','posetO6',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a poset corresponding to an \spad{O6} lattice');
INSERT INTO olibdb VALUES('o','posetP6',1,'n','(List(S))->FiniteBiCPO(S)','pPosetFactory(S)',NULL,'generates a poset corresponding to an \spad{P6} lattice');
INSERT INTO olibdb VALUES('o','position',1,'x','(%)->NonNegativeInteger','cCachableSet',NULL,'\spad{position(x)} returns the integer \spad{n} associated to \spad{x}.');
INSERT INTO olibdb VALUES('o','position',2,'n','(%,List(%))->Integer','dCubicalFacet',NULL,'return index of \spad{e} in \spad{lst}. Index will be negative if \spad{e} has negative multiplier.');
INSERT INTO olibdb VALUES('o','position',2,'n','(%,List(%))->Integer','dOrientedFacet',NULL,'return index of \spad{e} in \spad{lst}. Index will be negative if \spad{e} has negative multiplier.');
INSERT INTO olibdb VALUES('o','position',2,'n','(S,A)->Integer','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'n','(S,A)->Integer','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'n','(S,A)->Integer','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'n','((S)->Boolean,A)->Integer','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'n','((S)->Boolean,A)->Integer','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'n','((S)->Boolean,A)->Integer','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',2,'x','((S)->Boolean,%)->Integer','cLinearAggregate(S)','has(%,finiteAggregate)','\spad{position(p,{} a)} returns the index \spad{i} of the first \spad{x} in \spad{a} such that \spad{p(x)} is \spad{true},{} and \spad{minIndex(a) - 1} if there is no such \spad{x}.');
INSERT INTO olibdb VALUES('o','position',2,'x','(S,%)->Integer','cLinearAggregate(S)','AND(has(%,finiteAggregate),has(S,BasicType))','\spad{position(x,{} a)} returns the index \spad{i} of the first occurrence of \spad{x} in a,{} and \spad{minIndex(a) - 1} if there is no such \spad{x}.');
INSERT INTO olibdb VALUES('o','position',3,'n','(S,A,Integer)->Integer','xLinearAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',3,'n','(S,A,Integer)->Integer','xListAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',3,'n','(S,A,Integer)->Integer','xOneDimensionalArrayAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','position',3,'x','(CharacterClass,%,Integer)->Integer','cStringAggregate',NULL,'\spad{position(cc,{} t,{} i)} returns the position \spad{j} in string \spad{t} of the first character belonging to \spad{cc},{} beginning at index \spad{i}. Returns \spad{minIndex(t) - 1} if there is no such \spad{j}.');
INSERT INTO olibdb VALUES('o','position',3,'x','(%,%,Integer)->Integer','cStringAggregate',NULL,'\spad{position(s,{} t,{} i)} returns the position \spad{j} of the substring \spad{s} in string \spad{t},{} beginning at index \spad{i}. Returns \spad{minIndex(s) - 1} if there is no such \spad{j}.');
INSERT INTO olibdb VALUES('o','position',3,'x','(S,%,Integer)->Integer','cLinearAggregate(S)','AND(has(%,finiteAggregate),has(S,BasicType))','\spad{position(x,{} a,{} n)} returns the index \spad{i} of the first occurrence of \spad{x} in \spad{a} where \spad{i >= n},{} and \spad{minIndex(a) - 1} if no such \spad{x} is found.');
INSERT INTO olibdb VALUES('o','positive?',1,'n','(S)->Boolean','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','positive?',1,'n','(S)->Boolean','xOrderedRing&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','positive?',1,'x','(%)->Boolean','cIntervalCategory(R)',NULL,'\spad{positive?(u)} returns \spad{true} if every element of \spad{u} is positive,{} \spad{false} otherwise.');
INSERT INTO olibdb VALUES('o','positive?',1,'x','(%)->Boolean','cOrderedRing',NULL,'\spad{positive?(x)} tests whether \spad{x} is strictly greater than 0.');
INSERT INTO olibdb VALUES('o','positive?',2,'n','(ThePols,S)->Boolean','xRealRootCharacterizationCategory&(S,TheField,ThePols)',NULL,NULL);
INSERT INTO olibdb VALUES('o','positive?',2,'x','(ThePols,%)->Boolean','cRealRootCharacterizationCategory(TheField,ThePols)',NULL,'\spad{positive?(pol,{} aRoot)} answers if \spad{pol} interpreted as \spad{aRoot} is positive');
INSERT INTO olibdb VALUES('o','positivePower',2,'n','(S,Integer)->S','xMatrixCategory&(S,R,Row,Col)',NULL,NULL);
INSERT INTO olibdb VALUES('o','positivePower',2,'x','(%,Integer)->%','cMatrixCategory(R,Row,Col)','has(R,SemiRng)','\spad{positivePower(x,{} n)} computes a positive integral power of the matrix \spad{x}. Error: if the matrix is not square.');
INSERT INTO olibdb VALUES('o','positiveRemainder',2,'x','(%,%)->%','cIntegerNumberSystem',NULL,'\spad{positiveRemainder(a,{} b)} (where \spad{b > 1}) yields \spad{r} where \spad{0 <= r < b} and \spad{r = a rem b}.');
INSERT INTO olibdb VALUES('o','positiveSolve',1,'x','(List(Polynomial(R)))->List(List(RealClosure(Fraction(R))))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{positiveSolve(lp)} returns the same as \spad{positiveSolve(lp,{} false,{} false)}.');
INSERT INTO olibdb VALUES('o','positiveSolve',1,'x','(RegularChain(R,ls))->List(List(RealClosure(Fraction(R))))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{positiveSolve(ts)} returns the points of the regular set of \spad{ts} with (real) strictly positive coordinates.');
INSERT INTO olibdb VALUES('o','positiveSolve',2,'x','(List(Polynomial(R)),Boolean)->List(List(RealClosure(Fraction(R))))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{positiveSolve(lp)} returns the same as \spad{positiveSolve(lp,{} info?,{} false)}.');
INSERT INTO olibdb VALUES('o','positiveSolve',3,'x','(List(Polynomial(R)),Boolean,Boolean)->List(List(RealClosure(Fraction(R))))','pZeroDimensionalSolvePackage(R,ls,ls2)',NULL,'\spad{positiveSolve(lp,{} info?,{} lextri?)} returns the set of the points in the variety associated with \spad{lp} whose coordinates are (real) strictly positive. Moreover,{} if \spad{info?} is \spad{true} then some information is displayed during decomposition into regular chains. If \spad{lextri?} is \spad{true} then the lexTriangular algorithm is called from the \spadtype{LexTriangularPackage} constructor (see \spadopFrom{zeroSetSplit}{LexTriangularPackage}(\spad{lp},{} \spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \spadopFrom{zeroSetSplit}{RegularChain} from \spadtype{RegularChain}. WARNING: For each set of coordinates given by \spad{positiveSolve(lp,{} info?,{} lextri?)} the ordering of the indeterminates is reversed \spad{w}.\spad{r}.\spad{t}. \spad{ls}.');
INSERT INTO olibdb VALUES('o','possibleOrder',1,'n','(FiniteDivisor(F,UP,UPUP,R))->NonNegativeInteger','pPointsOfFiniteOrder(R0,F,UP,UPUP,R)',NULL,'\spad{possibleOrder(d)} returns \spad{n} such that \spad{d} is of order \spad{n},{} or of infinite order.');
INSERT INTO olibdb VALUES('o','possiblyInfinite?',1,'n','(A)->Boolean','xLazyStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','possiblyInfinite?',1,'n','(A)->Boolean','xStreamAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','possiblyInfinite?',1,'x','(%)->Boolean','cStreamAggregate(S)',NULL,'\spad{possiblyInfinite?(s)} tests if the stream \spad{s} could possibly have an infinite number of elements. Note: for many datatypes,{} \spad{possiblyInfinite?(s) = not explictlyFinite?(s)}.');
INSERT INTO olibdb VALUES('o','possiblyNewVariety?',2,'n','(List(P),List(List(P)))->Boolean','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{possiblyNewVariety?(newlp,{} llp)} returns \spad{true} iff for every \spad{lp} in \spad{llp} certainlySubVariety?(\spad{newlp},{} \spad{lp}) does not hold.');
INSERT INTO olibdb VALUES('o','postfix',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{postfix(op,{} a)} creates a form which prints as: a \spad{op}.');
INSERT INTO olibdb VALUES('o','pow',0,'n','()->PrimitiveArray(%)','dModMonic(R,Rep)',NULL,'\spad{pow()} returns precomputed array of powers of variable modulo current modulus from defree \spad{d} up to degree \spad{2*d -1},{} where \spad{d} is degree of the modulus. Note: element at index 0 is variable to power \spad{d}.');
INSERT INTO olibdb VALUES('o','pow',4,'n','(U32Vector,PositiveInteger,NonNegativeInteger,Integer)->U32Vector','pU32VectorPolynomialOperations',NULL,'\spad{pow(u,{} n,{} d,{} p)} returns u^n truncated after degree \spad{d},{} except if \spad{n=1},{} in which case \spad{u} itself is returned');
INSERT INTO olibdb VALUES('o','power',2,'n','(A,Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Field)','\spad{power(a,{} f)} returns the power series \spad{f} raised to the power \spad{a}.');
INSERT INTO olibdb VALUES('o','power',3,'n','(Integer,(Integer,List(OutputForm))->OutputBox,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{power(op,{} p,{} h1,{} h2)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats \spad{args.1} and \spad{args.2} according to \spad{h1} and \spad{h2},{} respectively. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','power!',5,'n','(Matrix(R),Matrix(R),Matrix(R),Matrix(R),NonNegativeInteger)->Matrix(R)','pStorageEfficientMatrixOperations(R)',NULL,'\spad{power!(a,{} b,{} c,{} m,{} n)} computes \spad{m} ^ \spad{n} and stores the result in \spad{a}. The matrices \spad{b} and \spad{c} are used to store intermediate results. Error: if \spad{a},{} \spad{b},{} \spad{c},{} and \spad{m} are not square and of the same dimensions.');
INSERT INTO olibdb VALUES('o','powerAssociative?',0,'x','()->Boolean','cFiniteRankNonAssociativeAlgebra(R)',NULL,'\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative.');
INSERT INTO olibdb VALUES('o','power_matrix',3,'n','(PA,NonNegativeInteger,PMD)->Record(matr:MMT,poly:PA)','cModularFactorizationOperations(PA,MMT,MD,PMD)',NULL,'\spad{power_matrix(s,{} l,{} rd)} computes [\spad{m},{} \spad{p}] such that \spad{p = s^l} modulo reduction data \spad{rd} and column \spad{j} of \spad{m} contain \spad{s^j} modulo reduction data \spad{rd}. Note that lowest column index is \spad{j = 0} and highest index is \spad{j=l-1}. \spad{rd} should be obtained by earlier call to \spad{ini_rdata}.');
INSERT INTO olibdb VALUES('o','powern',2,'n','(Fraction(Integer),Stream(A))->Stream(A)','pStreamTaylorSeriesOperations(A)','has(A,Algebra(Fraction(Integer)))','\spad{powern(r,{} f)} raises power series \spad{f} to the power \spad{r}.');
INSERT INTO olibdb VALUES('o','powers',1,'n','(List(Integer))->List(List(Integer))','dPartition',NULL,'\spad{powers(\spad{li})} returns a list of 2-element lists. For each 2-element list,{} the first element is an entry of \spad{li} and the second element is the multiplicity with which the first element occurs in \spad{li}. There is a 2-element list for each value occurring in \spad{l}.');
INSERT INTO olibdb VALUES('o','powerset',1,'n','(List(S))->FiniteBiCPO(List(S))','pPosetFactory(S)',NULL,'generate a poset representing all possible subsets of a given set with their subset relationships.');
INSERT INTO olibdb VALUES('o','powerSum',1,'x','(Integer)->SymmetricPolynomial(Fraction(Integer))','pCycleIndicators',NULL,'\spad{powerSum n} is the \spad{n} th power sum symmetric \indented{1}{function.}');
INSERT INTO olibdb VALUES('o','powmod',3,'n','(S,S,S)->S','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','powmod',3,'x','(%,%,%)->%','cIntegerNumberSystem',NULL,'\spad{powmod(a,{} b,{} p)},{} \spad{0<=a,{} b<p>1},{} means \spad{a^b mod p}.');
INSERT INTO olibdb VALUES('o','powToUPS',2,'n','(List(FE),Record(pos_Check?:Boolean,atan_Flag:Union(complex,real: two sides,real: left side,real: right side,just do it),coeff_check?:Union((FE)->Boolean,none),inv_check?:Union((FE)->Boolean,none),zero_check?:Union((FE)->Boolean,none),log_x_replace:Boolean,log_x_val:FE,cache:List(Record(ker:Kernel(FE),ser:Union(%series:UPS,%problem:Record(func:String,prob:String))))))->Union(%series:UPS,%problem:Record(func:String,prob:String))','pFunctionSpaceToUnivariatePowerSeries2(R,FE,Expon,UPS,TRAN,UTS,TEXP,coerce_Ex,x)',NULL,'\spad{powToUPS should} be local but conditional');
INSERT INTO olibdb VALUES('o','pquo',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pquo',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{pquo(a,{} b)} computes the pseudo-quotient of \spad{a} by \spad{b},{} both viewed as univariate polynomials in the main variable of \spad{b}.');
INSERT INTO olibdb VALUES('o','pquo',3,'n','(S,S,V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pquo',3,'x','(%,%,V)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{pquo(a,{} b,{} v)} computes the pseudo-quotient of \spad{a} by \spad{b},{} both viewed as univariate polynomials in \spad{v}.');
INSERT INTO olibdb VALUES('o','pr2dmp',1,'n','(Polynomial(R))->GR','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{pr2dmp(p)} converts \spad{p} to target domain');
INSERT INTO olibdb VALUES('o','Pr',2,'n','(PositiveInteger,List(PositiveInteger))->%','cJetBundleCategory',NULL,'\spad{Pr(i,{} ind)} is like \spad{P(i,{} ind)} but \spad{ind} is always a repeated index.');
INSERT INTO olibdb VALUES('o','Pr',2,'n','(PositiveInteger,List(PositiveInteger))->S','xJetBundleCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','precedence',2,'n','(Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{precedence(p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} returns \spad{hh(p,{} args)}. This handler can be used to change the context in which an expression is formatted.');
INSERT INTO olibdb VALUES('o','precedence',2,'n','(Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{precedence(p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} returns \spad{hh(p,{} args)}. This handler can be used to change the context in which an expression is formatted.');
INSERT INTO olibdb VALUES('o','precision',0,'n','()->PositiveInteger','dMachineFloat',NULL,'\spad{precision()} returns the number of digits in the model');
INSERT INTO olibdb VALUES('o','precision',0,'x','()->PositiveInteger','cFloatingPointSystem',NULL,'\spad{precision()} returns the precision in digits base.');
INSERT INTO olibdb VALUES('o','precision',1,'n','(PositiveInteger)->PositiveInteger','dMachineFloat',NULL,'\spad{precision(p)} sets the number of digits in the model to \spad{p}');
INSERT INTO olibdb VALUES('o','precision',1,'x','(PositiveInteger)->PositiveInteger','cFloatingPointSystem','has(%,arbitraryPrecision)','\spad{precision(n)} set the precision in the base to \spad{n} decimal digits.');
INSERT INTO olibdb VALUES('o','precondition',1,'n','(OutputForm)->OutputForm','pOutputFormTools',NULL,'\spad{precondition(f)} prepares form for formatting.');
INSERT INTO olibdb VALUES('o','predicate',1,'n','(Pattern(R))->(D)->Boolean','pPatternFunctions1(R,D)',NULL,'\spad{predicate(p)} returns the predicate attached to \spad{p},{} the constant function \spad{true} if \spad{p} has no predicates attached to it.');
INSERT INTO olibdb VALUES('o','predicates',1,'n','(%)->List(Any)','dPattern(R)',NULL,'\spad{predicates(p)} returns \spad{[p1,{} ...,{} pn]} such that the predicate attached to \spad{p} is \spad{p1} and ... and \spad{pn}.');
INSERT INTO olibdb VALUES('o','prefix',2,'n','(%,List(%))->%','dOutputForm',NULL,'\spad{prefix(f,{} l)} creates a form depicting the \spad{n}-ary prefix application of \spad{f} to a tuple of arguments given by list \spad{l}.');
INSERT INTO olibdb VALUES('o','prefix?',2,'n','(S,S)->Boolean','xStringAggregate&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prefix?',2,'x','(%,%)->Boolean','cStringAggregate',NULL,'\spad{prefix?(s,{} t)} tests if the string \spad{s} is the initial substring of \spad{t}. Note: \spad{prefix?(s,{} t) = reduce(and,{} [s.i = t.i for i in indices s])}.');
INSERT INTO olibdb VALUES('o','prefix',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{prefix(s,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats args according to \spad{hh} and then prefixes this box by \spad{box s}. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','prefix',3,'n','(String,Integer,(Integer,List(OutputForm))->OutputBox)->(Integer,List(OutputForm))->OutputBox','xFormatterCategory&(S)',NULL,'\spad{prefix(s,{} p,{} hh)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats args according to \spad{hh} and then prefixes this box by \spad{box s}. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','prefixRagits',1,'x','(%)->List(Integer)','dRadixExpansion(bb)',NULL,'\spad{prefixRagits(rx)} returns the non-cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \spad{x = 3/28 = 0.10 714285 714285 ...},{} then \spad{prefixRagits(x)=[1,{} 0]}.');
INSERT INTO olibdb VALUES('o','pre_gauss',1,'n','(Matrix(Integer))->Matrix(Integer)','pUnitGaussianElimination',NULL,'\spad{pre_gauss(m)} performs Gaussian eliminaton on rows of \spad{m} using only 1 and \spad{-1} as pivots. Note: \spad{m} is modified in place');
INSERT INTO olibdb VALUES('o','pre_lr',3,'n','(Matrix(Integer),Vector(Integer),Vector(Integer))->Matrix(Integer)','pUnitGaussianElimination',NULL,'\spad{pre_lr(m,{} \spad{pi},{} pj)} is like pre_gauss,{} but records positions of pivots in \spad{pi} and \spad{pj} and returns transformation matrix. \spad{m},{} \spad{pi},{} \spad{pj} are modified in place');
INSERT INTO olibdb VALUES('o','prem',2,'n','(S,S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prem',2,'x','(%,%)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{prem(a,{} b)} computes the pseudo-remainder of \spad{a} by \spad{b},{} both viewed as univariate polynomials in the main variable of \spad{b}.');
INSERT INTO olibdb VALUES('o','prem',3,'n','(S,S,V)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prem',3,'x','(%,%,V)->%','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{prem(a,{} b,{} v)} computes the pseudo-remainder of \spad{a} by \spad{b},{} both viewed as univariate polynomials in \spad{v}.');
INSERT INTO olibdb VALUES('o','prepareDecompose',4,'x','(List(P),List(TS),Boolean,Boolean)->List(Record(eq:List(P),tower:TS,ineq:List(P)))','pQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{prepareDecompose(lp,{} lts,{} b1,{} b2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','prepareDecompose',4,'x','(List(P),List(TS),Boolean,Boolean)->List(Record(eq:List(P),tower:TS,ineq:List(P)))','pSquareFreeQuasiComponentPackage(R,E,V,P,TS)',NULL,'\spad{prepareDecompose(lp,{} lts,{} b1,{} b2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','prepareSubResAlgo',3,'x','(P,P,TS)->List(Record(val:List(P),tower:TS))','pRegularTriangularSetGcdPackage(R,E,V,P,TS)',NULL,'\spad{prepareSubResAlgo(p1,{} p2,{} ts)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','pre_process',3,'x','(List(P),Boolean,Boolean)->Record(val:List(P),towers:List(%))','dRegularTriangularSet(R,E,V,P)',NULL,'\spad{pre_process(lp,{} b1,{} b2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','pre_process',3,'x','(List(P),Boolean,Boolean)->Record(val:List(P),towers:List(%))','dSquareFreeRegularTriangularSet(R,E,V,P)',NULL,'\spad{pre_process(lp,{} b1,{} b2)} is an internal subroutine,{} exported only for development.');
INSERT INTO olibdb VALUES('o','pre_smith',1,'n','(Matrix(Integer))->Matrix(Integer)','pUnitGaussianElimination',NULL,'\spad{pre_smith(m)} first performs pre_gauss(\spad{m}) and then drops all rows and columns of \spad{m} containing pivots.');
INSERT INTO olibdb VALUES('o','presub',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{presub(f,{} n)} creates a form for \spad{f} presubscripted by \spad{n}.');
INSERT INTO olibdb VALUES('o','presuper',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{presuper(f,{} n)} creates a form for \spad{f} presuperscripted by \spad{n}.');
INSERT INTO olibdb VALUES('o','pretendOfType',1,'n','(InputForm)->InputForm','pInputFormFunctions1(R)',NULL,'\spad{pretendOfType(f)} returns the input form corresponding to \spad{f pretend R}');
INSERT INTO olibdb VALUES('o','previous',1,'x','(%)->%','cDoublyLinkedAggregate(S)',NULL,'\spad{previous(l)} returns the doubly-link list beginning with its previous element. Error: if \spad{l} has no previous element. Note: \spad{next(previous(l)) = l}.');
INSERT INTO olibdb VALUES('o','prevPrime',1,'x','(I)->I','pIntegerPrimesPackage(I)',NULL,'\spad{prevPrime(n)} returns the largest prime strictly smaller than \spad{n}');
INSERT INTO olibdb VALUES('o','primaryDecomp',1,'x','(PolynomialIdeal(Fraction(Integer),DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl),DistributedMultivariatePolynomial(vl,Fraction(Integer))))->List(PolynomialIdeal(Fraction(Integer),DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl),DistributedMultivariatePolynomial(vl,Fraction(Integer))))','pIdealDecompositionPackage(vl)',NULL,'\spad{primaryDecomp(I)} returns a list of primary ideals such that their intersection is the ideal \spad{I}.');
INSERT INTO olibdb VALUES('o','prime',1,'n','(%)->%','dOutputForm',NULL,'\spad{prime(f)} creates the form \spad{f} followed by a suffix prime (single quote).');
INSERT INTO olibdb VALUES('o','prime',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{prime(p)} returns a handler that treats the typesetting of primes. Note that differentiate(a,{} 3) gives the following \spad{s}-expression in OutputForm: (PRIME a');
INSERT INTO olibdb VALUES('o','prime?',1,'n','(S)->Boolean','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prime?',1,'n','(S)->Boolean','xField&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prime?',1,'n','(S)->Boolean','xIntegerNumberSystem&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prime?',1,'n','(S)->Boolean','xUniqueFactorizationDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prime?',1,'x','(%)->Boolean','cUniqueFactorizationDomain',NULL,'\spad{prime?(x)} tests if \spad{x} can never be written as the product of two non-units of the ring,{} \spadignore{i.e.} \spad{x} is an irreducible element.');
INSERT INTO olibdb VALUES('o','prime?',1,'x','(Complex(Integer))->Boolean','pGaussianFactorizationPackage',NULL,'\spad{prime?(\spad{zi})} tests if the complex integer \spad{zi} is prime.');
INSERT INTO olibdb VALUES('o','prime?',1,'x','(I)->Boolean','pIntegerPrimesPackage(I)',NULL,'\spad{prime?(n)} returns \spad{true} if \spad{n} is prime and \spad{false} if not. Note that we ignore sign of \spad{n},{} so \spad{-5} is considered prime. The algorithm used is Rabin\spad{''s} probabilistic primality test (reference: Knuth Volume 2 Semi Numerical Algorithms). If \spad{prime? n} returns \spad{false},{} \spad{n} is proven composite. If \spad{prime? n} returns \spad{true},{} prime? may be in error however,{} the probability of error is very low. and is zero below 25*10^9 (due to a result of Pomerance et al),{} below 10^12 and 10^13 due to results of Pinch,{} and below 341550071728321 due to a result of Jaeschke. Specifically,{} this implementation does at least 10 pseudo prime tests and so the probability of error is \spad{< 4^(-10)}. The running time of this method is cubic in the length of the input \spad{n},{} that is \spad{O( (log n)^3 )},{} for \spad{n<10^20}. beyond that,{} the algorithm is quartic,{} \spad{O( (log n)^4 )}. Two improvements due to Davenport have been incorporated which catches some trivial strong pseudo-primes,{} such as [Jaeschke,{} 1991] 1377161253229053 * 413148375987157,{} which the original algorithm regards as prime');
INSERT INTO olibdb VALUES('o','prime?',1,'x','(PolynomialIdeal(Fraction(Integer),DirectProduct(#(vl),NonNegativeInteger),OrderedVariableList(vl),DistributedMultivariatePolynomial(vl,Fraction(Integer))))->Boolean','pIdealDecompositionPackage(vl)',NULL,'\spad{prime?(I)} tests if the ideal \spad{I} is prime.');
INSERT INTO olibdb VALUES('o','prime',2,'n','(%,NonNegativeInteger)->%','dOutputForm',NULL,'\spad{prime(f,{} n)} creates the form \spad{f} followed by \spad{n} primes.');
INSERT INTO olibdb VALUES('o','primeFactor',2,'x','(R,NonNegativeInteger)->%','dFactored(R)',NULL,'\spad{primeFactor(base,{} exponent)} creates a factored object with a single factor whose \spad{base} is asserted to be prime (flag = prime).');
INSERT INTO olibdb VALUES('o','primeFrobenius',1,'n','(S)->S','xFieldOfPrimeCharacteristic&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primeFrobenius',1,'x','(%)->%','cFieldOfPrimeCharacteristic',NULL,'\spad{primeFrobenius(a)} returns \spad{a ^ p} where \spad{p} is the characteristic.');
INSERT INTO olibdb VALUES('o','primeFrobenius',2,'n','(S,NonNegativeInteger)->S','xFieldOfPrimeCharacteristic&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primeFrobenius',2,'x','(%,NonNegativeInteger)->%','cFieldOfPrimeCharacteristic',NULL,'\spad{primeFrobenius(a,{} s)} returns \spad{a^(p^s)} where \spad{p} is the characteristic.');
INSERT INTO olibdb VALUES('o','primes',2,'x','(I,I)->List(I)','pIntegerPrimesPackage(I)',NULL,'\spad{primes(a,{} b)} returns a list of all primes \spad{p} with \spad{a <= p <= b}');
INSERT INTO olibdb VALUES('o','primextint',4,'n','((UP)->UP,(List(F))->List(Record(ratpart:F,coeffs:Vector(F))),(Matrix(F))->List(Vector(F)),List(Fraction(UP)))->List(Record(ratpart:Fraction(UP),coeffs:Vector(F)))','pParametricTranscendentalIntegration(F,UP)',NULL,'\spad{primextint('',{} ext,{} csolve,{} [g1,{} ...,{} gn])} returns a basis of solutions of the homogeneous system \spad{h'' + c1*g1 + ... + cn*gn = 0}. Argument \spad{ext} is an extended integration function on \spad{F}. \spad{csolve} is solver over constants.');
INSERT INTO olibdb VALUES('o','primintegrate',4,'n','(Fraction(UP),(UP)->UP,(Fraction(UP))->Record(answer:Fraction(UP),logpart:Fraction(UP),ir:IntegrationResult(Fraction(UP))),(F,NonNegativeInteger)->Union(Record(ratpart:F,coeff:F,prim:F),failed))->Record(answer:IntegrationResult(Fraction(UP)),a0:F)','pTranscendentalIntegration(F,UP)',NULL,'\spad{primintegrate(f,{} '',{} foo)} returns \spad{[g,{} a]} such that \spad{f = g'' + a},{} and \spad{a = 0} or \spad{a} has no integral in UP. Argument foo is an extended integration function on \spad{F}.');
INSERT INTO olibdb VALUES('o','primitive?',1,'n','(S)->Boolean','xFiniteFieldCategory&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitive?',1,'n','(SparseUnivariatePolynomial(GF))->Boolean','pFiniteFieldPolynomialPackage(GF)',NULL,'\spad{primitive?(f)} tests whether the polynomial \spad{f} over a finite field is primitive,{} \spadignore{i.e.} all its roots are primitive.');
INSERT INTO olibdb VALUES('o','primitive?',1,'x','(%)->Boolean','cFiniteFieldCategory',NULL,'\spad{primitive?(b)} tests whether the element \spad{b} is a generator of the (cyclic) multiplicative group of the field,{} \spadignore{i.e.} is a primitive element. Implementation Note: see \spad{ch}.IX.1.3,{} th.2 in \spad{D}. Lipson.');
INSERT INTO olibdb VALUES('o','primitiveElement',0,'x','()->%','cFiniteFieldCategory',NULL,'\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call,{} the primitive element is computed by calling \spadfun{createPrimitiveElement}.');
INSERT INTO olibdb VALUES('o','primitiveElement',1,'x','(List(F))->Record(primelt:F,poly:List(SparseUnivariatePolynomial(F)),prim:SparseUnivariatePolynomial(F))','pFunctionSpacePrimitiveElement(R,F)',NULL,'\spad{primitiveElement([a1,{} ...,{} an])} returns \spad{[a,{} [q1,{} ...,{} qn],{} q]} such that then \spad{k(a1,{} ...,{} an) = k(a)},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.');
INSERT INTO olibdb VALUES('o','primitiveElement',2,'n','(List(Polynomial(F)),List(Symbol))->Record(coef:List(Integer),poly:List(SparseUnivariatePolynomial(F)),prim:SparseUnivariatePolynomial(F))','pPrimitiveElement(F)',NULL,'\spad{primitiveElement([p1,{} ...,{} pn],{} [a1,{} ...,{} an])} returns \spad{[[c1,{} ...,{} cn],{} [q1,{} ...,{} qn],{} q]} such that then \spad{k(a1,{} ...,{} an) = k(a)},{} where \spad{a = a1 c1 + ... + an cn},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The \spad{pi}\spad{''s} are the defining polynomials for the \spad{ai}\spad{''s}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.');
INSERT INTO olibdb VALUES('o','primitiveElement',2,'x','(F,F)->Record(primelt:F,pol1:SparseUnivariatePolynomial(F),pol2:SparseUnivariatePolynomial(F),prim:SparseUnivariatePolynomial(F))','pFunctionSpacePrimitiveElement(R,F)','has(F,AlgebraicallyClosedField)','\spad{primitiveElement(a1,{} a2)} returns \spad{[a,{} q1,{} q2,{} q]} such that \spad{k(a1,{} a2) = k(a)},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The minimal polynomial for \spad{a2} may involve \spad{a1},{} but the minimal polynomial for \spad{a1} may not involve \spad{a2}; This operations uses \spadfun{resultant}.');
INSERT INTO olibdb VALUES('o','primitiveElement',3,'n','(List(Polynomial(F)),List(Symbol),Symbol)->Record(coef:List(Integer),poly:List(SparseUnivariatePolynomial(F)),prim:SparseUnivariatePolynomial(F))','pPrimitiveElement(F)',NULL,'\spad{primitiveElement([p1,{} ...,{} pn],{} [a1,{} ...,{} an],{} a)} returns \spad{[[c1,{} ...,{} cn],{} [q1,{} ...,{} qn],{} q]} such that then \spad{k(a1,{} ...,{} an) = k(a)},{} where \spad{a = a1 c1 + ... + an cn},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The \spad{pi}\spad{''s} are the defining polynomials for the \spad{ai}\spad{''s}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.');
INSERT INTO olibdb VALUES('o','primitiveElement',4,'n','(Polynomial(F),Symbol,Polynomial(F),Symbol)->Record(coef1:Integer,coef2:Integer,prim:SparseUnivariatePolynomial(F))','pPrimitiveElement(F)',NULL,'\spad{primitiveElement(p1,{} a1,{} p2,{} a2)} returns \spad{[c1,{} c2,{} q]} such that \spad{k(a1,{} a2) = k(a)} where \spad{a = c1 a1 + c2 a2,{} and q(a) = 0}. The \spad{pi}\spad{''s} are the defining polynomials for the \spad{ai}\spad{''s}. The \spad{p2} may involve \spad{a1},{} but \spad{p1} must not involve \spad{a2}. This operation uses \spadfun{resultant}.');
INSERT INTO olibdb VALUES('o','primitiveMonomials',1,'n','(%)->List(%)','cMaybeSkewPolynomialCategory(R,E,VarSet)','has(R,SemiRing)','\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \spad{p} with their coefficients removed. Note: \spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),{} ...,{} X^(n)]}.');
INSERT INTO olibdb VALUES('o','primitiveMonomials',1,'n','(S)->List(S)','xMaybeSkewPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',1,'n','(S)->S','xFiniteAbelianMonoidRing&(S,R,E)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',1,'n','(S)->S','xFunctionFieldCategory&(S,F,UP,UPUP)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',1,'n','(S)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart!',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',1,'n','(S)->S','xUnivariateSkewPolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',1,'x','(%)->%','cFiniteAbelianMonoidRing(R,E)','has(R,GcdDomain)','\spad{primitivePart(p)} returns the unit normalized form of polynomial \spad{p} divided by the content of \spad{p}.');
INSERT INTO olibdb VALUES('o','primitivePart',1,'x','(%)->%','cFunctionFieldCategory(F,UP,UPUP)',NULL,'\spad{primitivePart(f)} removes the content of the denominator and the common content of the numerator of \spad{f}.');
INSERT INTO olibdb VALUES('o','primitivePart',1,'x','(%)->%','cPolynomialCategory(R,E,VarSet)','has(R,GcdDomain)','\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \spad{p} with its content divided out.');
INSERT INTO olibdb VALUES('o','primitivePart!',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,GcdDomain)','\spad{primitivePart!(p)} replaces \spad{p} by its primitive part.');
INSERT INTO olibdb VALUES('o','primitivePart',2,'n','(S,VarSet)->S','xPolynomialCategory&(S,R,E,VarSet)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primitivePart',2,'n','(UP,R)->UP','pSubResultantPackage(R,UP)','has(R,EuclideanDomain)','\spad{primitivePart(p,{} q)} reduces the coefficient of \spad{p} modulo \spad{q},{} takes the primitive part of the result,{} and ensures that the leading coefficient of that result is monic.');
INSERT INTO olibdb VALUES('o','primitivePart',2,'x','(%,VarSet)->%','cPolynomialCategory(R,E,VarSet)','has(R,GcdDomain)','\spad{primitivePart(p,{} v)} returns the unitCanonical associate of the polynomial \spad{p} with its content with respect to the variable \spad{v} divided out.');
INSERT INTO olibdb VALUES('o','primitiveRowEchelon',1,'n','(%)->Record(Ech:%,Lt:Matrix(Fraction(D)),Pivots:List(D),Rank:NonNegativeInteger)','dSparseEchelonMatrix(C,D)','has(D,GcdDomain)','\spad{primitiveRowEchelon(A)} computes a row echelon form for the matrix \spad{A}. The algorithm used is fraction-free elimination. Every row is made primitive by division by the \spad{gcd}. The algorithm is especially adapted to matrices already close to row echelon form. The transformation matrix,{} the used pivots and the rank of the matrix are also returned.');
INSERT INTO olibdb VALUES('o','primPartElseUnitCanonical!',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primPartElseUnitCanonical',1,'n','(S)->S','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','primPartElseUnitCanonical!',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{primPartElseUnitCanonical!(p)} replaces \spad{p} by \spad{primPartElseUnitCanonical(p)}.');
INSERT INTO olibdb VALUES('o','primPartElseUnitCanonical',1,'x','(%)->%','cRecursivePolynomialCategory(R,E,V)','has(R,IntegralDomain)','\spad{primPartElseUnitCanonical(p)} returns \spad{primitivePart(p)} if \spad{R} is a \spad{gcd}-domain,{} otherwise \spad{unitCanonical(p)}.');
INSERT INTO olibdb VALUES('o','prinb',1,'n','(Integer)->Void','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{prinb }\undocumented');
INSERT INTO olibdb VALUES('o','principal?',1,'n','(S)->Boolean','xFiniteDivisorCategory&(S,F,UP,UPUP,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','principal?',1,'x','(%)->Boolean','cFiniteDivisorCategory(F,UP,UPUP,R)',NULL,'\spad{principal?(D)} tests if the argument is the divisor of a function.');
INSERT INTO olibdb VALUES('o','principalIdeal',1,'n','(List(S))->Record(coef:List(S),generator:S)','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','principalIdeal',1,'x','(List(%))->Record(coef:List(%),generator:%)','cPrincipalIdealDomain',NULL,'\spad{principalIdeal([f1,{} ...,{} fn])} returns a record whose generator component is a generator of the ideal generated by \spad{[f1,{} ...,{} fn]} whose coef component satisfies \spad{generator = sum (input.i * coef.i)}');
INSERT INTO olibdb VALUES('o','principalSubResultantSet',2,'n','(SparseUnivariatePolynomial(Polynomial(TheField)),SparseUnivariatePolynomial(Polynomial(TheField)))->List(Polynomial(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,NULL);
INSERT INTO olibdb VALUES('o','prindINFO',6,'n','(Record(lcmfij:Expon,totdeg:NonNegativeInteger,poli:Dpol,polj:Dpol),Dpol,Dpol,Integer,Integer,Integer)->Integer','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{prindINFO }\undocumented');
INSERT INTO olibdb VALUES('o','prinpolINFO',1,'n','(List(Dpol))->Void','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{prinpolINFO }\undocumented');
INSERT INTO olibdb VALUES('o','prinshINFO',1,'n','(Dpol)->Void','pGroebnerInternalPackage(Dom,Expon,Dpol)',NULL,'\spad{prinshINFO }\undocumented');
INSERT INTO olibdb VALUES('o','print',1,'n','(%)->Void','dOutputForm',NULL,'\spad{print(u)} prints the form \spad{u}.');
INSERT INTO olibdb VALUES('o','print',1,'x','(OutputForm)->Void','pPrintPackage',NULL,'\spad{print(o)} writes the output form \spad{o} on standard output using the two-dimensional formatter.');
INSERT INTO olibdb VALUES('o','printCode',1,'n','(%)->Void','dFortranCode',NULL,'\spad{printCode(f)} prints out \spad{f} in FORTRAN notation.');
INSERT INTO olibdb VALUES('o','printHeader',0,'n','()->Void','dTheSymbolTable',NULL,'\spad{printHeader()} produces the FORTRAN header for the current subprogram in the global symbol table on the current FORTRAN output stream.');
INSERT INTO olibdb VALUES('o','printHeader',1,'n','(Symbol)->Void','dTheSymbolTable',NULL,'\spad{printHeader(f)} produces the FORTRAN header for subprogram \spad{f} in the global symbol table on the current FORTRAN output stream.');
INSERT INTO olibdb VALUES('o','printHeader',2,'n','(Symbol,%)->Void','dTheSymbolTable',NULL,'\spad{printHeader(f,{} tab)} produces the FORTRAN header for subprogram \spad{f} in symbol table tab on the current FORTRAN output stream.');
INSERT INTO olibdb VALUES('o','printInfo!',2,'n','(String,String)->Void','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{printInfo!(x,{} y)} initializes the messages to be printed when manipulating items from the hash-table. If a key is retrieved then \spad{x} is displayed. If an item is stored then \spad{y} is displayed.');
INSERT INTO olibdb VALUES('o','printInfo',2,'x','(List(Record(val:List(P),tower:TS)),NonNegativeInteger)->Void','pRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','printInfo',2,'x','(List(Record(val:List(P),tower:TS)),NonNegativeInteger)->Void','pSquareFreeRegularSetDecompositionPackage(R,E,V,P,TS)',NULL,NULL);
INSERT INTO olibdb VALUES('o','printingInfo?',0,'n','()->Boolean','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{printingInfo?()} returns \spad{true} iff messages are printed when manipulating items from the hash-table.');
INSERT INTO olibdb VALUES('o','printStatement',1,'n','(List(OutputForm))->%','dFortranCode',NULL,'\spad{printStatement(l)} creates a representation of a PRINT statement.');
INSERT INTO olibdb VALUES('o','printStats!',0,'n','()->Void','pTabulatedComputationPackage(Key,Entry)',NULL,'\spad{printStats!()} prints the statistics.');
INSERT INTO olibdb VALUES('o','printSys',1,'n','(List(D))->OutputForm','dJetDifferentialEquation(JB,D)',NULL,'\spad{printSys(sys)} writes a list of functions as a vector of equations (with right hand side 0) and coerces the result to \spadtype{OutputForm}.');
INSERT INTO olibdb VALUES('o','printTypes',1,'n','(Symbol)->Void','dTheSymbolTable',NULL,'\spad{printTypes(tab)} produces FORTRAN type declarations from \spad{tab},{} on the current FORTRAN output stream');
INSERT INTO olibdb VALUES('o','printTypes',1,'n','(%)->Void','dSymbolTable',NULL,'\spad{printTypes(tab)} produces FORTRAN type declarations from \spad{tab},{} on the current FORTRAN output stream');
INSERT INTO olibdb VALUES('o','probablyZeroDim?',1,'n','(List(P))->Boolean','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{probablyZeroDim?(lp)} returns \spad{true} iff the number of polynomials in \spad{lp} is not smaller than the number of variables occurring in these polynomials.');
INSERT INTO olibdb VALUES('o','processTemplate',1,'n','(FileName)->FileName','dFortranTemplate',NULL,'\spad{processTemplate(tp)} processes the template \spad{tp},{} writing the result to the current FORTRAN output stream.');
INSERT INTO olibdb VALUES('o','processTemplate',2,'n','(FileName,FileName)->FileName','dFortranTemplate',NULL,'\spad{processTemplate(tp,{} fn)} processes the template \spad{tp},{} writing the result out to \spad{fn}.');
INSERT INTO olibdb VALUES('o','prod',1,'n','(%)->%','dOutputForm',NULL,'\spad{prod(expr)} creates the form prefixing \spad{expr} by a capital \spad{pi}.');
INSERT INTO olibdb VALUES('o','prod',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{prod(expr,{} lowerlimit)} creates the form prefixing \spad{expr} by a capital \spad{pi} with a lowerlimit.');
INSERT INTO olibdb VALUES('o','prod',3,'n','(%,%,%)->%','dOutputForm',NULL,'\spad{prod(expr,{} lowerlimit,{} upperlimit)} creates the form prefixing \spad{expr} by a capital \spad{pi} with both a \spad{lowerlimit} and upperlimit.');
INSERT INTO olibdb VALUES('o','prodiag',1,'n','(Stream(Stream(A)))->Stream(A)','pStreamTaylorSeriesOperations(A)',NULL,'\spad{prodiag(x)} performs diagonal infinite product of a stream of streams. When \spad{x(i)} is interpreted as stream of coefficients of series \spad{f_i(z),{} i=1,{}...},{} then \spad{prodiag(x) = (1 + z*f_1(z))*(1 + z^2*f_2(x))*...}');
INSERT INTO olibdb VALUES('o','product',1,'n','(Integer)->(Integer,List(OutputForm))->OutputBox','cFormatterCategory',NULL,'\spad{product(p)} returns a handler \spad{h} such that \spad{h(prec,{} args)} formats a product with product sign and respective limits. Outer parentheses are added if \spad{p < prec}.');
INSERT INTO olibdb VALUES('o','product',2,'n','(%,%)->%','dCubicalFacet',NULL,'This function returns the product of two cubical facets. Unlike the simplex case,{} the product is a single facet');
INSERT INTO olibdb VALUES('o','product',2,'n','(%,%)->%','dFiniteCubicalComplex(VS)',NULL,'Forms product of two cubical complexes.');
INSERT INTO olibdb VALUES('o','product',2,'n','(%,%)->%','dFiniteSimplicialComplex(VS)',NULL,'Forms product of two simplicial complexes. For more detailed explanation of simplex product code see: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Also see Hatcher [9]. page 277 - The simplicial cross product. page 278 - The cohomology cross product. Returns list,{} each entry is a ''lattice path'' from (0,{} 0) to (\spad{x},{} \spad{y}) where \spad{x} is number of entries in sa and \spad{y} is number of entries in \spad{sb}.');
INSERT INTO olibdb VALUES('o','product',2,'n','(F,SegmentBinding(F))->F','pCombinatorialFunction(R,F)',NULL,'\spad{product(f(n),{} n = a..b)} returns \spad{f}(a) * ... * \spad{f}(\spad{b}) as a formal product.');
INSERT INTO olibdb VALUES('o','product',2,'n','(F,Symbol)->F','pCombinatorialFunction(R,F)',NULL,'\spad{product(f(n),{} n)} returns the formal product \spad{P}(\spad{n}) which verifies \spad{P}(\spad{n+1})\spad{/P}(\spad{n}) = \spad{f}(\spad{n}).');
INSERT INTO olibdb VALUES('o','product',2,'n','(%,%)->List(ProductFacet)','dOrientedFacet',NULL,'This function returns the product of two facets. For more detailed explanation of simplex product code see: \url{http://www.euclideanspace.com/prog/scratchpad/mycode/topology/simplex/product/} Also see Hatcher [9]. page 277 - The simplicial cross product. page 278 - The cohomology cross product. Returns list,{} each entry is a ''lattice path'' from (0,{} 0) to (\spad{x},{} \spad{y}) where \spad{x} is number of entries in sa and \spad{y} is number of entries in \spad{sb}.');
INSERT INTO olibdb VALUES('o','product',2,'x','(%,%)->%','cGradedAlgebra(R,E)',NULL,'\spad{product(a,{} b)} is the degree-preserving \spad{R}-linear product: \blankline \indented{2}{\spad{degree product(a,{} b) = degree a + degree b}} \indented{2}{\spad{product(a1+a2,{} b) = product(a1,{} b) + product(a2,{} b)}} \indented{2}{\spad{product(a,{} b1+b2) = product(a,{} b1) + product(a,{} b2)}} \indented{2}{\spad{product(r*a,{} b) = product(a,{} r*b) = r*product(a,{} b)}} \indented{2}{\spad{product(a,{} product(b,{} c)) = product(product(a,{} b),{} c)}}');
INSERT INTO olibdb VALUES('o','product',2,'x','(%,%)->%','dCartesianTensor(minix,dim,R)',NULL,'\spad{product(s,{} t)} is the outer product of the tensors \spad{s} and \spad{t}. For example,{} if \spad{r = product(s,{} t)} for rank 2 tensors \spad{s} and \spad{t},{} then \spad{r} is a rank 4 tensor given by \indented{4}{\spad{r(i,{} j,{} k,{} l) = s(i,{} j)*t(k,{} l)}.}');
INSERT INTO olibdb VALUES('o','product',2,'x','(%,SegmentBinding(%))->%','cCombinatorialOpsCategory',NULL,'\spad{product(f(n),{} n = a..b)} returns \spad{f}(a) * ... * \spad{f}(\spad{b}) as a formal product.');
INSERT INTO olibdb VALUES('o','product',2,'x','(%,Symbol)->%','cCombinatorialOpsCategory',NULL,'\spad{product(f(n),{} n)} returns the formal product \spad{P}(\spad{n}) which verifies \spad{P}(\spad{n+1})\spad{/P}(\spad{n}) = \spad{f}(\spad{n}).');
INSERT INTO olibdb VALUES('o','product',3,'n','(%,%,NonNegativeInteger)->%','dXPBWPolynomial(VarSet,R)',NULL,'\spad{product(a,{} b,{} n)} returns \spad{a*b} (truncated up to order \spad{n}).');
INSERT INTO olibdb VALUES('o','productFacet',2,'n','(Integer,List(Record(left:NonNegativeInteger,right:NonNegativeInteger)))->%','dProductFacet',NULL,'Constructor for product facet');
INSERT INTO olibdb VALUES('o','productFacet',2,'n','(Integer,ProductFacet)->%','dProductFacet',NULL,'Copy constructor to allow change of sign');
INSERT INTO olibdb VALUES('o','project',2,'n','(%,NonNegativeInteger)->%','dJetDifferentialEquation(JB,D)',NULL,'\spad{project(de,{} q)} projects the differential equation \spad{de} of order higher than \spad{q} into the \spad{q}\spad{-}th order jet bundle.');
INSERT INTO olibdb VALUES('o','projection',1,'n','(%)->Union(%,failed)','dCell(TheField)',NULL,'\spad{projection(c)} projects \spad{c} with respect to main variable');
INSERT INTO olibdb VALUES('o','projectionSet',1,'n','(List(SparseUnivariatePolynomial(Polynomial(TheField))))->List(Polynomial(TheField))','pCylindricalAlgebraicDecompositionPackage(TheField)',NULL,'\spad{projectionSet(lup)} performs one projection step');
INSERT INTO olibdb VALUES('o','projectiveSpace',1,'n','(Integer)->DeltaComplex(VS)','pDeltaComplexFactory(VS)',NULL,'Generate a minimal projective space.');
INSERT INTO olibdb VALUES('o','projectiveSpace',1,'n','(Integer)->FiniteSimplicialComplex(VS)','pSimplicialComplexFactory(VS)',NULL,'Generate a minimal triangulation of the surface of a projective plane. A one sided surface which cannot be embedded in 3D space without intersecting itself. There are no external boundaries,{} every edge connects two faces. (A punctured projective plane is equivalent to a Moebius band)');
INSERT INTO olibdb VALUES('o','projectiveSpace',1,'n','(NonNegativeInteger)->FiniteCubicalComplex(Integer)','pCubicalComplexFactory',NULL,'Generate a cubical complex of the surface of a projective plane. A one sided surface which cannot be embedded in 3D space without intersecting itself. There are no external boundaries,{} every edge connects two faces. (A punctured projective plane is equivalent to a Moebius band)');
INSERT INTO olibdb VALUES('o','prolateSpheroidal',1,'x','(R)->(Point(R))->Point(R)','pCoordinateSystems(R)',NULL,'\spad{prolateSpheroidal(a)} transforms from prolate spheroidal coordinates to Cartesian coordinates: \spad{prolateSpheroidal(a)} is a function which will map the point \spad{(\spad{xi},{} eta,{} phi)} to \spad{x = a*sinh(\spad{xi})*sin(eta)*cos(phi)},{} \spad{y = a*sinh(\spad{xi})*sin(eta)*sin(phi)},{} \spad{z = a*cosh(\spad{xi})*cos(eta)}.');
INSERT INTO olibdb VALUES('o','prologue',1,'n','(%)->List(String)','dTexFormat',NULL,'\spad{prologue(t)} extracts the prologue section of a TeX form \spad{t}.');
INSERT INTO olibdb VALUES('o','prologue',1,'n','(%)->OutputBox','dFormatter(F)',NULL,'\spad{prologue(t)} extracts the prologue section of the form \spad{t}.');
INSERT INTO olibdb VALUES('o','prolong',1,'n','(%)->Record(SDe:%,IC:List(D))','dJetDifferentialEquation(JB,D)',NULL,'\spad{prolong(de)} prolongs the differential equation \spad{de}. Additionally the arising integrability conditions are returned.');
INSERT INTO olibdb VALUES('o','prolong',2,'n','(%,NonNegativeInteger)->%','dJetVectorField(JB,D)',NULL,'\spad{prolong(v,{} q)} prolongs a vector field \spad{v} defined on the base space into the jet bundle of order \spad{q}.');
INSERT INTO olibdb VALUES('o','prolong',2,'n','(%,NonNegativeInteger)->Record(SDe:%,IC:List(D))','dJetDifferentialEquation(JB,D)',NULL,'\spad{prolong(de,{} q)} is like \spad{prolong(de)}. However,{} only equations of lower order than \spad{q} are prolonged.');
INSERT INTO olibdb VALUES('o','prolongMV',1,'n','(Record(Rank:NonNegativeInteger,NumMultVar:NonNegativeInteger,Betas:List(NonNegativeInteger)))->Record(Rank:NonNegativeInteger,NumMultVar:NonNegativeInteger,Betas:List(NonNegativeInteger))','dJetDifferentialEquation(JB,D)',NULL,'\spad{prolongMV(mv)} calculates the number of multiplicative variables for the prolongation of an involutive symbol.');
INSERT INTO olibdb VALUES('o','prolongSymbol',1,'n','(SparseEchelonMatrix(JB,D))->SparseEchelonMatrix(JB,D)','dJetDifferentialEquation(JB,D)',NULL,'\spad{prolongSymbol(symb)} prolongs directly the symbol \spad{symb}.');
INSERT INTO olibdb VALUES('o','properties',1,'x','(%)->AssociationList(Symbol,None)','dBasicOperator',NULL,'\spad{properties(op)} returns the list of all the properties currently attached to \spad{op}.');
INSERT INTO olibdb VALUES('o','property',2,'x','(%,Symbol)->Union(None,failed)','dBasicOperator',NULL,'\spad{property(op,{} s)} returns the value of property \spad{s} if it is attached to \spad{op},{} and failed otherwise.');
INSERT INTO olibdb VALUES('o','proposition',1,'n','(String)->%','dILogic',NULL,'Constructs a proposition');
INSERT INTO olibdb VALUES('o','pseudoDivide',2,'n','(S,S)->Record(coef:R,quotient:S,remainder:S)','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pseudoDivide',2,'n','(S,S)->Record(quotient:S,remainder:S)','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pseudoDivide',2,'x','(%,%)->Record(coef:R,quotient:%,remainder:%)','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{pseudoDivide(p,{} q)} returns \spad{[c,{} s,{} r]},{} when \spad{p'' := p*lc(q)^(deg p - deg q + 1) = c * p} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p'' = s q + r}.');
INSERT INTO olibdb VALUES('o','pseudoDivide',2,'x','(%,%)->Record(quotient:%,remainder:%)','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{pseudoDivide(a,{} b)} computes \spad{[pquo(a,{} b),{} prem(a,{} b)]},{} both polynomials viewed as univariate polynomials in the main variable of \spad{b},{} if \spad{b} is not a constant polynomial.');
INSERT INTO olibdb VALUES('o','pseudoQuotient',2,'n','(S,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pseudoQuotient',2,'x','(%,%)->%','cUnivariatePolynomialCategory(R)','has(R,IntegralDomain)','\spad{pseudoQuotient(p,{} q)} returns \spad{s},{} the quotient when \spad{p'' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p'' = s q + r}.');
INSERT INTO olibdb VALUES('o','pseudoRem',3,'n','(MPT,MPT,MD)->MPT','cModularAlgebraicGcdOperations(MP,MPT,MD)',NULL,'\spad{pseudoRem(x,{} y,{} m)} computes pseudoremainder of \spad{x} by \spad{y} modulo \spad{m}.');
INSERT INTO olibdb VALUES('o','pseudoRemainder',2,'n','(S,S)->S','xUnivariatePolynomialCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','pseudoRemainder',2,'x','(%,%)->%','cUnivariatePolynomialCategory(R)','has(R,Ring)','\spad{pseudoRemainder(p,{} q)} = \spad{r},{} for polynomials \spad{p} and \spad{q},{} returns the remainder \spad{r} when \spad{p'' := p*lc(q)^(deg p - deg q + 1)} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p'' = s q + r}.');
INSERT INTO olibdb VALUES('o','Psi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{Psi()} returns symbol for capital greek letter psi.');
INSERT INTO olibdb VALUES('o','psi',0,'n','()->Symbol','pMathematicalSymbols',NULL,'\spad{psi()} returns symbol for small greek letter psi.');
INSERT INTO olibdb VALUES('o','psolve',1,'n','(Matrix(GR))->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c)} solves the homogeneous linear system \spad{c} \spad{z} = 0 for all possible ranks of the matrix \spad{c}');
INSERT INTO olibdb VALUES('o','psolve',2,'n','(Matrix(GR),List(GR))->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w}');
INSERT INTO olibdb VALUES('o','psolve',2,'n','(Matrix(GR),List(Symbol))->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and indeterminate right hand side \spad{w}');
INSERT INTO olibdb VALUES('o','psolve',2,'n','(Matrix(GR),PositiveInteger)->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c)} solves the homogeneous linear system \spad{c} \spad{z} = 0 for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c}');
INSERT INTO olibdb VALUES('o','psolve',2,'n','(Matrix(GR),String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} s)} solves \spad{c} \spad{z} = 0 for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','psolve',3,'n','(Matrix(GR),List(GR),PositiveInteger)->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} k)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and given right hand side vector \spad{w}');
INSERT INTO olibdb VALUES('o','psolve',3,'n','(Matrix(GR),List(GR),String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','psolve',3,'n','(Matrix(GR),List(Symbol),PositiveInteger)->List(Record(eqzro:List(GR),neqzro:List(GR),wcond:List(Polynomial(R)),bsoln:Record(partsol:Vector(Fraction(Polynomial(R))),basis:List(Vector(Fraction(Polynomial(R)))))))','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} k)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and indeterminate right hand side \spad{w}');
INSERT INTO olibdb VALUES('o','psolve',3,'n','(Matrix(GR),List(Symbol),String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and indeterminate right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','psolve',3,'n','(Matrix(GR),PositiveInteger,String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} k,{} s)} solves \spad{c} \spad{z} = 0 for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','psolve',4,'n','(Matrix(GR),List(GR),PositiveInteger,String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} k,{} s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and given right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','psolve',4,'n','(Matrix(GR),List(Symbol),PositiveInteger,String)->Integer','pParametricLinearEquations(R,Var,Expon,GR)',NULL,'\spad{psolve(c,{} w,{} k,{} s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and indeterminate right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes');
INSERT INTO olibdb VALUES('o','ptFunc',4,'n','((DoubleFloat,DoubleFloat)->DoubleFloat,(DoubleFloat,DoubleFloat)->DoubleFloat,(DoubleFloat,DoubleFloat)->DoubleFloat,(DoubleFloat,DoubleFloat,DoubleFloat)->DoubleFloat)->(DoubleFloat,DoubleFloat)->Point(DoubleFloat)','pMeshCreationRoutinesForThreeDimensions',NULL,'\spad{ptFunc(a,{} b,{} c,{} d)} is an internal function exported in order to compile packages.');
INSERT INTO olibdb VALUES('o','pToDmp',1,'n','(Polynomial(R))->DistributedMultivariatePolynomial(lv,R)','pPolToPol(lv,R)',NULL,'\spad{pToDmp(p)} converts \spad{p} from a \spadtype{POLY} to a \spadtype{DMP}.');
INSERT INTO olibdb VALUES('o','pToHdmp',1,'n','(Polynomial(R))->HomogeneousDistributedMultivariatePolynomial(lv,R)','pPolToPol(lv,R)',NULL,'\spad{pToHdmp(p)} converts \spad{p} from a \spadtype{POLY} to a \spadtype{HDMP}.');
INSERT INTO olibdb VALUES('o','ptree',1,'x','(S)->%','dPendantTree(S)',NULL,'\spad{ptree(s)} is a leaf? pendant tree');
INSERT INTO olibdb VALUES('o','ptree',2,'x','(%,%)->%','dPendantTree(S)',NULL,'\spad{ptree(x,{} y)} \undocumented');
INSERT INTO olibdb VALUES('o','puiseux',1,'x','(FE)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{puiseux(f)} returns a Puiseux expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.');
INSERT INTO olibdb VALUES('o','puiseux',1,'x','(Symbol)->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{puiseux(x)} returns \spad{x} viewed as a Puiseux series.');
INSERT INTO olibdb VALUES('o','puiseux',2,'x','(FE,Equation(FE))->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{puiseux(f,{} x = a)} expands the expression \spad{f} as a Puiseux series in powers of \spad{(x - a)}.');
INSERT INTO olibdb VALUES('o','puiseux',2,'x','(FE,Fraction(Integer))->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{puiseux(f,{} n)} returns a Puiseux expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.');
INSERT INTO olibdb VALUES('o','puiseux',2,'x','(Fraction(Integer),ULS)->%','cUnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)',NULL,'\spad{puiseux(r,{} f(x))} returns \spad{f(x^r)}.');
INSERT INTO olibdb VALUES('o','puiseux',3,'x','(FE,Equation(FE),Fraction(Integer))->Any','pExpressionToUnivariatePowerSeries(R,FE)',NULL,'\spad{puiseux(f,{} x = a,{} n)} expands the expression \spad{f} as a Puiseux series in powers of \spad{(x - a)}; terms will be computed up to order at least \spad{n}.');
INSERT INTO olibdb VALUES('o','puiseux',4,'n','((Fraction(Integer))->FE,Equation(FE),UniversalSegment(Fraction(Integer)),Fraction(Integer))->Any','pGenerateUnivariatePowerSeries2(FE)',NULL,'\spad{puiseux(n +-> a(n),{} x = a,{} r0..,{} r)} returns \spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \spad{puiseux(n +-> a(n),{} x = a,{} r0..r1,{} r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','puiseux',4,'x','((Fraction(Integer))->FE,Equation(FE),UniversalSegment(Fraction(Integer)),Fraction(Integer))->Any','pGenerateUnivariatePowerSeries(R,FE)',NULL,NULL);
INSERT INTO olibdb VALUES('o','puiseux',5,'n','(FE,Symbol,Equation(FE),UniversalSegment(Fraction(Integer)),Fraction(Integer))->Any','pGenerateUnivariatePowerSeries2(FE)','AND(has(FE,Evalable(FE)),has(FE,RetractableTo(Fraction(Integer))))','\spad{puiseux(a(n),{} n,{} x = a,{} r0..,{} r)} returns \spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \spad{puiseux(a(n),{} n,{} x = a,{} r0..r1,{} r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','puiseux',5,'n','((Fraction(Integer))->R,Symbol,R,UniversalSegment(Fraction(Integer)),Fraction(Integer))->Any','pGenerateUnivariatePowerSeries1(R)',NULL,'\spad{puiseux(n +-> a(n),{} x,{} a,{} r0..,{} r)} returns \spad{sum(n = r0,{} r0 + r,{} r0 + 2*r...,{} a(n) * (x - a)^n)}; \spad{puiseux(n +-> a(n),{} x = a,{} r0..r1,{} r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)^n)}.');
INSERT INTO olibdb VALUES('o','puiseux',5,'x','(FE,Symbol,Equation(FE),UniversalSegment(Fraction(Integer)),Fraction(Integer))->Any','pGenerateUnivariatePowerSeries(R,FE)','AND(has(FE,Evalable(FE)),has(FE,RetractableTo(Fraction(Integer))))',NULL);
INSERT INTO olibdb VALUES('o','pureLex',2,'n','(Vector(S),Vector(S))->Boolean','pOrderingFunctions(dim,S)',NULL,'\spad{pureLex(v1,{} v2)} return \spad{true} if the vector \spad{v1} is less than the vector \spad{v2} in the lexicographic ordering.');
INSERT INTO olibdb VALUES('o','purelyAlgebraic?',1,'n','(S)->Boolean','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','purelyAlgebraic?',1,'x','(%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{purelyAlgebraic?(ts)} returns \spad{true} iff for every algebraic variable \spad{v} of \spad{ts} we have \spad{algebraicCoefficients?(t_v,{} ts_v_-)} where \spad{ts_v} is \spadopFrom{select}{TriangularSetCategory}(\spad{ts},{} \spad{v}) and \spad{ts_v_-} is \spadopFrom{collectUnder}{TriangularSetCategory}(\spad{ts},{} \spad{v}).');
INSERT INTO olibdb VALUES('o','purelyAlgebraic?',2,'n','(P,S)->Boolean','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','purelyAlgebraic?',2,'x','(P,%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{purelyAlgebraic?(p,{} ts)} returns \spad{true} iff every variable of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','purelyAlgebraicLeadingMonomial?',2,'n','(P,S)->Boolean','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','purelyAlgebraicLeadingMonomial?',2,'x','(P,%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{purelyAlgebraicLeadingMonomial?(p,{} ts)} returns \spad{true} iff the main variable of any non-constant iterarted initial of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.');
INSERT INTO olibdb VALUES('o','purelyTranscendental?',2,'n','(P,S)->Boolean','xRegularTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','purelyTranscendental?',2,'x','(P,%)->Boolean','cRegularTriangularSetCategory(R,E,V,P)',NULL,'\spad{purelyTranscendental?(p,{} ts)} returns \spad{true} iff every variable of \spad{p} is not algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}');
INSERT INTO olibdb VALUES('o','purge!',2,'n','(%,(C)->Boolean)->Void','dSparseEchelonMatrix(C,D)',NULL,'\spad{purge!(A,{} crit)} eliminates all columns belonging to an index \spad{c} such that \spad{crit(c)} yields \spad{true}.');
INSERT INTO olibdb VALUES('o','push!',2,'x','(S,%)->S','cStackAggregate(S)',NULL,'\spad{push!(x,{} s)} pushes \spad{x} onto stack \spad{s},{} \spadignore{i.e.} destructively changing \spad{s} so as to have a new first (top) element \spad{x}. Afterwards,{} pop!(\spad{s}) produces \spad{x} and pop!(\spad{s}) produces the original \spad{s}.');
INSERT INTO olibdb VALUES('o','pushdown',2,'n','(PPR,List(OV))->PPR','pPushVariables(R,E,OV,PPR)',NULL,'\spad{pushdown(p,{} lv)} \undocumented{}');
INSERT INTO olibdb VALUES('o','pushdown',2,'x','(PRF,OV)->PRF','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{pushdown(prf,{} var)} pushes all top level occurrences of the variable var into the coefficient domain for the polynomial \spad{prf}.');
INSERT INTO olibdb VALUES('o','pushdterm',2,'x','(SparseUnivariatePolynomial(PRF),OV)->PRF','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{pushdterm(monom,{} var)} pushes all top level occurrences of the variable var into the coefficient domain for the monomial \spad{monom}.');
INSERT INTO olibdb VALUES('o','pushFortranOutputStack',1,'n','(FileName)->Void','pFortranOutputStackPackage',NULL,'\spad{pushFortranOutputStack(f)} pushes \spad{f} onto the Fortran output stack');
INSERT INTO olibdb VALUES('o','pushFortranOutputStack',1,'n','(String)->Void','pFortranOutputStackPackage',NULL,'\spad{pushFortranOutputStack(f)} pushes \spad{f} onto the Fortran output stack');
INSERT INTO olibdb VALUES('o','pushucoef',2,'x','(SparseUnivariatePolynomial(Polynomial(R)),OV)->PRF','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{pushucoef(upoly,{} var)} converts the anonymous univariate polynomial \spad{upoly} to a polynomial in var over rational functions.');
INSERT INTO olibdb VALUES('o','pushuconst',2,'x','(Fraction(Polynomial(R)),OV)->PRF','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{pushuconst(r,{} var)} takes a rational function and raises all occurrences of the variable var to the polynomial level.');
INSERT INTO olibdb VALUES('o','pushup',2,'n','(PPR,List(OV))->PPR','pPushVariables(R,E,OV,PPR)',NULL,'\spad{pushup(p,{} lv)} \undocumented{}');
INSERT INTO olibdb VALUES('o','pushup',2,'x','(PRF,OV)->PRF','pMPolyCatRationalFunctionFactorizer(E,OV,R,PRF)',NULL,'\spad{pushup(prf,{} var)} raises all occurrences of the variable var in the coefficients of the polynomial \spad{prf} back to the polynomial level.');
INSERT INTO olibdb VALUES('o','putColorInfo',2,'n','(List(List(Point(DoubleFloat))),List(Palette))->List(List(Point(DoubleFloat)))','dGraphImage',NULL,'\spad{putColorInfo(llp,{} lpal)} takes a list of list of points,{} \spad{llp},{} and returns the points with their hue and shade components set according to the list of palette colors,{} \spad{lpal}.');
INSERT INTO olibdb VALUES('o','putGraph',3,'n','(%,GraphImage,PositiveInteger)->Void','dTwoDimensionalViewport',NULL,'\spad{putGraph(v,{} \spad{gi},{} n)} sets the graph field indicated by \spad{n},{} of the indicated two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} to be the graph,{} \spad{\spad{gi}} of domain \spadtype{GraphImage}. The contents of viewport,{} \spad{v},{} will contain \spad{\spad{gi}} when the function \spadfun{makeViewport2D} is called to create the an updated viewport \spad{v}.');
INSERT INTO olibdb VALUES('o','qaddColumns!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addColumns!(f,{} i,{} j,{} alpha)} adds alpha*column(\spad{i}) to column(\spad{j}) in A and subtracts row(\spad{j}) from row(\spad{i}) in \spad{s} (in the ALS of \spad{f}),{} \spadignore{i.e.} (A*U)(U^-1*s) = \spad{v}.');
INSERT INTO olibdb VALUES('o','qaddColumns!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{addColumns!(p,{} i,{} j,{} alpha)} adds alpha*column(\spad{i}) to column(\spad{j}) in all matrices of the linear pencil \spad{p}. (no index check)');
INSERT INTO olibdb VALUES('o','qaddRows!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,F)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{addRows!(f,{} i,{} j,{} alpha)} adds alpha*row(\spad{i}) to row(\spad{j}) in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','qaddRows!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qaddRows!(p,{} i,{} j,{} alpha)} adds alpha*row(\spad{i}) to row(\spad{j}) in all matrices of the linear pencil \spad{p} (no index check). (no index check)');
INSERT INTO olibdb VALUES('o','qcoerce',1,'x','(Integer)->%','dNonNegativeInteger',NULL,'\spad{qcoerce(n)} coerces \spad{n} to \spad{\%} trusting that \spad{n} is nonnegative');
INSERT INTO olibdb VALUES('o','qcoerce',1,'x','(Integer)->%','dPositiveInteger',NULL,'\spad{qcoerce(n)} coerces \spad{n} to \spad{\%} trusting that \spad{n} is positive');
INSERT INTO olibdb VALUES('o','qcolumnIndices',2,'n','(%,NonNegativeInteger)->List(List(NonNegativeInteger))','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qcolumnIndices(p,{} off)} returns a list of column indices for nozero elements for every row starting at the specified offset. (no range check)');
INSERT INTO olibdb VALUES('o','qcolumnIndices',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(List(NonNegativeInteger))','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qcolumnIndices(p,{} off,{} l)} returns a list of column indices for nonzero elements in matrix \spad{l} for every row starting at the specified offset. (no range check)');
INSERT INTO olibdb VALUES('o','qcolumnIndices',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qcolumnIndices(p,{} off,{} i,{} l)} returns a list of column indices for nonzero elements in the specified row of matrix \spad{l} for starting at the specified offset. (no range check)');
INSERT INTO olibdb VALUES('o','qconvert',1,'n','(Integer)->%','dU64Int',NULL,NULL);
INSERT INTO olibdb VALUES('o','qconvert',1,'x','(Integer)->%','dSingleInteger',NULL,'\spad{qconvert(x)} converts \spad{x} to \% trusting that \spad{x} is in correct range.');
INSERT INTO olibdb VALUES('o','qdiagonal?',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qdiagonal?(p,{} k_min,{} k_max,{} l)} is the matrix \spad{l} diagonal between \spad{k_min} and k_max? (no range check)');
INSERT INTO olibdb VALUES('o','qdiagonal',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->List(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qdiagonal(p,{} k_min,{} k_max,{} l)} returns the entries along the diagonal between \spad{k_min} and \spad{k_max}. (no range check)');
INSERT INTO olibdb VALUES('o','qelt',2,'n','(S,Dom)->Im','xEltableAggregate&(S,Dom,Im)',NULL,NULL);
INSERT INTO olibdb VALUES('o','qelt',2,'x','(%,Dom)->Im','cEltableAggregate(Dom,Im)',NULL,'\spad{qelt(u,{} x)} applies \spad{u} to \spad{x} without checking whether \spad{x} is in the domain of \spad{u}. If \spad{x} is not in the domain of \spad{u} a memory-access violation may occur. If a check on whether \spad{x} is in the domain of \spad{u} is required,{} use the function \spad{elt}.');
INSERT INTO olibdb VALUES('o','qelt',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{elt(p,{} i,{} j)} returns the elements (\spad{i},{}\spad{j}) from the linear pencil \spad{p} as a list (no check).');
INSERT INTO olibdb VALUES('o','qelt',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->XDistributedPolynomial(VAR,F)','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{qelt(f,{} i,{} j)} returns A(\spad{i},{}\spad{j}) from the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','qelt',3,'x','(%,Integer,Integer)->R','cRectangularMatrixCategory(m,n,R,Row,Col)',NULL,'\spad{qelt(m,{} i,{} j)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m}. Note: there is NO error check to determine if indices are in the proper ranges.');
INSERT INTO olibdb VALUES('o','qelt',3,'x','(%,Integer,Integer)->R','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{qelt(m,{} i,{} j)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m} NO error check to determine if indices are in proper ranges');
INSERT INTO olibdb VALUES('o','qelt',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->R','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{elt(p,{} i,{} j,{} l)} returns the element (\spad{i},{}\spad{j}) in matrix \spad{l} of the linear pencil \spad{p} (no index-check).');
INSERT INTO olibdb VALUES('o','qequal?',5,'n','(%,List(NonNegativeInteger),%,List(NonNegativeInteger),NonNegativeInteger)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qequal?(p,{} pos_p,{} q,{} pos_q,{} offset)} checks,{} if the matrices are equal starting at offset.');
INSERT INTO olibdb VALUES('o','qinterval',2,'x','(R,R)->%','cIntervalCategory(R)',NULL,'\spad{qinterval(inf,{} sup)} creates a new interval \spad{[inf,{} sup]},{} without checking the ordering on the elements.');
INSERT INTO olibdb VALUES('o','qlog',1,'x','(%)->%','dDoubleFloat',NULL,'\spad{qlog(x)} computes natural logarithm of \spad{x}. It assumes that \spad{x > 0}.');
INSERT INTO olibdb VALUES('o','qmultiplyColumn!',3,'n','(%,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{multiplyColumn!(p,{} j,{} alphat)} multiplies column(\spad{j}) by alpha.');
INSERT INTO olibdb VALUES('o','qmultiplyRow!',3,'n','(%,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qmultiplyRow!(p,{} i,{} alpha)} multiplies row(\spad{i}) by alpha. (no index check)');
INSERT INTO olibdb VALUES('o','qnew',1,'n','(Integer)->%','dComplexDoubleFloatVector',NULL,'\spad{qnew(n)} creates a new uninitialized vector of length \spad{n}.');
INSERT INTO olibdb VALUES('o','qnew',1,'n','(Integer)->%','dDoubleFloatVector',NULL,'\spad{qnew(n)} creates a new uninitialized vector of length \spad{n}.');
INSERT INTO olibdb VALUES('o','qnew',1,'n','(NonNegativeInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{qnew(n)} creates an empty ALS of dimension \spad{n}.');
INSERT INTO olibdb VALUES('o','qnew',2,'n','(NonNegativeInteger,List(FreeMonoid(VAR)))->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{qnew(n,{} lst)} creates an empty ALS of dimension \spad{n}.');
INSERT INTO olibdb VALUES('o','qnew',2,'x','(NonNegativeInteger,NonNegativeInteger)->%','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{qnew(m,{} n)} is is an \spad{m}-by-\spad{n} uninitilized array');
INSERT INTO olibdb VALUES('o','qnew',3,'n','(NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qnew(m,{} n,{} l)} creates an empty linear pencil with \spad{l} matrices with \spad{m} rows and \spad{n} columns.');
INSERT INTO olibdb VALUES('o','qnilpotent?',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qnilpotent?(p,{} k_min,{} k_max,{} l)} ist the matrix \spad{l} nilpotent with respect to the specified block? (no range check)');
INSERT INTO olibdb VALUES('o','qPot',2,'n','(Vector(GF),Integer)->Vector(GF)','pInnerNormalBasisFieldFunctions(GF)',NULL,'\spad{qPot(v,{} e)} computes \spad{v^(q^e)},{} interpreting \spad{v} as an element of normal basis field,{} \spad{q} the size of the ground field. This is done by a cyclic \spad{e}-shift of the vector \spad{v}.');
INSERT INTO olibdb VALUES('o','qregular?',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->Boolean','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{qregular?(f,{} i_min,{} i_max)} does the specified diagonal block define a regular element?');
INSERT INTO olibdb VALUES('o','qroot',2,'n','(Fraction(Integer),NonNegativeInteger)->Record(exponent:NonNegativeInteger,coef:F,radicand:F)','pPolynomialRoots(E,V,R,P,F)',NULL,'\spad{qroot(f,{} n)} returns \spad{[m,{} c,{} r]} such that \spad{f^(1/n) = c * r^(1/m)}.');
INSERT INTO olibdb VALUES('o','qrowIndices',2,'n','(%,NonNegativeInteger)->List(List(NonNegativeInteger))','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qrowIndices(p,{} off)} returns a list of row indices for nonzero elements for every column starting at the specified offset. (no range check)');
INSERT INTO olibdb VALUES('o','qrowIndices',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->List(List(NonNegativeInteger))','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qrowIndices(p,{} off,{} l)} returns a list of row indices for nonzero elements in matrix \spad{l} for every column starting at the specified offset. (no range check)');
INSERT INTO olibdb VALUES('o','qrowIndices',4,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->List(NonNegativeInteger)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qrowIndices(p,{} off,{} j,{} l)} returns a list of row indices for nozero elements in column \spad{j} in matrix \spad{l} (no range check)');
INSERT INTO olibdb VALUES('o','qscaleBlock!',7,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,R)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qscalesubMatrix!(p,{} i_min,{} i_max,{} j_min,{} j_max,{} l,{} alpha)} multiplies the entries in the specified block of matrix \spad{l} with alpha.');
INSERT INTO olibdb VALUES('o','qsemizero?',6,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger)->Boolean','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qsemizero?(p,{} i_min,{} i_max,{} j_min,{} j_max,{} l)} checks,{} if the specified submatrix is zero except for matrix \spad{l} (no index check).');
INSERT INTO olibdb VALUES('o','qsetelt!',3,'n','(S,Dom,Im)->Im','xEltableAggregate&(S,Dom,Im)',NULL,NULL);
INSERT INTO olibdb VALUES('o','qsetelt!',3,'x','(%,Dom,Im)->Im','cEltableAggregate(Dom,Im)','has(%,shallowlyMutable)','\spad{qsetelt!(u,{} x,{} y)} sets the image of \spad{x} to be \spad{y} under \spad{u},{} without checking that \spad{x} is in the domain of \spad{u}. If such a check is required use the function \spad{setelt!}.');
INSERT INTO olibdb VALUES('o','qsetelt!',4,'n','(%,NonNegativeInteger,NonNegativeInteger,List(R))->List(R)','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qsetelt!(p,{} i,{} j,{} lst)} sets the element (\spad{i},{}\spad{j}) in the matrices of the linear pencil \spad{p} according to the elements in \spad{lst}.');
INSERT INTO olibdb VALUES('o','qsetelt!',4,'x','(%,Integer,Integer,R)->R','cTwoDimensionalArrayCategory(R,Row,Col)',NULL,'\spad{qsetelt!(m,{} i,{} j,{} r)} sets the element in the \spad{i}th row and \spad{j}th column of \spad{m} to \spad{r} NO error check to determine if indices are in proper ranges');
INSERT INTO olibdb VALUES('o','qsetelt!',5,'n','(%,NonNegativeInteger,NonNegativeInteger,NonNegativeInteger,R)->R','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qselelt!(p,{} i,{} j,{} l,{} alpha)} sets the element (\spad{i},{}\spad{j}) in matrix \spad{l} of the linear pencil \spad{p} to alpha.');
INSERT INTO olibdb VALUES('o','qsetfirst!',2,'n','(A,S)->S','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','qsetfirst!',2,'x','(%,S)->S','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{qsetfirst!(u,{} x)} destructively changes the first element of \spad{u} to \spad{x} without checking for errors.');
INSERT INTO olibdb VALUES('o','qsetrest!',2,'n','(A,A)->A','xUnaryRecursiveAggregate&(A,S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','qsetrest!',2,'x','(%,%)->%','cUnaryRecursiveAggregate(S)','has(%,shallowlyMutable)','\spad{qsetrest!(u,{} v)} destructively changes the rest of \spad{u} to \spad{v} without checking for errors.');
INSERT INTO olibdb VALUES('o','qShiftAction',4,'n','(D,NonNegativeInteger,NonNegativeInteger,V)->D','pFractionFreeFastGaussian(D,V)',NULL,'\spad{qShiftAction(q,{} k,{} l,{} g)} gives the coefficient of \spad{x^k} in \spad{z^l} \spad{g}(\spad{x}),{} where \spad{z*}(a+b*x+c*x^2+d*x^3+...) = (a+q*b*x+q^2*c*x^2+q^3*d*x^3+...). In terms of sequences,{} z*u(\spad{n})=q^n*u(\spad{n}).');
INSERT INTO olibdb VALUES('o','qShiftC',2,'n','(D,NonNegativeInteger)->List(D)','pFractionFreeFastGaussian(D,V)',NULL,'\spad{qShiftC} gives the coefficients \spad{c_}{\spad{k},{} \spad{k}} in the expansion <x^k> \spad{z} \spad{g}(\spad{x}) = sum_{\spad{i=0}}\spad{^k} \spad{c_}{\spad{k},{} \spad{i}} <x^i> \spad{g}(\spad{x}),{} where \spad{z} acts on \spad{g}(\spad{x}) by shifting. In fact,{} the result is [1,{} \spad{q},{} \spad{q^2},{} ...]');
INSERT INTO olibdb VALUES('o','qsqrt',1,'x','(%)->%','dDoubleFloat',NULL,'\spad{qsqrt(x)} computes square root of \spad{x}. It assumes that \spad{x >= 0}.');
INSERT INTO olibdb VALUES('o','qswapColumns!',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{swapColumns!(f,{} i,{} j)} exchanges columns \spad{i} and \spad{j} in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','qswapColumns!',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qswapColumns!(p,{} i,{} j)} exchanges columns \spad{i} and \spad{j} in all matrices of the linear pencil \spad{p} (no index check)');
INSERT INTO olibdb VALUES('o','qswapRows!',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->%','dFreeDivisionAlgebra(VAR,F)',NULL,'\spad{swapRows!(f,{} i,{} j)} exchanges rows \spad{i} and \spad{j} in the ALS of \spad{f}.');
INSERT INTO olibdb VALUES('o','qswapRows!',3,'n','(%,NonNegativeInteger,NonNegativeInteger)->%','dLinearMultivariateMatrixPencil(R)',NULL,'\spad{qswapRows!(p,{} i,{} j)} exchanges rows \spad{i} and \spad{j} in all matrices of the linear pencil \spad{p} (no index check).');
INSERT INTO olibdb VALUES('o','quadratic',1,'n','(UP)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{quadratic(u)} \undocumented');
INSERT INTO olibdb VALUES('o','quadratic',3,'n','(F,F,F)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{quadratic(f,{} g,{} h)} \undocumented');
INSERT INTO olibdb VALUES('o','quadraticForm',1,'x','(SquareMatrix(n,K))->%','dQuadraticForm(n,K)',NULL,'\spad{quadraticForm(m)} creates a quadratic form from a symmetric,{} square matrix \spad{m}.');
INSERT INTO olibdb VALUES('o','quadraticNonResidue',0,'n','()->%','dInnerPrimeField(p)',NULL,'\spad{quadraticNonResidue()} computes the smallest non negative integer,{} which represents a quadratic non residue.');
INSERT INTO olibdb VALUES('o','quadraticNorm',1,'n','(UP)->F','pGaloisGroupFactorizationUtilities(R,UP,F)',NULL,'\spad{quadraticNorm(f)} returns the \spad{l2} norm of the polynomial \spad{f}.');
INSERT INTO olibdb VALUES('o','quartic',1,'n','(UP)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{quartic(u)} \undocumented');
INSERT INTO olibdb VALUES('o','quartic2',2,'n','(SparseUnivariatePolynomial(F),F)->Union(Record(reals:List(F),complexes:List(Record(real:F,imag:F))),failed)','pRootUtilities(R,F)',NULL,'\spad{quartic2(p,{} a0)} should be local but conditional');
INSERT INTO olibdb VALUES('o','quartic',5,'n','(F,F,F,F,F)->List(F)','pPolynomialSolveByFormulas(UP,F,RR)',NULL,'\spad{quartic(f,{} g,{} h,{} i,{} j)} \undocumented');
INSERT INTO olibdb VALUES('o','quasiAlgebraicSet',2,'n','(List(Dpoly),Dpoly)->%','dQuasiAlgebraicSet(R,Var,Expon,Dpoly)',NULL,'\spad{quasiAlgebraicSet(pl,{} q)} returns the quasi-algebraic set with defining equations \spad{p} = 0 for \spad{p} belonging to the list \spad{pl},{} and defining inequation \spad{q} \spad{~=} 0.');
INSERT INTO olibdb VALUES('o','quasiComponent',1,'n','(S)->Record(close:List(P),open:List(P))','xTriangularSetCategory&(S,R,E,V,P)',NULL,NULL);
INSERT INTO olibdb VALUES('o','quasiComponent',1,'x','(%)->Record(close:List(P),open:List(P))','cTriangularSetCategory(R,E,V,P)',NULL,'\spad{quasiComponent(ts)} returns \spad{[lp,{} lq]} where \spad{lp} is the list of the members of \spad{ts} and \spad{lq}is \spad{initials(ts)}.');
INSERT INTO olibdb VALUES('o','quasiMonic?',1,'n','(S)->Boolean','xRecursivePolynomialCategory&(S,R,E,V)',NULL,NULL);
INSERT INTO olibdb VALUES('o','quasiMonic?',1,'x','(%)->Boolean','cRecursivePolynomialCategory(R,E,V)',NULL,'\spad{quasiMonic?(p)} returns \spad{false} if \spad{p} belongs to \spad{R},{} otherwise returns \spad{true} iff the initial of \spad{p} lies in the base ring \spad{R}.');
INSERT INTO olibdb VALUES('o','quasiMonicPolynomials',1,'n','(List(P))->Record(goodPols:List(P),badPols:List(P))','pPolynomialSetUtilitiesPackage(R,E,V,P)',NULL,'\spad{quasiMonicPolynomials(lp)} returns \spad{qmps,{} nqmps} where \spad{qmps} is a list of the quasi-monic polynomials in \spad{lp} and \spad{nqmps} are the other ones.');
INSERT INTO olibdb VALUES('o','quasiRegular?',1,'n','(%)->Boolean','dXPolynomialRing(R,E)',NULL,'\spad{quasiRegular?(x)} return \spad{true} if \spad{constant(p)} is zero.');
INSERT INTO olibdb VALUES('o','quasiRegular',1,'n','(%)->%','dXPolynomialRing(R,E)',NULL,'\spad{quasiRegular(x)} return \spad{x} minus its constant term.');
INSERT INTO olibdb VALUES('o','quasiRegular?',1,'x','(%)->Boolean','cXFreeAlgebra(vl,R)',NULL,'\spad{quasiRegular?(x)} return \spad{true} if \spad{constant(x)} is zero.');
INSERT INTO olibdb VALUES('o','quasiRegular',1,'x','(%)->%','cXFreeAlgebra(vl,R)',NULL,'\spad{quasiRegular(x)} return \spad{x} minus its constant term.');
INSERT INTO olibdb VALUES('o','quatern',4,'x','(R,R,R,R)->%','cQuaternionCategory(R)',NULL,'\spad{quatern(r,{} i,{} j,{} k)} constructs a quaternion from scalars.');
INSERT INTO olibdb VALUES('o','queue',1,'x','(List(S))->%','dQueue(S)',NULL,'\spad{queue([x,{} y,{} ...,{} z])} creates a queue with first (top) element \spad{x},{} second element \spad{y},{} ...,{} and last (bottom) element \spad{z}.');
INSERT INTO olibdb VALUES('o','quickSort',2,'x','((S,S)->Boolean,V)->V','pFiniteLinearAggregateSort(S,V)',NULL,'\spad{quickSort(f,{} agg)} sorts the aggregate agg with the ordering function \spad{f} using the quicksort algorithm.');
INSERT INTO olibdb VALUES('o','quo',2,'n','(%,%)->%','dOutputForm',NULL,'\spad{f quo g} creates the equivalent infix form.');
INSERT INTO olibdb VALUES('o','quo',2,'n','(S,S)->S','xComplexCategory&(S,R)',NULL,NULL);
INSERT INTO olibdb VALUES('o','quo',2,'n','(S,S)->S','xEuclideanDomain&(S)',NULL,NULL);
INSERT INTO olibdb VALUES('o','quo',2,'x','(%,%)->%','cEuclideanDomain',NULL,'\spad{x quo y} is the same as \spad{divide(x,{} y).quotient}. See \spadfunFrom{divide}{EuclideanDomain}.');
INSERT INTO olibdb VALUES('o','quo',2,'x','(%,%)->%','dNonNegativeInteger',NULL,'\spad{a quo b} returns the quotient of \spad{a} and \spad{b},{} forgetting the remainder.');
INSERT INTO olibdb VALUES('o','quoByVar',1,'x','(%)->%','cUnivariateTaylorSeriesCategory(Coef)',NULL,'\spad{quoByVar(a0 + a1 x + a2 x^2 + ...)} returns \spad{a1 + a2 x + a3 x^2 + ...} Thus,{} this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order.');
INSERT INTO olibdb VALUES('o','quote',0,'x','()->%','dCharacter',NULL,replace('\spad{quote()} provides the string quote character,{} \spad{}.\no,quote,1,n,(%)->%,dOutputForm,",\spad{quote(f)} creates the form \spad{f} with a prefix quote.\no,quoted?,1,n,(%)->Boolean,dPattern(R),",\spad{quoted?(p)} tests if \spad{p} is of the form \spad{''s} for a symbol \spad{s}.\no,quotedOperators,1,x,(%)->List(Symbol),dRewriteRule(Base','\n',char(10)));
INSERT INTO olibdb VALUES('p','GroebnerInternalPackage',3,'n','(Dom:GcdDomain,Expon:OrderedAbelianMonoidSup,Dpol:Join(FiniteAbelianMonoidRing(Dom,Expon),etc))->etc','(Dom,Expon,Dpol)','GBINTERN','This package provides low level tools for Groebner basis computations.');
INSERT INTO olibdb VALUES('p','GroebnerPackage',3,'x','(Dom:GcdDomain,Expon:OrderedAbelianMonoidSup,Dpol:Join(FiniteAbelianMonoidRing(Dom,Expon),etc))->etc','(Dom,Expon,Dpol)','GB','\spadtype{GroebnerPackage} computes groebner bases for polynomial ideals. The basic computation provides a distinguished set of generators for polynomial ideals over fields. This basis allows an easy test for membership: the operation \spadfun{normalForm} returns zero on ideal members. When the provided coefficient domain,{} Dom,{} is not a field,{} the result is equivalent to considering the extended ideal with \spadtype{Fraction(Dom)} as coefficients,{} but considerably more efficient since all calculations are performed in Dom. Additional argument info and redcrit can be given to provide incremental information during computation. Argument info produces a computational summary for each \spad{s}-polynomial. Argument redcrit prints out the reduced critical pairs. The term ordering is determined by the polynomial type used. Suggested types include \spadtype{DistributedMultivariatePolynomial},{} \spadtype{HomogeneousDistributedMultivariatePolynomial},{} \spadtype{GeneralDistributedMultivariatePolynomial}.');
INSERT INTO olibdb VALUES('p','GroebnerSolve',3,'n','(List(Symbol),F:GcdDomain,GcdDomain)->etc','(lv,F,R)','GROEBSOL','Solve systems of polynomial equations using Groebner bases Total order Groebner bases are computed and then converted to lex ones This package is mostly intended for internal use.');
INSERT INTO olibdb VALUES('p','GroupPresentationFunctions1',1,'n','(SetCategory)->etc','(S)','GROUPPF1','This package implements conversion between group \indented{1}{presentation given in terms of elements of \spadtype{FreeGroup}} \indented{1}{and \spadtype{GroupPresentation}.}');
INSERT INTO olibdb VALUES('p','Guess',5,'x','(F:Join(Field,etc),S:GcdDomain,EXPRR:Join(FunctionSpace(Integer),etc),(EXPRR)->F,(F)->EXPRR)->etc','(F,S,EXPRR,retract,coerce)','GUESS','This package implements guessing of sequences. Packages for the most common cases are provided as \spadtype{GuessInteger},{} \spadtype{GuessPolynomial},{} etc.');
INSERT INTO olibdb VALUES('p','GuessAlgebraicNumber',0,'n','()->etc',NULL,'GUESSAN','This package exports guessing of sequences of rational functions');
INSERT INTO olibdb VALUES('p','GuessExpBin',5,'n','(F:Join(Field,etc),S:GcdDomain,EXPRR:Join(FunctionSpace(Integer),etc),(EXPRR)->F,(F)->EXPRR)->etc','(F,S,EXPRR,retract,coerce)','GUESSEB','This package implements guessing GuessExpRat and GuessBinRat functions of guessing package.');
INSERT INTO olibdb VALUES('p','GuessFinite',1,'x','(Join(FiniteFieldCategory,etc))->etc','(F)','GUESSF','This package exports guessing of sequences of numbers in a finite field');
INSERT INTO olibdb VALUES('p','GuessFiniteFunctions',1,'n','(Join(FiniteFieldCategory,etc))->etc','(F)','GUESSF1','This package exports coercion and retraction from EXPR INT to finite fields');
INSERT INTO olibdb VALUES('p','GuessInteger',0,'x','()->etc',NULL,'GUESSINT','This package exports guessing of sequences of rational numbers');
INSERT INTO olibdb VALUES('p','GuessPolynomial',1,'x','(Ring)->etc','(R)','GUESSP','This package exports guessing of sequences of rational functions');
INSERT INTO olibdb VALUES('p','GuessPolynomialFunctions',1,'n','(Ring)->etc','(R)','GUESSP1','This package exports coercion and retraction from EXPR INT to polynomials');
INSERT INTO olibdb VALUES('p','GuessPolynomialInteger',0,'x','()->etc',NULL,'GUESSPI','This package exports guessing of sequences of rational functions over the integers');
INSERT INTO olibdb VALUES('p','HallBasis',0,'x','()->etc',NULL,'HB','Generate a basis for the free Lie algebra on \spad{n} generators over a ring \spad{R} with identity up to basic commutators of length \spad{c} using the algorithm of \spad{P}. Hall as given in Serre\spad{''s} book Lie Groups \spad{--} Lie Algebras.');
INSERT INTO olibdb VALUES('p','HankelPackage',1,'n','(Ring)->etc','(R)','HANKP','Package to generate Hankel matrices.');
INSERT INTO olibdb VALUES('p','HeuGcd',1,'n','(UnivariatePolynomialCategory(Integer))->etc','(BP)','HEUGCD','This package provides the functions for the heuristic integer \spad{gcd}. Geddes\spad{''s} algorithm,{} for univariate polynomials with integer coefficients');
INSERT INTO olibdb VALUES('p','IdealDecompositionPackage',1,'x','(List(Symbol))->etc','(vl)','IDECOMP','\indented{2}{This package provides functions for the primary decomposition of} polynomial ideals over the rational numbers. The ideals are members of the \spadtype{PolynomialIdeal} domain,{} and the polynomial generators are required to be from the \spadtype{DistributedMultivariatePolynomial} domain.');
INSERT INTO olibdb VALUES('p','IncrementingMaps',1,'n','(Join(Monoid,etc))->etc','(R)','INCRMAPS','This package provides operations to create incrementing functions.');
INSERT INTO olibdb VALUES('p','InfiniteLambertProduct',2,'x','(Coef:Ring,UTS:UnivariateTaylorSeriesCategory(Coef))->etc','(Coef,UTS)','INFPROD0','This package computes infinite products of univariate Taylor series');
INSERT INTO olibdb VALUES('p','InfiniteTupleFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','ITFUN2','Functions defined on streams with entries in two sets.');
INSERT INTO olibdb VALUES('p','InfiniteTupleFunctions3',3,'x','(Type,B:Type,C:Type)->etc','(A,B,C)','ITFUN3','Functions defined on streams with entries in three sets.');
INSERT INTO olibdb VALUES('p','Infinity',0,'x','()->etc',NULL,'INFINITY','Default infinity signatures for the interpreter; Date Created: 4 Oct 1989');
INSERT INTO olibdb VALUES('p','InnerAlgFactor',4,'n','(F:Field,UP:UnivariatePolynomialCategory(F),AlExt:Join(Field,etc),AlPol:UnivariatePolynomialCategory(AlExt))->etc','(F,UP,AlExt,AlPol)','IALGFACT','Factorization of univariate polynomials with coefficients in an algebraic extension of a field over which we can factor UP\spad{''s}.');
INSERT INTO olibdb VALUES('p','InnerCommonDenominator',4,'n','(R:IntegralDomain,Q:QuotientFieldCategory(R),A:Join(LinearAggregate(R),etc),B:Join(LinearAggregate(Q),etc))->etc','(R,Q,A,B)','ICDEN','InnerCommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain.');
INSERT INTO olibdb VALUES('p','InnerEigenPackage',1,'n','(Field)->etc','(F)','IEP','This is a package for the exact computation of eigenvalues and eigenvectors. This package works for matrices with coefficients from a field over which we can factor polynomials. Eigenvalues in base field are always explicitly computed while the other are expressed in terms of their minimal polynomial.');
INSERT INTO olibdb VALUES('p','InnerMatrixLinearAlgebraFunctions',4,'n','(R:DivisionRing,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:MatrixCategory(R,Row,Col))->etc','(R,Row,Col,M)','IMATLIN','\spadtype{InnerMatrixLinearAlgebraFunctions} is an internal package which provides standard linear algebra functions on domains in \spad{MatrixCategory}');
INSERT INTO olibdb VALUES('p','InnerMatrixQuotientFieldFunctions',8,'n','(R:IntegralDomain,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:MatrixCategory(R,Row,Col),QF:QuotientFieldCategory(R),Row2:FiniteLinearAggregate(QF),Col2:FiniteLinearAggregate(QF),M2:MatrixCategory(QF,Row2,Col2))->etc','(R,Row,Col,M,QF,Row2,Col2,M2)','IMATQF','\spadtype{InnerMatrixQuotientFieldFunctions} provides functions on matrices over an integral domain which involve the quotient field of that integral domain. The functions rowEchelon and inverse return matrices with entries in the quotient field.');
INSERT INTO olibdb VALUES('p','InnerModularGcd',4,'n','(R:EuclideanDomain,BP:UnivariatePolynomialCategory(R),R,(R,NonNegativeInteger)->R)->etc','(R,BP,pMod,nextMod)','INMODGCD','This file contains the functions for modular \spad{gcd} algorithm for univariate polynomials with coefficients in a non-trivial euclidean domain (\spadignore{i.e.} not a field). The package parametrised by the coefficient domain,{} the polynomial domain,{} a prime,{} and a function for choosing the next prime');
INSERT INTO olibdb VALUES('p','InnerModularHermitePade',0,'n','()->etc',NULL,'IMODHP','This package solves Hermite-Pade interpolation problem \indented{1}{over ring of integer polynomials.\space{2}We use reduction modulo primes} \indented{1}{and modular reconstruction to reduce problem to polynomials modulo} \indented{1}{\$\spad{Z_p}\$.\space{2}Then we use evaluation and Lagrange interpolation to} \indented{1}{reduce problem to solving over \$\spad{Z_p}\$.}');
INSERT INTO olibdb VALUES('p','InnerMultFact',4,'n','(OV:OrderedSet,E:OrderedAbelianMonoidSup,R:Join(EuclideanDomain,etc),P:PolynomialCategory(R,E,OV))->etc','(OV,E,R,P)','INNMFACT','\indented{2}{This is an inner package for factoring multivariate polynomials} over various coefficient domains in characteristic 0. The univariate factor operation is passed as a parameter. Multivariate hensel lifting is used to lift the univariate factorization');
INSERT INTO olibdb VALUES('p','InnerNormalBasisFieldFunctions',1,'n','(FiniteFieldCategory)->etc','(GF)','INBFF','InnerNormalBasisFieldFunctions(\spad{GF}) (unexposed): This package has functions used by every normal basis finite field extension domain.');
INSERT INTO olibdb VALUES('p','InnerNumericEigenPackage',3,'n','(Field,F:Field,Par:Join(Field,etc))->etc','(K,F,Par)','INEP','This package is the inner package to be used by NumericRealEigenPackage and NumericComplexEigenPackage for the computation of numeric eigenvalues and eigenvectors.');
INSERT INTO olibdb VALUES('p','InnerNumericFloatSolvePackage',3,'n','(GcdDomain,F:Field,Par:Join(Field,etc))->etc','(K,F,Par)','INFSP','This is an internal package for computing approximate solutions to systems of polynomial equations. The parameter \spad{K} specifies the coefficient field of the input polynomials and must be either \spad{Fraction(Integer)} or \spad{Complex(Fraction Integer)}. The parameter \spad{F} specifies where the solutions must lie and can be one of the following: \spad{Float},{} \spad{Fraction(Integer)},{} \spad{Complex(Float)},{} \spad{Complex(Fraction Integer)}. The last parameter specifies the type of the precision operand and must be either \spad{Fraction(Integer)} or \spad{Float}.');
INSERT INTO olibdb VALUES('p','InnerPolySign',2,'n','(R:Ring,UP:UnivariatePolynomialCategory(R))->etc','(R,UP)','INPSIGN','Find the sign of a polynomial around a point or infinity.');
INSERT INTO olibdb VALUES('p','InnerPolySum',4,'n','(E:OrderedAbelianMonoidSup,V:OrderedSet,R:IntegralDomain,P:PolynomialCategory(R,E,V))->etc','(E,V,R,P)','ISUMP','tools for the summation packages.');
INSERT INTO olibdb VALUES('p','InnerTrigonometricManipulations',3,'n','(R:Join(IntegralDomain,etc),F:Join(FunctionSpace(R),etc),FG:Join(FunctionSpace(Complex(R)),etc))->etc','(R,F,FG)','ITRIGMNP','This package provides transformations from trigonometric functions to exponentials and logarithms,{} and back. \spad{F} and \spad{FG} should be the same type of function space.');
INSERT INTO olibdb VALUES('p','InputFormFunctions1',1,'n','(Type)->etc','(R)','INFORM1','Tools for manipulating input forms.');
INSERT INTO olibdb VALUES('p','IntegerBits',0,'n','()->etc',NULL,'INTBIT','This package provides functions to lookup bits in integers.');
INSERT INTO olibdb VALUES('p','IntegerCombinatoricFunctions',1,'x','(IntegerNumberSystem)->etc','(I)','COMBINAT','The \spadtype{IntegerCombinatoricFunctions} package provides some standard functions in combinatorics.');
INSERT INTO olibdb VALUES('p','IntegerFactorizationPackage',1,'n','(IntegerNumberSystem)->etc','(I)','INTFACT','\indented{1}{This Package contains basic methods for integer factorization.} The factor operation employs trial division up to 10,{} 000. It then tests to see if \spad{n} is a perfect power before using Pollards rho method. Because Pollards method may fail,{} the result of factor may contain composite factors. We should also employ Lenstra\spad{''s} elliptic curve method.');
INSERT INTO olibdb VALUES('p','IntegerLinearDependence',1,'x','(LinearlyExplicitOver(Integer))->etc','(R)','ZLINDEP','Test for linear dependence over the integers.');
INSERT INTO olibdb VALUES('p','IntegerNumberTheoryFunctions',0,'x','()->etc',NULL,'INTHEORY','This package provides various number theoretic functions on the integers.');
INSERT INTO olibdb VALUES('p','IntegerPrimesPackage',1,'x','(IntegerNumberSystem)->etc','(I)','PRIMES','The \spadtype{IntegerPrimesPackage} implements a modification of Rabin\spad{''s} probabilistic primality test and the utility functions \spadfun{nextPrime},{} \spadfun{prevPrime} and \spadfun{primes}.');
INSERT INTO olibdb VALUES('p','IntegerRetractions',1,'x','(RetractableTo(Integer))->etc','(S)','INTRET','Provides integer testing and retraction functions. Date Created: March 1990');
INSERT INTO olibdb VALUES('p','IntegerRoots',1,'x','(IntegerNumberSystem)->etc','(I)','IROOT','The \spadtype{IntegerRoots} package computes square roots and \indented{2}{\spad{n}th roots of integers efficiently.}');
INSERT INTO olibdb VALUES('p','IntegerSmithNormalForm',0,'n','()->etc',NULL,'ISMITH','This package computes Smith form of integer matrices. \indented{1}{It is more efficinet than general case by first using elimination} \indented{1}{with unit pivots from \spadtype{UnitGaussianElimination}.}');
INSERT INTO olibdb VALUES('p','IntegerSolveLinearPolynomialEquation',0,'n','()->etc',NULL,'INTSLPE','This package provides the implementation for the \spadfun{solveLinearPolynomialEquation} operation over the integers. It uses a lifting technique from the package GenExEuclid');
INSERT INTO olibdb VALUES('p','IntegralBasisPolynomialTools',4,'n','(K:Ring,R:UnivariatePolynomialCategory(K),UP:UnivariatePolynomialCategory(R),L:Ring)->etc','(K,R,UP,L)','IBPTOOLS','IntegralBasisPolynomialTools provides functions for \indented{1}{mapping functions on the coefficients of univariate and bivariate} \indented{1}{polynomials.}');
INSERT INTO olibdb VALUES('p','IntegralBasisTools',3,'n','(R:Join(EuclideanDomain,etc),UP:UnivariatePolynomialCategory(R),FramedAlgebra(R,UP))->etc','(R,UP,F)','IBATOOL','This package contains functions used in the packages FunctionFieldIntegralBasis and NumberFieldIntegralBasis.');
INSERT INTO olibdb VALUES('p','IntegrateSolutions',2,'n','(F:Join(Field,etc),L:Join(UnivariateSkewPolynomialCategory(F),etc))->etc','(F,L)','INTDSOL','\spadtype{IntegrateSolutions} implements a method \indented{1}{to compute integral of solution of differential operator.}');
INSERT INTO olibdb VALUES('p','IntegrationResultFunctions2',2,'x','(Field,F:Field)->etc','(E,F)','IR2','Internally used by the integration packages.');
INSERT INTO olibdb VALUES('p','IntegrationResultRFToFunction',1,'x','(Join(GcdDomain,etc))->etc','(R)','IRRF2F','\indented{2}{This package allows a sum of logs over the roots of a polynomial} \indented{2}{to be expressed as explicit logarithms and arc tangents,{} provided} \indented{2}{that the indexing polynomial can be factored into quadratics.} Date Created: 21 August 1988');
INSERT INTO olibdb VALUES('p','IntegrationResultToFunction',2,'x','(R:Join(GcdDomain,etc),F:Join(AlgebraicallyClosedFunctionSpace(R),etc))->etc','(R,F)','IR2F','This package allows a sum of logs over the roots of a polynomial to be expressed as explicit logarithms and arc tangents,{} provided that the indexing polynomial can be factored into quadratics.');
INSERT INTO olibdb VALUES('p','IntegrationTools',2,'n','(R:Comparable,F:FunctionSpace(R))->etc','(R,F)','INTTOOLS','Tools for the integrator.');
INSERT INTO olibdb VALUES('p','InternalPrintPackage',0,'n','()->etc',NULL,'IPRNTPK','A package to print strings without line-feed nor carriage-return.');
INSERT INTO olibdb VALUES('p','InternalRationalUnivariateRepresentationPackage',5,'n','(R:Join(PolynomialFactorizationExplicit,etc),E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:SquareFreeRegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','IRURPK','\indented{1}{An internal package for computing the rational univariate representation} \indented{1}{of a zero-dimensional algebraic variety given by a square-free} \indented{1}{triangular set.} \indented{1}{The main operation is \spadopFrom{rur}{InternalRationalUnivariateRepresentationPackage}.} \indented{1}{It is based on the {\em generic} algorithm description in [1]. \newline References:} [1] \spad{D}. LAZARD Solving Zero-dimensional Algebraic Systems \indented{4}{Journal of Symbolic Computation,{} 1992,{} 13,{} 117-131}');
INSERT INTO olibdb VALUES('p','InverseLaplaceTransform',2,'x','(R:Join(EuclideanDomain,etc),F:Join(TranscendentalFunctionCategory,etc))->etc','(R,F)','INVLAPLA','This package computes the inverse Laplace Transform.');
INSERT INTO olibdb VALUES('p','IrrRepSymNatPackage',0,'x','()->etc',NULL,'IRSN','IrrRepSymNatPackage contains functions for computing the ordinary irreducible representations of symmetric groups on \spad{n} letters {\em {1,{} 2,{} ...,{} n}} in Young\spad{''s} natural form and their dimensions. These representations can be labelled by number partitions of \spad{n},{} \spadignore{i.e.} a weakly decreasing sequence of integers summing up to \spad{n},{} \spadignore{e.g.} {\em [3,{} 3,{} 3,{} 1]} labels an irreducible representation for \spad{n} equals 10. Note: whenever a \spadtype{List Integer} appears in a signature,{} a partition required.');
INSERT INTO olibdb VALUES('p','JetCoordinateTransformation',4,'n','(JetBundleCategory,JB2:JetBundleCategory,Vector(JetBundleExpression(JB2)),Vector(JetBundleExpression(JB2)))->etc','(JB1,JB2,Y,W)','JCT','\spadtype{JetCoordinateTransformation} implements changes of local coordinates. Given are the changes of the coordinates of the base space,{} \spadignore{i.e.} the independent and dependent variables. The transformations of the derivatives are computed via the chain rule. \spad{Y} (\spad{W}) contains expressions for the old variables in terms of the new ones.');
INSERT INTO olibdb VALUES('p','JetGroebner',5,'n','(R:GcdDomain,JB:JetBundleCategory,LJV:List(JB),P:Join(JetBundleFunctionCategory(JB),etc),DirectProductCategory(#(LJV),NonNegativeInteger))->etc','(R,JB,LJV,P,E)','JGB','\spadtype{JetGroebner} provides a procedure to compute Groebner bases for arbitrary domains of jet polynomials. Two internal procedures transform to and from \spadtype{DistributedJetBundlePolynomial} where the actual computation is done. The argument \spad{LJV} contains all jet variables effectively occurring in the polynomials. The ordering is determined by the ordering in \spad{P}.');
INSERT INTO olibdb VALUES('p','JFriCASSupport',0,'n','()->etc',NULL,'JFRICAS','\indented{1}{The package \spad{JFriCASSupport} provides a number of service} functions to more easily switch on/off certain formats,{} in particular the use of the FormatMathJax formatter. Use \spad{setFormat! FormatMathJax} to switch on MathJax output or \spad{setFormats [FormatMathJax,{} Format1D]} to enable several output formats.');
INSERT INTO olibdb VALUES('p','KernelFunctions2',2,'x','(Comparable,S:Comparable)->etc','(R,S)','KERNEL2','This package exports some auxiliary functions on kernels');
INSERT INTO olibdb VALUES('p','Kovacic',2,'n','(F:Join(CharacteristicZero,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','KOVACIC','\spadtype{Kovacic} provides a modified Kovacic\spad{''s} algorithm for solving explicitly irreducible 2nd order linear ordinary differential equations.');
INSERT INTO olibdb VALUES('p','LaplaceTransform',2,'x','(R:Join(PolynomialFactorizationExplicit,etc),F:Join(TranscendentalFunctionCategory,etc))->etc','(R,F)','LAPLACE','This package computes the forward Laplace Transform.');
INSERT INTO olibdb VALUES('p','LazardSetSolvingPackage',6,'n','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),RegularTriangularSetCategory(R,E,V,P),ST:SquareFreeRegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS,ST)','LAZM3PK','A package for solving polynomial systems by means of Lazard triangular sets [1]. This package provides two operations. One for solving in the sense of the regular zeros,{} and the other for solving in the sense of the Zariski closure. Both produce square-free regular sets. Moreover,{} the decompositions do not contain any redundant component. However,{} only zero-dimensional regular sets are normalized,{} since normalization may be time consumming in positive dimension. The decomposition process is that of [2].\newline');
INSERT INTO olibdb VALUES('p','LeadingCoefDetermination',4,'n','(OV:OrderedSet,E:OrderedAbelianMonoidSup,Z:GcdDomain,P:PolynomialCategory(Z,E,OV))->etc','(OV,E,Z,P)','LEADCDET','Package for leading coefficient determination in the lifting step. Package working for every unique factorization domain \spad{R} . Uses algorithm given in section 3 of [1] generalized to arbitrary unique factorization domain.');
INSERT INTO olibdb VALUES('p','LexTriangularPackage',2,'n','(GcdDomain,ls:List(Symbol))->etc','(R,ls)','LEXTRIPK','A package for solving polynomial systems with finitely many solutions. The decompositions are given by means of regular triangular sets. The computations use lexicographical Groebner bases. The main operations are \spadopFrom{lexTriangular}{LexTriangularPackage} and \spadopFrom{squareFreeLexTriangular}{LexTriangularPackage}. The second one provide decompositions by means of square-free regular triangular sets. Both are based on the {\em lexTriangular} method described in [1]. They differ from the algorithm described in [2] by the fact that multiciplities of the roots are not kept. With the \spadopFrom{squareFreeLexTriangular}{LexTriangularPackage} operation all multiciplities are removed. With the other operation some multiciplities may remain. Both operations admit an optional argument to produce normalized triangular sets. \newline');
INSERT INTO olibdb VALUES('p','LiftLinearDependence',3,'n','(F:Field,Q:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,Q,UP)','LLINDEP',NULL);
INSERT INTO olibdb VALUES('p','LinearCombinationUtilities',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','LINCOMB','This package implements frequently used operations \indented{1}{on linear combinations.}');
INSERT INTO olibdb VALUES('p','LinearDependence',2,'n','(S:IntegralDomain,R:LinearlyExplicitOver(S))->etc','(S,R)','LINDEP','Test for linear dependence.');
INSERT INTO olibdb VALUES('p','LinearOrdinaryDifferentialOperator3Aux',3,'n','(Coeff:Ring,A:AbelianMonoidRing(Coeff,NonNegativeInteger),R:Join(DifferentialRing,etc))->etc','(Coeff,A,R)','LODO3AUX','\spad{LinearOrdinaryDifferentialOperator3Aux} is \indented{1}{a helper for \spad{LinearOrdinaryDifferentialOperator3}} \indented{1}{defining appropriate derivative.}');
INSERT INTO olibdb VALUES('p','LinearOrdinaryDifferentialOperatorFactorizer2',2,'n','(Symbol,cen:Expression(Integer))->etc','(var,cen)','LODOF2','\spadtype{LinearOrdinaryDifferentialOperatorFactorizer2} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions.');
INSERT INTO olibdb VALUES('p','LinearOrdinaryDifferentialOperatorFactorizer',2,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','LODOF','\spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions.');
INSERT INTO olibdb VALUES('p','LinearOrdinaryDifferentialOperatorsOps',2,'n','(A:Field,L:LinearOrdinaryDifferentialOperatorCategory(A))->etc','(A,L)','LODOOPS','\spad{LinearOrdinaryDifferentialOperatorsOps} provides symmetric products and sums for linear ordinary differential operators.');
INSERT INTO olibdb VALUES('p','LinearPolynomialEquationByFractions',1,'n','(PolynomialFactorizationExplicit)->etc','(R)','LPEFRAC','Given a PolynomialFactorizationExplicit ring,{} this package provides a defaulting rule for the \spad{solveLinearPolynomialEquation} operation,{} by moving into the field of fractions,{} and solving it there via the \spad{multiEuclidean} operation.');
INSERT INTO olibdb VALUES('p','LinearSystemMatrixPackage1',1,'x','(Field)->etc','(F)','LSMP1','This package solves linear system in the matrix form \spad{AX = B}. It is essentially a particular instantiation of the package \spadtype{LinearSystemMatrixPackage} for Matrix and Vector. This package\spad{''s} existence makes it easier to use \spadfun{solve} in the FriCAS interpreter.');
INSERT INTO olibdb VALUES('p','LinearSystemMatrixPackage2',1,'n','(IntegralDomain)->etc','(S)','LSMP2','This package solve system by passing to fraction field.');
INSERT INTO olibdb VALUES('p','LinearSystemMatrixPackage',4,'x','(F:Field,Row:Join(FiniteLinearAggregate(F),etc),Col:Join(FiniteLinearAggregate(F),etc),M:MatrixCategory(F,Row,Col))->etc','(F,Row,Col,M)','LSMP','This package solves linear system in the matrix form \spad{AX = B}.');
INSERT INTO olibdb VALUES('p','LinearSystemPolynomialPackage',4,'x','(R:IntegralDomain,E:OrderedAbelianMonoidSup,OV:OrderedSet,P:PolynomialCategory(R,E,OV))->etc','(R,E,OV,P)','LSPP','this package finds the solutions of linear systems presented as a list of polynomials.');
INSERT INTO olibdb VALUES('p','LinGroebnerPackage',2,'n','(List(Symbol),F:GcdDomain)->etc','(lv,F)','LGROBP','\indented{1}{Given a Groebner basis \spad{B} with respect to the total degree ordering for a} zero-dimensional ideal \spad{I},{} compute a Groebner basis with respect to the lexicographical ordering by using linear algebra. This is an internal package,{} operations in this package may crash the system on invalid input.');
INSERT INTO olibdb VALUES('p','LiouvillianFunction',2,'n','(R:Join(Comparable,etc),F:Join(FunctionSpace(R),etc))->etc','(R,F)','LF','This package provides liouvillian functions over an integral domain.');
INSERT INTO olibdb VALUES('p','ListFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','LIST2','\spadtype{ListFunctions2} implements utility functions that operate on two kinds of lists,{} each with a possibly different type of element.');
INSERT INTO olibdb VALUES('p','ListFunctions3',3,'x','(Type,B:Type,C:Type)->etc','(A,B,C)','LIST3','\spadtype{ListFunctions3} implements utility functions that operate on three kinds of lists,{} each with a possibly different type of element.');
INSERT INTO olibdb VALUES('p','ListPackage',1,'n','(BasicType)->etc','(T)','LISTPKG','splitting lists');
INSERT INTO olibdb VALUES('p','ListToMap',2,'x','(SetCategory,B:Type)->etc','(A,B)','LIST2MAP','\spadtype{ListToMap} allows mappings to be described by a pair of lists of equal lengths. The image of an element \spad{x},{} which appears in position \spad{n} in the first list,{} is then the \spad{n}th element of the second list. A default value or default function can be specified to be used when \spad{x} does not appear in the first list. In the absence of defaults,{} an error will occur in that case.');
INSERT INTO olibdb VALUES('p','LLLReduction',0,'n','()->etc',NULL,'LLLRED','This package implements \spad{LLL} reduction. Before \indented{1}{use user must set appropriate floating point precision.\space{2}Too} \indented{1}{low precision may cause nontermination.\space{2}Higher precisions} \indented{1}{require more compute time.}');
INSERT INTO olibdb VALUES('p','LODOConvertions',3,'n','(Coeff:Ring,Ab:AbelianMonoidRing(Coeff,NonNegativeInteger),R:Join(DifferentialRing,etc))->etc','(Coeff,Ab,R)','LODOCONV','\spadtype{LODOConvertions} implements conversion between \indented{1}{\spadtype{LinearOrdinaryDifferentialOperator1} and} \indented{1}{\spadtype{LinearOrdinaryDifferentialOperator3} and back.}');
INSERT INTO olibdb VALUES('p','LUDecomposition',1,'n','(Field)->etc','(D)','LUD','\spadtype{LUDecomposition} contains procedures to solve linear systems of equations or to compute inverses using a LU decomposition.');
INSERT INTO olibdb VALUES('p','MakeBinaryCompiledFunction',4,'n','(ConvertibleTo(InputForm),D1:Type,D2:Type,I:Type)->etc','(S,D1,D2,I)','MKBCFUNC','transforms top-level objects into compiled functions.');
INSERT INTO olibdb VALUES('p','MakeFloatCompiledFunction',1,'x','(ConvertibleTo(InputForm))->etc','(S)','MKFLCFN','MakeFloatCompiledFunction transforms top-level objects into compiled Lisp functions whose arguments are Lisp floats. This by-passes the \Language{} compiler and interpreter,{} thereby gaining several orders of magnitude.');
INSERT INTO olibdb VALUES('p','MakeFunction',1,'x','(ConvertibleTo(InputForm))->etc','(S)','MKFUNC','transforms top-level objects into interpreter functions.');
INSERT INTO olibdb VALUES('p','MakeRecord',2,'x','(Type,T:Type)->etc','(S,T)','MKRECORD','MakeRecord is used internally by the interpreter to create record types which are used for doing parallel iterations on streams.');
INSERT INTO olibdb VALUES('p','MakeUnaryCompiledFunction',3,'n','(ConvertibleTo(InputForm),D:Type,I:Type)->etc','(S,D,I)','MKUCFUNC','transforms top-level objects into compiled functions.');
INSERT INTO olibdb VALUES('p','MappingPackage1',1,'x','(SetCategory)->etc','(A)','MAPPKG1','various Currying operations.');
INSERT INTO olibdb VALUES('p','MappingPackage2',2,'x','(SetCategory,C:SetCategory)->etc','(A,C)','MAPPKG2','various Currying operations.');
INSERT INTO olibdb VALUES('p','MappingPackage3',3,'x','(SetCategory,B:SetCategory,C:SetCategory)->etc','(A,B,C)','MAPPKG3','various Currying operations.');
INSERT INTO olibdb VALUES('p','MappingPackageInternalHacks1',1,'n','(SetCategory)->etc','(A)','MAPHACK1','various Currying operations.');
INSERT INTO olibdb VALUES('p','MappingPackageInternalHacks2',2,'n','(SetCategory,C:SetCategory)->etc','(A,C)','MAPHACK2','various Currying operations.');
INSERT INTO olibdb VALUES('p','MappingPackageInternalHacks3',3,'n','(SetCategory,B:SetCategory,C:SetCategory)->etc','(A,B,C)','MAPHACK3','various Currying operations.');
INSERT INTO olibdb VALUES('p','MathematicalSymbols',0,'n','()->etc',NULL,'MATHSYM','MathematicalSymbols defines several mathematical symbols,{} mostly Greek letters and multiletter Greek symbols.');
INSERT INTO olibdb VALUES('p','MatrixCategoryFunctions2',8,'x','(R1:Join(SemiRng,etc),Row1:FiniteLinearAggregate(R1),Col1:FiniteLinearAggregate(R1),M1:MatrixCategory(R1,Row1,Col1),R2:Join(SemiRng,etc),Row2:FiniteLinearAggregate(R2),Col2:FiniteLinearAggregate(R2),M2:MatrixCategory(R2,Row2,Col2))->etc','(R1,Row1,Col1,M1,R2,Row2,Col2,M2)','MATCAT2','\spadtype{MatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \spadfun{map} and \spadfun{reduce}.');
INSERT INTO olibdb VALUES('p','MatrixCommonDenominator',2,'x','(R:IntegralDomain,Q:QuotientFieldCategory(R))->etc','(R,Q)','MCDEN','MatrixCommonDenominator provides functions to compute the common denominator of a matrix of elements of the quotient field of an integral domain.');
INSERT INTO olibdb VALUES('p','MatrixLinearAlgebraFunctions',4,'x','(R:CommutativeRing,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:MatrixCategory(R,Row,Col))->etc','(R,Row,Col,M)','MATLIN','\spadtype{MatrixLinearAlgebraFunctions} provides functions to compute inverses and canonical forms.');
INSERT INTO olibdb VALUES('p','MatrixManipulation',4,'n','(R:Type,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:TwoDimensionalArrayCategory(R,Row,Col))->etc','(R,Row,Col,M)','MAMA','Some functions for manipulating (dense) matrices. Supported are various kinds of slicing,{} splitting and stacking of matrices. The functions resemble operations often used in numerical linear algebra algorithms.');
INSERT INTO olibdb VALUES('p','MergeThing',1,'x','(OrderedSet)->etc','(S)','MTHING','This package exports tools for merging lists');
INSERT INTO olibdb VALUES('p','MeshCreationRoutinesForThreeDimensions',0,'n','()->etc',NULL,'MESH','This package generates meshes for 3D plots.');
INSERT INTO olibdb VALUES('p','ModularAlgebraicGcd2',6,'n','(PT:Type,MP:Type,MPT:Type,MD:Type,ModularEvaluationCategory(PT,MP),ModularAlgebraicGcdOperations(MP,MPT,MD))->etc','(PT,MP,MPT,MD,ME,MO)','MAGCD2','This package computes \spad{gcd} over field of algebraic \indented{1}{functions over \spad{Q} using modular method based on \spad{M}. Monagan and} \indented{1}{van Hoej paper.} \indented{1}{Core modular operations are passed as parameter (MO) to this} \indented{1}{package.\space{2}Similarly,{} evaluation functions are passed as} \indented{1}{parameter ME.}');
INSERT INTO olibdb VALUES('p','ModularAlgebraicGcd',3,'n','(MPT:Type,MD:Type,ModularAlgebraicGcdOperations(Polynomial(Integer),MPT,MD))->etc','(MPT,MD,MO)','MAGCD','ModularAlgebraicGcd(\spad{MPT},{} \spad{MD},{} MO) is a compatibility \indented{1}{wrapper around \spad{ModularAlgebraicGcd2}.}');
INSERT INTO olibdb VALUES('p','ModularFactorization',0,'n','()->etc',NULL,'MODFACT',NULL);
INSERT INTO olibdb VALUES('p','ModularFactorizationGeneral',5,'n','(PA:Type,MMT:Type,MD:Type,PMD:Type,ModularFactorizationOperations(PA,MMT,MD,PMD))->etc','(PA,MMT,MD,PMD,MO)','MODFACTG','This package implements factorization of polynomials over finite fields using a variant of Kaltofen-Shoup method. Nontrivial data have abstract representation,{} operations are provided by matching package.');
INSERT INTO olibdb VALUES('p','ModularFactorizationK',1,'n','(FiniteFieldCategory)->etc','(K)','MODFACK',NULL);
INSERT INTO olibdb VALUES('p','ModularHermitePade',0,'n','()->etc',NULL,'MODHP','This package provides modular Hermite-Pade solvers \indented{1}{for a few rings.\space{2}Solver over integers is implemented in this} \indented{1}{package.\space{2}Also it contains interfaces to solver over \$\spad{Z_p}\$ and} \indented{1}{solver over ring of integer polynomials.}');
INSERT INTO olibdb VALUES('p','ModularHermitePadeSolver',2,'n','(CommutativeRing,S:CommutativeRing)->etc','(F,S)','MODHPS','This package provides generic interface to modular \indented{1}{Hermite-Pade solver.}');
INSERT INTO olibdb VALUES('p','ModularHermitianRowReduction',1,'n','(EuclideanDomain)->etc','(R)','MHROWRED','Modular hermitian row reduction.');
INSERT INTO olibdb VALUES('p','MomentPackage',1,'n','(CommutativeRing)->etc','(R)','MOMPKG','An auxiliary package for various moment and cumulant transformations used in \spad{Distribution}.');
INSERT INTO olibdb VALUES('p','MonoidRingFunctions2',3,'x','(Ring,S:Ring,M:Monoid)->etc','(R,S,M)','MRF2','\spad{MonoidRingFunctions2} implements functions between two monoid rings defined with the same monoid over different rings.');
INSERT INTO olibdb VALUES('p','MonomialExtensionTools',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','MONOTOOL','Tools for handling monomial extensions.');
INSERT INTO olibdb VALUES('p','MoreSystemCommands',0,'x','()->etc',NULL,'MSYSCMD','\spadtype{MoreSystemCommands} implements an interface with the system command facility. These are the commands that are issued from source files or the system interpreter and they start with a close parenthesis,{} \spadignore{e.g.} \spadsys{)what} commands.');
INSERT INTO olibdb VALUES('p','MPolyCatFunctions2',7,'x','(VarSet:OrderedSet,E1:OrderedAbelianMonoidSup,E2:OrderedAbelianMonoidSup,R:Ring,S:Ring,PR:PolynomialCategory(R,E1,VarSet),PS:PolynomialCategory(S,E2,VarSet))->etc','(VarSet,E1,E2,R,S,PR,PS)','MPC2','Utilities for MPolyCat.');
INSERT INTO olibdb VALUES('p','MPolyCatFunctions3',7,'n','(Vars1:OrderedSet,Vars2:OrderedSet,E1:OrderedAbelianMonoidSup,E2:OrderedAbelianMonoidSup,R:Ring,PR1:PolynomialCategory(R,E1,Vars1),PR2:PolynomialCategory(R,E2,Vars2))->etc','(Vars1,Vars2,E1,E2,R,PR1,PR2)','MPC3','This package \undocumented');
INSERT INTO olibdb VALUES('p','MPolyCatPolyFactorizer',4,'n','(E:OrderedAbelianMonoidSup,OV:Join(OrderedSet,etc),R:EuclideanDomain,PPR:PolynomialCategory(Polynomial(R),E,OV))->etc','(E,OV,R,PPR)','MPCPF','\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are polynomials over some ring \spad{R} over which we can factor. It is used internally by packages such as the solve package which need to work with polynomials in a specific set of variables with coefficients which are polynomials in all the other variables.');
INSERT INTO olibdb VALUES('p','MPolyCatRationalFunctionFactorizer',4,'x','(E:OrderedAbelianMonoidSup,OV:Join(OrderedSet,etc),R:IntegralDomain,PRF:PolynomialCategory(Fraction(Polynomial(R)),E,OV))->etc','(E,OV,R,PRF)','MPRFF','\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are rational functions over some ring \spad{R} over which we can factor. It is used internally by packages such as primary decomposition which need to work with polynomials with rational function coefficients,{} \spadignore{i.e.} themselves fractions of polynomials.');
INSERT INTO olibdb VALUES('p','MRationalFactorize',4,'n','(E:OrderedAbelianMonoidSup,OV:OrderedSet,R:Join(EuclideanDomain,etc),P:PolynomialCategory(Fraction(R),E,OV))->etc','(E,OV,R,P)','MRATFAC','\indented{1}{MRationalFactorize contains the factor function for multivariate} polynomials over the quotient field of a ring \spad{R} such that the package MultivariateFactorize can factor multivariate polynomials over \spad{R}.');
INSERT INTO olibdb VALUES('p','MrvLimitPackage',0,'n','()->etc',NULL,'MRVLIM','Compute limits using Gruntz-Gonnet \spad{MRV} algorithm');
INSERT INTO olibdb VALUES('p','MultFiniteFactorize',4,'x','(OV:OrderedSet,E:OrderedAbelianMonoidSup,F:FiniteFieldCategory,PG:PolynomialCategory(F,E,OV))->etc','(OV,E,F,PG)','MFINFACT','Package for factorization of multivariate polynomials over finite fields.');
INSERT INTO olibdb VALUES('p','MultipleMap',6,'n','(R1:IntegralDomain,UP1:UnivariatePolynomialCategory(R1),UPUP1:UnivariatePolynomialCategory(Fraction(UP1)),R2:IntegralDomain,UP2:UnivariatePolynomialCategory(R2),UPUP2:UnivariatePolynomialCategory(Fraction(UP2)))->etc','(R1,UP1,UPUP1,R2,UP2,UPUP2)','MMAP','Lifting of a map through 2 levels of polynomials.');
INSERT INTO olibdb VALUES('p','MultiplicativeDependence',0,'n','()->etc',NULL,'MULDEP',NULL);
INSERT INTO olibdb VALUES('p','MultiVariableCalculusFunctions',4,'n','(S:SetCategory,F:PartialDifferentialRing(S),FLAF:FiniteLinearAggregate(F),FLAS:FiniteLinearAggregate(S))->etc','(S,F,FLAF,FLAS)','MCALCFN','\indented{1}{\spadtype{MultiVariableCalculusFunctions} Package provides several} \indented{1}{functions for multivariable calculus.} These include gradient,{} hessian and jacobian,{} divergence and laplacian. Various forms for banded and sparse storage of matrices are included.');
INSERT INTO olibdb VALUES('p','MultivariateFactorize',4,'x','(OV:OrderedSet,E:OrderedAbelianMonoidSup,R:Join(PolynomialFactorizationExplicit,etc),P:PolynomialCategory(R,E,OV))->etc','(OV,E,R,P)','MULTFACT','\indented{2}{This is the top level package for doing multivariate factorization} over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.');
INSERT INTO olibdb VALUES('p','MultivariateLifting',4,'n','(E:OrderedAbelianMonoidSup,OV:OrderedSet,R:IntegralDomain,P:PolynomialCategory(R,E,OV))->etc','(E,OV,R,P)','MLIFT','This package provides the functions for the multivariate lifting,{} using an algorithm of Paul Wang. This package will work for every euclidean domain \spad{R} which has property \spad{F},{} \spadignore{i.e.} there exists a factor operation in \spad{R[x]}.');
INSERT INTO olibdb VALUES('p','MultivariateSquareFree',4,'n','(E:OrderedAbelianMonoidSup,OV:OrderedSet,R:EuclideanDomain,P:PolynomialCategory(R,E,OV))->etc','(E,OV,R,P)','MULTSQFR','This package provides the functions for the computation of the square free decomposition of a multivariate polynomial. It uses modular reduction and the package \spad{MultivariateLifting} for the multivariate lifting.');
INSERT INTO olibdb VALUES('p','NaiveBeckermannLabahnModular',0,'n','()->etc',NULL,'NBLM','This package solves (multipoint) Hermite-Pade \indented{1}{interpolation problem over \$\spad{Z_p}\$,{} where \$\spad{p}\$ is machine} \indented{1}{sized prime.\space{2}We use quadratic algorithm from 94} \indented{1}{Beckermann and Labahn paper (with modification to handle} \indented{1}{multipoint case).}');
INSERT INTO olibdb VALUES('p','NewSparseUnivariatePolynomialFunctions2',2,'n','(Ring,S:Ring)->etc','(R,S)','NSUP2','This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from sparse univariate polynomial over \spad{R} to a sparse univariate polynomial over \spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.');
INSERT INTO olibdb VALUES('p','NewtonInterpolation',1,'n','(IntegralDomain)->etc','(F)','NEWTON','This package exports Newton interpolation for the special case where the result is known to be in the original integral domain');
INSERT INTO olibdb VALUES('p','NGroebnerPackage',3,'n','(Dom:LeftOreRing,Expon:OrderedAbelianMonoidSup,Dpol:SolvableSkewPolynomialCategory(Dom,Expon))->etc','(Dom,Expon,Dpol)','NGROEB','This is package computes noncommutative Groebner basis. Based on commutative version. Note that this package accepts rings as base domain,{} however computed basis is over left fraction field. Computations are done in fraction free way (coefficients stay in base ring).');
INSERT INTO olibdb VALUES('p','NoneFunctions1',1,'x','(Type)->etc','(S)','NONE1','\spadtype{NoneFunctions1} implements functions on \spadtype{None}. It includes a particularly dangerous coercion from any other type to \spadtype{None}.');
INSERT INTO olibdb VALUES('p','NonLinearFirstOrderODESolver',2,'n','(R:Join(Comparable,etc),F:Join(AlgebraicallyClosedFunctionSpace(R),etc))->etc','(R,F)','NODE1','NonLinearFirstOrderODESolver provides a function for finding closed form first integrals of nonlinear ordinary differential equations of order 1.');
INSERT INTO olibdb VALUES('p','NonLinearSolvePackage',1,'n','(IntegralDomain)->etc','(R)','NLINSOL','NonLinearSolvePackage is an interface to \spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving. The solutions are given in the algebraic closure of \spad{R} whenever possible.');
INSERT INTO olibdb VALUES('p','NormalizationPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','NORMPK','A package for computing normalized associates of univariate polynomials with coefficients in a tower of simple extensions of a field.');
INSERT INTO olibdb VALUES('p','NormInMonogenicAlgebra',4,'x','(R:GcdDomain,PolR:UnivariatePolynomialCategory(R),E:MonogenicAlgebra(R,PolR),PolE:UnivariatePolynomialCategory(E))->etc','(R,PolR,E,PolE)','NORMMA','This package implements the norm of a polynomial with coefficients in a monogenic algebra (using resultants)');
INSERT INTO olibdb VALUES('p','NormRetractPackage',5,'n','(F:FiniteFieldCategory,ExtF:FiniteAlgebraicExtensionField(F),SUEx:UnivariatePolynomialCategory(ExtF),ExtP:UnivariatePolynomialCategory(SUEx),PositiveInteger)->etc','(F,ExtF,SUEx,ExtP,n)','NORMRETR','This package \undocumented');
INSERT INTO olibdb VALUES('p','NPCoef',5,'n','(UnivariatePolynomialCategory(R),E:OrderedAbelianMonoidSup,OV:OrderedSet,R:IntegralDomain,P:PolynomialCategory(R,E,OV))->etc','(BP,E,OV,R,P)','NPCOEF','Package for the determination of the coefficients in the lifting process. Used by \spadtype{MultivariateLifting}. This package will work for every integral domain \spad{R}. The same method is described in [1] section 2.3.4.');
INSERT INTO olibdb VALUES('p','NumberFieldIntegralBasis',2,'n','(UP:UnivariatePolynomialCategory(Integer),FramedAlgebra(Integer,UP))->etc','(UP,F)','NFINTBAS','In this package \spad{F} is a framed algebra over the integers (typically \spad{F = Z[a]} for some algebraic integer a). The package provides functions to compute the integral closure of \spad{Z} in the quotient field of \spad{F}.');
INSERT INTO olibdb VALUES('p','NumberFormats',0,'n','()->etc',NULL,'NUMFMT','NumberFormats provides function to format and read arabic and roman numbers,{} to convert numbers to strings and to read floating-point numbers.');
INSERT INTO olibdb VALUES('p','NumberTheoreticPolynomialFunctions',1,'x','(CommutativeRing)->etc','(R)','NTPOLFN','This package provides polynomials as functions on a ring.');
INSERT INTO olibdb VALUES('p','Numeric',1,'x','(ConvertibleTo(Float))->etc','(S)','NUMERIC','Numeric provides real and complex numerical evaluation functions for various symbolic types.');
INSERT INTO olibdb VALUES('p','NumericalOrdinaryDifferentialEquations',0,'x','()->etc',NULL,'NUMODE','This package is a suite of functions for the numerical integration of an ordinary differential equation of \spad{n} variables: \blankline \indented{8}{\centerline{dy/dx = \spad{f}(\spad{y},{} \spad{x})\space{5}\spad{y} is an \spad{n}-vector}} \blankline \par All the routines are based on a 4-th order Runge-Kutta kernel. These routines generally have as arguments: \spad{n},{} the number of dependent variables; \spad{x1},{} the initial point; \spad{h},{} the step size; \spad{y},{} a vector of initial conditions of length \spad{n} which upon exit contains the solution at \spad{x1 + h}; \spad{derivs},{} a function which computes the right hand side of the ordinary differential equation: \spad{derivs(dydx,{} y,{} x)} computes \spad{dydx},{} a vector which contains the derivative information. \blankline \par In order of increasing complexity: \begin{items} \blankline \item \spad{rk4(y,{} n,{} x1,{} h,{} derivs)} advances the solution vector to \spad{x1 + h} and return the values in \spad{y}. \blankline \item \spad{rk4(y,{} n,{} x1,{} h,{} derivs,{} t1,{} t2,{} t3,{} t4)} is the same as \spad{rk4(y,{} n,{} x1,{} h,{} derivs)} except that you must provide 4 scratch arrays \spad{t1}-\spad{t4} of size \spad{n}. \blankline \item Starting with \spad{y} at \spad{x1},{} \spad{rk4f(y,{} n,{} x1,{} x2,{} ns,{} derivs)} uses \spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance the solution vector to \spad{x2} and return the values in \spad{y}. Argument \spad{x2},{} is the final point,{} and \spad{ns},{} the number of steps to take. \blankline \item \spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs)} takes a 5-th order Runge-Kutta step with monitoring of local truncation to ensure accuracy and adjust stepsize. The function takes two half steps and one full step and scales the difference in solutions at the final point. If the error is within \spad{eps},{} the step is taken and the result is returned. If the error is not within \spad{eps},{} the stepsize if decreased and the procedure is tried again until the desired accuracy is reached. Upon input,{} an trial step size must be given and upon return,{} an estimate of the next step size to use is returned as well as the step size which produced the desired accuracy. The scaled error is computed as \centerline{\spad{error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))}} and this is compared against \spad{eps}. If this is greater than \spad{eps},{} the step size is reduced accordingly to \centerline{\spad{hnew = 0.9 * hdid * (error/eps)^(-1/4)}} If the error criterion is satisfied,{} then we check if the step size was too fine and return a more efficient one. If \spad{error} > \spad{eps} * (6.0E-04) then the next step size should be \centerline{\spad{hnext} = 0.9 * hdid * (\spad{error}/\spad{eps})^(\spad{-1/5})} Otherwise \spad{hnext = 4.0 * hdid} is returned. A more detailed discussion of this and related topics can be found in the book Numerical Recipes by \spad{W}.Press,{} \spad{B}.\spad{P}. Flannery,{} \spad{S}.A. Teukolsky,{} \spad{W}.\spad{T}. Vetterling published by Cambridge University Press. Argument \spad{step} is a record of 3 floating point numbers \spad{(to_try ,{} did ,{} next)},{} \spad{eps} is the required accuracy,{} \spad{yscal} is the scaling vector for the difference in solutions. On input,{} \spad{step.to_try} should be the guess at a step size to achieve the accuracy. On output,{} \spad{step.did} contains the step size which achieved the accuracy and \spad{step.next} is the next step size to use. \blankline \item \spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs,{} t1,{} t2,{} t3,{} t4,{} t5,{} t6,{} t7)} is the same as \spad{rk4qc(y,{} n,{} x1,{} step,{} eps,{} yscal,{} derivs)} except that the user must provide the 7 scratch arrays \spad{t1-t7} of size \spad{n}. \blankline \item \spad{rk4a(y,{} n,{} x1,{} x2,{} eps,{} h,{} ns,{} derivs)} is a driver program which uses \spad{rk4qc} to integrate \spad{n} ordinary differential equations starting at \spad{x1} to \spad{x2},{} keeping the local truncation error to within \spad{eps} by changing the local step size. The scaling vector is defined as \centerline{\spad{yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny}} where \spad{y(i)} is the solution at location \spad{x},{} \spad{dydx} is the ordinary differential equation\spad{''s} right hand side,{} \spad{h} is the current step size and \spad{tiny} is 10 times the smallest positive number representable. The user must supply an estimate for a trial step size and the maximum number of calls to \spad{rk4qc} to use. Argument \spad{x2} is the final point,{} \spad{eps} is local truncation,{} \spad{ns} is the maximum number of call to \spad{rk4qc} to use. \end{items}');
INSERT INTO olibdb VALUES('p','NumericalQuadrature',1,'x','(FloatingPointSystem)->etc','(F)','NUMQUAD','This suite of routines performs numerical quadrature using algorithms derived from the basic trapezoidal rule. Because the error term of this rule contains only even powers of the step size (for open and closed versions),{} fast convergence can be obtained if the integrand is sufficiently smooth. \blankline Each routine returns a Record of type TrapAns,{} which contains\indent{3} \newline value (\spadtype{Float}): \tab{20} estimate of the integral \newline error (\spadtype{Float}): \tab{20} estimate of the error in the computation \newline totalpts (\spadtype{Integer}): \tab{20} total number of function evaluations \newline success (\spadtype{Boolean}): \tab{20} if the integral was computed within the user specified error criterion \indent{0}\indent{0} To produce this estimate,{} each routine generates an internal sequence of sub-estimates,{} denoted by {\em S(i)},{} depending on the routine,{} to which the various convergence criteria are applied. The user must supply a relative accuracy,{} \spad{eps_r},{} and an absolute accuracy,{} \spad{eps_a}. Convergence is obtained when either \centerline{\spad{ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))}} \centerline{or \spad{ABS(S(i) - S(i-1)) < eps_a}} are \spad{true} statements. \blankline The routines come in three families and three flavors: \newline\tab{3} closed: \tab{20}romberg,{} \tab{30}simpson,{} \tab{42}trapezoidal \newline\tab{3} open: \tab{20}rombergo,{} \tab{30}simpsono,{} \tab{42}trapezoidalo \newline\tab{3} adaptive closed: \tab{20}aromberg,{} \tab{30}asimpson,{} \tab{42}atrapezoidal \par The {\em S(i)} for the trapezoidal family is the value of the integral using an equally spaced absicca trapezoidal rule for that level of refinement. \par The {\em S(i)} for the simpson family is the value of the integral using an equally spaced absicca simpson rule for that level of refinement. \par The {\em S(i)} for the romberg family is the estimate of the integral using an equally spaced absicca romberg method. For the \spad{i}\spad{-}th level,{} this is an appropriate combination of all the previous trapezodial estimates so that the error term starts with the \spad{2*(i+1)} power only. \par The three families come in a closed version,{} where the formulas include the endpoints,{} an open version where the formulas do not include the endpoints and an adaptive version,{} where the user is required to input the number of subintervals over which the appropriate closed family integrator will apply with the usual convergence parameters for each subinterval. This is useful where a large number of points are needed only in a small fraction of the entire domain. \par Each routine takes as arguments: \newline \spad{f}\tab{10} integrand \newline a\tab{10} starting point \newline \spad{b}\tab{10} ending point \newline \spad{eps_r}\tab{10} relative error \newline \spad{eps_a}\tab{10} absolute error \newline \spad{nmin} \tab{10} refinement level when to start checking for convergence (> 1) \newline \spad{nmax} \tab{10} maximum level of refinement \par The adaptive routines take as an additional parameter \newline \spad{nint}\tab{10} the number of independent intervals to apply a closed \indented{1}{family integrator of the same name.} \par Notes: \newline Closed family level \spad{i} uses \spad{1 + 2^i} points. \newline Open family level \spad{i} uses \spad{1 + 3^i} points.');
INSERT INTO olibdb VALUES('p','NumericComplexEigenPackage',1,'x','(Join(Field,etc))->etc','(Par)','NCEP','This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the complex rational numbers. The results are expressed either as complex floating numbers or as complex rational numbers depending on the type of the precision parameter.');
INSERT INTO olibdb VALUES('p','NumericContinuedFraction',1,'x','(FloatingPointSystem)->etc','(F)','NCNTFRAC','\spadtype{NumericContinuedFraction} provides functions \indented{2}{for converting floating point numbers to continued fractions.}');
INSERT INTO olibdb VALUES('p','NumericRealEigenPackage',1,'x','(Join(Field,etc))->etc','(Par)','NREP','This package computes explicitly eigenvalues and eigenvectors of matrices with entries over the Rational Numbers. The results are expressed as floating numbers or as rational numbers depending on the type of the parameter Par.');
INSERT INTO olibdb VALUES('p','NumericTubePlot',1,'n','(PlottableSpaceCurveCategory)->etc','(Curve)','NUMTUBE','Package for constructing tubes around 3-dimensional \indented{1}{parametric curves.}');
INSERT INTO olibdb VALUES('p','OctonionCategoryFunctions2',4,'x','(OctonionCategory(R),R:CommutativeRing,OS:OctonionCategory(S),S:CommutativeRing)->etc','(OR,R,OS,S)','OCTCT2','\spad{OctonionCategoryFunctions2} implements functions between two octonion domains defined over different rings. The function map is used to coerce between octonion types.');
INSERT INTO olibdb VALUES('p','ODEIntegration',2,'n','(R:Join(Comparable,etc),F:Join(AlgebraicallyClosedFunctionSpace(R),etc))->etc','(R,F)','ODEINT','\spadtype{ODEIntegration} provides an interface to the integrator. This package is intended for use by the differential equations solver but not at top-level.');
INSERT INTO olibdb VALUES('p','ODETools',2,'n','(F:Field,LODO:LinearOrdinaryDifferentialOperatorCategory(F))->etc','(F,LODO)','ODETOOLS','\spad{ODETools} provides tools for the linear ODE solver.');
INSERT INTO olibdb VALUES('p','OneDimensionalArrayFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','ARRAY12','This package provides tools for operating on one-dimensional arrays with unary and binary functions involving different underlying types.');
INSERT INTO olibdb VALUES('p','OnePointCompletionFunctions2',2,'x','(SetCategory,S:SetCategory)->etc','(R,S)','ONECOMP2','Lifting of maps to one-point completions. Date Created: 4 Oct 1989');
INSERT INTO olibdb VALUES('p','OpenMathPackage',0,'x','()->etc',NULL,'OMPKG','\spadtype{OpenMathPackage} provides some simple utilities to make reading OpenMath objects easier.');
INSERT INTO olibdb VALUES('p','OpenMathServerPackage',0,'x','()->etc',NULL,'OMSERVER','\spadtype{OpenMathServerPackage} provides the necessary operations to run FriCAS as an OpenMath server,{} reading/writing objects to/from a port. Please note the facilities available here are very basic. The idea is that a user calls \spadignore{e.g.} \spad{Omserve(4000,{} 60)} and then another process sends OpenMath objects to port 4000 and reads the result.');
INSERT INTO olibdb VALUES('p','OperationsQuery',0,'x','()->etc',NULL,'OPQUERY','This package exports tools to create FriCAS Library information databases.');
INSERT INTO olibdb VALUES('p','OrderedCompletionFunctions2',2,'x','(SetCategory,S:SetCategory)->etc','(R,S)','ORDCOMP2','Lifting of maps to ordered completions. Date Created: 4 Oct 1989');
INSERT INTO olibdb VALUES('p','OrderingFunctions',2,'n','(NonNegativeInteger,S:OrderedAbelianMonoid)->etc','(dim,S)','ORDFUNS','\indented{3}{This package provides ordering functions on vectors which} are suitable parameters for OrderedDirectProduct.');
INSERT INTO olibdb VALUES('p','OrePolynomialMatrixOperations',2,'n','(F:Field,LO:UnivariateSkewPolynomialCategory(F))->etc','(F,LO)','OREMAT',NULL);
INSERT INTO olibdb VALUES('p','OrthogonalPolynomialFunctions',1,'x','(CommutativeRing)->etc','(R)','ORTHPOL','This package provides orthogonal polynomials as functions on a ring.');
INSERT INTO olibdb VALUES('p','OutputFormTools',0,'n','()->etc',NULL,'OFTOOL','This package implements tools form handling \indented{1}{\spadtype{OutputForm}}');
INSERT INTO olibdb VALUES('p','OutputPackage',0,'x','()->etc',NULL,'OUT','OutPackage allows pretty-printing from programs.');
INSERT INTO olibdb VALUES('p','PadeApproximantPackage',3,'x','(R:Field,x:Symbol,pt:R)->etc','(R,x,pt)','PADEPAC','This package computes reliable Pade approximants using a generalized Viskovatov continued fraction algorithm.');
INSERT INTO olibdb VALUES('p','PadeApproximants',3,'n','(R:Field,PS:UnivariateTaylorSeriesCategory(R),UP:UnivariatePolynomialCategory(R))->etc','(R,PS,UP)','PADE','This package computes reliable Pade approximants using a generalized Viskovatov continued fraction algorithm.');
INSERT INTO olibdb VALUES('p','PAdicWildFunctionFieldIntegralBasis',4,'n','(K:FiniteFieldCategory,R:UnivariatePolynomialCategory(K),UP:UnivariatePolynomialCategory(R),MonogenicAlgebra(R,UP))->etc','(K,R,UP,F)','PWFFINTB','In this package \spad{K} is a finite field,{} \spad{R} is a ring of univariate polynomials over \spad{K},{} and \spad{F} is a monogenic algebra over \spad{R}. We require that \spad{F} is monogenic,{} \spadignore{i.e.} that \spad{F = K[x,{} y]/(f(x,{} y))},{} because the integral basis algorithm used will factor the polynomial \spad{f(x,{} y)}. The package provides a function to compute the integral closure of \spad{R} in the quotient field of \spad{F} as well as a function to compute a local integral basis at a specific prime.');
INSERT INTO olibdb VALUES('p','ParadoxicalCombinatorsForStreams',1,'n','(Type)->etc','(A)','YSTREAM','This package implements fixed-point computations on streams.');
INSERT INTO olibdb VALUES('p','ParallelIntegrationTools',3,'n','(R:Field,V:OrderedSet,P:PolynomialCategory(R,IndexedExponents(V),V))->etc','(R,V,P)','PIT',NULL);
INSERT INTO olibdb VALUES('p','ParametricIntegration',2,'n','(R:Join(GcdDomain,etc),F:Join(AlgebraicallyClosedField,etc))->etc','(R,F)','INTPAR2','This package implements general parametric integration. \indented{1}{Most work is delegated to other packages.}');
INSERT INTO olibdb VALUES('p','ParametricLinearEquations',4,'n','(R:Join(EuclideanDomain,etc),Var:Join(OrderedSet,etc),Expon:OrderedAbelianMonoidSup,GR:PolynomialCategory(R,Expon,Var))->etc','(R,Var,Expon,GR)','PLEQN','This package completely solves a parametric linear system of equations by decomposing the set of all parametric values for which the linear system is consistent into a union of quasi-algebraic sets (which need not be irredundant,{} but most of the time is). Each quasi-algebraic set is described by a list of polynomials that vanish on the set,{} and a list of polynomials that vanish at no point of the set. For each quasi-algebraic set,{} the solution of the linear system is given,{} as a particular solution and a basis of the homogeneous system. The parametric linear system should be given in matrix form,{} with a coefficient matrix and a right hand side vector. The entries of the coefficient matrix and right hand side vector should be polynomials in the parametric variables,{} over a Euclidean domain of characteristic zero. \blankline If the system is homogeneous,{} the right hand side need not be given. The right hand side can also be replaced by an indeterminate vector,{} in which case,{} the conditions required for consistency will also be given.');
INSERT INTO olibdb VALUES('p','ParametricPlaneCurveFunctions2',2,'x','(Type,CF2:Type)->etc','(CF1,CF2)','PARPC2','This package \undocumented');
INSERT INTO olibdb VALUES('p','ParametricRischDE',2,'n','(R:Join(GcdDomain,etc),F:Join(TranscendentalFunctionCategory,etc))->etc','(R,F)','RDEPAR','This package implements parametric RDE solver. Only \indented{1}{simplest algebraic cases are implemented,{} the rest of algebraic} \indented{1}{case is unimplemented.\space{2}The code throws errors on inimplmented} \indented{1}{cases.}');
INSERT INTO olibdb VALUES('p','ParametricSpaceCurveFunctions2',2,'x','(Type,CF2:Type)->etc','(CF1,CF2)','PARSC2','This package \undocumented');
INSERT INTO olibdb VALUES('p','ParametricSurfaceFunctions2',2,'x','(Type,CF2:Type)->etc','(CF1,CF2)','PARSU2','This package \undocumented');
INSERT INTO olibdb VALUES('p','ParametricTranscendentalIntegration',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','INTPAR1','This package implements parametric integration \indented{1}{in transcendental case.}');
INSERT INTO olibdb VALUES('p','PartialDifferentialOperatorHelper',2,'n','(PartialDifferentialRing(Var),Var:OrderedSet)->etc','(R,Var)','PDOHLP',NULL);
INSERT INTO olibdb VALUES('p','PartialFractionPackage',1,'x','(Join(EuclideanDomain,etc))->etc','(R)','PFRPAC','The package \spadtype{PartialFractionPackage} gives an easier to use interface to \spadtype{PartialFraction}. The user gives a fraction of polynomials,{} and a variable and the package converts it to the proper datatype for the \spadtype{PartialFraction} domain.');
INSERT INTO olibdb VALUES('p','PartialFractionUtilities',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','PFUTIL',NULL);
INSERT INTO olibdb VALUES('p','PartitionsAndPermutations',0,'x','()->etc',NULL,'PARTPERM','PartitionsAndPermutations contains functions for generating streams of integer partitions,{} and streams of sequences of integers composed from a multi-set.');
INSERT INTO olibdb VALUES('p','PathArrayPackage',1,'n','(Ring)->etc','(R)','PARRPKG','A package for weighted Motzkin paths over a ring.');
INSERT INTO olibdb VALUES('p','PatternFunctions1',2,'n','(SetCategory,D:Type)->etc','(R,D)','PATTERN1','Tools for patterns.');
INSERT INTO olibdb VALUES('p','PatternFunctions2',2,'x','(SetCategory,S:SetCategory)->etc','(R,S)','PATTERN2','Lifts maps to patterns.');
INSERT INTO olibdb VALUES('p','PatternMatch',3,'x','(Base:SetCategory,Subject:PatternMatchable(Base),Pat:ConvertibleTo(Pattern(Base)))->etc','(Base,Subject,Pat)','PATMATCH','This package provides the top-level pattern matching functions.');
INSERT INTO olibdb VALUES('p','PatternMatchAssertions',0,'x','()->etc',NULL,'PMASS','Attaching assertions to symbols for pattern matching. Date Created: 21 Mar 1989');
INSERT INTO olibdb VALUES('p','PatternMatchFunctionSpace',3,'n','(S:SetCategory,R:Join(IntegralDomain,etc),F:Join(FunctionSpace(R),etc))->etc','(S,R,F)','PMFS','This package provides pattern matching functions on function spaces.');
INSERT INTO olibdb VALUES('p','PatternMatchIntegerNumberSystem',1,'n','(IntegerNumberSystem)->etc','(I)','PMINS','This package provides pattern matching functions on integers.');
INSERT INTO olibdb VALUES('p','PatternMatchIntegration',2,'n','(R:Join(Comparable,etc),F:Join(AlgebraicallyClosedField,etc))->etc','(R,F)','INTPM','\spadtype{PatternMatchIntegration} provides functions that use the pattern matcher to find some indefinite and definite integrals involving special functions and found in the literature.');
INSERT INTO olibdb VALUES('p','PatternMatchKernel',2,'n','(S:SetCategory,E:Join(Comparable,etc))->etc','(S,E)','PMKERNEL','This package provides pattern matching functions on kernels.');
INSERT INTO olibdb VALUES('p','PatternMatchListAggregate',3,'n','(S:SetCategory,R:PatternMatchable(S),L:ListAggregate(R))->etc','(S,R,L)','PMLSAGG','This package provides pattern matching functions on lists.');
INSERT INTO olibdb VALUES('p','PatternMatchPolynomialCategory',5,'n','(S:SetCategory,E:OrderedAbelianMonoidSup,V:OrderedSet,R:Join(Ring,etc),P:Join(PolynomialCategory(R,E,V),etc))->etc','(S,E,V,R,P)','PMPLCAT','This package provides pattern matching functions on polynomials.');
INSERT INTO olibdb VALUES('p','PatternMatchPushDown',3,'n','(S:SetCategory,A:PatternMatchable(S),B:Join(SetCategory,etc))->etc','(S,A,B)','PMDOWN','This packages provides tools for matching recursively in type towers.');
INSERT INTO olibdb VALUES('p','PatternMatchQuotientFieldCategory',3,'n','(S:SetCategory,R:Join(IntegralDomain,etc),Q:QuotientFieldCategory(R))->etc','(S,R,Q)','PMQFCAT','This package provides pattern matching functions on quotients.');
INSERT INTO olibdb VALUES('p','PatternMatchResultFunctions2',3,'x','(SetCategory,A:SetCategory,B:SetCategory)->etc','(R,A,B)','PATRES2','Lifts maps to pattern matching results.');
INSERT INTO olibdb VALUES('p','PatternMatchSymbol',1,'n','(SetCategory)->etc','(S)','PMSYM','This package provides pattern matching functions on symbols.');
INSERT INTO olibdb VALUES('p','PatternMatchTools',3,'n','(S:SetCategory,R:Join(Comparable,etc),P:Join(Ring,etc))->etc','(S,R,P)','PMTOOLS','This package provides tools for the pattern matcher.');
INSERT INTO olibdb VALUES('p','Permanent',2,'x','(PositiveInteger,R:Join(Ring,etc))->etc','(n,R)','PERMAN','Permanent implements the functions {\em permanent},{} the permanent for square matrices.');
INSERT INTO olibdb VALUES('p','PermutationGroupExamples',0,'x','()->etc',NULL,'PGE','PermutationGroupExamples provides permutation groups for some classes of groups: symmetric,{} alternating,{} dihedral,{} cyclic,{} direct products of cyclic,{} which are in fact the finite abelian groups of symmetric groups called Young subgroups. Furthermore,{} Rubik\spad{''s} group as permutation group of 48 integers and a list of sporadic simple groups derived from the atlas of finite groups.');
INSERT INTO olibdb VALUES('p','PiCoercions',1,'x','(Join(Comparable,etc))->etc','(R)','PICOERCE','\indented{1}{Provides a coercion from the symbolic fractions in \%\spad{pi} with} integer coefficients to any Expression type. Date Created: 21 Feb 1990');
INSERT INTO olibdb VALUES('p','PlotFunctions1',1,'n','(ConvertibleTo(InputForm))->etc','(S)','PLOT1','\spad{PlotFunctions1} provides facilities for plotting curves where functions \spad{SF} \spad{->} \spad{SF} are specified by giving an expression');
INSERT INTO olibdb VALUES('p','PlotTools',0,'n','()->etc',NULL,'PLOTTOOL','This package exports plotting tools');
INSERT INTO olibdb VALUES('p','PointFunctions2',2,'x','(Ring,R2:Ring)->etc','(R1,R2)','PTFUNC2','This package \undocumented');
INSERT INTO olibdb VALUES('p','PointPackage',1,'n','(Ring)->etc','(R)','PTPACK','This package \undocumented');
INSERT INTO olibdb VALUES('p','PointsOfFiniteOrder',5,'n','(R0:Join(Comparable,etc),F:FunctionSpace(R0),UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F,UP,UPUP))->etc','(R0,F,UP,UPUP,R)','PFO','This package provides function for testing whether a divisor on a curve is a torsion divisor.');
INSERT INTO olibdb VALUES('p','PointsOfFiniteOrderRational',3,'n','(UP:UnivariatePolynomialCategory(Fraction(Integer)),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(Fraction(Integer),UP,UPUP))->etc','(UP,UPUP,R)','PFOQ','This package provides function for testing whether a divisor on a curve is a torsion divisor.');
INSERT INTO olibdb VALUES('p','PointsOfFiniteOrderTools',2,'n','(UP:UnivariatePolynomialCategory(Fraction(Integer)),UPUP:UnivariatePolynomialCategory(Fraction(UP)))->etc','(UP,UPUP)','PFOTOOLS','Utilities for PFOQ and PFO.');
INSERT INTO olibdb VALUES('p','PolToPol',2,'n','(List(Symbol),R:Ring)->etc','(lv,R)','POLTOPOL','Package with the conversion functions among different kind of polynomials');
INSERT INTO olibdb VALUES('p','PolyGroebner',1,'x','(GcdDomain)->etc','(F)','PGROEB','Groebner functions for \spad{P} \spad{F} \indented{2}{This package is an interface package to the groebner basis} package which allows you to compute groebner bases for polynomials in either lexicographic ordering or total degree ordering refined by reverse lex. The input is the ordinary polynomial type which is internally converted to a type with the required ordering. The resulting grobner basis is converted back to ordinary polynomials. The ordering among the variables is controlled by an explicit list of variables which is passed as a second argument. The coefficient domain is allowed to be any \spad{gcd} domain,{} but the groebner basis is computed as if the polynomials were over a field.');
INSERT INTO olibdb VALUES('p','PolynomialAN2Expression',0,'x','()->etc',NULL,'PAN2EXPR','This package provides a coerce from polynomials over algebraic numbers to \spadtype{Expression Integer}.');
INSERT INTO olibdb VALUES('p','PolynomialCategoryLifting',5,'n','(E:OrderedAbelianMonoidSup,Vars:OrderedSet,R:Join(SemiRng,etc),P:PolynomialCategory(R,E,Vars),S:etc)->etc','(E,Vars,R,P,S)','POLYLIFT','This package provides a very general map function,{} which given a set \spad{S} and polynomials over \spad{R} with maps from the variables into \spad{S} and the coefficients into \spad{S},{} maps polynomials into \spad{S}. \spad{S} is assumed to support \spad{+},{} \spad{*} and \spad{^}.');
INSERT INTO olibdb VALUES('p','PolynomialCategoryQuotientFunctions',5,'n','(E:OrderedAbelianMonoidSup,V:OrderedSet,R:Ring,P:PolynomialCategory(R,E,V),F:Join(Field,etc))->etc','(E,V,R,P,F)','POLYCATQ','This package transforms multivariate polynomials or fractions into univariate polynomials or fractions,{} and back.');
INSERT INTO olibdb VALUES('p','PolynomialCommonDenominator',5,'n','(R:IntegralDomain,Q:QuotientFieldCategory(R),E:OrderedAbelianMonoidSup,VarSet:OrderedSet,P:PolynomialCategory(Q,E,VarSet))->etc','(R,Q,E,VarSet,P)','PCDEN','PolynomialCommonDenominator provides \indented{1}{functions to compute and clear the common denominator of the} \indented{1}{coefficients of polynomials over the quotient field.}');
INSERT INTO olibdb VALUES('p','PolynomialEvaluationUtilities',0,'n','()->etc',NULL,'PEVALUT','This package implements evaluation functions \indented{1}{useful for modular algorithms.\space{2}Computations work} \indented{1}{on integer polynomials,{} but most is done modulo a prime} \indented{1}{which is provided via parameters,{} either explicitly or} \indented{1}{through a state parameter (state also caches needed buffers).} \indented{1}{Some functions work on fractions.\space{2}To avoid useless \spad{GCD}} \indented{1}{computations during evaluation fractions may be represented} \indented{1}{as a record.}');
INSERT INTO olibdb VALUES('p','PolynomialFactorizationByRecursion',4,'n','(R:PolynomialFactorizationExplicit,E:OrderedAbelianMonoidSup,VarSet:OrderedSet,S:PolynomialCategory(R,E,VarSet))->etc','(R,E,VarSet,S)','PFBR','PolynomialFactorizationByRecursion(\spad{R},{} \spad{E},{} \spad{VarSet},{} \spad{S}) is used for factorization of sparse univariate polynomials over a domain \spad{S} of multivariate polynomials over \spad{R}.');
INSERT INTO olibdb VALUES('p','PolynomialFunctions2',2,'x','(Ring,S:Ring)->etc','(R,S)','POLY2','\indented{2}{This package takes a mapping between coefficient rings,{} and lifts} it to a mapping between polynomials over those rings.');
INSERT INTO olibdb VALUES('p','PolynomialGcdPackage',4,'n','(E:OrderedAbelianMonoidSup,OV:OrderedSet,R:EuclideanDomain,P:PolynomialCategory(R,E,OV))->etc','(E,OV,R,P)','PGCD','\indented{2}{This package computes multivariate polynomial \spad{gcd}\spad{''s} using} a hensel lifting strategy. The constraint on the coefficient domain is imposed by the lifting strategy. It is assumed that the coefficient domain has the property that almost all specializations preserve the degree of the \spad{gcd}.');
INSERT INTO olibdb VALUES('p','PolynomialInterpolation',2,'n','(Symbol,F:Field)->etc','(xx,F)','PINTERP','This package exports interpolation algorithms');
INSERT INTO olibdb VALUES('p','PolynomialInterpolationAlgorithms',2,'n','(F:Field,P:UnivariatePolynomialCategory(F))->etc','(F,P)','PINTERPA','This package exports interpolation algorithms');
INSERT INTO olibdb VALUES('p','PolynomialNumberTheoryFunctions',0,'n','()->etc',NULL,'PNTHEORY','This package provides various polynomial number theoretic functions over the integers.');
INSERT INTO olibdb VALUES('p','PolynomialRationalRoots',2,'n','(F:Join(IntegralDomain,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','PRROOT',NULL);
INSERT INTO olibdb VALUES('p','PolynomialRoots',5,'n','(E:OrderedAbelianMonoidSup,V:OrderedSet,R:IntegralDomain,P:PolynomialCategory(R,E,V),F:Join(Field,etc))->etc','(E,V,R,P,F)','POLYROOT','computes \spad{n}-th roots of quotients of multivariate polynomials');
INSERT INTO olibdb VALUES('p','PolynomialSetUtilitiesPackage',4,'n','(R:IntegralDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->etc','(R,E,V,P)','PSETPK','This package provides modest routines for polynomial system solving. The aim of many of the operations of this package is to remove certain factors in some polynomials in order to avoid unnecessary computations in algorithms involving splitting techniques by partial factorization.');
INSERT INTO olibdb VALUES('p','PolynomialSolveByFormulas',3,'n','(UnivariatePolynomialCategory(F),F:Join(Field,etc),Join(PolynomialFactorizationExplicit,etc))->etc','(UP,F,RR)','SOLVEFOR','This package factors the formulas out of the general solve code,{} allowing their recursive use over different domains. Care is taken to introduce few radicals so that radical extension domains can more easily simplify the results.');
INSERT INTO olibdb VALUES('p','PolynomialSquareFree',4,'n','(VarSet:OrderedSet,E:OrderedAbelianMonoidSup,RC:GcdDomain,P:PolynomialCategory(RC,E,VarSet))->etc','(VarSet,E,RC,P)','PSQFR','This package computes square-free decomposition of multivariate polynomials over a coefficient ring which is an arbitrary \spad{gcd} domain. The requirement on the coefficient domain guarantees that the \spadfun{content} can be removed so that factors will be primitive as well as square-free. Over an infinite ring of finite characteristic,{} it may not be possible to guarantee that the factors are square-free.');
INSERT INTO olibdb VALUES('p','PolynomialToUnivariatePolynomial',2,'x','(Symbol,R:Ring)->etc','(x,R)','POLY2UP','This package is primarily to help the interpreter do coercions. It allows you to view a polynomial as a univariate polynomial in one of its variables with coefficients which are again a polynomial in all the other variables.');
INSERT INTO olibdb VALUES('p','PosetFactory',1,'n','(SetCategory)->etc','(S)','POSETF','Provides functions to construct various small posets including powerset. Perhaps it should be called a ''powerlist'' but since we do not expect duplicates or require specific ordering it is essentially the same.');
INSERT INTO olibdb VALUES('p','PowerSeriesLimitPackage',2,'x','(R:Join(GcdDomain,etc),FE:Join(AlgebraicallyClosedField,etc))->etc','(R,FE)','LIMITPS','PowerSeriesLimitPackage implements limits of expressions in one or more variables as one of the variables approaches a limiting value. Included are two-sided limits,{} left- and right- hand limits,{} and limits at plus or minus infinity.');
INSERT INTO olibdb VALUES('p','PrecomputedAssociatedEquations',2,'n','(R:IntegralDomain,L:LinearOrdinaryDifferentialOperatorCategory(R))->etc','(R,L)','PREASSOC','\spadtype{PrecomputedAssociatedEquations} stores some generic precomputations which speed up the computations of the associated equations needed for factoring operators.');
INSERT INTO olibdb VALUES('p','PrimGCD',0,'n','()->etc',NULL,'PRIGCD3','This is unfinished package for computing primitive \indented{1}{\spad{gcd} over algebraic extensions.\space{2}Algebraic extension is defined} \indented{1}{by list of polynomial forming triangular system.} \indented{1}{Currently implemented is only trial division.}');
INSERT INTO olibdb VALUES('p','PrimitiveArrayFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','PRIMARR2','This package provides tools for operating on primitive arrays with unary and binary functions involving different underlying types.');
INSERT INTO olibdb VALUES('p','PrimitiveElement',1,'n','(Join(Field,etc))->etc','(F)','PRIMELT','PrimitiveElement provides functions to compute primitive elements in algebraic extensions.');
INSERT INTO olibdb VALUES('p','PrimitiveRatDE',4,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F),L:LinearOrdinaryDifferentialOperatorCategory(UP),LQ:LinearOrdinaryDifferentialOperatorCategory(Fraction(UP)))->etc','(F,UP,L,LQ)','ODEPRIM','\spad{PrimitiveRatDE} provides functions for in-field solutions of linear \indented{1}{ordinary differential equations,{} in the transcendental case.} \indented{1}{The derivation to use is given by the parameter \spad{L}.}');
INSERT INTO olibdb VALUES('p','PrimitiveRatRicDE',4,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F),L:LinearOrdinaryDifferentialOperatorCategory(UP),LinearOrdinaryDifferentialOperatorCategory(Fraction(UP)))->etc','(F,UP,L,LQ)','ODEPRRIC','In-field solution of Riccati equations,{} primitive case.');
INSERT INTO olibdb VALUES('p','PrintPackage',0,'x','()->etc',NULL,'PRINT','PrintPackage provides a print function for output forms.');
INSERT INTO olibdb VALUES('p','PseudoLinearNormalForm',1,'n','(Field)->etc','(K)','PSEUDLIN','PseudoLinearNormalForm provides a function for computing a block-companion form for pseudo-linear operators.');
INSERT INTO olibdb VALUES('p','PseudoRemainderSequence',2,'n','(R:IntegralDomain,polR:UnivariatePolynomialCategory(R))->etc','(R,polR)','PRS','This package contains some functions: \spadopFrom{discriminant}{PseudoRemainderSequence},{} \spadopFrom{resultant}{PseudoRemainderSequence},{} \spadopFrom{subResultantGcd}{PseudoRemainderSequence},{} \spadopFrom{chainSubResultants}{PseudoRemainderSequence},{} \spadopFrom{degreeSubResultant}{PseudoRemainderSequence},{} \spadopFrom{lastSubResultant}{PseudoRemainderSequence},{} \spadopFrom{resultantEuclidean}{PseudoRemainderSequence},{} \spadopFrom{subResultantGcdEuclidean}{PseudoRemainderSequence},{} \spadopFrom{\spad{semiSubResultantGcdEuclidean1}}{PseudoRemainderSequence},{} \spadopFrom{\spad{semiSubResultantGcdEuclidean2}}{PseudoRemainderSequence},{} etc. These procedures are coming from improvements of the subresultants algorithm.');
INSERT INTO olibdb VALUES('p','PureAlgebraicIntegration',3,'n','(R:Join(GcdDomain,etc),F:Join(FunctionSpace(R),etc),L:SetCategory)->etc','(R,F,L)','INTPAF','This package provides functions for integration,{} limited integration,{} extended integration and the risch differential equation for pure algebraic integrands.');
INSERT INTO olibdb VALUES('p','PureAlgebraicLODE',4,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F,UP,UPUP))->etc','(F,UP,UPUP,R)','ODEPAL','In-field solution of an linear ordinary differential equation,{} pure algebraic case.');
INSERT INTO olibdb VALUES('p','PushVariables',4,'n','(R:Ring,E:OrderedAbelianMonoidSup,OV:Join(OrderedSet,etc),PPR:PolynomialCategory(Polynomial(R),E,OV))->etc','(R,E,OV,PPR)','PUSHVAR','This package \undocumented{}');
INSERT INTO olibdb VALUES('p','QuasiAlgebraicSet2',1,'n','(List(Symbol))->etc','(vl)','QALGSET2','\spadtype{QuasiAlgebraicSet2} adds a function \spadfun{radicalSimplify} which uses \spadtype{IdealDecompositionPackage} to simplify the representation of a quasi-algebraic set. A quasi-algebraic set is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the common zeros of a polynomial \spad{f} (the defining polynomial for the inequation). Quasi-algebraic sets are implemented in the domain \spadtype{QuasiAlgebraicSet},{} where two simplification routines are provided: \spadfun{idealSimplify} and \spadfun{simplify}. The function \spadfun{radicalSimplify} is added for comparison study only. Because the domain \spadtype{IdealDecompositionPackage} provides facilities for computing with radical ideals,{} it is necessary to restrict the ground ring to the domain \spadtype{Fraction Integer},{} and the polynomial ring to be of type \spadtype{DistributedMultivariatePolynomial}. The routine \spadfun{radicalSimplify} uses these to compute groebner basis of radical ideals and is inefficient and restricted when compared to the two in \spadtype{QuasiAlgebraicSet}.');
INSERT INTO olibdb VALUES('p','QuasiComponentPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','QCMPACK','A package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets. \newline');
INSERT INTO olibdb VALUES('p','QuaternionCategoryFunctions2',4,'x','(QuaternionCategory(R),R:CommutativeRing,QS:QuaternionCategory(S),S:CommutativeRing)->etc','(QR,R,QS,S)','QUATCT2','\spadtype{QuaternionCategoryFunctions2} implements functions between two quaternion domains. The function \spadfun{map} is used by the system interpreter to coerce between quaternion types.');
INSERT INTO olibdb VALUES('p','QuotientFieldCategoryFunctions2',4,'x','(A:IntegralDomain,B:IntegralDomain,R:QuotientFieldCategory(A),S:QuotientFieldCategory(B))->etc','(A,B,R,S)','QFCAT2','This package extends a function between integral domains to a mapping between their quotient fields.');
INSERT INTO olibdb VALUES('p','RadicalEigenPackage',0,'x','()->etc',NULL,'REP','Package for the computation of eigenvalues and eigenvectors. This package works for matrices with coefficients which are rational functions over the integers. (see \spadtype{Fraction Polynomial Integer}). The eigenvalues and eigenvectors are expressed in terms of radicals.');
INSERT INTO olibdb VALUES('p','RadicalSolvePackage',1,'x','(Join(PolynomialFactorizationExplicit,etc))->etc','(R)','SOLVERAD','This package tries to find solutions expressed in terms of radicals for systems of equations of rational functions with coefficients in an integral domain \spad{R}.');
INSERT INTO olibdb VALUES('p','RadixUtilities',0,'x','()->etc',NULL,'RADUTIL','This package provides tools for creating radix expansions.');
INSERT INTO olibdb VALUES('p','RandomDistributions',1,'n','(SetCategory)->etc','(S)','RDIST','This package exports random distributions');
INSERT INTO olibdb VALUES('p','RandomFloatDistributions',0,'n','()->etc',NULL,'RFDIST','This package exports random floating-point distributions');
INSERT INTO olibdb VALUES('p','RandomIntegerDistributions',0,'n','()->etc',NULL,'RIDIST','This package exports integer distributions');
INSERT INTO olibdb VALUES('p','RandomNumberSource',0,'x','()->etc',NULL,'RANDSRC','Random number generators \indented{1}{All random numbers used in the system should originate from} \indented{1}{the same generator.\space{2}This package is intended to be the source.}');
INSERT INTO olibdb VALUES('p','RationalFactorize',1,'n','(UnivariatePolynomialCategory(Fraction(Integer)))->etc','(RP)','RATFACT','Factorization of extended polynomials with rational coefficients. This package implements factorization of extended polynomials whose coefficients are rational numbers. It does this by taking the \spad{lcm} of the coefficients of the polynomial and creating a polynomial with integer coefficients. The algorithm in \spadtype{GaloisGroupFactorizer} is then used to factor the integer polynomial. The result is normalized with respect to the original \spad{lcm} of the denominators.');
INSERT INTO olibdb VALUES('p','RationalFunction',1,'x','(IntegralDomain)->etc','(R)','RF','Utilities that provide the same top-level manipulations on fractions than on polynomials.');
INSERT INTO olibdb VALUES('p','RationalFunctionDefiniteIntegration',1,'x','(Join(EuclideanDomain,etc))->etc','(R)','DEFINTRF','\spadtype{RationalFunctionDefiniteIntegration} provides functions to compute definite integrals of rational functions.');
INSERT INTO olibdb VALUES('p','RationalFunctionFactor',1,'x','(UnivariatePolynomialCategory(Fraction(Polynomial(Integer))))->etc','(UP)','RFFACT','Factorization of univariate polynomials with coefficients which are rational functions with integer coefficients.');
INSERT INTO olibdb VALUES('p','RationalFunctionIntegration',1,'x','(Join(IntegralDomain,etc))->etc','(F)','INTRF','This package provides functions for the integration of rational functions.');
INSERT INTO olibdb VALUES('p','RationalFunctionLimitPackage',1,'x','(GcdDomain)->etc','(R)','LIMITRF','Computation of limits for rational functions.');
INSERT INTO olibdb VALUES('p','RationalFunctionSign',1,'x','(GcdDomain)->etc','(R)','SIGNRF','Find the sign of a rational function around a point or infinity.');
INSERT INTO olibdb VALUES('p','RationalFunctionSum',1,'x','(Join(IntegralDomain,etc))->etc','(R)','SUMRF','Computes sums of rational functions.');
INSERT INTO olibdb VALUES('p','RationalIntegration',2,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','INTRAT','This package provides functions for the base case of the Risch algorithm.');
INSERT INTO olibdb VALUES('p','RationalInterpolation',2,'n','(Symbol,F:Field)->etc','(xx,F)','RINTERP','This package exports rational interpolation algorithms');
INSERT INTO olibdb VALUES('p','RationalLODE',2,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','ODERAT','\spad{RationalLODE} provides functions for in-field solutions of linear \indented{1}{ordinary differential equations,{} in the rational case.}');
INSERT INTO olibdb VALUES('p','RationalRetractions',1,'x','(RetractableTo(Fraction(Integer)))->etc','(S)','RATRET','rational number testing and retraction functions. Date Created: March 1990');
INSERT INTO olibdb VALUES('p','RationalRicDE',2,'n','(F:Join(Field,etc),UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','ODERTRIC','In-field solution of Riccati equations,{} rational case.');
INSERT INTO olibdb VALUES('p','RationalUnivariateRepresentationPackage',2,'n','(Join(PolynomialFactorizationExplicit,etc),List(Symbol))->etc','(R,ls)','RURPK','\indented{1}{A package for computing the rational univariate representation} \indented{1}{of a zero-dimensional algebraic variety given by a regular} \indented{1}{triangular set. This package is essentially an interface for the} \spadtype{InternalRationalUnivariateRepresentationPackage} constructor. It is used in the \spadtype{ZeroDimensionalSolvePackage} for solving polynomial systems with finitely many solutions.');
INSERT INTO olibdb VALUES('p','RDEaux',1,'n','(Field)->etc','(F)','RDEAUX','This package contains special case for RDE solver.');
INSERT INTO olibdb VALUES('p','RealNormalizationUtilities',2,'n','(R:Join(GcdDomain,etc),F:Join(TranscendentalFunctionCategory,etc))->etc','(R,F)','RNORM','This package tries to rewrite an expression in \indented{1}{real form preserving its value.}');
INSERT INTO olibdb VALUES('p','RealPolynomialUtilitiesPackage',2,'x','(TheField:Field,ThePols:UnivariatePolynomialCategory(TheField))->etc','(TheField,ThePols)','POLUTIL','\spadtype{RealPolynomialUtilitiesPackage} provides common functions used by interval coding.');
INSERT INTO olibdb VALUES('p','RealSolvePackage',0,'n','()->etc',NULL,'REALSOLV','This package provides numerical solutions of systems of polynomial equations for use in ACPLOT.');
INSERT INTO olibdb VALUES('p','RealZeroPackage',1,'x','(UnivariatePolynomialCategory(Integer))->etc','(Pol)','REAL0','\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the integers to arbitrary user-specified precision. The results are returned as a list of isolating intervals which are expressed as records with left and right rational number components.');
INSERT INTO olibdb VALUES('p','RealZeroPackageQ',1,'x','(UnivariatePolynomialCategory(Fraction(Integer)))->etc','(Pol)','REAL0Q','\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the rational numbers to arbitrary user-specified precision. The results are returned as a list of isolating intervals,{} expressed as records with left and right rational number components.');
INSERT INTO olibdb VALUES('p','RectangularMatrixCategoryFunctions2',10,'x','(m:NonNegativeInteger,n:NonNegativeInteger,R1:Join(SemiRng,etc),Row1:DirectProductCategory(n,R1),Col1:DirectProductCategory(m,R1),M1:RectangularMatrixCategory(m,n,R1,Row1,Col1),R2:Join(SemiRng,etc),Row2:DirectProductCategory(n,R2),Col2:DirectProductCategory(m,R2),M2:RectangularMatrixCategory(m,n,R2,Row2,Col2))->etc','(m,n,R1,Row1,Col1,M1,R2,Row2,Col2,M2)','RMCAT2','\spadtype{RectangularMatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \spadfun{map} and \spadfun{reduce}.');
INSERT INTO olibdb VALUES('p','RecurrenceOperator',2,'n','(R:Join(Comparable,etc),F:Join(FunctionSpace(R),etc))->etc','(R,F)','RECOP','This package provides an operator for the \spad{n}-th term of a recurrence and an operator for the coefficient of \spad{x^n} in a function specified by a functional equation.');
INSERT INTO olibdb VALUES('p','ReducedDivisor',5,'n','(F1:Field,UP:UnivariatePolynomialCategory(F1),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F1,UP,UPUP),F2:Join(Finite,etc))->etc','(F1,UP,UPUP,R,F2)','RDIV','This package finds the order of a divisor over a field \indented{1}{using reduction to finite field.}');
INSERT INTO olibdb VALUES('p','ReduceLODE',5,'n','(F:Field,L:LinearOrdinaryDifferentialOperatorCategory(F),UP:UnivariatePolynomialCategory(F),A:MonogenicAlgebra(F,UP),LO:LinearOrdinaryDifferentialOperatorCategory(A))->etc','(F,L,UP,A,LO)','ODERED','Elimination of an algebraic from the coefficients of a linear ordinary differential equation.');
INSERT INTO olibdb VALUES('p','ReductionOfOrder',2,'n','(F:Field,L:LinearOrdinaryDifferentialOperatorCategory(F))->etc','(F,L)','REDORDER','\spadtype{ReductionOfOrder} provides functions for reducing the order of linear ordinary differential equations once some solutions are known.');
INSERT INTO olibdb VALUES('p','RegularSetDecompositionPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','RSDCMPK','A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are proposed: in the sense of Zariski closure (like in Kalkbrener\spad{''s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard methods). This algorithm is valid for nay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \spad{TS} and the packages \spadtype{QCMPACK}(\spad{R},{} \spad{E},{} \spad{V},{} \spad{P},{} \spad{TS}) and \spadtype{RSETGCD}(\spad{R},{} \spad{E},{} \spad{V},{} \spad{P},{} \spad{TS}). The same way it does not care about the way univariate polynomial \spad{gcd} (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these \spad{gcd} need to have invertible initials (normalized or not). WARNING. There is no need for a user to call directly any operation of this package since they can be accessed by the domain \spad{TS}. Thus,{} the operations of this package are not documented.\newline');
INSERT INTO olibdb VALUES('p','RegularTriangularSetGcdPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','RSETGCD','An internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field.\newline');
INSERT INTO olibdb VALUES('p','RepeatedDoubling',1,'n','(Join(SetCategory,etc))->etc','(S)','REPDB','Implements multiplication by repeated addition');
INSERT INTO olibdb VALUES('p','RepeatedSquaring',1,'n','(Join(SetCategory,etc))->etc','(S)','REPSQ','Implements exponentiation by repeated squaring');
INSERT INTO olibdb VALUES('p','RepresentationPackage1',1,'x','(Ring)->etc','(R)','REP1','\spad{RepresentationPackage1} provides functions for representation theory for finite groups and algebras. The package creates permutation representations and uses tensor products and its symmetric and antisymmetric components to create new representations of larger degree from given ones. Note: instead of having parameters from \spadtype{Permutation} this package allows list notation of permutations as well: \spadignore{e.g.} \spad{[1,{} 4,{} 3,{} 2]} denotes permutes 2 and 4 and fixes 1 and 3.');
INSERT INTO olibdb VALUES('p','RepresentationPackage2',1,'x','(Ring)->etc','(R)','REP2','\spad{RepresentationPackage2} provides functions for working with modular representations of finite groups and algebra. The routines in this package are created,{} using ideas of \spad{R}. Parker,{} (the meat-Axe) to get smaller representations from bigger ones,{} \spadignore{i.e.} finding sub- and factormodules,{} or to show,{} that such the representations are irreducible. Note: most functions are randomized functions of Las Vegas type \spadignore{i.e.} every answer is correct,{} but with small probability the algorithm fails to get an answer.');
INSERT INTO olibdb VALUES('p','ResolveLatticeCompletion',1,'x','(Type)->etc','(S)','RESLATC','This package provides coercions for the special types \spadtype{Exit} and \spadtype{Void}.');
INSERT INTO olibdb VALUES('p','RetractSolvePackage',2,'n','(Q:IntegralDomain,R:Join(IntegralDomain,etc))->etc','(Q,R)','RETSOL','RetractSolvePackage is an interface to \spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving.');
INSERT INTO olibdb VALUES('p','RootFSSplit',2,'n','(R:Join(IntegralDomain,etc),F:FunctionSpace(R))->etc','(R,F)','RFSSPLIT','This package implements \spad{alg_split_roots} \indented{1}{allowing its reuse.}');
INSERT INTO olibdb VALUES('p','RootSimplification',0,'n','()->etc',NULL,'RSIMP','This package performs root simplifications developing further methods from references below.');
INSERT INTO olibdb VALUES('p','RootUtilities',2,'n','(R:Join(GcdDomain,etc),F:Join(AlgebraicallyClosedFunctionSpace(R),etc))->etc','(R,F)','ROOTUT','This package implements ''complex_roots''.');
INSERT INTO olibdb VALUES('p','ScanningUtilities',0,'n','()->etc',NULL,'SCANUTIL',NULL);
INSERT INTO olibdb VALUES('p','SegmentBindingFunctions2',2,'x','(Type,S:Type)->etc','(R,S)','SEGBIND2','This package provides operations for mapping functions onto \spadtype{SegmentBinding}\spad{s}.');
INSERT INTO olibdb VALUES('p','SegmentFunctions2',2,'x','(Type,S:Type)->etc','(R,S)','SEG2','This package provides operations for mapping functions onto segments.');
INSERT INTO olibdb VALUES('p','SequenceFunctions2',2,'x','(CommutativeRing,R2:CommutativeRing)->etc','(R1,R2)','SEQU2','A domain for mappings between sequences.');
INSERT INTO olibdb VALUES('p','SimplicialComplexFactory',1,'n','(AbelianGroup)->etc','(VS)','SIMPCF','Provides functions to construct various simplicial complexes.');
INSERT INTO olibdb VALUES('p','SimplifyAlgebraicNumberConvertPackage',0,'x','()->etc',NULL,'SIMPAN','\indented{1}{Package to allow simplify to be called on AlgebraicNumbers} by converting to EXPR(INT)');
INSERT INTO olibdb VALUES('p','SmithNormalForm',4,'x','(R:EuclideanDomain,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:MatrixCategory(R,Row,Col))->etc','(R,Row,Col,M)','SMITH','\spadtype{SmithNormalForm} is a package which provides some standard canonical forms for matrices.');
INSERT INTO olibdb VALUES('p','SortedCache',1,'n','(CachableSet)->etc','(S)','SCACHE','A sorted cache of a cachable set \spad{S} is a dynamic structure that keeps the elements of \spad{S} sorted and assigns an integer to each element of \spad{S} once it is in the cache. This way,{} equality and ordering on \spad{S} are tested directly on the integers associated with the elements of \spad{S},{} once they have been entered in the cache.');
INSERT INTO olibdb VALUES('p','SortPackage',2,'n','(S:Type,A:Join(IndexedAggregate(Integer,S),etc))->etc','(S,A)','SORTPAK','This package exports sorting algorithnms');
INSERT INTO olibdb VALUES('p','SparsePolynomialCoercionHelpers',3,'n','(Ring,VarSet1:OrderedSet,VarSet2:OrderedSet)->etc','(R,VarSet1,VarSet2)','SMPCOER','This package contains a function which speeds up \indented{1}{coercion in an important special case.}');
INSERT INTO olibdb VALUES('p','SparseUnivariatePolynomialFunctions2',2,'x','(Ring,S:Ring)->etc','(R,S)','SUP2','This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from sparse univariate polynomial over \spad{R} to a sparse univariate polynomial over \spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.');
INSERT INTO olibdb VALUES('p','SpecialFunctionUnivariateTaylorSeries',2,'n','(Coef:Field,UTS:UnivariateTaylorSeriesCategory(Coef))->etc','(Coef,UTS)','SPFUTS','This package implements series expansions for a few \indented{1}{special functions.}');
INSERT INTO olibdb VALUES('p','SpecialOutputPackage',0,'x','()->etc',NULL,'SPECOUT','SpecialOutputPackage allows FORTRAN,{} Tex and \indented{2}{MathML Formatter output from programs.}');
INSERT INTO olibdb VALUES('p','SquareFreeQuasiComponentPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','SFQCMPK','A internal package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets. \newline');
INSERT INTO olibdb VALUES('p','SquareFreeRegularSetDecompositionPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:SquareFreeRegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','SRDCMPK','A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are provided: in the sense of Zariski closure (like in Kalkbrener\spad{''s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard- Moreno methods). This algorithm is valid for nay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \spad{TS} and the packages \spad{QCMPPK(R,{} E,{} V,{} P,{} TS)} and \spad{RSETGCD(R,{} E,{} V,{} P,{} TS)}. The same way it does not care about the way univariate polynomial gcds (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these gcds need to have invertible initials (normalized or not). WARNING. There is no need for a user to call directly any operation of this package since they can be accessed by the domain \spadtype{TS}. Thus,{} the operations of this package are not documented.\newline');
INSERT INTO olibdb VALUES('p','SquareFreeRegularTriangularSetGcdPackage',5,'x','(R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V),TS:RegularTriangularSetCategory(R,E,V,P))->etc','(R,E,V,P,TS)','SFRGCD','A internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field. There is no need to use directly this package since its main operations are available from \spad{TS}. \newline');
INSERT INTO olibdb VALUES('p','StorageEfficientMatrixOperations',1,'n','(Ring)->etc','(R)','MATSTOR','This package provides standard arithmetic operations on matrices. The functions in this package store the results of computations in existing matrices,{} rather than creating new matrices. This package works only for matrices of type Matrix and uses the internal representation of this type.');
INSERT INTO olibdb VALUES('p','STransformPackage',4,'x','(R:Join(CommutativeRing,etc),UTSR:UnivariateTaylorSeriesCategory(R),ULSR:UnivariateLaurentSeriesConstructorCategory(R,UTSR),UPSR:UnivariatePuiseuxSeriesConstructorCategory(R,ULSR))->etc','(R,UTSR,ULSR,UPSR)','STRANS','A package to compute Taylor and Puiseux series of \spad{S}-transforms.');
INSERT INTO olibdb VALUES('p','StreamExponentialSeriesOperations',1,'n','(CommutativeRing)->etc','(Coef)','STEXPS','StreamExponentialSeriesOperations implements arithmetic of exponential power series,{} where a power series is represented by a stream of its coefficients.');
INSERT INTO olibdb VALUES('p','StreamExponentialSeriesTranscendentalFunctions',1,'n','(Join(Algebra(Fraction(Integer)),etc))->etc','(Coef)','STEXPST','\indented{1}{StreamExponentialSeriesTranscendentalFunctions implements} \indented{1}{exp and log of exponential power series,{}} where a power series is represented by a stream of its coefficients.');
INSERT INTO olibdb VALUES('p','StreamFunctions1',1,'x','(Type)->etc','(S)','STREAM1','Functions defined on streams with entries in one set.');
INSERT INTO olibdb VALUES('p','StreamFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','STREAM2','Functions defined on streams with entries in two sets.');
INSERT INTO olibdb VALUES('p','StreamFunctions3',3,'x','(Type,B:Type,C:Type)->etc','(A,B,C)','STREAM3','Functions defined on streams with entries in three sets.');
INSERT INTO olibdb VALUES('p','StreamTaylorSeriesOperations',1,'n','(Ring)->etc','(A)','STTAYLOR','StreamTaylorSeriesOperations implements Taylor series arithmetic,{} where a Taylor series is represented by a stream of its coefficients,{} see corresponding operations in the category Ring.');
INSERT INTO olibdb VALUES('p','StreamTensor',1,'n','(Type)->etc','(R)','STNSR',NULL);
INSERT INTO olibdb VALUES('p','StreamTranscendentalFunctions',1,'n','(Algebra(Fraction(Integer)))->etc','(Coef)','STTF','StreamTranscendentalFunctions implements transcendental functions on Taylor series,{} where a Taylor series is represented by a stream of its coefficients.');
INSERT INTO olibdb VALUES('p','StreamTranscendentalFunctionsNonCommutative',1,'n','(Algebra(Fraction(Integer)))->etc','(Coef)','STTFNC','StreamTranscendentalFunctionsNonCommutative implements transcendental functions on Taylor series over a non-commutative ring,{} where a Taylor series is represented by a stream of its coefficients.');
INSERT INTO olibdb VALUES('p','StructuralConstantsPackage',1,'x','(IntegralDomain)->etc','(R)','SCPKG','StructuralConstantsPackage provides functions creating structural constants from a multiplication tables or a basis of a matrix algebra and other useful functions in this context.');
INSERT INTO olibdb VALUES('p','SturmHabichtPackage',2,'x','(R:OrderedIntegralDomain,UP:UnivariatePolynomialCategory(R))->etc','(R,UP)','SHP','This package provides functions for counting real roots of univariate polynomials over an OrderedIntegralDomain.');
INSERT INTO olibdb VALUES('p','SubResultantPackage',2,'n','(R:IntegralDomain,UP:UnivariatePolynomialCategory(R))->etc','(R,UP)','SUBRESP','This package computes the subresultants of two polynomials which is needed for the');
INSERT INTO olibdb VALUES('p','SymmetricFunctions',1,'n','(Ring)->etc','(R)','SYMFUNC','Computes all the symmetric functions in \spad{n} variables.');
INSERT INTO olibdb VALUES('p','SymmetricGroupCombinatoricFunctions',0,'x','()->etc',NULL,'SGCF','SymmetricGroupCombinatoricFunctions contains combinatoric functions concerning symmetric groups and representation theory: list young tableaus,{} improper partitions,{} subsets bijection of Coleman.');
INSERT INTO olibdb VALUES('p','SymmetryAnalysis',3,'n','(JetBundleCategory,xi:Union(Symbol,List(Symbol)),eta:Union(Symbol,List(Symbol)))->etc','(JB1,xi,eta)','SYMANA','\spad{SymmetryAnalysis(JB,{} \spad{xi},{} eta)} provides procedures for the symmetry analysis of differential equations over a given jet bundle. Currently there exist only some procedures to set up the determining system for the symmetry generators of Lie point symmetries.');
INSERT INTO olibdb VALUES('p','SystemODESolver',2,'n','(F:Field,LO:LinearOrdinaryDifferentialOperatorCategory(F))->etc','(F,LO)','ODESYS','SystemODESolver provides tools for triangulating and solving some systems of linear ordinary differential equations.');
INSERT INTO olibdb VALUES('p','SystemSolvePackage',1,'x','(IntegralDomain)->etc','(R)','SYSSOLP','Symbolic solver for systems of rational functions with coefficients in an integral domain \spad{R}. The systems are solved in the field of rational functions over \spad{R}. Solutions are exact of the form variable = value when the value is a member of the coefficient domain \spad{R}. Otherwise the solutions are implicitly expressed as roots of univariate polynomial equations over \spad{R}. Care is taken to guarantee that the denominators of the input equations do not vanish on the solution sets. The arguments to solve can either be given as equations or as rational functions interpreted as equal to zero. The user can specify an explicit list of symbols to be solved for,{} treating all other symbols appearing as parameters or omit the list of symbols in which case the system tries to solve with respect to all symbols appearing in the input.');
INSERT INTO olibdb VALUES('p','TableauxBumpers',1,'n','(OrderedSet)->etc','(S)','TABLBUMP','TableauBumpers implements the Schenstead-Knuth correspondence between sequences and pairs of Young tableaux. The 2 Young tableaux are represented as a single tableau with pairs as components.');
INSERT INTO olibdb VALUES('p','TabulatedComputationPackage',2,'n','(SetCategory,Entry:SetCategory)->etc','(Key,Entry)','TBCMPPK','\spad{TabulatedComputationPackage(Key ,{} Entry)} provides some modest support for dealing with operations with type \spad{Key -> Entry}. The result of such operations can be stored and retrieved with this package by using a hash-table. The user does not need to worry about the management of this hash-table. However,{} only one hash-table is built by calling \spad{TabulatedComputationPackage(Key ,{} Entry)}.');
INSERT INTO olibdb VALUES('p','TangentExpansions',1,'n','(Field)->etc','(R)','TANEXP','Expands tangents of sums and scalar products.');
INSERT INTO olibdb VALUES('p','TaylorSolve',3,'n','(F:Field,UTSF:UnivariateTaylorSeriesCategory(F),UTSSMPF:UnivariateTaylorSeriesCategory(SparseMultivariatePolynomialExpressions(F)))->etc','(F,UTSF,UTSSMPF)','UTSSOL',NULL);
INSERT INTO olibdb VALUES('p','TemplateUtilities',0,'n','()->etc',NULL,'TEMUTL','This package provides functions for template manipulation');
INSERT INTO olibdb VALUES('p','TensorPowerFunctions2',5,'n','(NonNegativeInteger,R:CommutativeRing,B:OrderedSet,M1:FreeModuleCategory(R,B),M2:Module(R))->etc','(n,R,B,M1,M2)','TENSPO2','linear extensions of maps on the basis');
INSERT INTO olibdb VALUES('p','TexFormat1',1,'x','(SetCategory)->etc','(S)','TEX1','\spadtype{TexFormat1} provides a utility coercion for changing to TeX format anything that has a coercion to the standard output format.');
INSERT INTO olibdb VALUES('p','TimeoutPackage',1,'n','(Type)->etc','(S)','TIMEOUT','This package supports evaluation with timeout.');
INSERT INTO olibdb VALUES('p','ToolsForSign',1,'n','(Ring)->etc','(R)','TOOLSIGN','Tools for the sign finding utilities.');
INSERT INTO olibdb VALUES('p','TopLevelDrawFunctions',1,'x','(Join(ConvertibleTo(InputForm),etc))->etc','(Ex)','DRAW','TopLevelDrawFunctions provides top level functions for drawing graphics of expressions.');
INSERT INTO olibdb VALUES('p','TopLevelDrawFunctionsForAlgebraicCurves',2,'x','(R:Join(IntegralDomain,etc),Ex:FunctionSpace(R))->etc','(R,Ex)','DRAWCURV','TopLevelDrawFunctionsForAlgebraicCurves provides top level functions for drawing non-singular algebraic curves.');
INSERT INTO olibdb VALUES('p','TopLevelDrawFunctionsForCompiledFunctions',0,'x','()->etc',NULL,'DRAWCFUN','TopLevelDrawFunctionsForCompiledFunctions provides top level functions for drawing graphics of expressions.');
INSERT INTO olibdb VALUES('p','TopLevelDrawFunctionsForPoints',0,'x','()->etc',NULL,'DRAWPT','TopLevelDrawFunctionsForPoints provides top level functions for drawing curves and surfaces described by sets of points.');
INSERT INTO olibdb VALUES('p','TopLevelThreeSpace',0,'x','()->etc',NULL,'TOPSP','This package exports a function for making a \spadtype{ThreeSpace}');
INSERT INTO olibdb VALUES('p','TranscendentalHermiteIntegration',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','INTHERTR','Hermite integration,{} transcendental case.');
INSERT INTO olibdb VALUES('p','TranscendentalIntegration',2,'n','(F:Field,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','INTTR','This package provides functions for the transcendental case of the Risch algorithm.');
INSERT INTO olibdb VALUES('p','TranscendentalManipulations',2,'x','(R:Join(Comparable,etc),F:Join(FunctionSpace(R),etc))->etc','(R,F)','TRMANIP','TranscendentalManipulations provides functions to simplify and expand expressions involving transcendental operators.');
INSERT INTO olibdb VALUES('p','TransSolvePackage',1,'x','(Join(Comparable,etc))->etc','(R)','SOLVETRA','This package tries to find solutions of equations of type Expression(\spad{R}). This means expressions involving transcendental,{} exponential,{} logarithmic and nthRoot functions. After trying to transform different kernels to one kernel by applying several rules,{} it calls zerosOf for the SparseUnivariatePolynomial in the remaining kernel. For example the expression \spad{sin(x)*cos(x)-2} will be transformed to \indented{3}{\spad{-2 tan(x/2)^4 -2 tan(x/2)^3 -4 tan(x/2)^2 +2 tan(x/2) -2}} by using the function normalize and then to \indented{3}{\spad{-2 tan(x)^2 + tan(x) -2}} with help of subsTan. This function tries to express the given function in terms of \spad{tan(x/2)} to express in terms of \spad{tan(x)} . Other examples are the expressions \spad{sqrt(x+1)+sqrt(x+7)+1} or \indented{1}{\spad{sqrt(sin(x))+1} .}');
INSERT INTO olibdb VALUES('p','TransSolvePackageService',1,'n','(Join(Comparable,etc))->etc','(R)','SOLVESER','This package finds the function \spad{func3} where \spad{func1} and \spad{func2} \indented{1}{are given and\space{2}\spad{func1} = \spad{func3}(\spad{func2}) .\space{2}If there is no solution then} \indented{1}{function \spad{func1} will be returned.} \indented{1}{An example would be\space{2}\spad{func1 := 8*X^3+32*X^2-14*X ::EXPR INT} and} \indented{1}{\spad{func2 := 2*X ::EXPR INT} convert them via univariate} \indented{1}{to FRAC SUP EXPR INT and then the solution is \spad{func3 := X^3+X^2-X}} \indented{1}{of type FRAC SUP EXPR INT}');
INSERT INTO olibdb VALUES('p','TriangularMatrixOperations',4,'n','(R:IntegralDomain,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R),M:MatrixCategory(R,Row,Col))->etc','(R,Row,Col,M)','TRIMAT','This package provides functions that compute fraction-free inverses of upper and lower triangular matrices over a integral domain. By fraction-free inverses we mean the following: given a matrix \spad{B} with entries in \spad{R} and an element \spad{d} of \spad{R} such that \spad{d} * inv(\spad{B}) also has entries in \spad{R},{} we return \spad{d} * inv(\spad{B}). Thus,{} it is not necessary to pass to the quotient field in any of our computations.');
INSERT INTO olibdb VALUES('p','TrigonometricManipulations',2,'x','(R:Join(GcdDomain,etc),F:Join(AlgebraicallyClosedField,etc))->etc','(R,F)','TRIGMNIP','\spadtype{TrigonometricManipulations} provides transformations from trigonometric functions to complex exponentials and logarithms,{} and back.');
INSERT INTO olibdb VALUES('p','TrigonometricManipulationsAux',2,'n','(G:Join(IntegralDomain,etc),FG:Join(FunctionSpace(G),etc))->etc','(G,FG)','TRIGMNPA','This package provides transformations from trigonometric functions to exponentials and logarithms,{} and back. \spad{F} and \spad{FG} should be the same type of function space.');
INSERT INTO olibdb VALUES('p','TubePlotTools',0,'n','()->etc',NULL,'TUBETOOL','Tools for constructing tubes around 3-dimensional parametric curves.');
INSERT INTO olibdb VALUES('p','TwoDimensionalArrayFunctions',8,'n','(A:Type,RA:FiniteLinearAggregate(A),CA:FiniteLinearAggregate(A),MA:TwoDimensionalArrayCategory(A,RA,CA),B:Type,RB:FiniteLinearAggregate(B),CB:FiniteLinearAggregate(B),MB:TwoDimensionalArrayCategory(B,RB,CB))->etc','(A,RA,CA,MA,B,RB,CB,MB)','ARRAY22',NULL);
INSERT INTO olibdb VALUES('p','TwoDimensionalPlotClipping',0,'n','()->etc',NULL,'CLIP','\indented{1}{The purpose of this package is to provide reasonable plots of} functions with singularities.');
INSERT INTO olibdb VALUES('p','TwoFactorize',1,'n','(FiniteFieldCategory)->etc','(F)','TWOFACT','A basic package for the factorization of bivariate polynomials over a finite field. The functions here represent the base step for the multivariate factorizer.');
INSERT INTO olibdb VALUES('p','U32VectorPolynomialOperations',0,'n','()->etc',NULL,'POLYVEC','This is a low-level package which implements operations \indented{1}{on vectors treated as univariate modular polynomials.\space{2}Most} \indented{1}{operations takes modulus as parameter.\space{2}Modulus is machine} \indented{1}{sized prime which should be small enough to avoid overflow} \indented{1}{in intermediate calculations.}');
INSERT INTO olibdb VALUES('p','UnitGaussianElimination',0,'n','()->etc',NULL,'UGAUSS','Gaussian elimination using only 1 or \spad{-1} as pivots \blankline');
INSERT INTO olibdb VALUES('p','Unittest',0,'n','()->etc',NULL,'TESTUNIT','Unittest is a package that provides functions for regression \indented{13}{testing.\space{2}Note that it calls the interpreter,{} thus,{} all} \indented{13}{functions require that their arguments be passed as strings.}');
INSERT INTO olibdb VALUES('p','UnittestAux',1,'n','(BasicType)->etc','(R)','TESTAUX','UnittestAux is an auxiliary package to Unittest,{} that performs \indented{13}{checking of tests,{} dealing also with fatal errors.}');
INSERT INTO olibdb VALUES('p','UnittestCount',0,'n','()->etc',NULL,'TESTCNT','UnittestCount is a package that keeps track of statistics \indented{13}{collected during testing.\space{2}It is separate from} \indented{13}{\spadtype{UnittestAux} because the latter takes an argument,{}} \indented{13}{and we want the state to be common for all arguments.}');
INSERT INTO olibdb VALUES('p','UnivariateFiniteFieldFactorize',2,'n','(F:FiniteFieldCategory,UP:UnivariatePolynomialCategory(F))->etc','(F,UP)','UFFACT',NULL);
INSERT INTO olibdb VALUES('p','UnivariateFormalPowerSeriesFunctions',1,'n','(Ring)->etc','(Coef)','UFPS1',NULL);
INSERT INTO olibdb VALUES('p','UnivariateLaurentSeriesFunctions2',6,'x','(Coef1:Ring,Coef2:Ring,var1:Symbol,var2:Symbol,cen1:Coef1,cen2:Coef2)->etc','(Coef1,Coef2,var1,var2,cen1,cen2)','ULS2','Mapping package for univariate Laurent series \indented{2}{This package allows one to apply a function to the coefficients of} \indented{2}{a univariate Laurent series.}');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialCategoryFunctions2',4,'x','(R:Join(SemiRng,etc),PR:UnivariatePolynomialCategory(R),S:Join(SemiRng,etc),PS:UnivariatePolynomialCategory(S))->etc','(R,PR,S,PS)','UPOLYC2','Mapping from polynomials over \spad{R} to polynomials over \spad{S} given a map from \spad{R} to \spad{S} assumed to send zero to zero.');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialCommonDenominator',3,'x','(R:IntegralDomain,Q:QuotientFieldCategory(R),UP:UnivariatePolynomialCategory(Q))->etc','(R,Q,UP)','UPCDEN',NULL);
INSERT INTO olibdb VALUES('p','UnivariatePolynomialDecompositionPackage',2,'x','(R:IntegralDomain,UP:UnivariatePolynomialCategory(R))->etc','(R,UP)','UPDECOMP','UnivariatePolynomialDecompositionPackage implements functional decomposition of univariate polynomial with coefficients in an \spad{IntegralDomain} of \spad{CharacteristicZero}.');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialDivisionPackage',2,'n','(R:IntegralDomain,UP:UnivariatePolynomialCategory(R))->etc','(R,UP)','UPDIVP','UnivariatePolynomialDivisionPackage provides a division for non monic univarite polynomials with coefficients in an \spad{IntegralDomain}.');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialFunctions2',4,'x','(Symbol,R:Ring,y:Symbol,S:Ring)->etc','(x,R,y,S)','UP2','This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from \spadtype{UnivariatePolynomial}(\spad{x},{} \spad{R}) to \spadtype{UnivariatePolynomial}(\spad{y},{} \spad{S}). Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialMultiplicationPackage',2,'x','(R:Ring,U:UnivariatePolynomialCategory(R))->etc','(R,U)','UPMP','This package implements Karatsuba\spad{''s} trick for multiplying (large) univariate polynomials. It could be improved with a version doing the work on place and also with a special case for squares. We''ve done this in Basicmath,{} but we believe that this out of the scope of FriCAS.');
INSERT INTO olibdb VALUES('p','UnivariatePolynomialSquareFree',2,'n','(RC:IntegralDomain,P:Join(UnivariatePolynomialCategory(RC),etc))->etc','(RC,P)','UPSQFREE','This package provides for square-free decomposition of univariate polynomials over arbitrary rings,{} \spadignore{i.e.} a partial factorization such that each factor is a product of irreducibles with multiplicity one and the factors are pairwise relatively prime. If the ring has characteristic zero,{} the result is guaranteed to satisfy this condition. If the ring is an infinite ring of finite characteristic,{} then it may not be possible to decide when polynomials contain factors which are \spad{p}th powers. In this case,{} the flag associated with that polynomial is set to nil (meaning that that polynomials are not guaranteed to be square-free).');
INSERT INTO olibdb VALUES('p','UnivariatePuiseuxSeriesFunctions2',6,'x','(Coef1:Ring,Coef2:Ring,var1:Symbol,var2:Symbol,cen1:Coef1,cen2:Coef2)->etc','(Coef1,Coef2,var1,var2,cen1,cen2)','UPXS2','Mapping package for univariate Puiseux series. This package allows one to apply a function to the coefficients of a univariate Puiseux series.');
INSERT INTO olibdb VALUES('p','UnivariateSkewPolynomialCategoryOps',2,'n','(R:Ring,C:UnivariateSkewPolynomialCategory(R))->etc','(R,C)','OREPCTO','\spad{UnivariateSkewPolynomialCategoryOps} provides products and \indented{1}{divisions of univariate skew polynomials.}');
INSERT INTO olibdb VALUES('p','UnivariateTaylorSeriesFunctions2',4,'x','(Coef1:Ring,Coef2:Ring,UTS1:UnivariateTaylorSeriesCategory(Coef1),UTS2:UnivariateTaylorSeriesCategory(Coef2))->etc','(Coef1,Coef2,UTS1,UTS2)','UTS2','Mapping package for univariate Taylor series. \indented{2}{This package allows one to apply a function to the coefficients of} \indented{2}{a univariate Taylor series.}');
INSERT INTO olibdb VALUES('p','UnivariateTaylorSeriesODESolver',2,'n','(Coef:Algebra(Fraction(Integer)),UTS:UnivariateTaylorSeriesCategory(Coef))->etc','(Coef,UTS)','UTSODE','\indented{1}{This package provides Taylor series solutions to regular} linear or non-linear ordinary differential equations of arbitrary order.');
INSERT INTO olibdb VALUES('p','UniversalSegmentFunctions2',2,'x','(Type,S:Type)->etc','(R,S)','UNISEG2','This package provides operations for mapping functions onto segments.');
INSERT INTO olibdb VALUES('p','UserDefinedPartialOrdering',1,'n','(SetCategory)->etc','(S)','UDPO','Provides functions to force a partial ordering on any set.');
INSERT INTO olibdb VALUES('p','UserDefinedVariableOrdering',0,'x','()->etc',NULL,'UDVO','This packages provides functions to allow the user to select the ordering on the variables and operators for displaying polynomials,{} fractions and expressions. The ordering affects the display only and not the computations.');
INSERT INTO olibdb VALUES('p','UTSodetools',4,'n','(F:Ring,UP:UnivariatePolynomialCategory(F),L:LinearOrdinaryDifferentialOperatorCategory(UP),UTS:UnivariateTaylorSeriesCategory(F))->etc','(F,UP,L,UTS)','UTSODETL','\spad{RUTSodetools} provides tools to interface with the series \indented{1}{ODE solver when presented with linear ODEs.}');
INSERT INTO olibdb VALUES('p','VectorFunctions2',2,'x','(Type,B:Type)->etc','(A,B)','VECTOR2','\indented{2}{This package provides operations which all take as arguments} vectors of elements of some type \spad{A} and functions from \spad{A} to another of type \spad{B}. The operations all iterate over their vector argument and either return a value of type \spad{B} or a vector over \spad{B}.');
INSERT INTO olibdb VALUES('p','VectorHermitePadeSolver',0,'n','()->etc',NULL,'VHPSOLV',NULL);
INSERT INTO olibdb VALUES('p','VectorPolynomialOperationsF',1,'n','(FiniteFieldCategory)->etc','(K)','POLVECF',NULL);
INSERT INTO olibdb VALUES('p','VectorPolynomialOperationsP',1,'n','(PositiveInteger)->etc','(p)','POLVECP',NULL);
INSERT INTO olibdb VALUES('p','ViewDefaultsPackage',0,'x','()->etc',NULL,'VIEWDEF','ViewportDefaultsPackage describes default and user definable values for graphics');
INSERT INTO olibdb VALUES('p','ViewportPackage',0,'n','()->etc',NULL,'VIEW','ViewportPackage provides functions for creating GraphImages and TwoDimensionalViewports from lists of lists of points.');
INSERT INTO olibdb VALUES('p','WeierstrassPreparation',1,'n','(Field)->etc','(R)','WEIER','This package implements the Weierstrass preparation theorem \spad{f} for multivariate power series. weierstrass(\spad{v},{} \spad{p}) where \spad{v} is a variable,{} and \spad{p} is a TaylorSeries(\spad{R}) in which there is term of form c*v^s where \spad{c} is a constant. Let \spad{s} be minimal as above. The result is a list of TaylorSeries coefficients A[\spad{i}] of the equivalent polynomial A = A[0] + A[1]\spad{*v} + A[2]\spad{*v^2} + ... + A[\spad{s}-1]\spad{*v^}(\spad{s}-1) + \spad{v^s} such that p=A*B ,{} \spad{B} being a TaylorSeries of minimum degree 0');
INSERT INTO olibdb VALUES('p','WildFunctionFieldIntegralBasis',4,'n','(K:FiniteFieldCategory,R:UnivariatePolynomialCategory(K),UP:UnivariatePolynomialCategory(R),FramedAlgebra(R,UP))->etc','(K,R,UP,F)','WFFINTBS','In this package \spad{K} is a finite field,{} \spad{R} is a ring of univariate polynomials over \spad{K},{} and \spad{F} is a framed algebra over \spad{R}. The package provides a function to compute the integral closure of \spad{R} in the quotient field of \spad{F} as well as a function to compute a local integral basis at a specific prime.');
INSERT INTO olibdb VALUES('p','XDistributedPolynomialFunctions',2,'n','(OrderedSet,F:Field)->etc','(VAR,F)','XDPOLYF','Using the Hankel matrix of a noncommutative polynomial one can determine the rank (Matrices de Hankel by Fliess). The extended Ho-Algorithmus (Fornasini+Marchesini) is used to create a minimal linear representation. Another approach is implemented in NonCommutativeRationalFunctions.');
INSERT INTO olibdb VALUES('p','XExponentialPackage',3,'n','(R:Join(Ring,etc),VarSet:OrderedSet,XPOLY:XPolynomialsCat(VarSet,R))->etc','(R,VarSet,XPOLY)','XEXPPKG','This package provides computations of logarithms and exponentials for polynomials in non-commutative variables. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('p','XPolynomialFactor',2,'n','(OrderedSet,F:Field)->etc','(vl,F)','XPFACT',NULL);
INSERT INTO olibdb VALUES('p','ZeroDimensionalSolvePackage',3,'x','(Join(OrderedRing,etc),ls:List(Symbol),ls2:List(Symbol))->etc','(R,ls,ls2)','ZDSOLVE','A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the \spadtype{RealClosure} of the coefficient ring. This constructor takes three arguments. The first one \spad{R} is the coefficient ring. The second one \spad{ls} is the list of variables involved in the systems to solve. The third one must be \spad{concat(ls,{} s)} where \spad{s} is an additional symbol used for the univariate representations. WARNING: The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the \spadtype{RegularChain} domain constructor. The lexTriangular algorithm can also be used for computing these decompositions (see the \spadtype{LexTriangularPackage} package constructor). For that purpose,{} the operations \spadopFrom{univariateSolve}{ZeroDimensionalSolvePackage},{} \spadopFrom{realSolve}{ZeroDimensionalSolvePackage} and \spadopFrom{positiveSolve}{ZeroDimensionalSolvePackage} admit an optional argument. \newline Author: Marc Moreno Maza.');
INSERT INTO olibdb VALUES('x','AbelianGroup&',1,'n','(AbelianGroup)->etc','(S)','ABELGRP-','The class of abelian groups,{} \spadignore{i.e.} additive monoids where each element has an additive inverse. \blankline');
INSERT INTO olibdb VALUES('x','AbelianMonoid&',1,'n','(AbelianMonoid)->etc','(S)','ABELMON-','The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with an additive identity element. \blankline');
INSERT INTO olibdb VALUES('x','AbelianMonoidRing&',3,'n','(AbelianMonoidRing(R,E),R:Join(SemiRng,etc),E:OrderedAbelianMonoid)->etc','(S,R,E)','AMR-','Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficients and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} but in general do not commute with the coefficients (which themselves may or may not be commutative). See \spadtype{FiniteAbelianMonoidRing} for the case of finite support. A useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on.');
INSERT INTO olibdb VALUES('x','AbelianSemiGroup&',1,'n','(AbelianSemiGroup)->etc','(S)','ABELSG-','the class of all additive (commutative) semigroups,{} \spadignore{i.e.} a set with a commutative and associative operation \spadop{+}. \blankline');
INSERT INTO olibdb VALUES('x','Aggregate&',1,'n','(Aggregate)->etc','(S)','AGG-','The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogeneous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as the set of \spad{x} satisfying relation {\em r(x)}. An attribute \spadtype{finiteAggregate} is used to assert that a domain has a finite number of elements.');
INSERT INTO olibdb VALUES('x','Algebra&',2,'n','(Algebra(R),R:CommutativeRing)->etc','(S,R)','ALGEBRA-','The category of associative algebras (modules which are themselves rings). \blankline');
INSERT INTO olibdb VALUES('x','AlgebraicallyClosedField&',1,'n','(AlgebraicallyClosedField)->etc','(S)','ACF-','Model for algebraically closed fields.');
INSERT INTO olibdb VALUES('x','AlgebraicallyClosedFunctionSpace&',2,'n','(AlgebraicallyClosedFunctionSpace(R),Join(Comparable,etc))->etc','(S,R)','ACFS-','Model for algebraically closed function spaces.');
INSERT INTO olibdb VALUES('x','ArcTrigonometricFunctionCategory&',1,'n','(ArcTrigonometricFunctionCategory)->etc','(S)','ATRIG-','Category for the inverse trigonometric functions.');
INSERT INTO olibdb VALUES('x','AssociationListAggregate&',3,'n','(AssociationListAggregate(Key,Entry),SetCategory,Entry:Type)->etc','(S,Key,Entry)','ALAGG-','An association list is a list of key entry pairs which may be viewed as a table. It is a poor mans version of a table: searching for a key is a linear operation.');
INSERT INTO olibdb VALUES('x','BagAggregate&',2,'n','(BagAggregate(S),S:Type)->etc','(A,S)','BGAGG-','A bag aggregate is an aggregate for which one can insert and extract objects,{} and where the order in which objects are inserted determines the order of extraction. Examples of bags are stacks,{} queues,{} and dequeues.');
INSERT INTO olibdb VALUES('x','BasicType&',1,'n','(BasicType)->etc','(S)','BASTYPE-','\spadtype{BasicType} is the basic category for describing a collection of elements with \spadop{=} (equality).');
INSERT INTO olibdb VALUES('x','BinaryRecursiveAggregate&',2,'n','(BinaryRecursiveAggregate(S),S:Type)->etc','(A,S)','BRAGG-','A binary-recursive aggregate has 0,{} 1 or 2 children and serves as a model for a binary tree or a doubly-linked aggregate structure');
INSERT INTO olibdb VALUES('x','BinaryTreeCategory&',2,'n','(BinaryTreeCategory(S),S:SetCategory)->etc','(A,S)','BTCAT-','\spadtype{BinaryTreeCategory(S)} is the category of binary trees: a tree which is either empty or has a \spadfun{node} consisting of a value and a \spadfun{left} and \spadfun{right} which are both binary trees.');
INSERT INTO olibdb VALUES('x','BitAggregate&',1,'n','(BitAggregate)->etc','(S)','BTAGG-','The bit aggregate category models aggregates representing large quantities of Boolean data.');
INSERT INTO olibdb VALUES('x','Collection&',2,'n','(Collection(S),S:Type)->etc','(A,S)','CLAGG-','A collection is a homogeneous aggregate which can be built from a list of members. The operation used to build the aggregate is generically named \spadfun{construct}. However,{} each collection provides its own special function with the same name as the data type,{} except with an initial lower case letter,{} \spadignore{e.g.} \spadfun{list} for \spadtype{List},{} \spadfun{flexibleArray} for \spadtype{FlexibleArray},{} and so on.');
INSERT INTO olibdb VALUES('x','ComplexCategory&',2,'n','(ComplexCategory(R),R:CommutativeRing)->etc','(S,R)','COMPCAT-','This category represents the extension of a ring by a square root of \spad{-1}.');
INSERT INTO olibdb VALUES('x','Dictionary&',2,'n','(Dictionary(S),S:Type)->etc','(A,S)','DIAGG-','A dictionary is an aggregate in which entries can be inserted,{} searched for and removed. Duplicates are thrown away on insertion. This category models the usual notion of dictionary which involves large amounts of data where copying is impractical. Principal operations are thus destructive (non-copying) ones.');
INSERT INTO olibdb VALUES('x','DictionaryOperations&',2,'n','(DictionaryOperations(S),S:Type)->etc','(A,S)','DIOPS-','This category is a collection of operations common to both categories \spadtype{Dictionary} and \spadtype{MultiDictionary}');
INSERT INTO olibdb VALUES('x','DifferentialExtension&',2,'n','(DifferentialExtension(R),R:Ring)->etc','(S,R)','DIFEXT-','Differential extensions of a ring \spad{R}. Given a differentiation on \spad{R},{} extend it to a differentiation on \%.');
INSERT INTO olibdb VALUES('x','DifferentialPolynomialCategory&',5,'n','(DifferentialPolynomialCategory(R,S,V,E),R:Ring,S:OrderedSet,V:DifferentialVariableCategory(S),E:OrderedAbelianMonoidSup)->etc','(A,R,S,V,E)','DPOLCAT-','\spadtype{DifferentialPolynomialCategory} is a category constructor specifying basic functions in an ordinary differential polynomial ring with a given ordered set of differential indeterminates. In addition,{} it implements defaults for the basic functions. The functions \spadfun{order} and \spadfun{weight} are extended from the set of derivatives of differential indeterminates to the set of differential polynomials. Other operations provided on differential polynomials are \spadfun{leader},{} \spadfun{initial},{} \spadfun{separant},{} \spadfun{differentialVariables},{} and \spadfun{isobaric?}. Furthermore,{} if the ground ring is a differential ring,{} then evaluation (substitution of differential indeterminates by elements of the ground ring or by differential polynomials) is provided by \spadfun{eval}. A convenient way of referencing derivatives is provided by the functions \spadfun{makeVariable}. \blankline To construct a domain using this constructor,{} one needs to provide a ground ring \spad{R},{} an ordered set \spad{S} of differential indeterminates,{} a ranking \spad{V} on the set of derivatives of the differential indeterminates,{} and a set \spad{E} of exponents in bijection with the set of differential monomials in the given differential indeterminates. \blankline');
INSERT INTO olibdb VALUES('x','DifferentialRing&',1,'n','(DifferentialRing)->etc','(S)','DIFRING-','An ordinary differential ring,{} that is,{} a ring with an operation \spadfun{differentiate}. \blankline');
INSERT INTO olibdb VALUES('x','DifferentialVariableCategory&',2,'n','(DifferentialVariableCategory(S),S:OrderedSet)->etc','(A,S)','DVARCAT-','\spadtype{DifferentialVariableCategory} constructs the set of derivatives of a given set of (ordinary) differential indeterminates. If \spad{x},{} ...,{} \spad{y} is an ordered set of differential indeterminates,{} and the prime notation is used for differentiation,{} then the set of derivatives (including zero-th order) of the differential indeterminates is \spad{x},{} \spad{x''},{} \spad{x''''},{} ...,{} \spad{y},{} \spad{y''},{} \spad{y''''},{} ... (Note: in the interpreter,{} the \spad{n}-th derivative of \spad{y} is displayed as \spad{y} with a subscript \spad{n}.) This set is viewed as a set of algebraic indeterminates,{} totally ordered in a way compatible with differentiation and the given order on the differential indeterminates. Such a total order is called a ranking of the differential indeterminates. \blankline A domain in this category is needed to construct a differential polynomial domain. Differential polynomials are ordered by a ranking on the derivatives,{} and by an order (extending the ranking) on on the set of differential monomials. One may thus associate a domain in this category with a ranking of the differential indeterminates,{} just as one associates a domain in the category \spadtype{OrderedAbelianMonoidSup} with an ordering of the set of monomials in a set of algebraic indeterminates. The ranking is specified through the binary relation \spadfun{<}. For example,{} one may define one derivative to be less than another by lexicographically comparing first the \spadfun{order},{} then the given order of the differential indeterminates appearing in the derivatives. This is the default implementation. \blankline The notion of weight generalizes that of degree. A polynomial domain may be made into a graded ring if a weight function is given on the set of indeterminates,{} Very often,{} a grading is the first step in ordering the set of monomials. For differential polynomial domains,{} this constructor provides a function \spadfun{weight},{} which allows the assignment of a non-negative number to each derivative of a differential indeterminate. For example,{} one may define the weight of a derivative to be simply its \spadfun{order} (this is the default assignment). This weight function can then be extended to the set of all differential polynomials,{} providing a graded ring structure.');
INSERT INTO olibdb VALUES('x','DirectProductCategory&',3,'n','(DirectProductCategory(dim,R),NonNegativeInteger,R:Type)->etc','(S,dim,R)','DIRPCAT-','\indented{2}{This category represents a finite cartesian product of a given type.} Many categorical properties are preserved under this construction.');
INSERT INTO olibdb VALUES('x','DivisionRing&',1,'n','(DivisionRing)->etc','(S)','DIVRING-','A division ring (sometimes called a skew field),{} \spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.');
INSERT INTO olibdb VALUES('x','ElementaryFunctionCategory&',1,'n','(ElementaryFunctionCategory)->etc','(S)','ELEMFUN-','Category for the elementary functions.');
INSERT INTO olibdb VALUES('x','EltableAggregate&',3,'n','(EltableAggregate(Dom,Im),Dom:Type,Im:Type)->etc','(S,Dom,Im)','ELTAGG-','An eltable aggregate is one which can be viewed as a function. For example,{} the list \spad{[1,{} 7,{} 4]} can be applied to 1,{} 2,{} and 3 respectively and will return the integers 1,{} 7,{} and 4; thus this list may be viewed as mapping 1 to 1,{} 2 to 7 and 3 to 4. In general,{} an aggregate can map members of a domain {\em Dom} to an image domain {\em Im}.');
INSERT INTO olibdb VALUES('x','EntireRing&',1,'n','(EntireRing)->etc','(S)','ENTIRER-','Entire Rings (non-commutative Integral Domains),{} \spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \blankline');
INSERT INTO olibdb VALUES('x','EuclideanDomain&',1,'n','(EuclideanDomain)->etc','(S)','EUCDOM-','A constructive euclidean domain,{} \spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\spadfun{euclideanSize}) than the divisor. \blankline Conditional attributes: \indented{2}{multiplicativeValuation\tab{25}\spad{Size(a*b)=Size(a)*Size(b)}} \indented{2}{additiveValuation\tab{25}\spad{Size(a*b)=Size(a)+Size(b)}}');
INSERT INTO olibdb VALUES('x','Evalable&',2,'n','(Evalable(R),R:SetCategory)->etc','(S,R)','EVALAB-','This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make');
INSERT INTO olibdb VALUES('x','ExpressionSpace2&',2,'n','(ExpressionSpace2(K),K:KernelCategory(%))->etc','(S,K)','ESC2-','An expression space is a set which is closed under certain operators.');
INSERT INTO olibdb VALUES('x','ExtensibleLinearAggregate&',2,'n','(ExtensibleLinearAggregate(S),S:Type)->etc','(A,S)','ELAGG-','An extensible aggregate is one which allows insertion and deletion of entries. These aggregates are models of lists which are represented by linked structures so as to make insertion,{} deletion,{} and concatenation efficient. However,{} access to elements of these extensible aggregates is generally slow since access is made from the end. See \spadtype{FlexibleArray} for an exception.');
INSERT INTO olibdb VALUES('x','ExtensionField&',2,'n','(ExtensionField(F),Field)->etc','(S,F)','XF-','ExtensionField {\em F} is the category of fields which extend the field \spad{F}');
INSERT INTO olibdb VALUES('x','FacetCategory&',1,'n','(FacetCategory)->etc','(S)','FACTCAT-','This is a category to represent different types of facet,{} such as,{} (1) A single simplex (2) A single cubical simplex (3) The product of two facets \blankline');
INSERT INTO olibdb VALUES('x','Field&',1,'n','(Field)->etc','(S)','FIELD-','The category of commutative fields,{} \spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \spadfun{factor} operation while trivial is useful to have defined. \blankline');
INSERT INTO olibdb VALUES('x','FieldOfPrimeCharacteristic&',1,'n','(FieldOfPrimeCharacteristic)->etc','(S)','FPC-','FieldOfPrimeCharacteristic is the category of fields of prime characteristic,{} \spadignore{e.g.} finite fields,{} algebraic closures of fields of prime characteristic,{} transcendental extensions of of fields of prime characteristic.');
INSERT INTO olibdb VALUES('x','Finite&',1,'n','(Finite)->etc','(S)','FINITE-','The category of domains composed of a finite set of elements. We include the functions \spadfun{lookup} and \spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \blankline');
INSERT INTO olibdb VALUES('x','FiniteAbelianMonoidRing&',3,'n','(FiniteAbelianMonoidRing(R,E),R:Join(SemiRng,etc),E:OrderedAbelianMonoid)->etc','(S,R,E)','FAMR-','This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general.');
INSERT INTO olibdb VALUES('x','FiniteAlgebraicExtensionField&',2,'n','(FiniteAlgebraicExtensionField(F),F:Field)->etc','(S,F)','FAXF-','FiniteAlgebraicExtensionField {\em F} is the category of fields which are finite algebraic extensions of the field {\em F}. If {\em F} is finite then any finite algebraic extension of {\em F} is finite,{} too. Let {\em K} be a finite algebraic extension of the finite field {\em F}. The exponentiation of elements of {\em K} defines a \spad{Z}-module structure on the multiplicative group of {\em K}. The additive group of {\em K} becomes a module over the ring of polynomials over {\em F} via the operation \spadfun{linearAssociatedExp}(a: \spad{K},{} \spad{f:} SparseUnivariatePolynomial \spad{F}) which is linear over {\em F},{} \spadignore{i.e.} for elements {\em a} from {\em K},{} {\em c,{} d} from {\em F} and {\em f,{} g} univariate polynomials over {\em F} we have \spadfun{linearAssociatedExp}(a,{} cf+dg) equals {\em c} times \spadfun{linearAssociatedExp}(a,{} \spad{f}) plus {\em d} times \spadfun{linearAssociatedExp}(a,{} \spad{g}). Therefore \spadfun{linearAssociatedExp} is defined completely by its action on monomials from {\em F[X]}: \spadfun{linearAssociatedExp}(a,{} monomial(1,{} \spad{k})\spad{\$}SUP(\spad{F})) is defined to be \spadfun{Frobenius}(a,{} \spad{k}) which is {\em a^(q^k)} where {\em q=size()\$F}. The operations order and discreteLog associated with the multiplicative exponentiation have additive analogues associated to the operation \spadfun{linearAssociatedExp}. These are the functions \spadfun{linearAssociatedOrder} and \spadfun{linearAssociatedLog},{} respectively.');
INSERT INTO olibdb VALUES('x','FiniteDivisorCategory&',5,'n','(FiniteDivisorCategory(F,UP,UPUP,R),F:Field,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)),R:FunctionFieldCategory(F,UP,UPUP))->etc','(S,F,UP,UPUP,R)','FDIVCAT-','This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{''s} are integers and the \spad{P}\spad{''s} are finite rational points on the curve.');
INSERT INTO olibdb VALUES('x','FiniteFieldCategory&',1,'n','(FiniteFieldCategory)->etc','(S)','FFIELDC-','FiniteFieldCategory is the category of finite fields');
INSERT INTO olibdb VALUES('x','FiniteGraph&',2,'n','(FiniteGraph(S),S:SetCategory)->etc','(A,S)','FGRPH-','Category of finite graphs,{} allows us to model graph theory \blankline');
INSERT INTO olibdb VALUES('x','FiniteGroup&',1,'n','(FiniteGroup)->etc','(S)','FINGRP-','The category of finite groups.');
INSERT INTO olibdb VALUES('x','FiniteRankAlgebra&',3,'n','(FiniteRankAlgebra(R,UP),R:CommutativeRing,UP:UnivariatePolynomialCategory(R))->etc','(S,R,UP)','FINRALG-','A FiniteRankAlgebra is an algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.');
INSERT INTO olibdb VALUES('x','FiniteRankNonAssociativeAlgebra&',2,'n','(FiniteRankNonAssociativeAlgebra(R),R:CommutativeRing)->etc','(S,R)','FINAALG-','A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.');
INSERT INTO olibdb VALUES('x','FiniteSetAggregate&',2,'n','(FiniteSetAggregate(S),S:SetCategory)->etc','(A,S)','FSAGG-','A finite-set aggregate models the notion of a finite set,{} that is,{} a collection of elements characterized by membership,{} but not by order or multiplicity. See \spadtype{Set} for an example.');
INSERT INTO olibdb VALUES('x','FloatingPointSystem&',1,'n','(FloatingPointSystem)->etc','(S)','FPS-','This category is intended as a model for floating point systems. A floating point system is a model for the real numbers. In fact,{} it is an approximation in the sense that not all real numbers are exactly representable by floating point numbers. A floating point system is characterized by the following: \blankline \indented{2}{1: \spadfunFrom{base}{FloatingPointSystem} of the \spadfunFrom{exponent}{FloatingPointSystem}.} \indented{9}{(actual implementations are usually binary or decimal)} \indented{2}{2: \spadfunFrom{precision}{FloatingPointSystem} of the \spadfunFrom{mantissa}{FloatingPointSystem} (arbitrary or fixed)} \indented{2}{3: rounding error for operations} \blankline Because a Float is an approximation to the real numbers,{} even though it is defined to be a join of a Field and OrderedRing,{} some of the attributes do not hold. In particular associative(\spad{+}) does not hold. Algorithms defined over a field need special considerations when the field is a floating point system.');
INSERT INTO olibdb VALUES('x','FormatterCategory&',1,'n','(FormatterCategory)->etc','(S)','FMTCAT-',NULL);
INSERT INTO olibdb VALUES('x','FramedAlgebra&',3,'n','(FramedAlgebra(R,UP),R:CommutativeRing,UP:UnivariatePolynomialCategory(R))->etc','(S,R,UP)','FRAMALG-','A \spadtype{FramedAlgebra} is a \spadtype{FiniteRankAlgebra} together with a fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('x','FramedModule&',2,'n','(FramedModule(R),R:Join(SemiRng,etc))->etc','(S,R)','FRMOD-','A \spadtype{FramedModule} is a finite rank free module with fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('x','FramedNonAssociativeAlgebra&',2,'n','(FramedNonAssociativeAlgebra(R),R:CommutativeRing)->etc','(S,R)','FRNAALG-','FramedNonAssociativeAlgebra(\spad{R}) is a \spadtype{FiniteRankNonAssociativeAlgebra} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank) over a commutative ring \spad{R} together with a fixed \spad{R}-module basis.');
INSERT INTO olibdb VALUES('x','FreeModuleCategory&',3,'n','(FreeModuleCategory(R,S),R:Join(SemiRng,etc),S:SetCategory)->etc','(A,R,S)','FMCAT-','A domain of this category implements formal linear combinations of elements from a domain \spad{Basis} with coefficients in a domain \spad{R}. The domain \spad{Basis} needs only to belong to the category \spadtype{SetCategory} and \spad{R} to the category \spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \spadtype{XDistributedPolynomial} constructor for examples of domains built with the \spadtype{FreeModuleCategory} category constructor. Author: Michel Petitot (petitot@lifl.\spad{fr}) \blankline Note (Franz Lehner,{} June 2009): \spad{FreeModule} originally was not of FreeModuleCategory. Some functions (like \spad{support},{} \spad{coefficients},{} \spad{monomials},{} ...) from here could be moved to \spad{IndexedDirectProductCategory} but at the moment there is no need for this.');
INSERT INTO olibdb VALUES('x','FullyEvalableOver&',2,'n','(FullyEvalableOver(R),R:SetCategory)->etc','(S,R)','FEVALAB-','This category provides a selection of evaluation operations depending on what the argument type \spad{R} provides.');
INSERT INTO olibdb VALUES('x','FullyLinearlyExplicitOver&',2,'n','(FullyLinearlyExplicitOver(R),R:Ring)->etc','(S,R)','FLINEXP-','\spad{S} is \spadtype{FullyLinearlyExplicitOver R} means that \spad{S} is a \spadtype{LinearlyExplicitOver R} and,{} in addition,{} if \spad{R} is a \spadtype{LinearlyExplicitOver Integer},{} then so is \spad{S}');
INSERT INTO olibdb VALUES('x','FullyRetractableTo&',2,'n','(FullyRetractableTo(S),S:Type)->etc','(A,S)','FRETRCT-','\indented{2}{A is fully retractable to \spad{B} means that A is retractable to \spad{B},{} and,{}} \indented{2}{in addition,{} if \spad{B} is retractable to the integers or rational} \indented{2}{numbers then so is A.} \indented{2}{In particular,{} what we are asserting is that there are no integers} \indented{2}{(rationals) in A which don\spad{''t} retract into \spad{B}.} Date Created: March 1990');
INSERT INTO olibdb VALUES('x','FunctionFieldCategory&',4,'n','(FunctionFieldCategory(F,UP,UPUP),F:UniqueFactorizationDomain,UP:UnivariatePolynomialCategory(F),UPUP:UnivariatePolynomialCategory(Fraction(UP)))->etc','(S,F,UP,UPUP)','FFCAT-','This category is a model for the function field of a plane algebraic curve.');
INSERT INTO olibdb VALUES('x','FunctionSpace2&',3,'n','(FunctionSpace2(R,K),R:Comparable,K:KernelCategory(%))->etc','(S,R,K)','FSC2-','A space of formal functions with arguments in an arbitrary ordered set.');
INSERT INTO olibdb VALUES('x','GcdDomain&',1,'n','(GcdDomain)->etc','(S)','GCDDOM-','This category describes domains where \spadfun{\spad{gcd}} can be computed but where there is no guarantee of the existence of \spadfun{factor} operation for factorization into irreducibles. However,{} if such a \spadfun{factor} operation exist,{} factorization will be unique up to order and units.');
INSERT INTO olibdb VALUES('x','GradedAlgebra&',3,'n','(GradedAlgebra(R,E),R:CommutativeRing,E:AbelianMonoid)->etc','(S,R,E)','GRALG-','GradedAlgebra(\spad{R},{} \spad{E}) denotes');
INSERT INTO olibdb VALUES('x','GradedModule&',3,'n','(GradedModule(R,E),CommutativeRing,E:AbelianMonoid)->etc','(S,R,E)','GRMOD-','GradedModule(\spad{R},{} \spad{E}) denotes');
INSERT INTO olibdb VALUES('x','Group&',1,'n','(Group)->etc','(S)','GROUP-','The class of multiplicative groups,{} \spadignore{i.e.} monoids with multiplicative inverses. \blankline');
INSERT INTO olibdb VALUES('x','Hashable&',1,'n','(Hashable)->etc','(S)','HASHABL-','All domains for which we can compute hash function \indented{1}{compatible with equality.}');
INSERT INTO olibdb VALUES('x','HomogeneousAggregate&',2,'n','(HomogeneousAggregate(S),S:Type)->etc','(A,S)','HOAGG-','A homogeneous aggregate is an aggregate of elements all of the same type. In the current system,{} all aggregates are homogeneous. Two attributes characterize classes of aggregates. Aggregates from domains with attribute \spadtype{finiteAggregate} have a finite number of members. Of course,{} such a domain may have an infinite number of elements,{} like,{} for example \spadtype{List}. Those domains with attribute \spadtype{shallowlyMutable} allow an element to be modified or updated without changing its overall value.');
INSERT INTO olibdb VALUES('x','HyperbolicFunctionCategory&',1,'n','(HyperbolicFunctionCategory)->etc','(S)','HYPCAT-','Category for the hyperbolic trigonometric functions.');
INSERT INTO olibdb VALUES('x','IndexedAggregate&',3,'n','(IndexedAggregate(Index,Entry),Index:Type,Entry:Type)->etc','(S,Index,Entry)','IXAGG-','An indexed aggregate is a many-to-one mapping of indices to entries. For example,{} a one-dimensional-array is an indexed aggregate where the index is an integer. Also,{} a table is an indexed aggregate where the indices and entries may have any type.');
INSERT INTO olibdb VALUES('x','InnerEvalable&',3,'n','(InnerEvalable(A,B),A:SetCategory,B:Type)->etc','(S,A,B)','IEVALAB-','This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make');
INSERT INTO olibdb VALUES('x','IntegerNumberSystem&',1,'n','(IntegerNumberSystem)->etc','(S)','INS-','An \spad{IntegerNumberSystem} is a model for the integers.');
INSERT INTO olibdb VALUES('x','JetBundleBaseFunctionCategory&',2,'n','(JetBundleBaseFunctionCategory(JB),JetBundleCategory)->etc','(S,JB)','JBBFC-','\spadtype{JetBundleBaseFunctionCategory} defines the category of functions (local sections) of the base space of a jet bundle,{} \spadignore{i.e.} functions depending only on the independent variables. Such a category is needed \spadignore{e.g.} for the representation of solutions.');
INSERT INTO olibdb VALUES('x','JetBundleCategory&',1,'n','(JetBundleCategory)->etc','(S)','JBC-','\spadtype{JetBundleCategory} provides basic data structures and procedures for jet bundles. Nearly all necessary functions are implemented already here. Only the representation and functions which directly access it must be implemented in a domain. Two notations of derivatives are supported. Default is multi-index notation,{} where the \spad{i}-th entry of the index denotes the number of differentiations taken with respect to \spad{x^i}. In repeated index notation each entry \spad{i} in the index denotes a differentiation with respect to \spad{x^i}. The choice affects,{} however,{} only in- and output. Internally,{} multi-index notation is used throughout.');
INSERT INTO olibdb VALUES('x','JetBundleFunctionCategory&',2,'n','(JetBundleFunctionCategory(JB),JB:JetBundleCategory)->etc','(S,JB)','JBFC-','\spadtype{JetBundleFunctionCategory} defines the category of functions (local sections) over a jet bundle. The formal derivative is defined already here. It uses the Jacobi matrix of the functions. The columns of the matrices are enumerated by jet variables. Thus they are represented as a \spadtype{Record} of the matrix and a list of the jet variables. Several simplification routines are implemented already here.');
INSERT INTO olibdb VALUES('x','KeyedDictionary&',3,'n','(KeyedDictionary(Key,Entry),Key:Type,Entry:Type)->etc','(S,Key,Entry)','KDAGG-','A keyed dictionary is a dictionary of key-entry pairs for which there is a unique entry for each key.');
INSERT INTO olibdb VALUES('x','LazyStreamAggregate&',2,'n','(LazyStreamAggregate(S),S:Type)->etc','(A,S)','LZSTAGG-','LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function ''empty?'' will cause lazy evaluation if necessary to determine if there are entries. Functions which call ''empty?'',{} \spadignore{e.g.} ''first'' and ''rest'',{} will also cause lazy evaluation if necessary. Elements of LazyStreamAggregate are computed only when strictly needed. Lazy computation means that potential errors are delayed,{} so errors are detected later than in case of normal (eager) evaluation used by other aggregates. In some cases computation that would signal error when using eager evaluation can succeed when using lazy evaluation.');
INSERT INTO olibdb VALUES('x','LeftAlgebra&',2,'n','(LeftAlgebra(R),R:Ring)->etc','(S,R)','LALG-','The category of all left algebras over an arbitrary ring.');
INSERT INTO olibdb VALUES('x','LieAlgebra&',2,'n','(LieAlgebra(R),R:CommutativeRing)->etc','(S,R)','LIECAT-','The category of Lie Algebras. It is used by the following domains of non-commutative algebra: \spadtype{LiePolynomial} and \spadtype{XPBWPolynomial}. \newline Author : Michel Petitot (petitot@lifl.\spad{fr}).');
INSERT INTO olibdb VALUES('x','LinearAggregate&',2,'n','(LinearAggregate(S),S:Type)->etc','(A,S)','LNAGG-','A linear aggregate is an aggregate whose elements are indexed by integers. Examples of linear aggregates are strings,{} lists,{} and arrays. Most of the exported operations for linear aggregates are non-destructive but are not always efficient for a particular aggregate. For example,{} \spadfun{concat} of two lists needs only to copy its first argument,{} whereas \spadfun{concat} of two arrays needs to copy both arguments. Most of the operations exported here apply to infinite objects (\spadignore{e.g.} streams) as well to finite ones. If the aggregate is a finite aggregate then it has several additional exports such as \spadfun{reverse},{} \spadfun{sort},{} and so on.');
INSERT INTO olibdb VALUES('x','LinearOrdinaryDifferentialOperatorCategory&',2,'n','(LinearOrdinaryDifferentialOperatorCategory(A),Ring)->etc','(S,A)','LODOCAT-','\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}');
INSERT INTO olibdb VALUES('x','ListAggregate&',2,'n','(ListAggregate(S),S:Type)->etc','(A,S)','LSAGG-','A list aggregate is a model for a linked list data structure. A linked list is a versatile data structure. Insertion and deletion are efficient and searching is a linear operation.');
INSERT INTO olibdb VALUES('x','Logic&',1,'n','(Logic)->etc','(S)','LOGIC-','''Logic'' adds ''not'' operation to lattices,{} Implements De Morgan\spad{''s} laws.');
INSERT INTO olibdb VALUES('x','Magma&',1,'n','(Magma)->etc','(S)','MAGMA-','Magma is the class of all multiplicative magmas,{} \spadignore{i.e.} sets with a binary operation.');
INSERT INTO olibdb VALUES('x','MagmaWithUnit&',1,'n','(MagmaWithUnit)->etc','(S)','MAGMAWU-','\indented{1}{MagmaWithUnit is the class of multiplicative monads with unit,{}} \indented{1}{\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \indented{3}{leftIdentity(*:(\%,{}\%)\spad{->}\%,{}1)\space{3}\tab{30} 1*x=x} \indented{3}{rightIdentity(*:(\%,{}\%)\spad{->}\%,{}1)\space{2}\tab{30} x*1=x} Common Additional Axioms \indented{3}{unitsKnown---if recip says failed,{} that PROVES input wasn\spad{''t} a unit}');
INSERT INTO olibdb VALUES('x','MatrixCategory&',4,'n','(MatrixCategory(R,Row,Col),R:AbelianMonoid,Row:FiniteLinearAggregate(R),Col:FiniteLinearAggregate(R))->etc','(S,R,Row,Col)','MATCAT-','\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the ''first'' row may be obtained by calling the function \spadfun{minRowIndex}. The index of the ''first'' column may be obtained by calling the function \spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.');
INSERT INTO olibdb VALUES('x','MaybeSkewPolynomialCategory&',4,'n','(MaybeSkewPolynomialCategory(R,E,VarSet),R:Join(SemiRng,etc),E:OrderedAbelianMonoidSup,VarSet:OrderedSet)->etc','(S,R,E,VarSet)','GPOLCAT-','The category for general multi-variate possibly skew polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}.');
INSERT INTO olibdb VALUES('x','Module&',2,'n','(Module(R),R:CommutativeRing)->etc','(S,R)','MODULE-','The category of modules over a commutative ring. \blankline');
INSERT INTO olibdb VALUES('x','MonogenicAlgebra&',3,'n','(MonogenicAlgebra(R,UP),R:CommutativeRing,UP:UnivariatePolynomialCategory(R))->etc','(S,R,UP)','MONOGEN-','A \spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.');
INSERT INTO olibdb VALUES('x','MultivariateTaylorSeriesCategory&',3,'n','(MultivariateTaylorSeriesCategory(Coef,Var),Coef:Ring,Var:OrderedSet)->etc','(S,Coef,Var)','MTSCAT-','\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category.');
INSERT INTO olibdb VALUES('x','NonAssociativeAlgebra&',2,'n','(NonAssociativeAlgebra(R),CommutativeRing)->etc','(S,R)','NAALG-','NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \indented{3}{\spad{r*}(a*b) = (r*a)\spad{*b} = a*(\spad{r*b})}');
INSERT INTO olibdb VALUES('x','NonAssociativeRing&',1,'n','(NonAssociativeRing)->etc','(S)','NARING-','A NonAssociativeRing is a non associative \spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative.');
INSERT INTO olibdb VALUES('x','NonAssociativeRng&',1,'n','(NonAssociativeRng)->etc','(S)','NARNG-','NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \indented{2}{\spad{x*}(\spad{y+z}) = x*y + \spad{x*z}} \indented{2}{(x+y)\spad{*z} = \spad{x*z} + \spad{y*z}} Common Additional Axioms \indented{2}{noZeroDivisors\space{2}ab = 0 \spad{=>} \spad{a=0} or \spad{b=0}}');
INSERT INTO olibdb VALUES('x','NonAssociativeSemiRng&',1,'n','(NonAssociativeSemiRng)->etc','(S)','NASRNG-','The category of semirings,{} not necessarily associative,{} not necessarily commutative,{} and not necessarily with a 1.');
INSERT INTO olibdb VALUES('x','OctonionCategory&',2,'n','(OctonionCategory(R),R:CommutativeRing)->etc','(S,R)','OC-','OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the Complex numbers to get the quaternions.');
INSERT INTO olibdb VALUES('x','OneDimensionalArrayAggregate&',2,'n','(OneDimensionalArrayAggregate(S),S:Type)->etc','(A,S)','A1AGG-','One-dimensional-array aggregates serves as models for one-dimensional arrays. Categorically,{} these aggregates are finite linear aggregates with the \spadtype{shallowlyMutable} property,{} that is,{} any component of the array may be changed without affecting the identity of the overall array. Array data structures are typically represented by a fixed area in storage and therefore cannot efficiently grow or shrink on demand as can list structures (see however \spadtype{FlexibleArray} for a data structure which is a cross between a list and an array). Iteration over,{} and access to,{} elements of arrays is extremely fast (and often can be optimized to open-code). Insertion and deletion however is generally slow since an entirely new data structure must be created for the result.');
INSERT INTO olibdb VALUES('x','OpenMath&',1,'n','(OpenMath)->etc','(S)','OM-','\spadtype{OpenMath} provides operations for exporting an object in OpenMath format.');
INSERT INTO olibdb VALUES('x','OrderedRing&',1,'n','(OrderedRing)->etc','(S)','ORDRING-','Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \blankline');
INSERT INTO olibdb VALUES('x','OrderedSet&',1,'n','(OrderedSet)->etc','(S)','ORDSET-','The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \spad{(a,{} b)} exactly one of the following relations holds \spad{a<b or a=b or b<a} and the relation is transitive,{} \spadignore{i.e.} \spad{a<b and b<c => a<c}. This order should be the natural order on given structure.');
INSERT INTO olibdb VALUES('x','PartialDifferentialRing&',2,'n','(PartialDifferentialRing(S),S:SetCategory)->etc','(A,S)','PDRING-','A partial differential ring with differentiations indexed by a parameter type \spad{S}. \blankline');
INSERT INTO olibdb VALUES('x','PartialOrder&',1,'n','(PartialOrder)->etc','(S)','PORDER-','The class of partially ordered sets,{} that is sets equipped with transitive and reflexive relation \spad{<=}.');
INSERT INTO olibdb VALUES('x','PolynomialCategory&',4,'n','(PolynomialCategory(R,E,VarSet),R:Join(SemiRng,etc),E:OrderedAbelianMonoidSup,VarSet:OrderedSet)->etc','(S,R,E,VarSet)','POLYCAT-','The category for general multi-variate polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}. Here variables commute with the coefficients.');
INSERT INTO olibdb VALUES('x','PolynomialFactorizationExplicit&',1,'n','(PolynomialFactorizationExplicit)->etc','(S)','PFECAT-','This is the category of domains that know enough about themselves in order to factor univariate polynomials over their fraction field.');
INSERT INTO olibdb VALUES('x','PolynomialSetCategory&',5,'n','(PolynomialSetCategory(R,E,VarSet,P),R:Ring,E:OrderedAbelianMonoidSup,VarSet:OrderedSet,P:RecursivePolynomialCategory(R,E,VarSet))->etc','(S,R,E,VarSet,P)','PSETCAT-','A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \spad{R} being an integral domain,{} a set of polynomials may be viewed as a representation of the ideal it generates in the polynomial ring \spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions.');
INSERT INTO olibdb VALUES('x','Poset&',2,'n','(Poset(S),S:SetCategory)->etc','(A,S)','POSET-','holds a complete set together with a structure to codify \indented{2}{the partial order.} \indented{2}{for more documentation see:} \indented{2}{\url{http://www.euclideanspace.com/prog/scratchpad/mycode/discrete/logic/index.\spad{htm}}}');
INSERT INTO olibdb VALUES('x','PowerSeriesCategory&',4,'n','(PowerSeriesCategory(Coef,Expon,Var),Coef:Ring,Expon:OrderedAbelianMonoid,Var:OrderedSet)->etc','(S,Coef,Expon,Var)','PSCAT-','\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.');
INSERT INTO olibdb VALUES('x','QuaternionCategory&',2,'n','(QuaternionCategory(R),R:CommutativeRing)->etc','(S,R)','QUATCAT-','\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.');
INSERT INTO olibdb VALUES('x','QuotientFieldCategory&',2,'n','(QuotientFieldCategory(S),S:IntegralDomain)->etc','(A,S)','QFCAT-','QuotientField(\spad{S}) is the category of fractions of an Integral Domain \spad{S}.');
INSERT INTO olibdb VALUES('x','RadicalCategory&',1,'n','(RadicalCategory)->etc','(S)','RADCAT-','The \spad{RadicalCategory} is a model for the rational numbers.');
INSERT INTO olibdb VALUES('x','RealClosedField&',1,'n','(RealClosedField)->etc','(S)','RCFIELD-','\spadtype{RealClosedField} provides common access functions for all real closed fields.');
INSERT INTO olibdb VALUES('x','RealNumberSystem&',1,'n','(RealNumberSystem)->etc','(S)','RNS-','The real number system category is intended as a model for the real numbers. The real numbers form an ordered normed field. Note that we have purposely not included \spadtype{DifferentialRing} or the elementary functions (see \spadtype{TranscendentalFunctionCategory}) in the definition.');
INSERT INTO olibdb VALUES('x','RealRootCharacterizationCategory&',3,'n','(RealRootCharacterizationCategory(TheField,ThePols),TheField:Join(OrderedRing,etc),ThePols:UnivariatePolynomialCategory(TheField))->etc','(S,TheField,ThePols)','RRCC-','\spadtype{RealRootCharacterizationCategory} provides common access functions for all real root codings.');
INSERT INTO olibdb VALUES('x','RectangularMatrixCategory&',6,'n','(RectangularMatrixCategory(m,n,R,Row,Col),m:NonNegativeInteger,n:NonNegativeInteger,R:Join(SemiRng,etc),Row:DirectProductCategory(n,R),Col:DirectProductCategory(m,R))->etc','(S,m,n,R,Row,Col)','RMATCAT-','\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \spad{R}-modules and will be non-mutable.');
INSERT INTO olibdb VALUES('x','RecursiveAggregate&',2,'n','(RecursiveAggregate(S),S:Type)->etc','(A,S)','RCAGG-','A recursive aggregate over a type \spad{S} is a model for a a directed graph containing values of type \spad{S}. Recursively,{} a recursive aggregate is either empty or a {\em node} consisting of a \spadfun{value} from \spad{S} and 0 or more \spadfun{children} which are also nodes. A node with no children is called a \spadfun{leaf} node. A recursive aggregate may be cyclic for which some operations as noted may go into an infinite loop.');
INSERT INTO olibdb VALUES('x','RecursivePolynomialCategory&',4,'n','(RecursivePolynomialCategory(R,E,V),R:Ring,E:OrderedAbelianMonoidSup,V:OrderedSet)->etc','(S,R,E,V)','RPOLCAT-','A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \spadfun{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in the ordered set,{} so that some operations usually defined for univariate polynomials make sense here.');
INSERT INTO olibdb VALUES('x','RegularTriangularSetCategory&',5,'n','(RegularTriangularSetCategory(R,E,V,P),R:GcdDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->etc','(S,R,E,V,P)','RSETCAT-','The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \spad{k[x1,{} ...,{} xn]} where \spad{k} is the fraction field of \spad{R}. The triangular set \spad{[t1,{} ...,{} tm]} is regular iff for every \spad{i} the initial of \spad{ti+1} is invertible in the tower of simple extensions associated with \spad{[t1,{} ...,{} \spad{ti}]}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \spad{I} iff the radical of \spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \spad{[T1,{} ...,{} \spad{Ti}]}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \spad{T} iff it is a split of Kalkbrener of the saturated ideal of \spad{T}. Let \spad{K} be an algebraic closure of \spad{k}. Assume that \spad{V} is finite with cardinality \spad{n} and let \spad{A} be the affine space \spad{K^n}. For a regular triangular set \spad{T} let denote by \spad{W(T)} the set of regular zeros of \spad{T}. A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given subset \spad{S} of \spad{A} iff the union of the \spad{W(\spad{Ti})} contains \spad{S} and is contained in the closure of \spad{S} (\spad{w}.\spad{r}.\spad{t}. Zariski topology). A family \spad{[T1,{} ...,{} Ts]} of regular triangular sets is a split of Lazard of a given triangular set \spad{T} if it is a split of Lazard of \spad{W(T)}. Note that if \spad{[T1,{} ...,{} Ts]} is a split of Lazard of \spad{T} then it is also a split of Kalkbrener of \spad{T}. The converse is \spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \newline');
INSERT INTO olibdb VALUES('x','RetractableFrom&',2,'n','(RetractableFrom(S),S:Type)->etc','(A,S)','RETFROM-','\spad{B} is retractable from A means that some elements in A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.');
INSERT INTO olibdb VALUES('x','RetractableTo&',2,'n','(RetractableTo(S),S:Type)->etc','(A,S)','RETRACT-','A is retractable to \spad{B} means that some elements of A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.');
INSERT INTO olibdb VALUES('x','Rng&',1,'n','(Rng)->etc','(S)','RNG-','The category of associative rings,{} not necessarily commutative,{} and not necessarily with a 1. This is a combination of an abelian group and a semigroup,{} with multiplication distributing over addition. \blankline');
INSERT INTO olibdb VALUES('x','SetAggregate&',2,'n','(SetAggregate(S),S:SetCategory)->etc','(A,S)','SETAGG-','A set category lists a collection of set-theoretic operations useful for both finite sets and multisets. Note however that finite sets are distinct from multisets. Although the operations defined for set categories are common to both,{} the relationship between the two cannot be described by inclusion or inheritance.');
INSERT INTO olibdb VALUES('x','SetCategory&',1,'n','(SetCategory)->etc','(S)','SETCAT-','\spadtype{SetCategory} is the basic category for describing a collection of elements with \spadop{=} (equality) and \spadfun{coerce} to output form. \blankline Conditional Attributes: \indented{3}{canonical\tab{15}data structure equality is the same as \spadop{=}}');
INSERT INTO olibdb VALUES('x','SPointCategory&',1,'n','(SPointCategory)->etc','(S)','SPTCAT-','PointCategory is the category of points and vectors in space. Points may be used to represent shapes in a scenegraph such as: the vertices of a cube or points along a line. Shapes such as these may be defined explicitly or may be plotted. We implement SetCategory to allow us to curry transforms from one point to another.');
INSERT INTO olibdb VALUES('x','SquareMatrixCategory&',5,'n','(SquareMatrixCategory(ndim,R,Row,Col),ndim:NonNegativeInteger,R:Join(SemiRng,etc),Row:DirectProductCategory(ndim,R),Col:DirectProductCategory(ndim,R))->etc','(S,ndim,R,Row,Col)','SMATCAT-','\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col.');
INSERT INTO olibdb VALUES('x','StreamAggregate&',2,'n','(StreamAggregate(S),S:Type)->etc','(A,S)','STAGG-','A stream aggregate is a linear aggregate which possibly has an infinite number of elements. A basic domain constructor which builds stream aggregates is \spadtype{Stream}. From streams,{} a number of infinite structures such as power series can be built.');
INSERT INTO olibdb VALUES('x','StringAggregate&',1,'n','(StringAggregate)->etc','(S)','SRAGG-','A string aggregate is a category for strings,{} that is,{} one dimensional arrays of characters.');
INSERT INTO olibdb VALUES('x','TableAggregate&',3,'n','(TableAggregate(Key,Entry),Key:Type,Entry:Type)->etc','(S,Key,Entry)','TBAGG-','A table aggregate is a model of a table,{} \spadignore{i.e.} a discrete many-to-one mapping from keys to entries.');
INSERT INTO olibdb VALUES('x','TaylorSeriesExpansion&',6,'n','(TaylorSeriesExpansion(Coef,Expon,Var,PS,UTS),Coef:Algebra(Fraction(Integer)),Expon:OrderedAbelianMonoid,Var:OrderedSet,PS:PowerSeriesCategory(Coef,Expon,Var),UTS:UnivariateTaylorSeriesCategory(Coef))->etc','(S,Coef,Expon,Var,PS,UTS)','TSEREXP-','Category for operations needed by Taylor expansions.');
INSERT INTO olibdb VALUES('x','TensorPowerCategory&',4,'n','(TensorPowerCategory(n,R,M),NonNegativeInteger,R:CommutativeRing,M:Module(R))->etc','(S,n,R,M)','TENSPC-','Category of tensor powers of modules over commutative rings.');
INSERT INTO olibdb VALUES('x','TranscendentalFunctionCategory&',1,'n','(TranscendentalFunctionCategory)->etc','(S)','TRANFUN-','Category for the transcendental elementary functions.');
INSERT INTO olibdb VALUES('x','TriangularSetCategory&',5,'n','(TriangularSetCategory(R,E,V,P),R:IntegralDomain,E:OrderedAbelianMonoidSup,V:OrderedSet,P:RecursivePolynomialCategory(R,E,V))->etc','(S,R,E,V,P)','TSETCAT-','The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \spad{R} be an integral domain and \spad{V} a finite ordered set of variables,{} say \spad{X1 < X2 < ... < Xn}. A set \spad{S} of polynomials in \spad{R[X1,{} X2,{} ...,{} Xn]} is triangular if no elements of \spad{S} lies in \spad{R},{} and if two distinct elements of \spad{S} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \spad{P} is reduced \spad{w}.\spad{r}.\spad{t} a non-constant polynomial \spad{Q} if the degree of \spad{P} in the main variable of \spad{Q} is less than the main degree of \spad{Q}. A polynomial \spad{P} is reduced \spad{w}.\spad{r}.\spad{t} a triangular set \spad{T} if it is reduced \spad{w}.\spad{r}.\spad{t}. every polynomial of \spad{T}. \newline');
INSERT INTO olibdb VALUES('x','TrigonometricFunctionCategory&',1,'n','(TrigonometricFunctionCategory)->etc','(S)','TRIGCAT-','Category for the trigonometric functions.');
INSERT INTO olibdb VALUES('x','TwoDimensionalArrayCategory&',4,'n','(TwoDimensionalArrayCategory(R,Row,Col),R:Type,Row:IndexedAggregate(Integer,R),Col:IndexedAggregate(Integer,R))->etc','(S,R,Row,Col)','ARR2CAT-','\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the ''first'' row may be obtained by calling the function ''minRowIndex''. The index of the ''first'' column may be obtained by calling the function ''minColIndex''. The index of the first element of a ''Row'' is the same as the index of the first column in an array and vice versa.');
INSERT INTO olibdb VALUES('x','UnaryRecursiveAggregate&',2,'n','(UnaryRecursiveAggregate(S),S:Type)->etc','(A,S)','URAGG-','A unary-recursive aggregate is an aggregate where nodes may have either 0 or 1 children. This aggregate models,{} though not precisely,{} a linked list possibly with a single cycle. A node with one children models a non-empty list,{} with the \spadfun{value} of the list designating the head,{} or \spadfun{first},{} of the list,{} and the child designating the tail,{} or \spadfun{rest},{} of the list. Since these aggregates are recursive aggregates,{} they may be cyclic.');
INSERT INTO olibdb VALUES('x','UniqueFactorizationDomain&',1,'n','(UniqueFactorizationDomain)->etc','(S)','UFD-','A constructive unique factorization domain,{} \spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.');
INSERT INTO olibdb VALUES('x','UnivariateLaurentSeriesCategory&',2,'n','(UnivariateLaurentSeriesCategory(Coef),Coef:Ring)->etc','(S,Coef)','ULSCAT-','\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable.');
INSERT INTO olibdb VALUES('x','UnivariateLaurentSeriesConstructorCategory&',3,'n','(UnivariateLaurentSeriesConstructorCategory(Coef,UTS),Coef:Ring,UTS:UnivariateTaylorSeriesCategory(Coef))->etc','(S,Coef,UTS)','ULSCCAT-','This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \spad{[n,{} f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x^n * f(x)}.');
INSERT INTO olibdb VALUES('x','UnivariatePolynomialCategory&',2,'n','(UnivariatePolynomialCategory(R),R:Join(SemiRng,etc))->etc','(S,R)','UPOLYC-','The category of univariate polynomials over a ring \spad{R}. No particular model is assumed - implementations can be either sparse or dense.');
INSERT INTO olibdb VALUES('x','UnivariatePowerSeriesCategory&',3,'n','(UnivariatePowerSeriesCategory(Coef,Expon),Coef:Ring,Expon:OrderedAbelianMonoid)->etc','(S,Coef,Expon)','UPSCAT-','\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents.');
INSERT INTO olibdb VALUES('x','UnivariatePuiseuxSeriesConstructorCategory&',3,'n','(UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS),Coef:Ring,ULS:UnivariateLaurentSeriesCategory(Coef))->etc','(S,Coef,ULS)','UPXSCCA-','This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{} f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.');
INSERT INTO olibdb VALUES('x','UnivariateSkewPolynomialCategory&',2,'n','(UnivariateSkewPolynomialCategory(R),R:Ring)->etc','(S,R)','OREPCAT-','This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}. This category is an evolution of the types \indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \indented{2}{NonCommutativeOperatorDivision} developed by Jean Della Dora and Stephen \spad{M}. Watt.');
INSERT INTO olibdb VALUES('x','UnivariateTaylorSeriesCategory&',2,'n','(UnivariateTaylorSeriesCategory(Coef),Coef:Ring)->etc','(S,Coef)','UTSCAT-','\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.');
INSERT INTO olibdb VALUES('x','VectorCategory&',2,'n','(VectorCategory(R),R:Type)->etc','(S,R)','VECTCAT-','\spadtype{VectorCategory} represents the type of vector like objects,{} \spadignore{i.e.} finite sequences indexed by some finite segment of the integers. The operations available on vectors depend on the structure of the underlying components. Many operations from the component domain are defined for vectors componentwise. It can by assumed that extraction or updating components can be done in constant time.');
COMMIT;
